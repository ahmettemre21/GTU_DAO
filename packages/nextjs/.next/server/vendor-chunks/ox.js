"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ox";
exports.ids = ["vendor-chunks/ox"];
exports.modules = {

/***/ "../node_modules/ox/_esm/core/Abi.js":
/*!*******************************************!*\
  !*** ../node_modules/ox/_esm/core/Abi.js ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"abitype\");\n/* harmony import */ var _internal_abi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/abi.js */ \"../node_modules/ox/_esm/core/internal/abi.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([abitype__WEBPACK_IMPORTED_MODULE_0__]);\nabitype__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/** @internal */\nfunction format(abi) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbi(abi);\n}\n/** @internal */\nfunction from(abi) {\n    if (_internal_abi_js__WEBPACK_IMPORTED_MODULE_1__.isSignatures(abi))\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.parseAbi(abi);\n    return abi;\n}\n//# sourceMappingURL=Abi.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtQztBQUNXO0FBQzlDO0FBQ087QUFDUCxXQUFXLDhDQUFpQjtBQUM1QjtBQUNBO0FBQ087QUFDUCxRQUFRLDBEQUFxQjtBQUM3QixlQUFlLDZDQUFnQjtBQUMvQjtBQUNBO0FBQ0EsK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmkuanM/YjVmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9hYmkuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChhYmkpIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmkoYWJpKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaSkge1xuICAgIGlmIChpbnRlcm5hbC5pc1NpZ25hdHVyZXMoYWJpKSlcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmkoYWJpKTtcbiAgICByZXR1cm4gYWJpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Abi.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AbiConstructor.js":
/*!******************************************************!*\
  !*** ../node_modules/ox/_esm/core/AbiConstructor.js ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"abitype\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiItem.js */ \"../node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbiParameters.js */ \"../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([abitype__WEBPACK_IMPORTED_MODULE_0__, _AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__, _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__]);\n([abitype__WEBPACK_IMPORTED_MODULE_0__, _AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__, _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n/** @internal */\nfunction decode(abiConstructor, options) {\n    const { bytecode } = options;\n    if (abiConstructor.inputs.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.decode(abiConstructor.inputs, data);\n}\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nfunction encode(abiConstructor, options) {\n    const { bytecode, args } = options;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encode(abiConstructor.inputs, args)\n        : '0x');\n}\n/** @internal */\nfunction format(abiConstructor) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiConstructor);\n}\n/** @internal */\nfunction from(abiConstructor) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.from(abiConstructor);\n}\n/** @internal */\nfunction fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlDb25zdHJ1Y3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSztBQUNZO0FBQ3BCO0FBQ2hDO0FBQ087QUFDUCxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGlCQUFpQjtBQUM3QixXQUFXLDJDQUFVO0FBQ3JCLFVBQVUscURBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxrREFBcUI7QUFDaEM7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2Q0FBWTtBQUN2QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFxQixHQUFHLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0EsMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlDb25zdHJ1Y3Rvci5qcz9mMDAzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBBYmlJdGVtIGZyb20gJy4vQWJpSXRlbS5qcyc7XG5pbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4vQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShhYmlDb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYnl0ZWNvZGUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGFiaUNvbnN0cnVjdG9yLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YS5yZXBsYWNlKGJ5dGVjb2RlLCAnMHgnKTtcbiAgICByZXR1cm4gQWJpUGFyYW1ldGVycy5kZWNvZGUoYWJpQ29uc3RydWN0b3IuaW5wdXRzLCBkYXRhKTtcbn1cbi8qKlxuICogQUJJLWVuY29kZXMgdGhlIHByb3ZpZGVkIGNvbnN0cnVjdG9yIGlucHV0IChgaW5wdXRzYCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlDb25zdHJ1Y3RvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGNvbnN0cnVjdG9yID0gQWJpQ29uc3RydWN0b3IuZnJvbSgnY29uc3RydWN0b3IoYWRkcmVzcywgdWludDI1NiknKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlDb25zdHJ1Y3Rvci5lbmNvZGUoY29uc3RydWN0b3IsIHtcbiAqICAgYnl0ZWNvZGU6ICcweC4uLicsXG4gKiAgIGFyZ3M6IFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgMTIzbl0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmQtdG8tZW5kXG4gKlxuICogQmVsb3cgaXMgYW4gZW5kLXRvLWVuZCBleGFtcGxlIG9mIHVzaW5nIGBBYmlDb25zdHJ1Y3Rvci5lbmNvZGVgIHRvIGVuY29kZSB0aGUgY29uc3RydWN0b3Igb2YgYSBjb250cmFjdCBhbmQgZGVwbG95IGl0LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IEFiaUNvbnN0cnVjdG9yLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiAvLyAxLiBJbnN0YW50aWF0ZSB0aGUgQUJJIENvbnN0cnVjdG9yLlxuICogY29uc3QgY29uc3RydWN0b3IgPSBBYmlDb25zdHJ1Y3Rvci5mcm9tKFxuICogICAnY29uc3RydWN0b3IoYWRkcmVzcyBvd25lciwgdWludDI1NiBhbW91bnQpJyxcbiAqIClcbiAqXG4gKiAvLyAyLiBFbmNvZGUgdGhlIEFCSSBDb25zdHJ1Y3Rvci5cbiAqIGNvbnN0IGRhdGEgPSBBYmlDb25zdHJ1Y3Rvci5lbmNvZGUoY29uc3RydWN0b3IsIHtcbiAqICAgYnl0ZWNvZGU6ICcweC4uLicsXG4gKiAgIGFyZ3M6IFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgMTIzbl0sXG4gKiB9KVxuICpcbiAqIC8vIDMuIERlcGxveSB0aGUgY29udHJhY3QuXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgd2luZG93LmV0aGVyZXVtIS5yZXF1ZXN0KHtcbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gKiAgIHBhcmFtczogW3sgZGF0YSB9XSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRm9yIHNpbXBsaWNpdHksIHRoZSBhYm92ZSBleGFtcGxlIHVzZXMgYHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0YCwgYnV0IHlvdSBjYW4gdXNlIGFueVxuICogdHlwZSBvZiBKU09OLVJQQyBpbnRlcmZhY2UuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaUNvbnN0cnVjdG9yIC0gVGhlIEFCSSBDb25zdHJ1Y3RvciB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShhYmlDb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYnl0ZWNvZGUsIGFyZ3MgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEhleC5jb25jYXQoYnl0ZWNvZGUsIGFiaUNvbnN0cnVjdG9yLmlucHV0cz8ubGVuZ3RoICYmIGFyZ3M/Lmxlbmd0aFxuICAgICAgICA/IEFiaVBhcmFtZXRlcnMuZW5jb2RlKGFiaUNvbnN0cnVjdG9yLmlucHV0cywgYXJncylcbiAgICAgICAgOiAnMHgnKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUNvbnN0cnVjdG9yKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZnJvbShhYmlDb25zdHJ1Y3Rvcik7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFiaShhYmkpIHtcbiAgICBjb25zdCBpdGVtID0gYWJpLmZpbmQoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgaWYgKCFpdGVtKVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5Ob3RGb3VuZEVycm9yKHsgbmFtZTogJ2NvbnN0cnVjdG9yJyB9KTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaUNvbnN0cnVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AbiConstructor.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AbiError.js":
/*!************************************************!*\
  !*** ../node_modules/ox/_esm/core/AbiError.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector),\n/* harmony export */   panicReasons: () => (/* binding */ panicReasons),\n/* harmony export */   solidityError: () => (/* binding */ solidityError),\n/* harmony export */   solidityErrorSelector: () => (/* binding */ solidityErrorSelector),\n/* harmony export */   solidityPanic: () => (/* binding */ solidityPanic),\n/* harmony export */   solidityPanicSelector: () => (/* binding */ solidityPanicSelector)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"abitype\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbiItem.js */ \"../node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiParameters.js */ \"../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([abitype__WEBPACK_IMPORTED_MODULE_0__, _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__, _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__]);\n([abitype__WEBPACK_IMPORTED_MODULE_0__, _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__, _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n/** @internal */\nfunction decode(abiError, data, options = {}) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(data) < 4)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.InvalidSelectorSizeError({ data });\n    if (abiError.inputs.length === 0)\n        return undefined;\n    const values = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decode(abiError.inputs, _Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 4), options);\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n/**\n * ABI-encodes the provided error input (`inputs`), prefixed with the 4 byte error selector.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from(\n *   'error InvalidSignature(uint r, uint s, uint8 yParity)'\n * )\n *\n * const data = AbiError.encode( // [!code focus]\n *   error, // [!code focus]\n *   [1n, 2n, 0] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Error from a JSON ABI with {@link ox#AbiError.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([ // [!code hl]\n *   // ... // [!code hl]\n *   { // [!code hl]\n *     name: 'InvalidSignature', // [!code hl]\n *     type: 'error', // [!code hl]\n *     inputs: [ // [!code hl]\n *       { name: 'r', type: 'uint256' }, // [!code hl]\n *       { name: 's', type: 'uint256' }, // [!code hl]\n *       { name: 'yParity', type: 'uint8' }, // [!code hl]\n *     ], // [!code hl]\n *   }, // [!code hl]\n *   // ... // [!code hl]\n * ]) // [!code hl]\n * const error = AbiError.fromAbi(abi, 'InvalidSignature') // [!code hl]\n *\n * const data = AbiError.encode(\n *   error,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @param abiError - ABI Error to encode\n * @param args - Error arguments\n * @returns ABI-encoded error name and arguments\n */\nfunction encode(abiError, ...args) {\n    const selector = getSelector(abiError);\n    const data = args.length > 0\n        ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(abiError.inputs, args[0])\n        : undefined;\n    return data ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(selector, data) : selector;\n}\n/**\n * Formats an {@link ox#AbiError.AbiError} into a **Human Readable ABI Error**.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const formatted = AbiError.format({\n *   type: 'error',\n *   name: 'Example',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiError - The ABI Error to format.\n * @returns The formatted ABI Error.\n */\nfunction format(abiError) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiError);\n}\n/**\n * Parses an arbitrary **JSON ABI Error** or **Human Readable ABI Error** into a typed {@link ox#AbiError.AbiError}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from({\n *   inputs: [{ name: 'v', type: 'uint8' }],\n *   name: 'BadSignatureV',\n *   type: 'error',\n * })\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from(\n *   'error BadSignatureV(uint8 v)' // [!code hl]\n * )\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from([\n *   'struct Signature { uint8 v; }', // [!code hl]\n *   'error BadSignatureV(Signature signature)',\n * ])\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiError - The ABI Error to parse.\n * @returns Typed ABI Error.\n */\nfunction from(abiError, options = {}) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.from(abiError, options);\n}\n/**\n * Extracts an {@link ox#AbiError.AbiError} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Errors can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiError.fromAbi(abi, 'BadSignatureV') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Errors can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiError.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Error from JSON-RPC error data.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    if (name === 'Error')\n        return solidityError;\n    if (name === 'Panic')\n        return solidityPanic;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(name, { strict: false })) {\n        const selector = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(name, 0, 4);\n        if (selector === solidityErrorSelector)\n            return solidityError;\n        if (selector === solidityPanicSelector)\n            return solidityPanic;\n    }\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.fromAbi(abi, name, options);\n    if (item.type !== 'error')\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.NotFoundError({ name, type: 'error' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiError.AbiError}.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const selector = AbiError.getSelector('error BadSignatureV(uint8 v)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const selector = AbiError.getSelector({\n *   inputs: [{ name: 'v', type: 'uint8' }],\n *   name: 'BadSignatureV',\n *   type: 'error'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the error signature.\n */\nfunction getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.getSelector(abiItem);\n}\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nconst panicReasons = {\n    1: 'An `assert` condition failed.',\n    17: 'Arithmetic operation resulted in underflow or overflow.',\n    18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n    33: 'Attempted to convert to an invalid type.',\n    34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n    49: 'Performed `.pop()` on an empty array',\n    50: 'Array index is out of bounds.',\n    65: 'Allocated too much memory or created an array which is too large.',\n    81: 'Attempted to call a zero-initialized variable of internal function type.',\n};\nconst solidityError = /*#__PURE__*/ from({\n    inputs: [\n        {\n            name: 'message',\n            type: 'string',\n        },\n    ],\n    name: 'Error',\n    type: 'error',\n});\nconst solidityErrorSelector = '0x08c379a0';\nconst solidityPanic = /*#__PURE__*/ from({\n    inputs: [\n        {\n            name: 'reason',\n            type: 'uint8',\n        },\n    ],\n    name: 'Panic',\n    type: 'error',\n});\nconst solidityPanicSelector = '0x4e487b71';\n//# sourceMappingURL=AbiError.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlFcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSztBQUNZO0FBQ3BCO0FBQ2hDO0FBQ08sNENBQTRDO0FBQ25ELFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLGlFQUFnQyxHQUFHLE1BQU07QUFDM0Q7QUFDQTtBQUNBLG1CQUFtQixxREFBb0Isa0JBQWtCLDBDQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQ0FBcUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFVBQVUscURBQW9CO0FBQzlCO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsa0RBQXFCO0FBQ2hDO0FBQ0E7QUFDQSx3RkFBd0YsMkJBQTJCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQztBQUMzQyxXQUFXLDZDQUFZO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCLFNBQVMsa0JBQWtCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkU7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZDQUFZLFNBQVMsZUFBZTtBQUM1Qyx5QkFBeUIsMENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnREFBZTtBQUNoQztBQUNBLGtCQUFrQixzREFBcUIsR0FBRyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDJCQUEyQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQ0FBb0M7QUFDMUU7QUFDTztBQUNQLFdBQVcsb0RBQW1CO0FBQzlCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQLG9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpRXJyb3IuanM/MjA1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgQWJpSXRlbSBmcm9tICcuL0FiaUl0ZW0uanMnO1xuaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoYWJpRXJyb3IsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChIZXguc2l6ZShkYXRhKSA8IDQpXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLkludmFsaWRTZWxlY3RvclNpemVFcnJvcih7IGRhdGEgfSk7XG4gICAgaWYgKGFiaUVycm9yLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gQWJpUGFyYW1ldGVycy5kZWNvZGUoYWJpRXJyb3IuaW5wdXRzLCBIZXguc2xpY2UoZGF0YSwgNCksIG9wdGlvbnMpO1xuICAgIGlmICh2YWx1ZXMgJiYgT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlcylbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vKipcbiAqIEFCSS1lbmNvZGVzIHRoZSBwcm92aWRlZCBlcnJvciBpbnB1dCAoYGlucHV0c2ApLCBwcmVmaXhlZCB3aXRoIHRoZSA0IGJ5dGUgZXJyb3Igc2VsZWN0b3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFcnJvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVycm9yID0gQWJpRXJyb3IuZnJvbShcbiAqICAgJ2Vycm9yIEludmFsaWRTaWduYXR1cmUodWludCByLCB1aW50IHMsIHVpbnQ4IHlQYXJpdHkpJ1xuICogKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlFcnJvci5lbmNvZGUoIC8vIFshY29kZSBmb2N1c11cbiAqICAgZXJyb3IsIC8vIFshY29kZSBmb2N1c11cbiAqICAgWzFuLCAybiwgMF0gLy8gWyFjb2RlIGZvY3VzXVxuICogKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHgwOTVlYTdiMzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZjJjJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFlvdSBjYW4gZXh0cmFjdCBhbiBBQkkgRXJyb3IgZnJvbSBhIEpTT04gQUJJIHdpdGgge0BsaW5rIG94I0FiaUVycm9yLihmcm9tQWJpOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlFcnJvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFsgLy8gWyFjb2RlIGhsXVxuICogICAvLyAuLi4gLy8gWyFjb2RlIGhsXVxuICogICB7IC8vIFshY29kZSBobF1cbiAqICAgICBuYW1lOiAnSW52YWxpZFNpZ25hdHVyZScsIC8vIFshY29kZSBobF1cbiAqICAgICB0eXBlOiAnZXJyb3InLCAvLyBbIWNvZGUgaGxdXG4gKiAgICAgaW5wdXRzOiBbIC8vIFshY29kZSBobF1cbiAqICAgICAgIHsgbmFtZTogJ3InLCB0eXBlOiAndWludDI1NicgfSwgLy8gWyFjb2RlIGhsXVxuICogICAgICAgeyBuYW1lOiAncycsIHR5cGU6ICd1aW50MjU2JyB9LCAvLyBbIWNvZGUgaGxdXG4gKiAgICAgICB7IG5hbWU6ICd5UGFyaXR5JywgdHlwZTogJ3VpbnQ4JyB9LCAvLyBbIWNvZGUgaGxdXG4gKiAgICAgXSwgLy8gWyFjb2RlIGhsXVxuICogICB9LCAvLyBbIWNvZGUgaGxdXG4gKiAgIC8vIC4uLiAvLyBbIWNvZGUgaGxdXG4gKiBdKSAvLyBbIWNvZGUgaGxdXG4gKiBjb25zdCBlcnJvciA9IEFiaUVycm9yLmZyb21BYmkoYWJpLCAnSW52YWxpZFNpZ25hdHVyZScpIC8vIFshY29kZSBobF1cbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpRXJyb3IuZW5jb2RlKFxuICogICBlcnJvcixcbiAqICAgWycweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUnLCA2OTQyMG5dXG4gKiApXG4gKiAvLyBAbG9nOiAnMHgwOTVlYTdiMzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZjJjJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUVycm9yIC0gQUJJIEVycm9yIHRvIGVuY29kZVxuICogQHBhcmFtIGFyZ3MgLSBFcnJvciBhcmd1bWVudHNcbiAqIEByZXR1cm5zIEFCSS1lbmNvZGVkIGVycm9yIG5hbWUgYW5kIGFyZ3VtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGFiaUVycm9yLCAuLi5hcmdzKSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihhYmlFcnJvcik7XG4gICAgY29uc3QgZGF0YSA9IGFyZ3MubGVuZ3RoID4gMFxuICAgICAgICA/IEFiaVBhcmFtZXRlcnMuZW5jb2RlKGFiaUVycm9yLmlucHV0cywgYXJnc1swXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRhdGEgPyBIZXguY29uY2F0KHNlbGVjdG9yLCBkYXRhKSA6IHNlbGVjdG9yO1xufVxuLyoqXG4gKiBGb3JtYXRzIGFuIHtAbGluayBveCNBYmlFcnJvci5BYmlFcnJvcn0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEVycm9yKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFcnJvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaUVycm9yLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdlcnJvcicsXG4gKiAgIG5hbWU6ICdFeGFtcGxlJyxcbiAqICAgaW5wdXRzOiBbXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpRXJyb3IgLSBUaGUgQUJJIEVycm9yIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIEVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUVycm9yKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlFcnJvcik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBFcnJvcioqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIEVycm9yKiogaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlFcnJvci5BYmlFcnJvcn0uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIEFCSXNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXJyb3IgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBiYWRTaWduYXR1cmVWRXJyb3IgPSBBYmlFcnJvci5mcm9tKHtcbiAqICAgaW5wdXRzOiBbeyBuYW1lOiAndicsIHR5cGU6ICd1aW50OCcgfV0sXG4gKiAgIG5hbWU6ICdCYWRTaWduYXR1cmVWJyxcbiAqICAgdHlwZTogJ2Vycm9yJyxcbiAqIH0pXG4gKlxuICogYmFkU2lnbmF0dXJlVkVycm9yXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEh1bWFuIFJlYWRhYmxlIEFCSXNcbiAqXG4gKiBBIEh1bWFuIFJlYWRhYmxlIEFCSSBjYW4gYmUgcGFyc2VkIGludG8gYSB0eXBlZCBBQkkgb2JqZWN0OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFcnJvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJhZFNpZ25hdHVyZVZFcnJvciA9IEFiaUVycm9yLmZyb20oXG4gKiAgICdlcnJvciBCYWRTaWduYXR1cmVWKHVpbnQ4IHYpJyAvLyBbIWNvZGUgaGxdXG4gKiApXG4gKlxuICogYmFkU2lnbmF0dXJlVkVycm9yXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXJyb3IgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBiYWRTaWduYXR1cmVWRXJyb3IgPSBBYmlFcnJvci5mcm9tKFtcbiAqICAgJ3N0cnVjdCBTaWduYXR1cmUgeyB1aW50OCB2OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnZXJyb3IgQmFkU2lnbmF0dXJlVihTaWduYXR1cmUgc2lnbmF0dXJlKScsXG4gKiBdKVxuICpcbiAqIGJhZFNpZ25hdHVyZVZFcnJvclxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKiBAcGFyYW0gYWJpRXJyb3IgLSBUaGUgQUJJIEVycm9yIHRvIHBhcnNlLlxuICogQHJldHVybnMgVHlwZWQgQUJJIEVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhYmlFcnJvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZnJvbShhYmlFcnJvciwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4dHJhY3RzIGFuIHtAbGluayBveCNBYmlFcnJvci5BYmlFcnJvcn0gZnJvbSBhbiB7QGxpbmsgb3gjQWJpLkFiaX0gZ2l2ZW4gYSBuYW1lIGFuZCBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IE5hbWVcbiAqXG4gKiBBQkkgRXJyb3JzIGNhbiBiZSBleHRyYWN0ZWQgYnkgdGhlaXIgbmFtZSB1c2luZyB0aGUgYG5hbWVgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlFcnJvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2Vycm9yIEJhZFNpZ25hdHVyZVYodWludDggdiknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUVycm9yLmZyb21BYmkoYWJpLCAnQmFkU2lnbmF0dXJlVicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgU2VsZWN0b3JcbiAqXG4gKiBBQkkgRXJyb3JzIGNhbiBiZSBleHRyYWN0IGJ5IHRoZWlyIHNlbGVjdG9yIHdoZW4ge0BsaW5rIG94I0hleC5IZXh9IGlzIHByb3ZpZGVkIHRvIGBuYW1lYC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlFcnJvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2Vycm9yIEJhZFNpZ25hdHVyZVYodWludDggdiknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKiBjb25zdCBpdGVtID0gQWJpRXJyb3IuZnJvbUFiaShhYmksICcweDA5NWVhN2IzJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBFeHRyYWN0aW5nIHZpYSBhIGhleCBzZWxlY3RvciBpcyB1c2VmdWwgd2hlbiBleHRyYWN0aW5nIGFuIEFCSSBFcnJvciBmcm9tIEpTT04tUlBDIGVycm9yIGRhdGEuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaSAtIFRoZSBBQkkgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSAob3Igc2VsZWN0b3IpIG9mIHRoZSBBQkkgaXRlbSB0byBleHRyYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYWN0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQUJJIGl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGlmIChuYW1lID09PSAnRXJyb3InKVxuICAgICAgICByZXR1cm4gc29saWRpdHlFcnJvcjtcbiAgICBpZiAobmFtZSA9PT0gJ1BhbmljJylcbiAgICAgICAgcmV0dXJuIHNvbGlkaXR5UGFuaWM7XG4gICAgaWYgKEhleC52YWxpZGF0ZShuYW1lLCB7IHN0cmljdDogZmFsc2UgfSkpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBIZXguc2xpY2UobmFtZSwgMCwgNCk7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gc29saWRpdHlFcnJvclNlbGVjdG9yKVxuICAgICAgICAgICAgcmV0dXJuIHNvbGlkaXR5RXJyb3I7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gc29saWRpdHlQYW5pY1NlbGVjdG9yKVxuICAgICAgICAgICAgcmV0dXJuIHNvbGlkaXR5UGFuaWM7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoaXRlbS50eXBlICE9PSAnZXJyb3InKVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5Ob3RGb3VuZEVycm9yKHsgbmFtZSwgdHlwZTogJ2Vycm9yJyB9KTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFs0LWJ5dGUgc2VsZWN0b3JdKGh0dHBzOi8vc29saWRpdHktYnktZXhhbXBsZS5vcmcvZnVuY3Rpb24tc2VsZWN0b3IvKSBmb3IgYW4ge0BsaW5rIG94I0FiaUVycm9yLkFiaUVycm9yfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUVycm9yIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlFcnJvci5nZXRTZWxlY3RvcignZXJyb3IgQmFkU2lnbmF0dXJlVih1aW50OCB2KScpXG4gKiAvLyBAbG9nOiAnMHg2MzUyMjExZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXJyb3IgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUVycm9yLmdldFNlbGVjdG9yKHtcbiAqICAgaW5wdXRzOiBbeyBuYW1lOiAndicsIHR5cGU6ICd1aW50OCcgfV0sXG4gKiAgIG5hbWU6ICdCYWRTaWduYXR1cmVWJyxcbiAqICAgdHlwZTogJ2Vycm9yJ1xuICogfSlcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIGl0ZW0gdG8gY29tcHV0ZSB0aGUgc2VsZWN0b3IgZm9yLlxuICogQHJldHVybnMgVGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHtAbGluayBveCNIYXNoLihrZWNjYWsyNTY6ZnVuY3Rpb24pfSBoYXNoIG9mIHRoZSBlcnJvciBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZ2V0U2VsZWN0b3IoYWJpSXRlbSk7XG59XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE2L2NvbnRyb2wtc3RydWN0dXJlcy5odG1sI3BhbmljLXZpYS1hc3NlcnQtYW5kLWVycm9yLXZpYS1yZXF1aXJlXG5leHBvcnQgY29uc3QgcGFuaWNSZWFzb25zID0ge1xuICAgIDE6ICdBbiBgYXNzZXJ0YCBjb25kaXRpb24gZmFpbGVkLicsXG4gICAgMTc6ICdBcml0aG1ldGljIG9wZXJhdGlvbiByZXN1bHRlZCBpbiB1bmRlcmZsb3cgb3Igb3ZlcmZsb3cuJyxcbiAgICAxODogJ0RpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvIChlLmcuIGA1IC8gMGAgb3IgYDIzICUgMGApLicsXG4gICAgMzM6ICdBdHRlbXB0ZWQgdG8gY29udmVydCB0byBhbiBpbnZhbGlkIHR5cGUuJyxcbiAgICAzNDogJ0F0dGVtcHRlZCB0byBhY2Nlc3MgYSBzdG9yYWdlIGJ5dGUgYXJyYXkgdGhhdCBpcyBpbmNvcnJlY3RseSBlbmNvZGVkLicsXG4gICAgNDk6ICdQZXJmb3JtZWQgYC5wb3AoKWAgb24gYW4gZW1wdHkgYXJyYXknLFxuICAgIDUwOiAnQXJyYXkgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy4nLFxuICAgIDY1OiAnQWxsb2NhdGVkIHRvbyBtdWNoIG1lbW9yeSBvciBjcmVhdGVkIGFuIGFycmF5IHdoaWNoIGlzIHRvbyBsYXJnZS4nLFxuICAgIDgxOiAnQXR0ZW1wdGVkIHRvIGNhbGwgYSB6ZXJvLWluaXRpYWxpemVkIHZhcmlhYmxlIG9mIGludGVybmFsIGZ1bmN0aW9uIHR5cGUuJyxcbn07XG5leHBvcnQgY29uc3Qgc29saWRpdHlFcnJvciA9IC8qI19fUFVSRV9fKi8gZnJvbSh7XG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogJ0Vycm9yJyxcbiAgICB0eXBlOiAnZXJyb3InLFxufSk7XG5leHBvcnQgY29uc3Qgc29saWRpdHlFcnJvclNlbGVjdG9yID0gJzB4MDhjMzc5YTAnO1xuZXhwb3J0IGNvbnN0IHNvbGlkaXR5UGFuaWMgPSAvKiNfX1BVUkVfXyovIGZyb20oe1xuICAgIGlucHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAncmVhc29uJyxcbiAgICAgICAgICAgIHR5cGU6ICd1aW50OCcsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnUGFuaWMnLFxuICAgIHR5cGU6ICdlcnJvcicsXG59KTtcbmV4cG9ydCBjb25zdCBzb2xpZGl0eVBhbmljU2VsZWN0b3IgPSAnMHg0ZTQ4N2I3MSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlFcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AbiError.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AbiEvent.js":
/*!************************************************!*\
  !*** ../node_modules/ox/_esm/core/AbiEvent.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArgsMismatchError: () => (/* binding */ ArgsMismatchError),\n/* harmony export */   DataMismatchError: () => (/* binding */ DataMismatchError),\n/* harmony export */   FilterTypeNotSupportedError: () => (/* binding */ FilterTypeNotSupportedError),\n/* harmony export */   InputNotFoundError: () => (/* binding */ InputNotFoundError),\n/* harmony export */   SelectorTopicMismatchError: () => (/* binding */ SelectorTopicMismatchError),\n/* harmony export */   TopicsMismatchError: () => (/* binding */ TopicsMismatchError),\n/* harmony export */   assertArgs: () => (/* binding */ assertArgs),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"abitype\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AbiItem.js */ \"../node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AbiParameters.js */ \"../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/cursor.js */ \"../node_modules/ox/_esm/core/internal/cursor.js\");\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./internal/errors.js */ \"../node_modules/ox/_esm/core/internal/errors.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([abitype__WEBPACK_IMPORTED_MODULE_0__, _AbiParameters_js__WEBPACK_IMPORTED_MODULE_4__, _AbiItem_js__WEBPACK_IMPORTED_MODULE_7__]);\n([abitype__WEBPACK_IMPORTED_MODULE_0__, _AbiParameters_js__WEBPACK_IMPORTED_MODULE_4__, _AbiItem_js__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n/**\n * Asserts that the provided arguments match the decoded log arguments.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from('event Transfer(address indexed from, address indexed to, uint256 value)')\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   value: 1n,\n * })\n *\n * // @error: AbiEvent.ArgsMismatchError: Given arguments to not match the arguments decoded from the log.\n * // @error: Event: event Transfer(address indexed from, address indexed to, uint256 value)\n * // @error: Expected Arguments:\n * // @error:   from:   0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac\n * // @error:   to:     0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad\n * // @error:   value:  1\n * // @error: Given Arguments:\n * // @error:   from:   0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad\n * // @error:   to:     0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac\n * // @error:   value:  1\n * ```\n *\n * @param abiEvent - ABI Event to check.\n * @param args - Decoded arguments.\n * @param matchArgs - The arguments to check.\n */\nfunction assertArgs(abiEvent, args, matchArgs) {\n    if (!args || !matchArgs)\n        throw new ArgsMismatchError({\n            abiEvent,\n            expected: args,\n            given: matchArgs,\n        });\n    function isEqual(input, value, arg) {\n        if (input.type === 'address')\n            return _Address_js__WEBPACK_IMPORTED_MODULE_1__.isEqual(value, arg);\n        if (input.type === 'string')\n            return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromString(value)) === arg;\n        if (input.type === 'bytes')\n            return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(value) === arg;\n        return value === arg;\n    }\n    if (Array.isArray(args) && Array.isArray(matchArgs)) {\n        for (const [index, value] of matchArgs.entries()) {\n            if (value === null || value === undefined)\n                continue;\n            const input = abiEvent.inputs[index];\n            if (!input)\n                throw new InputNotFoundError({\n                    abiEvent,\n                    name: `${index}`,\n                });\n            const value_ = Array.isArray(value) ? value : [value];\n            let equal = false;\n            for (const value of value_) {\n                if (isEqual(input, value, args[index]))\n                    equal = true;\n            }\n            if (!equal)\n                throw new ArgsMismatchError({\n                    abiEvent,\n                    expected: args,\n                    given: matchArgs,\n                });\n        }\n    }\n    if (typeof args === 'object' &&\n        !Array.isArray(args) &&\n        typeof matchArgs === 'object' &&\n        !Array.isArray(matchArgs))\n        for (const [key, value] of Object.entries(matchArgs)) {\n            if (value === null || value === undefined)\n                continue;\n            const input = abiEvent.inputs.find((input) => input.name === key);\n            if (!input)\n                throw new InputNotFoundError({ abiEvent, name: key });\n            const value_ = Array.isArray(value) ? value : [value];\n            let equal = false;\n            for (const value of value_) {\n                if (isEqual(input, value, args[key]))\n                    equal = true;\n            }\n            if (!equal)\n                throw new ArgsMismatchError({\n                    abiEvent,\n                    expected: args,\n                    given: matchArgs,\n                });\n        }\n}\n/**\n * ABI-Decodes the provided [Log Topics and Data](https://info.etherscan.com/what-is-event-logs/) according to the ABI Event's parameter types (`input`).\n *\n * :::tip\n *\n * This function is typically used to decode an [Event Log](https://info.etherscan.com/what-is-event-logs/) that may be returned from a Log Query (e.g. `eth_getLogs`) or Transaction Receipt.\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const log = {\n *   // ...\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * } as const\n *\n * const decoded = AbiEvent.decode(transfer, log)\n * // @log: {\n * // @log:   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   value: 1n\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiEvent.decode` to decode the topics of a `Transfer` event on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex } from 'ox'\n *\n * // 1. Instantiate the `Transfer` ABI Event.\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * // 2. Encode the ABI Event into Event Topics.\n * const { topics } = AbiEvent.encode(transfer)\n *\n * // 3. Query for events matching the encoded Topics.\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Log. // [!code focus]\n * const decoded = AbiEvent.decode(transfer, logs[0]!) // [!code focus]\n * // @log: {\n * // @log:   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   value: 603n\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiEvent - The ABI Event to decode.\n * @param log - `topics` & `data` to decode.\n * @returns The decoded event.\n */\nfunction decode(abiEvent, log) {\n    const { data, topics } = log;\n    const [selector_, ...argTopics] = topics;\n    const selector = getSelector(abiEvent);\n    if (selector_ !== selector)\n        throw new SelectorTopicMismatchError({\n            abiEvent,\n            actual: selector_,\n            expected: selector,\n        });\n    const { inputs } = abiEvent;\n    const isUnnamed = inputs?.every((x) => !('name' in x && x.name));\n    let args = isUnnamed ? [] : {};\n    // Decode topics (indexed args).\n    const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed);\n    for (let i = 0; i < indexedInputs.length; i++) {\n        const param = indexedInputs[i];\n        const topic = argTopics[i];\n        if (!topic)\n            throw new TopicsMismatchError({\n                abiEvent,\n                param: param,\n            });\n        args[isUnnamed ? i : param.name || i] = (() => {\n            if (param.type === 'string' ||\n                param.type === 'bytes' ||\n                param.type === 'tuple' ||\n                param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n                return topic;\n            const decoded = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_4__.decode([param], topic) || [];\n            return decoded[0];\n        })();\n    }\n    // Decode data (non-indexed args).\n    const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed));\n    if (nonIndexedInputs.length > 0) {\n        if (data && data !== '0x') {\n            try {\n                const decodedData = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_4__.decode(nonIndexedInputs, data);\n                if (decodedData) {\n                    if (isUnnamed)\n                        args = [...args, ...decodedData];\n                    else {\n                        for (let i = 0; i < nonIndexedInputs.length; i++) {\n                            const index = inputs.indexOf(nonIndexedInputs[i]);\n                            args[nonIndexedInputs[i].name || index] = decodedData[i];\n                        }\n                    }\n                }\n            }\n            catch (err) {\n                if (err instanceof _AbiParameters_js__WEBPACK_IMPORTED_MODULE_4__.DataSizeTooSmallError ||\n                    err instanceof _internal_cursor_js__WEBPACK_IMPORTED_MODULE_5__.PositionOutOfBoundsError)\n                    throw new DataMismatchError({\n                        abiEvent,\n                        data: data,\n                        parameters: nonIndexedInputs,\n                        size: _Hex_js__WEBPACK_IMPORTED_MODULE_6__.size(data),\n                    });\n                throw err;\n            }\n        }\n        else {\n            throw new DataMismatchError({\n                abiEvent,\n                data: '0x',\n                parameters: nonIndexedInputs,\n                size: 0,\n            });\n        }\n    }\n    return Object.values(args).length > 0 ? args : undefined;\n}\n/**\n * ABI-encodes the provided event input (`inputs`) into an array of [Event Topics](https://info.etherscan.com/what-is-event-logs/).\n *\n * :::tip\n *\n * This function is typically used to encode event arguments into [Event Topics](https://info.etherscan.com/what-is-event-logs/).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const { topics } = AbiEvent.encode(transfer)\n * // @log: ['0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0']\n * ```\n *\n * @example\n * ### Passing Arguments\n *\n * You can pass `indexed` parameter values to `AbiEvent.encode`.\n *\n * TypeScript types will be inferred from the ABI Event, to guard you from inserting the wrong values.\n *\n * For example, the `Transfer` event below accepts an `address` type for the `from` and `to` attributes.\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const { topics } = AbiEvent.encode(transfer, {\n *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code hl]\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8' // [!code hl]\n * })\n * // @log: [\n * // @log:   '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0',\n * // @log:   '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * // @log:   '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'\n * // @log: ]\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiEvent.encode` to encode the topics of a `Transfer` event and query for events matching the encoded topics on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex } from 'ox'\n *\n * // 1. Instantiate the `Transfer` ABI Event.\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * // 2. Encode the ABI Event into Event Topics.\n * const { topics } = AbiEvent.encode(transfer)\n *\n * // 3. Query for events matching the encoded Topics.\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n * // @log: [\n * // @log:   \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:   \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:   \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:   \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log: ]\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiEvent - The event to encode.\n * @param args - The arguments to encode.\n * @returns The encoded event topics.\n */\nfunction encode(abiEvent, ...[args]) {\n    let topics = [];\n    if (args && abiEvent.inputs) {\n        const indexedInputs = abiEvent.inputs.filter((param) => 'indexed' in param && param.indexed);\n        const args_ = Array.isArray(args)\n            ? args\n            : Object.values(args).length > 0\n                ? indexedInputs?.map((x, i) => args[x.name ?? i]) ?? []\n                : [];\n        if (args_.length > 0) {\n            const encode = (param, value) => {\n                if (param.type === 'string')\n                    return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_6__.fromString(value));\n                if (param.type === 'bytes')\n                    return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(value);\n                if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n                    throw new FilterTypeNotSupportedError(param.type);\n                return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_4__.encode([param], [value]);\n            };\n            topics =\n                indexedInputs?.map((param, i) => {\n                    if (Array.isArray(args_[i]))\n                        return args_[i].map((_, j) => encode(param, args_[i][j]));\n                    return typeof args_[i] !== 'undefined' && args_[i] !== null\n                        ? encode(param, args_[i])\n                        : null;\n                }) ?? [];\n        }\n    }\n    const selector = (() => {\n        if (abiEvent.hash)\n            return abiEvent.hash;\n        return getSelector(abiEvent);\n    })();\n    return { topics: [selector, ...topics] };\n}\n/**\n * Formats an {@link ox#AbiEvent.AbiEvent} into a **Human Readable ABI Error**.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const formatted = AbiEvent.format({\n *   type: 'event',\n *   name: 'Transfer',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'value', type: 'uint256' },\n *   ],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiEvent - The ABI Event to format.\n * @returns The formatted ABI Event.\n */\nfunction format(abiEvent) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiEvent);\n}\n/**\n * Parses an arbitrary **JSON ABI Event** or **Human Readable ABI Event** into a typed {@link ox#AbiEvent.AbiEvent}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'value', type: 'uint256' },\n *   ],\n * })\n *\n * transfer\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)' // [!code hl]\n * )\n *\n * transfer\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param abiEvent - The ABI Event to parse.\n * @returns Typed ABI Event.\n */\nfunction from(abiEvent, options = {}) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_7__.from(abiEvent, options);\n}\n/**\n * Extracts an {@link ox#AbiEvent.AbiEvent} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Events can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiEvent.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Events can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiEvent.fromAbi(abi, '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Event from the first topic of a Log.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_7__.fromAbi(abi, name, options);\n    if (item.type !== 'event')\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_7__.NotFoundError({ name, type: 'event' });\n    return item;\n}\n/**\n * Computes the event selector (hash of event signature) for an {@link ox#AbiEvent.AbiEvent}.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const selector = AbiEvent.getSelector('event Transfer(address indexed from, address indexed to, uint256 value)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f556a2'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const selector = AbiEvent.getSelector({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'value', type: 'uint256' }\n *   ]\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f556a2'\n * ```\n *\n * @param abiItem - The ABI event to compute the selector for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the event signature.\n */\nfunction getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_7__.getSignatureHash(abiItem);\n}\n/**\n * Thrown when the provided arguments do not match the expected arguments.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   value: 1n,\n * })\n * // @error: AbiEvent.ArgsMismatchError: Given arguments do not match the expected arguments.\n * // @error: Event: event Transfer(address indexed from, address indexed to, uint256 value)\n * // @error: Expected Arguments:\n * // @error:   from:   0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac\n * // @error:   to:     0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad\n * // @error:   value:  1\n * // @error: Given Arguments:\n * // @error:   from:   0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad\n * // @error:   to:     0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac\n * // @error:   value:  1\n * ```\n *\n * ### Solution\n *\n * The provided arguments need to match the expected arguments.\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad', // [!code --]\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac', // [!code ++]\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac', // [!code --]\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad', // [!code ++]\n *   value: 1n,\n * })\n * ```\n */\nclass ArgsMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ abiEvent, expected, given, }) {\n        super('Given arguments do not match the expected arguments.', {\n            metaMessages: [\n                `Event: ${format(abiEvent)}`,\n                `Expected Arguments: ${!expected ? 'None' : ''}`,\n                expected ? (0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_9__.prettyPrint)(expected) : undefined,\n                `Given Arguments: ${!given ? 'None' : ''}`,\n                given ? (0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_9__.prettyPrint)(given) : undefined,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEvent.ArgsMismatchError'\n        });\n    }\n}\n/**\n * Thrown when no argument was found on the event signature.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   a: 'b',\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   value: 1n,\n * })\n * // @error: AbiEvent.InputNotFoundError: Parameter \"a\" not found on `event Transfer(address indexed from, address indexed to, uint256 value)`.\n * ```\n *\n * ### Solution\n *\n * Ensure the arguments match the event signature.\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   a: 'b', // [!code --]\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   value: 1n,\n * })\n * ```\n */\nclass InputNotFoundError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ abiEvent, name, }) {\n        super(`Parameter \"${name}\" not found on \\`${format(abiEvent)}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEvent.InputNotFoundError'\n        });\n    }\n}\n/**\n * Thrown when the provided data size does not match the expected size from the non-indexed parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address to, uint256 value)',\n *   //                                     32 bytes +  32 bytes = 64 bytes\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000023c34600',\n *   //        32 bytes \n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   ],\n * })\n * // @error: AbiEvent.DataMismatchError: Data size of 32 bytes is too small for non-indexed event parameters.\n * // @error: Non-indexed Parameters: (address to, uint256 value)\n * // @error: Data:   0x0000000000000000000000000000000000000000000000000000000023c34600 (32 bytes)\n * ```\n *\n * ### Solution\n *\n * Ensure that the data size matches the expected size.\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address to, uint256 value)',\n *   //                                     32 bytes +  32 bytes = 64 bytes\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000000000023c34600',\n *   //        64 bytes \n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   ],\n * })\n * ```\n */\nclass DataMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ abiEvent, data, parameters, size, }) {\n        super([\n            `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n        ].join('\\n'), {\n            metaMessages: [\n                `Non-indexed Parameters: (${_AbiParameters_js__WEBPACK_IMPORTED_MODULE_4__.format(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEvent.DataMismatchError'\n        });\n        Object.defineProperty(this, \"abiEvent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parameters\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiEvent = abiEvent;\n        this.data = data;\n        this.parameters = parameters;\n        this.size = size;\n    }\n}\n/**\n * Thrown when the provided topics do not match the expected number of topics.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * })\n * // @error: AbiEvent.TopicsMismatchError: Expected a topic for indexed event parameter \"to\" for \"event Transfer(address indexed from, address indexed to, uint256 value)\".\n * ```\n *\n * ### Solution\n *\n * Ensure that the topics match the expected number of topics.\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code ++]\n *   ],\n * })\n * ```\n *\n */\nclass TopicsMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ abiEvent, param, }) {\n        super([\n            `Expected a topic for indexed event parameter${param.name ? ` \"${param.name}\"` : ''} for \"${format(abiEvent)}\".`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEvent.TopicsMismatchError'\n        });\n        Object.defineProperty(this, \"abiEvent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiEvent = abiEvent;\n    }\n}\n/**\n * Thrown when the provided selector does not match the expected selector.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, bool sender)',\n * )\n *\n * AbiEvent.decode(transfer, {\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   ],\n * })\n * // @error: AbiEvent.SelectorTopicMismatchError: topics[0]=\"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\" does not match the expected topics[0]=\"0x3da3cd3cf420c78f8981e7afeefa0eab1f0de0eb56e78ad9ba918ed01c0b402f\".\n * // @error: Event: event Transfer(address indexed from, address indexed to, bool sender)\n * // @error: Selector: 0x3da3cd3cf420c78f8981e7afeefa0eab1f0de0eb56e78ad9ba918ed01c0b402f\n * ```\n *\n * ### Solution\n *\n * Ensure that the provided selector matches the selector of the event signature.\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, bool sender)',\n * )\n *\n * AbiEvent.decode(transfer, {\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // [!code --]\n *     '0x3da3cd3cf420c78f8981e7afeefa0eab1f0de0eb56e78ad9ba918ed01c0b402f', // [!code ++]\n *     '0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   ],\n * })\n * ```\n */\nclass SelectorTopicMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ abiEvent, actual, expected, }) {\n        super(`topics[0]=\"${actual}\" does not match the expected topics[0]=\"${expected}\".`, {\n            metaMessages: [`Event: ${format(abiEvent)}`, `Selector: ${expected}`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEvent.SelectorTopicMismatchError'\n        });\n    }\n}\n/**\n * Thrown when the provided filter type is not supported.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from('event Transfer((string) indexed a, string b)')\n *\n * AbiEvent.encode(transfer, {\n *   a: ['hello'],\n * })\n * // @error: AbiEvent.FilterTypeNotSupportedError: Filter type \"tuple\" is not supported.\n * ```\n *\n * ### Solution\n *\n * Provide a valid event input type.\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from('event Transfer((string) indexed a, string b)') // [!code --]\n * const transfer = AbiEvent.from('event Transfer(string indexed a, string b)') // [!code ++]\n * ```\n *\n *\n */\nclass FilterTypeNotSupportedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(type) {\n        super(`Filter type \"${type}\" is not supported.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEvent.FilterTypeNotSupportedError'\n        });\n    }\n}\n//# sourceMappingURL=AbiEvent.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlFdmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNLO0FBQ1k7QUFDWjtBQUNKO0FBQ0U7QUFDSjtBQUNGO0FBQ2U7QUFDSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0EsbUJBQW1CLCtDQUFjLENBQUMsaURBQWdCO0FBQ2xEO0FBQ0EsbUJBQW1CLCtDQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQkFBcUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ08seUNBQXlDLGlEQUFnQjtBQUNoRSxrQkFBa0IsNkJBQTZCO0FBQy9DLDRCQUE0QixPQUFPLDJDQUEyQyxTQUFTO0FBQ3ZGLHFDQUFxQyxpQkFBaUIsZ0JBQWdCLFNBQVM7QUFDL0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlFdmVudC5qcz83ZWZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBBYmlJdGVtIGZyb20gJy4vQWJpSXRlbS5qcyc7XG5pbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4vQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgQ3Vyc29yIGZyb20gJy4vaW50ZXJuYWwvY3Vyc29yLmpzJztcbmltcG9ydCB7IHByZXR0eVByaW50IH0gZnJvbSAnLi9pbnRlcm5hbC9lcnJvcnMuanMnO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCB0aGUgZGVjb2RlZCBsb2cgYXJndW1lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXZlbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlFdmVudCA9IEFiaUV2ZW50LmZyb20oJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpJylcbiAqXG4gKiBjb25zdCBhcmdzID0gQWJpRXZlbnQuZGVjb2RlKGFiaUV2ZW50LCB7XG4gKiAgIGRhdGE6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqICAgXSxcbiAqIH0pXG4gKlxuICogQWJpRXZlbnQuYXNzZXJ0QXJncyhhYmlFdmVudCwgYXJncywge1xuICogICBmcm9tOiAnMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFkJyxcbiAqICAgdG86ICcweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLFxuICogICB2YWx1ZTogMW4sXG4gKiB9KVxuICpcbiAqIC8vIEBlcnJvcjogQWJpRXZlbnQuQXJnc01pc21hdGNoRXJyb3I6IEdpdmVuIGFyZ3VtZW50cyB0byBub3QgbWF0Y2ggdGhlIGFyZ3VtZW50cyBkZWNvZGVkIGZyb20gdGhlIGxvZy5cbiAqIC8vIEBlcnJvcjogRXZlbnQ6IGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpXG4gKiAvLyBAZXJyb3I6IEV4cGVjdGVkIEFyZ3VtZW50czpcbiAqIC8vIEBlcnJvcjogICBmcm9tOiAgIDB4YTVjYzNjMDM5OTRkYjViMGQ5YTVlZWRkMTBjYWJhYjA4MTM2NzhhY1xuICogLy8gQGVycm9yOiAgIHRvOiAgICAgMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFkXG4gKiAvLyBAZXJyb3I6ICAgdmFsdWU6ICAxXG4gKiAvLyBAZXJyb3I6IEdpdmVuIEFyZ3VtZW50czpcbiAqIC8vIEBlcnJvcjogICBmcm9tOiAgIDB4YTVjYzNjMDM5OTRkYjViMGQ5YTVlZWRkMTBjYWJhYjA4MTM2NzhhZFxuICogLy8gQGVycm9yOiAgIHRvOiAgICAgMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjXG4gKiAvLyBAZXJyb3I6ICAgdmFsdWU6ICAxXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpRXZlbnQgLSBBQkkgRXZlbnQgdG8gY2hlY2suXG4gKiBAcGFyYW0gYXJncyAtIERlY29kZWQgYXJndW1lbnRzLlxuICogQHBhcmFtIG1hdGNoQXJncyAtIFRoZSBhcmd1bWVudHMgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmdzKGFiaUV2ZW50LCBhcmdzLCBtYXRjaEFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MgfHwgIW1hdGNoQXJncylcbiAgICAgICAgdGhyb3cgbmV3IEFyZ3NNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGFiaUV2ZW50LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IGFyZ3MsXG4gICAgICAgICAgICBnaXZlbjogbWF0Y2hBcmdzLFxuICAgICAgICB9KTtcbiAgICBmdW5jdGlvbiBpc0VxdWFsKGlucHV0LCB2YWx1ZSwgYXJnKSB7XG4gICAgICAgIGlmIChpbnB1dC50eXBlID09PSAnYWRkcmVzcycpXG4gICAgICAgICAgICByZXR1cm4gQWRkcmVzcy5pc0VxdWFsKHZhbHVlLCBhcmcpO1xuICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyh2YWx1ZSkpID09PSBhcmc7XG4gICAgICAgIGlmIChpbnB1dC50eXBlID09PSAnYnl0ZXMnKVxuICAgICAgICAgICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KHZhbHVlKSA9PT0gYXJnO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGFyZztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgQXJyYXkuaXNBcnJheShtYXRjaEFyZ3MpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCB2YWx1ZV0gb2YgbWF0Y2hBcmdzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGFiaUV2ZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnB1dE5vdEZvdW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBhYmlFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7aW5kZXh9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlXyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgbGV0IGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlXykge1xuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsKGlucHV0LCB2YWx1ZSwgYXJnc1tpbmRleF0pKVxuICAgICAgICAgICAgICAgICAgICBlcXVhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVxdWFsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmdzTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGFiaUV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogYXJncyxcbiAgICAgICAgICAgICAgICAgICAgZ2l2ZW46IG1hdGNoQXJncyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KGFyZ3MpICYmXG4gICAgICAgIHR5cGVvZiBtYXRjaEFyZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KG1hdGNoQXJncykpXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1hdGNoQXJncykpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBhYmlFdmVudC5pbnB1dHMuZmluZCgoaW5wdXQpID0+IGlucHV0Lm5hbWUgPT09IGtleSk7XG4gICAgICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnB1dE5vdEZvdW5kRXJyb3IoeyBhYmlFdmVudCwgbmFtZToga2V5IH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVfID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgICAgICBsZXQgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVfKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwoaW5wdXQsIHZhbHVlLCBhcmdzW2tleV0pKVxuICAgICAgICAgICAgICAgICAgICBlcXVhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVxdWFsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmdzTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGFiaUV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogYXJncyxcbiAgICAgICAgICAgICAgICAgICAgZ2l2ZW46IG1hdGNoQXJncyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxufVxuLyoqXG4gKiBBQkktRGVjb2RlcyB0aGUgcHJvdmlkZWQgW0xvZyBUb3BpY3MgYW5kIERhdGFdKGh0dHBzOi8vaW5mby5ldGhlcnNjYW4uY29tL3doYXQtaXMtZXZlbnQtbG9ncy8pIGFjY29yZGluZyB0byB0aGUgQUJJIEV2ZW50J3MgcGFyYW1ldGVyIHR5cGVzIChgaW5wdXRgKS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSB1c2VkIHRvIGRlY29kZSBhbiBbRXZlbnQgTG9nXShodHRwczovL2luZm8uZXRoZXJzY2FuLmNvbS93aGF0LWlzLWV2ZW50LWxvZ3MvKSB0aGF0IG1heSBiZSByZXR1cm5lZCBmcm9tIGEgTG9nIFF1ZXJ5IChlLmcuIGBldGhfZ2V0TG9nc2ApIG9yIFRyYW5zYWN0aW9uIFJlY2VpcHQuXG4gKlxuICogU2VlIHRoZSBbRW5kLXRvLWVuZCBFeGFtcGxlXSgjZW5kLXRvLWVuZCkuXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHRyYW5zZmVyID0gQWJpRXZlbnQuZnJvbShcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpJ1xuICogKVxuICpcbiAqIGNvbnN0IGxvZyA9IHtcbiAqICAgLy8gLi4uXG4gKiAgIGRhdGE6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqICAgXSxcbiAqIH0gYXMgY29uc3RcbiAqXG4gKiBjb25zdCBkZWNvZGVkID0gQWJpRXZlbnQuZGVjb2RlKHRyYW5zZmVyLCBsb2cpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGZyb206ICcweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLFxuICogLy8gQGxvZzogICB0bzogJzB4YTVjYzNjMDM5OTRkYjViMGQ5YTVlZWRkMTBjYWJhYjA4MTM2NzhhYycsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmQtdG8tZW5kXG4gKlxuICogQmVsb3cgaXMgYW4gZW5kLXRvLWVuZCBleGFtcGxlIG9mIHVzaW5nIGBBYmlFdmVudC5kZWNvZGVgIHRvIGRlY29kZSB0aGUgdG9waWNzIG9mIGEgYFRyYW5zZmVyYCBldmVudCBvbiB0aGUgW1dhZ21pIE1pbnQgRXhhbXBsZSBjb250cmFjdF0oaHR0cHM6Ly9ldGhlcnNjYW4uaW8vYWRkcmVzcy8weGZiYTM5MTJjYTA0ZGQ0NThjODQzZTJlZTA4OTY3ZmMwNGYzNTc5YzIpLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IEFiaUV2ZW50LCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiAvLyAxLiBJbnN0YW50aWF0ZSB0aGUgYFRyYW5zZmVyYCBBQkkgRXZlbnQuXG4gKiBjb25zdCB0cmFuc2ZlciA9IEFiaUV2ZW50LmZyb20oXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyBpbmRleGVkIHRvLCB1aW50MjU2IHZhbHVlKScsXG4gKiApXG4gKlxuICogLy8gMi4gRW5jb2RlIHRoZSBBQkkgRXZlbnQgaW50byBFdmVudCBUb3BpY3MuXG4gKiBjb25zdCB7IHRvcGljcyB9ID0gQWJpRXZlbnQuZW5jb2RlKHRyYW5zZmVyKVxuICpcbiAqIC8vIDMuIFF1ZXJ5IGZvciBldmVudHMgbWF0Y2hpbmcgdGhlIGVuY29kZWQgVG9waWNzLlxuICogY29uc3QgbG9ncyA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSEucmVxdWVzdCh7XG4gKiAgIG1ldGhvZDogJ2V0aF9nZXRMb2dzJyxcbiAqICAgcGFyYW1zOiBbXG4gKiAgICAge1xuICogICAgICAgYWRkcmVzczogJzB4ZmJhMzkxMmNhMDRkZDQ1OGM4NDNlMmVlMDg5NjdmYzA0ZjM1NzljMicsXG4gKiAgICAgICBmcm9tQmxvY2s6IEhleC5mcm9tTnVtYmVyKDE5NzYwMjM1biksXG4gKiAgICAgICB0b0Jsb2NrOiBIZXguZnJvbU51bWJlcigxOTc2MDI0MG4pLFxuICogICAgICAgdG9waWNzLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiB9KVxuICpcbiAqIC8vIDQuIERlY29kZSB0aGUgTG9nLiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCBkZWNvZGVkID0gQWJpRXZlbnQuZGVjb2RlKHRyYW5zZmVyLCBsb2dzWzBdISkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBmcm9tOiAnMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqIC8vIEBsb2c6ICAgdG86ICcweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLFxuICogLy8gQGxvZzogICB2YWx1ZTogNjAzblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogOjo6bm90ZVxuICpcbiAqIEZvciBzaW1wbGljaXR5LCB0aGUgYWJvdmUgZXhhbXBsZSB1c2VzIGB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdGAsIGJ1dCB5b3UgY2FuIHVzZSBhbnlcbiAqIHR5cGUgb2YgSlNPTi1SUEMgaW50ZXJmYWNlLlxuICpcbiAqIDo6OlxuICpcbiAqIEBwYXJhbSBhYmlFdmVudCAtIFRoZSBBQkkgRXZlbnQgdG8gZGVjb2RlLlxuICogQHBhcmFtIGxvZyAtIGB0b3BpY3NgICYgYGRhdGFgIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGV2ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGFiaUV2ZW50LCBsb2cpIHtcbiAgICBjb25zdCB7IGRhdGEsIHRvcGljcyB9ID0gbG9nO1xuICAgIGNvbnN0IFtzZWxlY3Rvcl8sIC4uLmFyZ1RvcGljc10gPSB0b3BpY3M7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihhYmlFdmVudCk7XG4gICAgaWYgKHNlbGVjdG9yXyAhPT0gc2VsZWN0b3IpXG4gICAgICAgIHRocm93IG5ldyBTZWxlY3RvclRvcGljTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBhYmlFdmVudCxcbiAgICAgICAgICAgIGFjdHVhbDogc2VsZWN0b3JfLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IHNlbGVjdG9yLFxuICAgICAgICB9KTtcbiAgICBjb25zdCB7IGlucHV0cyB9ID0gYWJpRXZlbnQ7XG4gICAgY29uc3QgaXNVbm5hbWVkID0gaW5wdXRzPy5ldmVyeSgoeCkgPT4gISgnbmFtZScgaW4geCAmJiB4Lm5hbWUpKTtcbiAgICBsZXQgYXJncyA9IGlzVW5uYW1lZCA/IFtdIDoge307XG4gICAgLy8gRGVjb2RlIHRvcGljcyAoaW5kZXhlZCBhcmdzKS5cbiAgICBjb25zdCBpbmRleGVkSW5wdXRzID0gaW5wdXRzLmZpbHRlcigoeCkgPT4gJ2luZGV4ZWQnIGluIHggJiYgeC5pbmRleGVkKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZWRJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBpbmRleGVkSW5wdXRzW2ldO1xuICAgICAgICBjb25zdCB0b3BpYyA9IGFyZ1RvcGljc1tpXTtcbiAgICAgICAgaWYgKCF0b3BpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBUb3BpY3NNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgICAgICBhYmlFdmVudCxcbiAgICAgICAgICAgICAgICBwYXJhbTogcGFyYW0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgYXJnc1tpc1VubmFtZWQgPyBpIDogcGFyYW0ubmFtZSB8fCBpXSA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICBwYXJhbS50eXBlID09PSAnYnl0ZXMnIHx8XG4gICAgICAgICAgICAgICAgcGFyYW0udHlwZSA9PT0gJ3R1cGxlJyB8fFxuICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUubWF0Y2goL14oLiopXFxbKFxcZCspP1xcXSQvKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9waWM7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gQWJpUGFyYW1ldGVycy5kZWNvZGUoW3BhcmFtXSwgdG9waWMpIHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZWRbMF07XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8vIERlY29kZSBkYXRhIChub24taW5kZXhlZCBhcmdzKS5cbiAgICBjb25zdCBub25JbmRleGVkSW5wdXRzID0gaW5wdXRzLmZpbHRlcigoeCkgPT4gISgnaW5kZXhlZCcgaW4geCAmJiB4LmluZGV4ZWQpKTtcbiAgICBpZiAobm9uSW5kZXhlZElucHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEgIT09ICcweCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb2RlZERhdGEgPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShub25JbmRleGVkSW5wdXRzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjb2RlZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5uYW1lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbLi4uYXJncywgLi4uZGVjb2RlZERhdGFdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9uSW5kZXhlZElucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaW5wdXRzLmluZGV4T2Yobm9uSW5kZXhlZElucHV0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tub25JbmRleGVkSW5wdXRzW2ldLm5hbWUgfHwgaW5kZXhdID0gZGVjb2RlZERhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEFiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIEN1cnNvci5Qb3NpdGlvbk91dE9mQm91bmRzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBEYXRhTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmlFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBub25JbmRleGVkSW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUoZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEYXRhTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgYWJpRXZlbnQsXG4gICAgICAgICAgICAgICAgZGF0YTogJzB4JyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBub25JbmRleGVkSW5wdXRzLFxuICAgICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhhcmdzKS5sZW5ndGggPiAwID8gYXJncyA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQUJJLWVuY29kZXMgdGhlIHByb3ZpZGVkIGV2ZW50IGlucHV0IChgaW5wdXRzYCkgaW50byBhbiBhcnJheSBvZiBbRXZlbnQgVG9waWNzXShodHRwczovL2luZm8uZXRoZXJzY2FuLmNvbS93aGF0LWlzLWV2ZW50LWxvZ3MvKS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSB1c2VkIHRvIGVuY29kZSBldmVudCBhcmd1bWVudHMgaW50byBbRXZlbnQgVG9waWNzXShodHRwczovL2luZm8uZXRoZXJzY2FuLmNvbS93aGF0LWlzLWV2ZW50LWxvZ3MvKS5cbiAqXG4gKiBTZWUgdGhlIFtFbmQtdG8tZW5kIEV4YW1wbGVdKCNlbmQtdG8tZW5kKS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUV2ZW50IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNmZXIgPSBBYmlFdmVudC5mcm9tKFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSknXG4gKiApXG4gKlxuICogY29uc3QgeyB0b3BpY3MgfSA9IEFiaUV2ZW50LmVuY29kZSh0cmFuc2ZlcilcbiAqIC8vIEBsb2c6IFsnMHg0MDZkYWRlMzFmN2FlNGI1ZGJjMjc2MjU4YzI4ZGRlNWFlNmQ1YzI3NzNjNTc0NTgwMmM0OTNhMjM2MGU1NWUwJ11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgUGFzc2luZyBBcmd1bWVudHNcbiAqXG4gKiBZb3UgY2FuIHBhc3MgYGluZGV4ZWRgIHBhcmFtZXRlciB2YWx1ZXMgdG8gYEFiaUV2ZW50LmVuY29kZWAuXG4gKlxuICogVHlwZVNjcmlwdCB0eXBlcyB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlIEFCSSBFdmVudCwgdG8gZ3VhcmQgeW91IGZyb20gaW5zZXJ0aW5nIHRoZSB3cm9uZyB2YWx1ZXMuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoZSBgVHJhbnNmZXJgIGV2ZW50IGJlbG93IGFjY2VwdHMgYW4gYGFkZHJlc3NgIHR5cGUgZm9yIHRoZSBgZnJvbWAgYW5kIGB0b2AgYXR0cmlidXRlcy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXZlbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmFuc2ZlciA9IEFiaUV2ZW50LmZyb20oXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyBpbmRleGVkIHRvLCB1aW50MjU2IHZhbHVlKSdcbiAqIClcbiAqXG4gKiBjb25zdCB7IHRvcGljcyB9ID0gQWJpRXZlbnQuZW5jb2RlKHRyYW5zZmVyLCB7XG4gKiAgIGZyb206ICcweGYzOWZkNmU1MWFhZDg4ZjZmNGNlNmFiODgyNzI3OWNmZmZiOTIyNjYnLCAvLyBbIWNvZGUgaGxdXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyAvLyBbIWNvZGUgaGxdXG4gKiB9KVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICAnMHg0MDZkYWRlMzFmN2FlNGI1ZGJjMjc2MjU4YzI4ZGRlNWFlNmQ1YzI3NzNjNTc0NTgwMmM0OTNhMjM2MGU1NWUwJyxcbiAqIC8vIEBsb2c6ICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmMzlmZDZlNTFhYWQ4OGY2ZjRjZTZhYjg4MjcyNzljZmZmYjkyMjY2JyxcbiAqIC8vIEBsb2c6ICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4J1xuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmQtdG8tZW5kXG4gKlxuICogQmVsb3cgaXMgYW4gZW5kLXRvLWVuZCBleGFtcGxlIG9mIHVzaW5nIGBBYmlFdmVudC5lbmNvZGVgIHRvIGVuY29kZSB0aGUgdG9waWNzIG9mIGEgYFRyYW5zZmVyYCBldmVudCBhbmQgcXVlcnkgZm9yIGV2ZW50cyBtYXRjaGluZyB0aGUgZW5jb2RlZCB0b3BpY3Mgb24gdGhlIFtXYWdtaSBNaW50IEV4YW1wbGUgY29udHJhY3RdKGh0dHBzOi8vZXRoZXJzY2FuLmlvL2FkZHJlc3MvMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyKS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBBYmlFdmVudCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogLy8gMS4gSW5zdGFudGlhdGUgdGhlIGBUcmFuc2ZlcmAgQUJJIEV2ZW50LlxuICogY29uc3QgdHJhbnNmZXIgPSBBYmlFdmVudC5mcm9tKFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSknLFxuICogKVxuICpcbiAqIC8vIDIuIEVuY29kZSB0aGUgQUJJIEV2ZW50IGludG8gRXZlbnQgVG9waWNzLlxuICogY29uc3QgeyB0b3BpY3MgfSA9IEFiaUV2ZW50LmVuY29kZSh0cmFuc2ZlcilcbiAqXG4gKiAvLyAzLiBRdWVyeSBmb3IgZXZlbnRzIG1hdGNoaW5nIHRoZSBlbmNvZGVkIFRvcGljcy5cbiAqIGNvbnN0IGxvZ3MgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0hLnJlcXVlc3Qoe1xuICogICBtZXRob2Q6ICdldGhfZ2V0TG9ncycsXG4gKiAgIHBhcmFtczogW1xuICogICAgIHtcbiAqICAgICAgIGFkZHJlc3M6ICcweGZiYTM5MTJjYTA0ZGQ0NThjODQzZTJlZTA4OTY3ZmMwNGYzNTc5YzInLFxuICogICAgICAgZnJvbUJsb2NrOiBIZXguZnJvbU51bWJlcigxOTc2MDIzNW4pLFxuICogICAgICAgdG9CbG9jazogSGV4LmZyb21OdW1iZXIoMTk3NjAyNDBuKSxcbiAqICAgICAgIHRvcGljcyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgXCIweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWZcIixcbiAqIC8vIEBsb2c6ICAgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAqIC8vIEBsb2c6ICAgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjMDRkOWU5Mjc4ZWM1ZTRkNDI0NDc2ZDNlYmVjNzBjYjVkNjQ4ZDFcIixcbiAqIC8vIEBsb2c6ICAgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyNWJcIixcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFib3ZlIGV4YW1wbGUgdXNlcyBgd2luZG93LmV0aGVyZXVtLnJlcXVlc3RgLCBidXQgeW91IGNhbiB1c2UgYW55XG4gKiB0eXBlIG9mIEpTT04tUlBDIGludGVyZmFjZS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpRXZlbnQgLSBUaGUgZXZlbnQgdG8gZW5jb2RlLlxuICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIGV2ZW50IHRvcGljcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShhYmlFdmVudCwgLi4uW2FyZ3NdKSB7XG4gICAgbGV0IHRvcGljcyA9IFtdO1xuICAgIGlmIChhcmdzICYmIGFiaUV2ZW50LmlucHV0cykge1xuICAgICAgICBjb25zdCBpbmRleGVkSW5wdXRzID0gYWJpRXZlbnQuaW5wdXRzLmZpbHRlcigocGFyYW0pID0+ICdpbmRleGVkJyBpbiBwYXJhbSAmJiBwYXJhbS5pbmRleGVkKTtcbiAgICAgICAgY29uc3QgYXJnc18gPSBBcnJheS5pc0FycmF5KGFyZ3MpXG4gICAgICAgICAgICA/IGFyZ3NcbiAgICAgICAgICAgIDogT2JqZWN0LnZhbHVlcyhhcmdzKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBpbmRleGVkSW5wdXRzPy5tYXAoKHgsIGkpID0+IGFyZ3NbeC5uYW1lID8/IGldKSA/PyBbXVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgIGlmIChhcmdzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGUgPSAocGFyYW0sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2J5dGVzJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3R1cGxlJyB8fCBwYXJhbS50eXBlLm1hdGNoKC9eKC4qKVxcWyhcXGQrKT9cXF0kLykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaWx0ZXJUeXBlTm90U3VwcG9ydGVkRXJyb3IocGFyYW0udHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZW5jb2RlKFtwYXJhbV0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRvcGljcyA9XG4gICAgICAgICAgICAgICAgaW5kZXhlZElucHV0cz8ubWFwKChwYXJhbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzX1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc19baV0ubWFwKChfLCBqKSA9PiBlbmNvZGUocGFyYW0sIGFyZ3NfW2ldW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnc19baV0gIT09ICd1bmRlZmluZWQnICYmIGFyZ3NfW2ldICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGVuY29kZShwYXJhbSwgYXJnc19baV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSkgPz8gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0b3IgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYWJpRXZlbnQuaGFzaClcbiAgICAgICAgICAgIHJldHVybiBhYmlFdmVudC5oYXNoO1xuICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3IoYWJpRXZlbnQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHsgdG9waWNzOiBbc2VsZWN0b3IsIC4uLnRvcGljc10gfTtcbn1cbi8qKlxuICogRm9ybWF0cyBhbiB7QGxpbmsgb3gjQWJpRXZlbnQuQWJpRXZlbnR9IGludG8gYSAqKkh1bWFuIFJlYWRhYmxlIEFCSSBFcnJvcioqLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXZlbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmlFdmVudC5mb3JtYXQoe1xuICogICB0eXBlOiAnZXZlbnQnLFxuICogICBuYW1lOiAnVHJhbnNmZXInLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7IG5hbWU6ICdmcm9tJywgdHlwZTogJ2FkZHJlc3MnLCBpbmRleGVkOiB0cnVlIH0sXG4gKiAgICAgeyBuYW1lOiAndG8nLCB0eXBlOiAnYWRkcmVzcycsIGluZGV4ZWQ6IHRydWUgfSxcbiAqICAgICB7IG5hbWU6ICd2YWx1ZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICogICBdLFxuICogfSlcbiAqXG4gKiBmb3JtYXR0ZWRcbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlFdmVudCAtIFRoZSBBQkkgRXZlbnQgdG8gZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBBQkkgRXZlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpRXZlbnQpIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUV2ZW50KTtcbn1cbi8qKlxuICogUGFyc2VzIGFuIGFyYml0cmFyeSAqKkpTT04gQUJJIEV2ZW50Kiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgRXZlbnQqKiBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0FiaUV2ZW50LkFiaUV2ZW50fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gQUJJc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHRyYW5zZmVyID0gQWJpRXZlbnQuZnJvbSh7XG4gKiAgIG5hbWU6ICdUcmFuc2ZlcicsXG4gKiAgIHR5cGU6ICdldmVudCcsXG4gKiAgIGlucHV0czogW1xuICogICAgIHsgbmFtZTogJ2Zyb20nLCB0eXBlOiAnYWRkcmVzcycsIGluZGV4ZWQ6IHRydWUgfSxcbiAqICAgICB7IG5hbWU6ICd0bycsIHR5cGU6ICdhZGRyZXNzJywgaW5kZXhlZDogdHJ1ZSB9LFxuICogICAgIHsgbmFtZTogJ3ZhbHVlJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gKiAgIF0sXG4gKiB9KVxuICpcbiAqIHRyYW5zZmVyXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEh1bWFuIFJlYWRhYmxlIEFCSXNcbiAqXG4gKiBBIEh1bWFuIFJlYWRhYmxlIEFCSSBjYW4gYmUgcGFyc2VkIGludG8gYSB0eXBlZCBBQkkgb2JqZWN0OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHRyYW5zZmVyID0gQWJpRXZlbnQuZnJvbShcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpJyAvLyBbIWNvZGUgaGxdXG4gKiApXG4gKlxuICogdHJhbnNmZXJcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpRXZlbnQgLSBUaGUgQUJJIEV2ZW50IHRvIHBhcnNlLlxuICogQHJldHVybnMgVHlwZWQgQUJJIEV2ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhYmlFdmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZnJvbShhYmlFdmVudCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4dHJhY3RzIGFuIHtAbGluayBveCNBYmlFdmVudC5BYmlFdmVudH0gZnJvbSBhbiB7QGxpbmsgb3gjQWJpLkFiaX0gZ2l2ZW4gYSBuYW1lIGFuZCBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IE5hbWVcbiAqXG4gKiBBQkkgRXZlbnRzIGNhbiBiZSBleHRyYWN0ZWQgYnkgdGhlaXIgbmFtZSB1c2luZyB0aGUgYG5hbWVgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUV2ZW50LmZyb21BYmkoYWJpLCAnVHJhbnNmZXInKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IFNlbGVjdG9yXG4gKlxuICogQUJJIEV2ZW50cyBjYW4gYmUgZXh0cmFjdCBieSB0aGVpciBzZWxlY3RvciB3aGVuIHtAbGluayBveCNIZXguSGV4fSBpcyBwcm92aWRlZCB0byBgbmFtZWAuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRXZlbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUV2ZW50LmZyb21BYmkoYWJpLCAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBFeHRyYWN0aW5nIHZpYSBhIGhleCBzZWxlY3RvciBpcyB1c2VmdWwgd2hlbiBleHRyYWN0aW5nIGFuIEFCSSBFdmVudCBmcm9tIHRoZSBmaXJzdCB0b3BpYyBvZiBhIExvZy5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpIC0gVGhlIEFCSSB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIChvciBzZWxlY3Rvcikgb2YgdGhlIEFCSSBpdGVtIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEV4dHJhY3Rpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBBQkkgaXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksIG5hbWUsIG9wdGlvbnMpO1xuICAgIGlmIChpdGVtLnR5cGUgIT09ICdldmVudCcpXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLk5vdEZvdW5kRXJyb3IoeyBuYW1lLCB0eXBlOiAnZXZlbnQnIH0pO1xuICAgIHJldHVybiBpdGVtO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZXZlbnQgc2VsZWN0b3IgKGhhc2ggb2YgZXZlbnQgc2lnbmF0dXJlKSBmb3IgYW4ge0BsaW5rIG94I0FiaUV2ZW50LkFiaUV2ZW50fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUV2ZW50IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlFdmVudC5nZXRTZWxlY3RvcignZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSknKVxuICogLy8gQGxvZzogJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTU2YTInXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUV2ZW50IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlFdmVudC5nZXRTZWxlY3Rvcih7XG4gKiAgIG5hbWU6ICdUcmFuc2ZlcicsXG4gKiAgIHR5cGU6ICdldmVudCcsXG4gKiAgIGlucHV0czogW1xuICogICAgIHsgbmFtZTogJ2Zyb20nLCB0eXBlOiAnYWRkcmVzcycsIGluZGV4ZWQ6IHRydWUgfSxcbiAqICAgICB7IG5hbWU6ICd0bycsIHR5cGU6ICdhZGRyZXNzJywgaW5kZXhlZDogdHJ1ZSB9LFxuICogICAgIHsgbmFtZTogJ3ZhbHVlJywgdHlwZTogJ3VpbnQyNTYnIH1cbiAqICAgXVxuICogfSlcbiAqIC8vIEBsb2c6ICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1NmEyJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIGV2ZW50IHRvIGNvbXB1dGUgdGhlIHNlbGVjdG9yIGZvci5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjSGFzaC4oa2VjY2FrMjU2OmZ1bmN0aW9uKX0gaGFzaCBvZiB0aGUgZXZlbnQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0b3IoYWJpSXRlbSkge1xuICAgIHJldHVybiBBYmlJdGVtLmdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSk7XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgZG8gbm90IG1hdGNoIHRoZSBleHBlY3RlZCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUV2ZW50ID0gQWJpRXZlbnQuZnJvbShcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpJyxcbiAqIClcbiAqXG4gKiBjb25zdCBhcmdzID0gQWJpRXZlbnQuZGVjb2RlKGFiaUV2ZW50LCB7XG4gKiAgIGRhdGE6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFkJyxcbiAqICAgXSxcbiAqIH0pXG4gKlxuICogQWJpRXZlbnQuYXNzZXJ0QXJncyhhYmlFdmVudCwgYXJncywge1xuICogICBmcm9tOiAnMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFkJyxcbiAqICAgdG86ICcweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLFxuICogICB2YWx1ZTogMW4sXG4gKiB9KVxuICogLy8gQGVycm9yOiBBYmlFdmVudC5BcmdzTWlzbWF0Y2hFcnJvcjogR2l2ZW4gYXJndW1lbnRzIGRvIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgYXJndW1lbnRzLlxuICogLy8gQGVycm9yOiBFdmVudDogZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSlcbiAqIC8vIEBlcnJvcjogRXhwZWN0ZWQgQXJndW1lbnRzOlxuICogLy8gQGVycm9yOiAgIGZyb206ICAgMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjXG4gKiAvLyBAZXJyb3I6ICAgdG86ICAgICAweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWRcbiAqIC8vIEBlcnJvcjogICB2YWx1ZTogIDFcbiAqIC8vIEBlcnJvcjogR2l2ZW4gQXJndW1lbnRzOlxuICogLy8gQGVycm9yOiAgIGZyb206ICAgMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFkXG4gKiAvLyBAZXJyb3I6ICAgdG86ICAgICAweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWNcbiAqIC8vIEBlcnJvcjogICB2YWx1ZTogIDFcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFRoZSBwcm92aWRlZCBhcmd1bWVudHMgbmVlZCB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgYXJndW1lbnRzLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaUV2ZW50IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpRXZlbnQgPSBBYmlFdmVudC5mcm9tKFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSknLFxuICogKVxuICpcbiAqIGNvbnN0IGFyZ3MgPSBBYmlFdmVudC5kZWNvZGUoYWJpRXZlbnQsIHtcbiAqICAgZGF0YTogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgIHRvcGljczogW1xuICogICAgICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnLFxuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLFxuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWQnLFxuICogICBdLFxuICogfSlcbiAqXG4gKiBBYmlFdmVudC5hc3NlcnRBcmdzKGFiaUV2ZW50LCBhcmdzLCB7XG4gKiAgIGZyb206ICcweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWQnLCAvLyBbIWNvZGUgLS1dXG4gKiAgIGZyb206ICcweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLCAvLyBbIWNvZGUgKytdXG4gKiAgIHRvOiAnMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJywgLy8gWyFjb2RlIC0tXVxuICogICB0bzogJzB4YTVjYzNjMDM5OTRkYjViMGQ5YTVlZWRkMTBjYWJhYjA4MTM2NzhhZCcsIC8vIFshY29kZSArK11cbiAqICAgdmFsdWU6IDFuLFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXJnc01pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGFiaUV2ZW50LCBleHBlY3RlZCwgZ2l2ZW4sIH0pIHtcbiAgICAgICAgc3VwZXIoJ0dpdmVuIGFyZ3VtZW50cyBkbyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIGFyZ3VtZW50cy4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgRXZlbnQ6ICR7Zm9ybWF0KGFiaUV2ZW50KX1gLFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBBcmd1bWVudHM6ICR7IWV4cGVjdGVkID8gJ05vbmUnIDogJyd9YCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA/IHByZXR0eVByaW50KGV4cGVjdGVkKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBgR2l2ZW4gQXJndW1lbnRzOiAkeyFnaXZlbiA/ICdOb25lJyA6ICcnfWAsXG4gICAgICAgICAgICAgICAgZ2l2ZW4gPyBwcmV0dHlQcmludChnaXZlbikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUV2ZW50LkFyZ3NNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIG5vIGFyZ3VtZW50IHdhcyBmb3VuZCBvbiB0aGUgZXZlbnQgc2lnbmF0dXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUV2ZW50ID0gQWJpRXZlbnQuZnJvbShcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpJyxcbiAqIClcbiAqXG4gKiBjb25zdCBhcmdzID0gQWJpRXZlbnQuZGVjb2RlKGFiaUV2ZW50LCB7XG4gKiAgIGRhdGE6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFkJyxcbiAqICAgXSxcbiAqIH0pXG4gKlxuICogQWJpRXZlbnQuYXNzZXJ0QXJncyhhYmlFdmVudCwgYXJncywge1xuICogICBhOiAnYicsXG4gKiAgIGZyb206ICcweGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLFxuICogICB0bzogJzB4YTVjYzNjMDM5OTRkYjViMGQ5YTVlZWRkMTBjYWJhYjA4MTM2NzhhZCcsXG4gKiAgIHZhbHVlOiAxbixcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEFiaUV2ZW50LklucHV0Tm90Rm91bmRFcnJvcjogUGFyYW1ldGVyIFwiYVwiIG5vdCBmb3VuZCBvbiBgZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSlgLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogRW5zdXJlIHRoZSBhcmd1bWVudHMgbWF0Y2ggdGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUV2ZW50ID0gQWJpRXZlbnQuZnJvbShcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpJyxcbiAqIClcbiAqXG4gKiBjb25zdCBhcmdzID0gQWJpRXZlbnQuZGVjb2RlKGFiaUV2ZW50LCB7XG4gKiAgIGRhdGE6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFkJyxcbiAqICAgXSxcbiAqIH0pXG4gKlxuICogQWJpRXZlbnQuYXNzZXJ0QXJncyhhYmlFdmVudCwgYXJncywge1xuICogICBhOiAnYicsIC8vIFshY29kZSAtLV1cbiAqICAgZnJvbTogJzB4YTVjYzNjMDM5OTRkYjViMGQ5YTVlZWRkMTBjYWJhYjA4MTM2NzhhYycsXG4gKiAgIHRvOiAnMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFkJyxcbiAqICAgdmFsdWU6IDFuLFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW5wdXROb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhYmlFdmVudCwgbmFtZSwgfSkge1xuICAgICAgICBzdXBlcihgUGFyYW1ldGVyIFwiJHtuYW1lfVwiIG5vdCBmb3VuZCBvbiBcXGAke2Zvcm1hdChhYmlFdmVudCl9XFxgLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpRXZlbnQuSW5wdXROb3RGb3VuZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBkYXRhIHNpemUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHNpemUgZnJvbSB0aGUgbm9uLWluZGV4ZWQgcGFyYW1ldGVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUV2ZW50IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpRXZlbnQgPSBBYmlFdmVudC5mcm9tKFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQyNTYgdmFsdWUpJyxcbiAqICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgMzIgYnl0ZXMgKyDihpEgMzIgYnl0ZXMgPSA2NCBieXRlc1xuICogKVxuICpcbiAqIGNvbnN0IGFyZ3MgPSBBYmlFdmVudC5kZWNvZGUoYWJpRXZlbnQsIHtcbiAqICAgZGF0YTogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyM2MzNDYwMCcsXG4gKiAgIC8vICAgICAgIOKGkSAzMiBieXRlcyDinYxcbiAqICAgdG9waWNzOiBbXG4gKiAgICAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZicsXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NicsXG4gKiAgIF0sXG4gKiB9KVxuICogLy8gQGVycm9yOiBBYmlFdmVudC5EYXRhTWlzbWF0Y2hFcnJvcjogRGF0YSBzaXplIG9mIDMyIGJ5dGVzIGlzIHRvbyBzbWFsbCBmb3Igbm9uLWluZGV4ZWQgZXZlbnQgcGFyYW1ldGVycy5cbiAqIC8vIEBlcnJvcjogTm9uLWluZGV4ZWQgUGFyYW1ldGVyczogKGFkZHJlc3MgdG8sIHVpbnQyNTYgdmFsdWUpXG4gKiAvLyBAZXJyb3I6IERhdGE6ICAgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIzYzM0NjAwICgzMiBieXRlcylcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIEVuc3VyZSB0aGF0IHRoZSBkYXRhIHNpemUgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgc2l6ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXZlbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlFdmVudCA9IEFiaUV2ZW50LmZyb20oXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyB0bywgdWludDI1NiB2YWx1ZSknLFxuICogICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSAzMiBieXRlcyArIOKGkSAzMiBieXRlcyA9IDY0IGJ5dGVzXG4gKiApXG4gKlxuICogY29uc3QgYXJncyA9IEFiaUV2ZW50LmRlY29kZShhYmlFdmVudCwge1xuICogICBkYXRhOiAnMHgweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGYzOWZkNmU1MWFhZDg4ZjZmNGNlNmFiODgyNzI3OWNmZmZiOTIyNjYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIzYzM0NjAwJyxcbiAqICAgLy8gICAgICAg4oaRIDY0IGJ5dGVzIOKchVxuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmMzlmZDZlNTFhYWQ4OGY2ZjRjZTZhYjg4MjcyNzljZmZmYjkyMjY2JyxcbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhYmlFdmVudCwgZGF0YSwgcGFyYW1ldGVycywgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihbXG4gICAgICAgICAgICBgRGF0YSBzaXplIG9mICR7c2l6ZX0gYnl0ZXMgaXMgdG9vIHNtYWxsIGZvciBub24taW5kZXhlZCBldmVudCBwYXJhbWV0ZXJzLmAsXG4gICAgICAgIF0uam9pbignXFxuJyksIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBOb24taW5kZXhlZCBQYXJhbWV0ZXJzOiAoJHtBYmlQYXJhbWV0ZXJzLmZvcm1hdChwYXJhbWV0ZXJzKX0pYCxcbiAgICAgICAgICAgICAgICBgRGF0YTogICAke2RhdGF9ICgke3NpemV9IGJ5dGVzKWAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUV2ZW50LkRhdGFNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWJpRXZlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJhbWV0ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hYmlFdmVudCA9IGFiaUV2ZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIHRvcGljcyBkbyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIG51bWJlciBvZiB0b3BpY3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUV2ZW50ID0gQWJpRXZlbnQuZnJvbShcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpJyxcbiAqIClcbiAqXG4gKiBjb25zdCBhcmdzID0gQWJpRXZlbnQuZGVjb2RlKGFiaUV2ZW50LCB7XG4gKiAgIGRhdGE6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqICAgXSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEFiaUV2ZW50LlRvcGljc01pc21hdGNoRXJyb3I6IEV4cGVjdGVkIGEgdG9waWMgZm9yIGluZGV4ZWQgZXZlbnQgcGFyYW1ldGVyIFwidG9cIiBmb3IgXCJldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyBpbmRleGVkIHRvLCB1aW50MjU2IHZhbHVlKVwiLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogRW5zdXJlIHRoYXQgdGhlIHRvcGljcyBtYXRjaCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHRvcGljcy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXZlbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlFdmVudCA9IEFiaUV2ZW50LmZyb20oXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyBpbmRleGVkIHRvLCB1aW50MjU2IHZhbHVlKScsXG4gKiApXG4gKlxuICogY29uc3QgYXJncyA9IEFiaUV2ZW50LmRlY29kZShhYmlFdmVudCwge1xuICogICBkYXRhOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqICAgdG9waWNzOiBbXG4gKiAgICAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZicsXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYTVjYzNjMDM5OTRkYjViMGQ5YTVlZWRkMTBjYWJhYjA4MTM2NzhhYycsXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NicsIC8vIFshY29kZSArK11cbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBUb3BpY3NNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhYmlFdmVudCwgcGFyYW0sIH0pIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAgYEV4cGVjdGVkIGEgdG9waWMgZm9yIGluZGV4ZWQgZXZlbnQgcGFyYW1ldGVyJHtwYXJhbS5uYW1lID8gYCBcIiR7cGFyYW0ubmFtZX1cImAgOiAnJ30gZm9yIFwiJHtmb3JtYXQoYWJpRXZlbnQpfVwiLmAsXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpRXZlbnQuVG9waWNzTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFiaUV2ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWJpRXZlbnQgPSBhYmlFdmVudDtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBzZWxlY3RvciBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgc2VsZWN0b3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHRyYW5zZmVyID0gQWJpRXZlbnQuZnJvbShcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIGJvb2wgc2VuZGVyKScsXG4gKiApXG4gKlxuICogQWJpRXZlbnQuZGVjb2RlKHRyYW5zZmVyLCB7XG4gKiAgIHRvcGljczogW1xuICogICAgICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnLFxuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUnLFxuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGYzOWZkNmU1MWFhZDg4ZjZmNGNlNmFiODgyNzI3OWNmZmZiOTIyNjYnLFxuICogICBdLFxuICogfSlcbiAqIC8vIEBlcnJvcjogQWJpRXZlbnQuU2VsZWN0b3JUb3BpY01pc21hdGNoRXJyb3I6IHRvcGljc1swXT1cIjB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZlwiIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCB0b3BpY3NbMF09XCIweDNkYTNjZDNjZjQyMGM3OGY4OTgxZTdhZmVlZmEwZWFiMWYwZGUwZWI1NmU3OGFkOWJhOTE4ZWQwMWMwYjQwMmZcIi5cbiAqIC8vIEBlcnJvcjogRXZlbnQ6IGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIGJvb2wgc2VuZGVyKVxuICogLy8gQGVycm9yOiBTZWxlY3RvcjogMHgzZGEzY2QzY2Y0MjBjNzhmODk4MWU3YWZlZWZhMGVhYjFmMGRlMGViNTZlNzhhZDliYTkxOGVkMDFjMGI0MDJmXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBFbnN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgc2VsZWN0b3IgbWF0Y2hlcyB0aGUgc2VsZWN0b3Igb2YgdGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRXZlbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmFuc2ZlciA9IEFiaUV2ZW50LmZyb20oXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyBpbmRleGVkIHRvLCBib29sIHNlbmRlciknLFxuICogKVxuICpcbiAqIEFiaUV2ZW50LmRlY29kZSh0cmFuc2Zlciwge1xuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJywgLy8gWyFjb2RlIC0tXVxuICogICAgICcweDNkYTNjZDNjZjQyMGM3OGY4OTgxZTdhZmVlZmEwZWFiMWYwZGUwZWI1NmU3OGFkOWJhOTE4ZWQwMWMwYjQwMmYnLCAvLyBbIWNvZGUgKytdXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NicsXG4gKiAgIF0sXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWxlY3RvclRvcGljTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWJpRXZlbnQsIGFjdHVhbCwgZXhwZWN0ZWQsIH0pIHtcbiAgICAgICAgc3VwZXIoYHRvcGljc1swXT1cIiR7YWN0dWFsfVwiIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCB0b3BpY3NbMF09XCIke2V4cGVjdGVkfVwiLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW2BFdmVudDogJHtmb3JtYXQoYWJpRXZlbnQpfWAsIGBTZWxlY3RvcjogJHtleHBlY3RlZH1gXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlFdmVudC5TZWxlY3RvclRvcGljTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgZmlsdGVyIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUV2ZW50IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNmZXIgPSBBYmlFdmVudC5mcm9tKCdldmVudCBUcmFuc2Zlcigoc3RyaW5nKSBpbmRleGVkIGEsIHN0cmluZyBiKScpXG4gKlxuICogQWJpRXZlbnQuZW5jb2RlKHRyYW5zZmVyLCB7XG4gKiAgIGE6IFsnaGVsbG8nXSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEFiaUV2ZW50LkZpbHRlclR5cGVOb3RTdXBwb3J0ZWRFcnJvcjogRmlsdGVyIHR5cGUgXCJ0dXBsZVwiIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQcm92aWRlIGEgdmFsaWQgZXZlbnQgaW5wdXQgdHlwZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHRyYW5zZmVyID0gQWJpRXZlbnQuZnJvbSgnZXZlbnQgVHJhbnNmZXIoKHN0cmluZykgaW5kZXhlZCBhLCBzdHJpbmcgYiknKSAvLyBbIWNvZGUgLS1dXG4gKiBjb25zdCB0cmFuc2ZlciA9IEFiaUV2ZW50LmZyb20oJ2V2ZW50IFRyYW5zZmVyKHN0cmluZyBpbmRleGVkIGEsIHN0cmluZyBiKScpIC8vIFshY29kZSArK11cbiAqIGBgYFxuICpcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJUeXBlTm90U3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHN1cGVyKGBGaWx0ZXIgdHlwZSBcIiR7dHlwZX1cIiBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpRXZlbnQuRmlsdGVyVHlwZU5vdFN1cHBvcnRlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlFdmVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AbiEvent.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AbiFunction.js":
/*!***************************************************!*\
  !*** ../node_modules/ox/_esm/core/AbiFunction.js ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeData: () => (/* binding */ decodeData),\n/* harmony export */   decodeResult: () => (/* binding */ decodeResult),\n/* harmony export */   encodeData: () => (/* binding */ encodeData),\n/* harmony export */   encodeResult: () => (/* binding */ encodeResult),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"abitype\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbiItem.js */ \"../node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiParameters.js */ \"../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([abitype__WEBPACK_IMPORTED_MODULE_0__, _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__, _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__]);\n([abitype__WEBPACK_IMPORTED_MODULE_0__, _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__, _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n/**\n * ABI-decodes function arguments according to the ABI Item's input types (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n *\n * const input = AbiFunction.decodeData(approve, data) // [!code focus]\n * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * ```\n *\n * @param abiFunction - The ABI Item to decode.\n * @param data - The data to decode.\n */\nfunction decodeData(abiFunction, data) {\n    const { overloads } = abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(data) < 4)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(data) <= 4)\n        return undefined;\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decode(item.inputs, _Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 4));\n}\n/**\n * ABI-decodes a function's result according to the ABI Item's output types (`outputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function return values (e.g. the response of an `eth_call` or the `input` property of a Transaction).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const totalSupply = AbiFunction.fromAbi(erc20Abi, 'totalSupply') // [!code hl]\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.decodeResult` to decode the result of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   balanceOf,\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B']\n * )\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output. // [!code focus]\n * const balance = AbiFunction.decodeResult(balanceOf, response) // [!code focus]\n * // @log: 42n\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to decode\n * @param data - ABI-encoded function output\n * @param options - Decoding options\n * @returns Decoded function output\n */\nfunction decodeResult(abiFunction, data, options = {}) {\n    const values = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n/**\n * ABI-encodes function arguments (`inputs`), prefixed with the 4 byte function selector.\n *\n * :::tip\n *\n * This function is typically used to encode a contract function and its arguments for contract calls (e.g. `data` parameter of an `eth_call` or `eth_sendTransaction`).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const approve = AbiFunction.fromAbi(erc20Abi, 'approve') // [!code hl]\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.encodeData` to encode the input of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input. // [!code focus]\n * const data = AbiFunction.encodeData( // [!code focus]\n *   balanceOf, // [!code focus]\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B'] // [!code focus]\n * ) // [!code focus]\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output.\n * const balance = AbiFunction.decodeResult(balanceOf, response)\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to encode\n * @param args - Function arguments\n * @returns ABI-encoded function name and arguments\n */\nfunction encodeData(abiFunction, ...args) {\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args: args[0],\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0\n        ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(item.inputs, args[0])\n        : undefined;\n    return data ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(selector, data) : selector;\n}\n/**\n * ABI-encodes a function's result (`outputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n * const output = AbiFunction.decodeResult(totalSupply, '0x000000000000000000000000000000000000000000000000000000000000002a')\n * // 42n\n *\n * const data = AbiFunction.encodeResult(totalSupply, 42n) // [!code focus]\n * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'\n * ```\n *\n * @param abiFunction - The ABI item to encode the function output for.\n * @param output - The function output to encode.\n * @param options - Encoding options.\n * @returns The encoded function output.\n */\nfunction encodeResult(abiFunction, output, options = {}) {\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nfunction format(abiFunction) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nfunction from(abiFunction, options = {}) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.NotFoundError({ name, type: 'function' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nfunction getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_2__.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlGdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSztBQUNZO0FBQ3BCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksWUFBWTtBQUN4QixRQUFRLHlDQUFRO0FBQ2hCLGtCQUFrQixpRUFBZ0MsR0FBRyxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFRO0FBQ2hCO0FBQ0EsV0FBVyxxREFBb0IsY0FBYywwQ0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdDQUF3QztBQUNqRztBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELG1CQUFtQixrQ0FBa0M7QUFDckQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNB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b2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUZ1bmN0aW9uLmpzPzk5ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFiaUl0ZW0gZnJvbSAnLi9BYmlJdGVtLmpzJztcbmltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIEFCSS1kZWNvZGVzIGZ1bmN0aW9uIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlIEFCSSBJdGVtJ3MgaW5wdXQgdHlwZXMgKGBpbnB1dHNgKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcywgdWludDI1NiknKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKFxuICogICBhcHByb3ZlLFxuICogICBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDY5NDIwbl1cbiAqIClcbiAqIC8vICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKlxuICogY29uc3QgaW5wdXQgPSBBYmlGdW5jdGlvbi5kZWNvZGVEYXRhKGFwcHJvdmUsIGRhdGEpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgNjk0MjBuXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUZ1bmN0aW9uIC0gVGhlIEFCSSBJdGVtIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gZGVjb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRGF0YShhYmlGdW5jdGlvbiwgZGF0YSkge1xuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPCA0KVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IoeyBkYXRhIH0pO1xuICAgIGlmIChhYmlGdW5jdGlvbi5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgZGF0YSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPD0gNClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gQWJpUGFyYW1ldGVycy5kZWNvZGUoaXRlbS5pbnB1dHMsIEhleC5zbGljZShkYXRhLCA0KSk7XG59XG4vKipcbiAqIEFCSS1kZWNvZGVzIGEgZnVuY3Rpb24ncyByZXN1bHQgYWNjb3JkaW5nIHRvIHRoZSBBQkkgSXRlbSdzIG91dHB1dCB0eXBlcyAoYG91dHB1dHNgKS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSB1c2VkIHRvIGRlY29kZSBjb250cmFjdCBmdW5jdGlvbiByZXR1cm4gdmFsdWVzIChlLmcuIHRoZSByZXNwb25zZSBvZiBhbiBgZXRoX2NhbGxgIG9yIHRoZSBgaW5wdXRgIHByb3BlcnR5IG9mIGEgVHJhbnNhY3Rpb24pLlxuICpcbiAqIFNlZSB0aGUgW0VuZC10by1lbmQgRXhhbXBsZV0oI2VuZC10by1lbmQpLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyYSdcbiAqXG4gKiBjb25zdCB0b3RhbFN1cHBseSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIHRvdGFsU3VwcGx5KCkgcmV0dXJucyAodWludDI1NiknKVxuICpcbiAqIGNvbnN0IG91dHB1dCA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdCh0b3RhbFN1cHBseSwgZGF0YSlcbiAqIC8vIEBsb2c6IDQyblxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFlvdSBjYW4gZXh0cmFjdCBhbiBBQkkgRnVuY3Rpb24gZnJvbSBhIEpTT04gQUJJIHdpdGgge0BsaW5rIG94I0FiaUZ1bmN0aW9uLihmcm9tQWJpOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJhJ1xuICpcbiAqIGNvbnN0IGVyYzIwQWJpID0gQWJpLmZyb20oWy4uLl0pIC8vIFshY29kZSBobF1cbiAqIGNvbnN0IHRvdGFsU3VwcGx5ID0gQWJpRnVuY3Rpb24uZnJvbUFiaShlcmMyMEFiaSwgJ3RvdGFsU3VwcGx5JykgLy8gWyFjb2RlIGhsXVxuICpcbiAqIGNvbnN0IG91dHB1dCA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdCh0b3RhbFN1cHBseSwgZGF0YSlcbiAqIC8vIEBsb2c6IDQyblxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmQtdG8tZW5kXG4gKlxuICogQmVsb3cgaXMgYW4gZW5kLXRvLWVuZCBleGFtcGxlIG9mIHVzaW5nIGBBYmlGdW5jdGlvbi5kZWNvZGVSZXN1bHRgIHRvIGRlY29kZSB0aGUgcmVzdWx0IG9mIGEgYGJhbGFuY2VPZmAgY29udHJhY3QgY2FsbCBvbiB0aGUgW1dhZ21pIE1pbnQgRXhhbXBsZSBjb250cmFjdF0oaHR0cHM6Ly9ldGhlcnNjYW4uaW8vYWRkcmVzcy8weGZiYTM5MTJjYTA0ZGQ0NThjODQzZTJlZTA4OTY3ZmMwNGYzNTc5YzIpLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiAvLyAxLiBFeHRyYWN0IHRoZSBGdW5jdGlvbiBmcm9tIHRoZSBDb250cmFjdCdzIEFCSS5cbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgLy8gLi4uXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnYmFsYW5jZU9mJyxcbiAqICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICAgIGlucHV0czogW3sgbmFtZTogJ2FjY291bnQnLCB0eXBlOiAnYWRkcmVzcycgfV0sXG4gKiAgICAgb3V0cHV0czogW3sgbmFtZTogJ2JhbGFuY2UnLCB0eXBlOiAndWludDI1NicgfV0sXG4gKiAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gKiAgIH0sXG4gKiAgIC8vIC4uLlxuICogXSlcbiAqIGNvbnN0IGJhbGFuY2VPZiA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnYmFsYW5jZU9mJylcbiAqXG4gKiAvLyAyLiBFbmNvZGUgdGhlIEZ1bmN0aW9uIElucHV0LlxuICogY29uc3QgZGF0YSA9IEFiaUZ1bmN0aW9uLmVuY29kZURhdGEoXG4gKiAgIGJhbGFuY2VPZixcbiAqICAgWycweGQyMTM1Q2ZCMjE2Yjc0MTA5Nzc1MjM2RTM2ZDRiNDMzRjFERjUwN0InXVxuICogKVxuICpcbiAqIC8vIDMuIFBlcmZvcm0gdGhlIENvbnRyYWN0IENhbGwuXG4gKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSEucmVxdWVzdCh7XG4gKiAgIG1ldGhvZDogJ2V0aF9jYWxsJyxcbiAqICAgcGFyYW1zOiBbXG4gKiAgICAge1xuICogICAgICAgZGF0YSxcbiAqICAgICAgIHRvOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqXG4gKiAvLyA0LiBEZWNvZGUgdGhlIEZ1bmN0aW9uIE91dHB1dC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3QgYmFsYW5jZSA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdChiYWxhbmNlT2YsIHJlc3BvbnNlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiA0Mm5cbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFib3ZlIGV4YW1wbGUgdXNlcyBgd2luZG93LmV0aGVyZXVtLnJlcXVlc3RgLCBidXQgeW91IGNhbiB1c2UgYW55XG4gKiB0eXBlIG9mIEpTT04tUlBDIGludGVyZmFjZS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBBQkkgRnVuY3Rpb24gdG8gZGVjb2RlXG4gKiBAcGFyYW0gZGF0YSAtIEFCSS1lbmNvZGVkIGZ1bmN0aW9uIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNvZGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyBEZWNvZGVkIGZ1bmN0aW9uIG91dHB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmVzdWx0KGFiaUZ1bmN0aW9uLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCBkYXRhLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh2YWx1ZXMgJiYgT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlcylbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vKipcbiAqIEFCSS1lbmNvZGVzIGZ1bmN0aW9uIGFyZ3VtZW50cyAoYGlucHV0c2ApLCBwcmVmaXhlZCB3aXRoIHRoZSA0IGJ5dGUgZnVuY3Rpb24gc2VsZWN0b3IuXG4gKlxuICogOjo6dGlwXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0eXBpY2FsbHkgdXNlZCB0byBlbmNvZGUgYSBjb250cmFjdCBmdW5jdGlvbiBhbmQgaXRzIGFyZ3VtZW50cyBmb3IgY29udHJhY3QgY2FsbHMgKGUuZy4gYGRhdGFgIHBhcmFtZXRlciBvZiBhbiBgZXRoX2NhbGxgIG9yIGBldGhfc2VuZFRyYW5zYWN0aW9uYCkuXG4gKlxuICogU2VlIHRoZSBbRW5kLXRvLWVuZCBFeGFtcGxlXSgjZW5kLXRvLWVuZCkuXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFwcHJvdmUgPSBBYmlGdW5jdGlvbi5mcm9tKCdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3MsIHVpbnQyNTYpJylcbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpRnVuY3Rpb24uZW5jb2RlRGF0YSggLy8gWyFjb2RlIGZvY3VzXVxuICogICBhcHByb3ZlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgNjk0MjBuXSAvLyBbIWNvZGUgZm9jdXNdXG4gKiApIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogWW91IGNhbiBleHRyYWN0IGFuIEFCSSBGdW5jdGlvbiBmcm9tIGEgSlNPTiBBQkkgd2l0aCB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uKGZyb21BYmk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZXJjMjBBYmkgPSBBYmkuZnJvbShbLi4uXSkgLy8gWyFjb2RlIGhsXVxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoZXJjMjBBYmksICdhcHByb3ZlJykgLy8gWyFjb2RlIGhsXVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKFxuICogICBhcHByb3ZlLFxuICogICBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDY5NDIwbl1cbiAqIClcbiAqIC8vIEBsb2c6ICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEVuZC10by1lbmRcbiAqXG4gKiBCZWxvdyBpcyBhbiBlbmQtdG8tZW5kIGV4YW1wbGUgb2YgdXNpbmcgYEFiaUZ1bmN0aW9uLmVuY29kZURhdGFgIHRvIGVuY29kZSB0aGUgaW5wdXQgb2YgYSBgYmFsYW5jZU9mYCBjb250cmFjdCBjYWxsIG9uIHRoZSBbV2FnbWkgTWludCBFeGFtcGxlIGNvbnRyYWN0XShodHRwczovL2V0aGVyc2Nhbi5pby9hZGRyZXNzLzB4ZmJhMzkxMmNhMDRkZDQ1OGM4NDNlMmVlMDg5NjdmYzA0ZjM1NzljMikuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCAnb3gvd2luZG93J1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIC8vIDEuIEV4dHJhY3QgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIENvbnRyYWN0J3MgQUJJLlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAvLyAuLi5cbiAqICAge1xuICogICAgIG5hbWU6ICdiYWxhbmNlT2YnLFxuICogICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgICAgaW5wdXRzOiBbeyBuYW1lOiAnYWNjb3VudCcsIHR5cGU6ICdhZGRyZXNzJyB9XSxcbiAqICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnYmFsYW5jZScsIHR5cGU6ICd1aW50MjU2JyB9XSxcbiAqICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgfSxcbiAqICAgLy8gLi4uXG4gKiBdKVxuICogY29uc3QgYmFsYW5jZU9mID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICdiYWxhbmNlT2YnKVxuICpcbiAqIC8vIDIuIEVuY29kZSB0aGUgRnVuY3Rpb24gSW5wdXQuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGJhbGFuY2VPZiwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBbJzB4ZDIxMzVDZkIyMTZiNzQxMDk3NzUyMzZFMzZkNGI0MzNGMURGNTA3QiddIC8vIFshY29kZSBmb2N1c11cbiAqICkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIDMuIFBlcmZvcm0gdGhlIENvbnRyYWN0IENhbGwuXG4gKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSEucmVxdWVzdCh7XG4gKiAgIG1ldGhvZDogJ2V0aF9jYWxsJyxcbiAqICAgcGFyYW1zOiBbXG4gKiAgICAge1xuICogICAgICAgZGF0YSxcbiAqICAgICAgIHRvOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqXG4gKiAvLyA0LiBEZWNvZGUgdGhlIEZ1bmN0aW9uIE91dHB1dC5cbiAqIGNvbnN0IGJhbGFuY2UgPSBBYmlGdW5jdGlvbi5kZWNvZGVSZXN1bHQoYmFsYW5jZU9mLCByZXNwb25zZSlcbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFib3ZlIGV4YW1wbGUgdXNlcyBgd2luZG93LmV0aGVyZXVtLnJlcXVlc3RgLCBidXQgeW91IGNhbiB1c2UgYW55XG4gKiB0eXBlIG9mIEpTT04tUlBDIGludGVyZmFjZS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBBQkkgRnVuY3Rpb24gdG8gZW5jb2RlXG4gKiBAcGFyYW0gYXJncyAtIEZ1bmN0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybnMgQUJJLWVuY29kZWQgZnVuY3Rpb24gbmFtZSBhbmQgYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVEYXRhKGFiaUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgeyBvdmVybG9hZHMgfSA9IGFiaUZ1bmN0aW9uO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgYWJpRnVuY3Rpb24ubmFtZSwge1xuICAgICAgICAgICAgYXJnczogYXJnc1swXSxcbiAgICAgICAgfSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGl0ZW0pO1xuICAgIGNvbnN0IGRhdGEgPSBhcmdzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBBYmlQYXJhbWV0ZXJzLmVuY29kZShpdGVtLmlucHV0cywgYXJnc1swXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRhdGEgPyBIZXguY29uY2F0KHNlbGVjdG9yLCBkYXRhKSA6IHNlbGVjdG9yO1xufVxuLyoqXG4gKiBBQkktZW5jb2RlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0IChgb3V0cHV0c2ApLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0b3RhbFN1cHBseSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIHRvdGFsU3VwcGx5KCkgcmV0dXJucyAodWludDI1NiknKVxuICogY29uc3Qgb3V0cHV0ID0gQWJpRnVuY3Rpb24uZGVjb2RlUmVzdWx0KHRvdGFsU3VwcGx5LCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJhJylcbiAqIC8vIDQyblxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVSZXN1bHQodG90YWxTdXBwbHksIDQybikgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyYSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgaXRlbSB0byBlbmNvZGUgdGhlIGZ1bmN0aW9uIG91dHB1dCBmb3IuXG4gKiBAcGFyYW0gb3V0cHV0IC0gVGhlIGZ1bmN0aW9uIG91dHB1dCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBmdW5jdGlvbiBvdXRwdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVSZXN1bHQoYWJpRnVuY3Rpb24sIG91dHB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdBcnJheScgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWVzID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGFiaUZ1bmN0aW9uLm91dHB1dHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpKVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgaWYgKGFzID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmVuY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCB2YWx1ZXMpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGFuIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaUZ1bmN0aW9uLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBUaGUgQUJJIEZ1bmN0aW9uIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIEZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlGdW5jdGlvbik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBGdW5jdGlvbioqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiogaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIEFCSXNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYXBwcm92ZVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShcbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCkgcmV0dXJucyAoYm9vbCknIC8vIFshY29kZSBobF1cbiAqIClcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoRm9vIGZvbykgcmV0dXJucyAoYm9vbCknLFxuICogXSlcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgRnVuY3Rpb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUeXBlZCBBQkkgRnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufSBmcm9tIGFuIHtAbGluayBveCNBYmkuQWJpfSBnaXZlbiBhIG5hbWUgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgTmFtZVxuICpcbiAqIEFCSSBGdW5jdGlvbnMgY2FuIGJlIGV4dHJhY3RlZCBieSB0aGVpciBuYW1lIHVzaW5nIHRoZSBgbmFtZWAgb3B0aW9uOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqXG4gKiBjb25zdCBpdGVtID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICdmb28nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IFNlbGVjdG9yXG4gKlxuICogQUJJIEZ1bmN0aW9ucyBjYW4gYmUgZXh0cmFjdCBieSB0aGVpciBzZWxlY3RvciB3aGVuIHtAbGluayBveCNIZXguSGV4fSBpcyBwcm92aWRlZCB0byBgbmFtZWAuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnMHgwOTVlYTdiMycpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgRnVuY3Rpb24gZnJvbSBhbiBgZXRoX2NhbGxgIFJQQyByZXNwb25zZSBvclxuICogZnJvbSBhIFRyYW5zYWN0aW9uIGBpbnB1dGAuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaSAtIFRoZSBBQkkgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSAob3Igc2VsZWN0b3IpIG9mIHRoZSBBQkkgaXRlbSB0byBleHRyYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYWN0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQUJJIGl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoaXRlbS50eXBlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5Ob3RGb3VuZEVycm9yKHsgbmFtZSwgdHlwZTogJ2Z1bmN0aW9uJyB9KTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFs0LWJ5dGUgc2VsZWN0b3JdKGh0dHBzOi8vc29saWRpdHktYnktZXhhbXBsZS5vcmcvZnVuY3Rpb24tc2VsZWN0b3IvKSBmb3IgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufS5cbiAqXG4gKiBVc2VmdWwgZm9yIGNvbXB1dGluZyBmdW5jdGlvbiBzZWxlY3RvcnMgZm9yIGNhbGxkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUZ1bmN0aW9uLmdldFNlbGVjdG9yKCdmdW5jdGlvbiBvd25lck9mKHVpbnQyNTYgdG9rZW5JZCknKVxuICogLy8gQGxvZzogJzB4NjM1MjIxMWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlGdW5jdGlvbi5nZXRTZWxlY3Rvcih7XG4gKiAgIGlucHV0czogW3sgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICogICBuYW1lOiAnb3duZXJPZicsXG4gKiAgIG91dHB1dHM6IFtdLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICogfSlcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIGl0ZW0gdG8gY29tcHV0ZSB0aGUgc2VsZWN0b3IgZm9yLlxuICogQHJldHVybnMgVGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHtAbGluayBveCNIYXNoLihrZWNjYWsyNTY6ZnVuY3Rpb24pfSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZ2V0U2VsZWN0b3IoYWJpSXRlbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AbiFunction.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AbiItem.js":
/*!***********************************************!*\
  !*** ../node_modules/ox/_esm/core/AbiItem.js ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AmbiguityError: () => (/* binding */ AmbiguityError),\n/* harmony export */   InvalidSelectorSizeError: () => (/* binding */ InvalidSelectorSizeError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector),\n/* harmony export */   getSignature: () => (/* binding */ getSignature),\n/* harmony export */   getSignatureHash: () => (/* binding */ getSignatureHash)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"abitype\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/abiItem.js */ \"../node_modules/ox/_esm/core/internal/abiItem.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([abitype__WEBPACK_IMPORTED_MODULE_0__]);\nabitype__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nfunction format(abiItem) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nfunction from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype__WEBPACK_IMPORTED_MODULE_0__.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype__WEBPACK_IMPORTED_MODULE_0__.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === _Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_2__.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_2__.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nfunction getSelector(abiItem) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(getSignatureHash(abiItem), 0, 4);\n}\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */\nfunction getSignature(abiItem) {\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n    })();\n    return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_2__.normalizeSignature(signature);\n}\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */\nfunction getSignatureHash(abiItem) {\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nclass AmbiguityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_2__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_2__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nclass NotFoundError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nclass InvalidSelectorSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiItem.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0c7QUFDSjtBQUNGO0FBQ2tCO0FBQ2xEO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsa0RBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxzRkFBc0YseUJBQXlCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUIsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFvQjtBQUN2QztBQUNBLG1CQUFtQixpREFBb0I7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0IsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLFNBQVMsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDRCQUE0QjtBQUN4QyxVQUFVO0FBQ1YsdUJBQXVCLDZDQUFZLFNBQVMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMENBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0MsSUFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0NBQWtDLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQW9CO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1FQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0MsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYseUJBQXlCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ087QUFDUCxXQUFXLDBDQUFTO0FBQ3BCO0FBQ0E7QUFDQSxtREFBbUQseUJBQXlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQXFCO0FBQ3BDLEtBQUs7QUFDTCxXQUFXLG9FQUEyQjtBQUN0QztBQUNBO0FBQ0EsdUNBQXVDLHlCQUF5QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDRDQUE0QztBQUNyRCxTQUFTLGlEQUFpRDtBQUMxRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxXQUFXLCtDQUFjLENBQUMsK0NBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsaURBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU8sVUFBVSxvRUFBMkIsQ0FBQyxrREFBcUIsYUFBYTtBQUNwRyxxQkFBcUIsT0FBTyxVQUFVLG9FQUEyQixDQUFDLGtEQUFxQixhQUFhO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQsa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBLFNBQVM7QUFDVCxxQkFBcUIsS0FBSyxFQUFFLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsaURBQWdCO0FBQzlELGtCQUFrQixNQUFNO0FBQ3hCLHNFQUFzRSx5Q0FBUSxRQUFRLFVBQVUsS0FBSztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUl0ZW0uanM/OGVmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2FiaUl0ZW0uanMnO1xuLyoqXG4gKiBGb3JtYXRzIGFuIHtAbGluayBveCNBYmlJdGVtLkFiaUl0ZW19IGludG8gYSAqKkh1bWFuIFJlYWRhYmxlIEFCSSBJdGVtKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9ybWF0dGVkID0gQWJpSXRlbS5mb3JtYXQoe1xuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBuYW1lOiAnYXBwcm92ZScsXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgICB9LFxuICogICBdLFxuICogICBvdXRwdXRzOiBbeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiB9KVxuICpcbiAqIGZvcm1hdHRlZFxuICogLy8gICAgXj9cbiAqXG4gKlxuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIEl0ZW0gdG8gZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBBQkkgSXRlbSAgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUl0ZW0pIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUl0ZW0pO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gYXJiaXRyYXJ5ICoqSlNPTiBBQkkgSXRlbSoqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIEl0ZW0qKiBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIEFCSXNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUl0ZW0gPSBBYmlJdGVtLmZyb20oe1xuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBuYW1lOiAnYXBwcm92ZScsXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgICB9LFxuICogICBdLFxuICogICBvdXRwdXRzOiBbeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiB9KVxuICpcbiAqIGFiaUl0ZW1cbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSHVtYW4gUmVhZGFibGUgQUJJc1xuICpcbiAqIEEgSHVtYW4gUmVhZGFibGUgQUJJIGNhbiBiZSBwYXJzZWQgaW50byBhIHR5cGVkIEFCSSBvYmplY3Q6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlJdGVtID0gQWJpSXRlbS5mcm9tKFxuICogICAnZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50KSByZXR1cm5zIChib29sKScgLy8gWyFjb2RlIGhsXVxuICogKVxuICpcbiAqIGFiaUl0ZW1cbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeSBgc3RydWN0YHMgYWxvbmcgd2l0aCB5b3VyIGRlZmluaXRpb25zOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoRm9vIGZvbykgcmV0dXJucyAoYm9vbCknLFxuICogXSlcbiAqXG4gKiBhYmlJdGVtXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBhYmlJdGVtIC0gVGhlIEFCSSBJdGVtIHRvIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHR5cGVkIEFCSSBJdGVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhYmlJdGVtLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHByZXBhcmUgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhYmlJdGVtKSlcbiAgICAgICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpSXRlbShhYmlJdGVtKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhYmlJdGVtID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpSXRlbShhYmlJdGVtKTtcbiAgICAgICAgcmV0dXJuIGFiaUl0ZW07XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pdGVtLFxuICAgICAgICAuLi4ocHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChpdGVtKSB9IDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIEV4dHJhY3RzIGFuIHtAbGluayBveCNBYmlJdGVtLkFiaUl0ZW19IGZyb20gYW4ge0BsaW5rIG94I0FiaS5BYml9IGdpdmVuIGEgbmFtZSBhbmQgb3B0aW9uYWwgYXJndW1lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBBQkkgSXRlbXMgY2FuIGJlIGV4dHJhY3RlZCBieSB0aGVpciBuYW1lIHVzaW5nIHRoZSBgbmFtZWAgb3B0aW9uOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICpcbiAqIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCAnVHJhbnNmZXInKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IFNlbGVjdG9yXG4gKlxuICogQUJJIEl0ZW1zIGNhbiBiZSBleHRyYWN0IGJ5IHRoZWlyIHNlbGVjdG9yIHdoZW4ge0BsaW5rIG94I0hleC5IZXh9IGlzIHByb3ZpZGVkIHRvIGBuYW1lYC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCAnMHgwOTVlYTdiMycpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogOjo6bm90ZVxuICpcbiAqIEV4dHJhY3RpbmcgdmlhIGEgaGV4IHNlbGVjdG9yIGlzIHVzZWZ1bCB3aGVuIGV4dHJhY3RpbmcgYW4gQUJJIEl0ZW0gZnJvbSBhbiBgZXRoX2NhbGxgIFJQQyByZXNwb25zZSxcbiAqIGEgVHJhbnNhY3Rpb24gYGlucHV0YCwgb3IgZnJvbSBFdmVudCBMb2cgYHRvcGljc2AuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaSAtIFRoZSBBQkkgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSAob3Igc2VsZWN0b3IpIG9mIHRoZSBBQkkgaXRlbSB0byBleHRyYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYWN0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQUJJIGl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXJncyA9IFtdLCBwcmVwYXJlID0gdHJ1ZSB9ID0gKG9wdGlvbnMgPz9cbiAgICAgICAge30pO1xuICAgIGNvbnN0IGlzU2VsZWN0b3IgPSBIZXgudmFsaWRhdGUobmFtZSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGFiaUl0ZW1zID0gYWJpLmZpbHRlcigoYWJpSXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXNTZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBhYmlJdGVtLnR5cGUgPT09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNlbGVjdG9yKGFiaUl0ZW0pID09PSBIZXguc2xpY2UobmFtZSwgMCwgNCk7XG4gICAgICAgICAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZXZlbnQnKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pID09PSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbmFtZScgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLm5hbWUgPT09IG5hbWU7XG4gICAgfSk7XG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoeyBuYW1lOiBuYW1lIH0pO1xuICAgIGlmIChhYmlJdGVtcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5hYmlJdGVtc1swXSxcbiAgICAgICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW1zWzBdKSB9IDoge30pLFxuICAgICAgICB9O1xuICAgIGxldCBtYXRjaGVkQWJpSXRlbSA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IGFiaUl0ZW0gb2YgYWJpSXRlbXMpIHtcbiAgICAgICAgaWYgKCEoJ2lucHV0cycgaW4gYWJpSXRlbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFhcmdzIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIWFiaUl0ZW0uaW5wdXRzIHx8IGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSB9IDoge30pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFiaUl0ZW0uaW5wdXRzKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChhYmlJdGVtLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbWF0Y2hlZCA9IGFyZ3MuZXZlcnkoKGFyZywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9ICdpbnB1dHMnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5pbnB1dHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFhYmlQYXJhbWV0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLmlzQXJnT2ZUeXBlKGFyZywgYWJpUGFyYW1ldGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYW1iaWd1aXR5IGFnYWluc3QgYWxyZWFkeSBtYXRjaGVkIHBhcmFtZXRlcnMgKGUuZy4gYGFkZHJlc3NgIHZzIGBieXRlczIwYCkuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZEFiaUl0ZW0gJiZcbiAgICAgICAgICAgICAgICAnaW5wdXRzJyBpbiBtYXRjaGVkQWJpSXRlbSAmJlxuICAgICAgICAgICAgICAgIG1hdGNoZWRBYmlJdGVtLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFtYmlndW91c1R5cGVzID0gaW50ZXJuYWwuZ2V0QW1iaWd1b3VzVHlwZXMoYWJpSXRlbS5pbnB1dHMsIG1hdGNoZWRBYmlJdGVtLmlucHV0cywgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKGFtYmlndW91c1R5cGVzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQW1iaWd1aXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJpSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFtYmlndW91c1R5cGVzWzBdLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmlJdGVtOiBtYXRjaGVkQWJpSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFtYmlndW91c1R5cGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoZWRBYmlJdGVtID0gYWJpSXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhYmlJdGVtID0gKCgpID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWRBYmlJdGVtKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRBYmlJdGVtO1xuICAgICAgICBjb25zdCBbYWJpSXRlbSwgLi4ub3ZlcmxvYWRzXSA9IGFiaUl0ZW1zO1xuICAgICAgICByZXR1cm4geyAuLi5hYmlJdGVtLCBvdmVybG9hZHMgfTtcbiAgICB9KSgpO1xuICAgIGlmICghYWJpSXRlbSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoeyBuYW1lOiBuYW1lIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFiaUl0ZW0sXG4gICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pIH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFs0LWJ5dGUgc2VsZWN0b3JdKGh0dHBzOi8vc29saWRpdHktYnktZXhhbXBsZS5vcmcvZnVuY3Rpb24tc2VsZWN0b3IvKSBmb3IgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0uXG4gKlxuICogVXNlZnVsIGZvciBjb21wdXRpbmcgZnVuY3Rpb24gc2VsZWN0b3JzIGZvciBjYWxsZGF0YS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUl0ZW0uZ2V0U2VsZWN0b3IoJ2Z1bmN0aW9uIG93bmVyT2YodWludDI1NiB0b2tlbklkKScpXG4gKiAvLyBAbG9nOiAnMHg2MzUyMjExZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNlbGVjdG9yID0gQWJpSXRlbS5nZXRTZWxlY3Rvcih7XG4gKiAgIGlucHV0czogW3sgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICogICBuYW1lOiAnb3duZXJPZicsXG4gKiAgIG91dHB1dHM6IFtdLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICogfSlcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIGl0ZW0gdG8gY29tcHV0ZSB0aGUgc2VsZWN0b3IgZm9yLiBDYW4gYmUgYSBzaWduYXR1cmUgb3IgYW4gQUJJIGl0ZW0gZm9yIGFuIGVycm9yLCBldmVudCwgZnVuY3Rpb24sIGV0Yy5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSB7QGxpbmsgb3gjSGFzaC4oa2VjY2FrMjU2OmZ1bmN0aW9uKX0gaGFzaCBvZiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0b3IoYWJpSXRlbSkge1xuICAgIHJldHVybiBIZXguc2xpY2UoZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSwgMCwgNCk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzdHJpbmdpZmllZCBzaWduYXR1cmUgZm9yIGEgZ2l2ZW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gQWJpSXRlbS5nZXRTaWduYXR1cmUoJ2Z1bmN0aW9uIG93bmVyT2YodWludDI1NiB0b2tlbklkKScpXG4gKiAvLyBAbG9nOiAnb3duZXJPZih1aW50MjU2KSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IEFiaUl0ZW0uZ2V0U2lnbmF0dXJlKHtcbiAqICAgbmFtZTogJ293bmVyT2YnLFxuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBpbnB1dHM6IFt7IG5hbWU6ICd0b2tlbklkJywgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICogICBvdXRwdXRzOiBbXSxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gKiB9KVxuICogLy8gQGxvZzogJ293bmVyT2YodWludDI1NiknXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgSXRlbSB0byBjb21wdXRlIHRoZSBzaWduYXR1cmUgZm9yLlxuICogQHJldHVybnMgVGhlIHN0cmluZ2lmaWVkIHNpZ25hdHVyZSBvZiB0aGUgQUJJIEl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduYXR1cmUoYWJpSXRlbSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgYWJpSXRlbSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gYWJpSXRlbTtcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlJdGVtKTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBpbnRlcm5hbC5ub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNpZ25hdHVyZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfS5cbiAqXG4gKiBVc2VmdWwgZm9yIGNvbXB1dGluZyBFdmVudCBUb3BpYyB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgaGFzaCA9IEFiaUl0ZW0uZ2V0U2lnbmF0dXJlSGFzaCgnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiBhbW91bnQpJylcbiAqIC8vIEBsb2c6ICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBoYXNoID0gQWJpSXRlbS5nZXRTaWduYXR1cmVIYXNoKHtcbiAqICAgbmFtZTogJ1RyYW5zZmVyJyxcbiAqICAgdHlwZTogJ2V2ZW50JyxcbiAqICAgaW5wdXRzOiBbXG4gKiAgICAgeyBuYW1lOiAnZnJvbScsIHR5cGU6ICdhZGRyZXNzJywgaW5kZXhlZDogdHJ1ZSB9LFxuICogICAgIHsgbmFtZTogJ3RvJywgdHlwZTogJ2FkZHJlc3MnLCBpbmRleGVkOiB0cnVlIH0sXG4gKiAgICAgeyBuYW1lOiAnYW1vdW50JywgdHlwZTogJ3VpbnQyNTYnLCBpbmRleGVkOiBmYWxzZSB9LFxuICogICBdLFxuICogfSlcbiAqIC8vIEBsb2c6ICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgSXRlbSB0byBjb21wdXRlIHRoZSBzaWduYXR1cmUgaGFzaCBmb3IuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0hhc2guKGtlY2NhazI1NjpmdW5jdGlvbil9IGhhc2ggb2YgdGhlIEFCSSBpdGVtJ3Mgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSB7XG4gICAgaWYgKHR5cGVvZiBhYmlJdGVtICE9PSAnc3RyaW5nJyAmJiAnaGFzaCcgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLmhhc2gpXG4gICAgICAgIHJldHVybiBhYmlJdGVtLmhhc2g7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KEhleC5mcm9tU3RyaW5nKGdldFNpZ25hdHVyZShhYmlJdGVtKSkpO1xufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiBhbWJpZ3VvdXMgdHlwZXMgYXJlIGZvdW5kIG9uIG92ZXJsb2FkZWQgQUJJIGl0ZW1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFsnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJywgJ2Z1bmN0aW9uIGZvbyhieXRlczIwKSddKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICdmb28nLCB7XG4gKiAgIGFyZ3M6IFsnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ10sXG4gKiB9KVxuICogLy8gQGVycm9yOiBBYmlJdGVtLkFtYmlndWl0eUVycm9yOiBGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgSXRlbXMuXG4gKiAvLyBAZXJyb3I6IGBieXRlczIwYCBpbiBgZm9vKGJ5dGVzMjApYCwgYW5kXG4gKiAvLyBAZXJyb3I6IGBhZGRyZXNzYCBpbiBgZm9vKGFkZHJlc3MpYFxuICogLy8gQGVycm9yOiBUaGVzZSB0eXBlcyBlbmNvZGUgZGlmZmVyZW50bHkgYW5kIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIGF0IHJ1bnRpbWUuXG4gKiAvLyBAZXJyb3I6IFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUmVtb3ZlIG9uZSBvZiB0aGUgYW1iaWd1b3VzIHR5cGVzIGZyb20gdGhlIEFCSS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBmb28oYnl0ZXMyMCknIC8vIFshY29kZSAtLV1cbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2ZvbycsIHtcbiAqICAgYXJnczogWycweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uQW1iaWd1aXR5RXJyb3I6IEZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBJdGVtcy5cbiAqIC8vIEBlcnJvcjogYGJ5dGVzMjBgIGluIGBmb28oYnl0ZXMyMClgLCBhbmRcbiAqIC8vIEBlcnJvcjogYGFkZHJlc3NgIGluIGBmb28oYWRkcmVzcylgXG4gKiAvLyBAZXJyb3I6IFRoZXNlIHR5cGVzIGVuY29kZSBkaWZmZXJlbnRseSBhbmQgY2Fubm90IGJlIGRpc3Rpbmd1aXNoZWQgYXQgcnVudGltZS5cbiAqIC8vIEBlcnJvcjogUmVtb3ZlIG9uZSBvZiB0aGUgYW1iaWd1b3VzIGl0ZW1zIGluIHRoZSBBQkkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEFtYmlndWl0eUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICBzdXBlcignRm91bmQgYW1iaWd1b3VzIHR5cGVzIGluIG92ZXJsb2FkZWQgQUJJIEl0ZW1zLicsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFiaXR5cGUgdG8gYWRkIHN1cHBvcnQgZm9yIHNpZ25hdHVyZS1mb3JtYXR0ZWQgQUJJIGl0ZW1zLlxuICAgICAgICAgICAgICAgIGBcXGAke3gudHlwZX1cXGAgaW4gXFxgJHtpbnRlcm5hbC5ub3JtYWxpemVTaWduYXR1cmUoYWJpdHlwZS5mb3JtYXRBYmlJdGVtKHguYWJpSXRlbSkpfVxcYCwgYW5kYCxcbiAgICAgICAgICAgICAgICBgXFxgJHt5LnR5cGV9XFxgIGluIFxcYCR7aW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKGFiaXR5cGUuZm9ybWF0QWJpSXRlbSh5LmFiaUl0ZW0pKX1cXGBgLFxuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICdUaGVzZSB0eXBlcyBlbmNvZGUgZGlmZmVyZW50bHkgYW5kIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIGF0IHJ1bnRpbWUuJyxcbiAgICAgICAgICAgICAgICAnUmVtb3ZlIG9uZSBvZiB0aGUgYW1iaWd1b3VzIGl0ZW1zIGluIHRoZSBBQkkuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5BbWJpZ3VpdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiBhbiBBQkkgaXRlbSBpcyBub3QgZm91bmQgaW4gdGhlIEFCSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICdiYXonKVxuICogLy8gQGVycm9yOiBBYmlJdGVtLk5vdEZvdW5kRXJyb3I6IEFCSSBmdW5jdGlvbiB3aXRoIG5hbWUgXCJiYXpcIiBub3QgZm91bmQuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBFbnN1cmUgdGhlIEFCSSBpdGVtIGV4aXN0cyBvbiB0aGUgQUJJLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gYmFyKHVpbnQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJheihib29sKScgLy8gWyFjb2RlICsrXVxuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnYmF6JylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbmFtZSwgZGF0YSwgdHlwZSA9ICdpdGVtJywgfSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCB3aXRoIG5hbWUgXCIke25hbWV9XCJgO1xuICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAgd2l0aCBkYXRhIFwiJHtkYXRhfVwiYDtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgc3VwZXIoYEFCSSAke3R5cGV9JHtzZWxlY3Rvcn0gbm90IGZvdW5kLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5Ob3RGb3VuZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyB3aGVuIHRoZSBzZWxlY3RvciBzaXplIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KSdcbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJzB4YWFhJylcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3I6IFNlbGVjdG9yIHNpemUgaXMgaW52YWxpZC4gRXhwZWN0ZWQgNCBieXRlcy4gUmVjZWl2ZWQgMiBieXRlcyAoXCIweGFhYVwiKS5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIEVuc3VyZSB0aGUgc2VsZWN0b3Igc2l6ZSBpcyA0IGJ5dGVzLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gYmFyKHVpbnQpJ1xuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnMHg3YWY4MmIxYScpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZWxlY3RvclNpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZGF0YSB9KSB7XG4gICAgICAgIHN1cGVyKGBTZWxlY3RvciBzaXplIGlzIGludmFsaWQuIEV4cGVjdGVkIDQgYnl0ZXMuIFJlY2VpdmVkICR7SGV4LnNpemUoZGF0YSl9IGJ5dGVzIChcIiR7ZGF0YX1cIikuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlJdGVtLkludmFsaWRTZWxlY3RvclNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpSXRlbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AbiItem.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AbiParameters.js":
/*!*****************************************************!*\
  !*** ../node_modules/ox/_esm/core/AbiParameters.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayLengthMismatchError: () => (/* binding */ ArrayLengthMismatchError),\n/* harmony export */   BytesSizeMismatchError: () => (/* binding */ BytesSizeMismatchError),\n/* harmony export */   DataSizeTooSmallError: () => (/* binding */ DataSizeTooSmallError),\n/* harmony export */   InvalidArrayError: () => (/* binding */ InvalidArrayError),\n/* harmony export */   InvalidTypeError: () => (/* binding */ InvalidTypeError),\n/* harmony export */   LengthMismatchError: () => (/* binding */ LengthMismatchError),\n/* harmony export */   ZeroDataError: () => (/* binding */ ZeroDataError),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodePacked: () => (/* binding */ encodePacked),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"abitype\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Solidity.js */ \"../node_modules/ox/_esm/core/Solidity.js\");\n/* harmony import */ var _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/abiParameters.js */ \"../node_modules/ox/_esm/core/internal/abiParameters.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"../node_modules/ox/_esm/core/internal/cursor.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([abitype__WEBPACK_IMPORTED_MODULE_0__, _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_4__]);\n([abitype__WEBPACK_IMPORTED_MODULE_0__, _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(data) : data;\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes);\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.size(bytes) && _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromBytes(data),\n            parameters: parameters,\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_4__.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nfunction encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_4__.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_4__.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nfunction encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(...data);\n}\n(function (encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            _Address_js__WEBPACK_IMPORTED_MODULE_5__.assert(address);\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_6__.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits) / 8;\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_6__.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size),\n                    value: value,\n                });\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_6__.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nfunction format(parameters) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nfunction from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                               2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nclass DataSizeTooSmallError extends _Errors_js__WEBPACK_IMPORTED_MODULE_7__.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                             zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nclass ZeroDataError extends _Errors_js__WEBPACK_IMPORTED_MODULE_7__.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                                expected: 3    length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                           length: 3\n * ```\n */\nclass ArrayLengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_7__.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                             expected: 8 bytes    size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                         size: 8 bytes\n * ```\n */\nclass BytesSizeMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_7__.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${_Hex_js__WEBPACK_IMPORTED_MODULE_3__.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nclass LengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_7__.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nclass InvalidArrayError extends _Errors_js__WEBPACK_IMPORTED_MODULE_7__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                               invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nclass InvalidTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_7__.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiParameters.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDSjtBQUNFO0FBQ047QUFDVTtBQUNjO0FBQ1Q7QUFDL0M7QUFDTyw4Q0FBOEM7QUFDckQsWUFBWSx3Q0FBd0M7QUFDcEQsNkNBQTZDLDhDQUFhO0FBQzFELG1CQUFtQix1REFBYTtBQUNoQyxRQUFRLDJDQUFVO0FBQ2xCO0FBQ0EsUUFBUSwyQ0FBVSxXQUFXLDJDQUFVO0FBQ3ZDO0FBQ0Esb0RBQW9ELDhDQUFhO0FBQ2pFO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0Esa0NBQWtDLHVFQUF3QjtBQUMxRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QyxTQUFTLDJCQUEyQjtBQUNwQyxTQUFTLCtCQUErQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLHlFQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDhEQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNoRDtBQUNBO0FBQ0EsNkNBQTZDLGVBQWU7QUFDNUQsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsaURBQWdCO0FBQ3ZEO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsaURBQWdCO0FBQ3REO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlQYXJhbWV0ZXJzLmpzPzczOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBTb2xpZGl0eSBmcm9tICcuL1NvbGlkaXR5LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBDdXJzb3IgZnJvbSAnLi9pbnRlcm5hbC9jdXJzb3IuanMnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUocGFyYW1ldGVycywgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdBcnJheScsIGNoZWNrc3VtQWRkcmVzcyA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChkYXRhKSA6IGRhdGE7XG4gICAgY29uc3QgY3Vyc29yID0gQ3Vyc29yLmNyZWF0ZShieXRlcyk7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID09PSAwICYmIHBhcmFtZXRlcnMubGVuZ3RoID4gMClcbiAgICAgICAgdGhyb3cgbmV3IFplcm9EYXRhRXJyb3IoKTtcbiAgICBpZiAoQnl0ZXMuc2l6ZShieXRlcykgJiYgQnl0ZXMuc2l6ZShieXRlcykgPCAzMilcbiAgICAgICAgdGhyb3cgbmV3IERhdGFTaXplVG9vU21hbGxFcnJvcih7XG4gICAgICAgICAgICBkYXRhOiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogSGV4LmZyb21CeXRlcyhkYXRhKSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKGJ5dGVzKSxcbiAgICAgICAgfSk7XG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICBjb25zdCB2YWx1ZXMgPSBhcyA9PT0gJ0FycmF5JyA/IFtdIDoge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gcGFyYW1ldGVyc1tpXTtcbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKGNvbnN1bWVkKTtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBpbnRlcm5hbC5kZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgIGlmIChhcyA9PT0gJ0FycmF5JylcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGRhdGEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWx1ZXNbcGFyYW0ubmFtZSA/PyBpXSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgcHJpbWl0aXZlIHZhbHVlcyBpbnRvIEFCSSBlbmNvZGVkIGRhdGEgYXMgcGVyIHRoZSBbQXBwbGljYXRpb24gQmluYXJ5IEludGVyZmFjZSAoQUJJKSBTcGVjaWZpY2F0aW9uXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvYWJpLXNwZWMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlQYXJhbWV0ZXJzLmVuY29kZShcbiAqICAgQWJpUGFyYW1ldGVycy5mcm9tKFsnc3RyaW5nJywgJ3VpbnQnLCAnYm9vbCddKSxcbiAqICAgWyd3YWdtaScsIDQyMG4sIHRydWVdLFxuICogKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIFBhcmFtZXRlcnNcbiAqXG4gKiBTcGVjaWZ5ICoqSlNPTiBBQkkqKiBQYXJhbWV0ZXJzIGFzIHNjaGVtYTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlQYXJhbWV0ZXJzLmVuY29kZShcbiAqICAgW1xuICogICAgIHsgdHlwZTogJ3N0cmluZycsIG5hbWU6ICduYW1lJyB9LFxuICogICAgIHsgdHlwZTogJ3VpbnQnLCBuYW1lOiAnYWdlJyB9LFxuICogICAgIHsgdHlwZTogJ2Jvb2wnLCBuYW1lOiAnaXNPd25lcicgfSxcbiAqICAgXSxcbiAqICAgWyd3YWdtaScsIDQyMG4sIHRydWVdLFxuICogKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIEFCSSBwYXJhbWV0ZXJzIHRvIGVuY29kZSwgaW4gdGhlIHNoYXBlIG9mIHRoZSBgaW5wdXRzYCBvciBgb3V0cHV0c2AgYXR0cmlidXRlIG9mIGFuIEFCSSBJdGVtLiBUaGVzZSBwYXJhbWV0ZXJzIG11c3QgaW5jbHVkZSB2YWxpZCBbQUJJIHR5cGVzXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvdHlwZXMuaHRtbCkuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHNldCBvZiBwcmltaXRpdmUgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgQUJJIHR5cGVzIGRlZmluZWQgaW4gYHBhcmFtZXRlcnNgLlxuICogQHJldHVybnMgQUJJIGVuY29kZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShwYXJhbWV0ZXJzLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcyA9IGZhbHNlIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IExlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IHBhcmFtZXRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgIC8vIFByZXBhcmUgdGhlIHBhcmFtZXRlcnMgdG8gZGV0ZXJtaW5lIGR5bmFtaWMgdHlwZXMgdG8gZW5jb2RlLlxuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IGludGVybmFsLnByZXBhcmVQYXJhbWV0ZXJzKHtcbiAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gaW50ZXJuYWwuZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycyk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gJzB4JztcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogRW5jb2RlcyBhbiBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzIHRvIGEgW3BhY2tlZCBBQkkgZW5jb2RpbmddKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC9hYmktc3BlYy5odG1sI25vbi1zdGFuZGFyZC1wYWNrZWQtbW9kZSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW5jb2RlZCA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlUGFja2VkKFxuICogICBbJ2FkZHJlc3MnLCAnc3RyaW5nJ10sXG4gKiAgIFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgJ2hlbGxvIHdvcmxkJ10sXG4gKiApXG4gKiAvLyBAbG9nOiAnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0eXBlcyAtIFNldCBvZiBBQkkgdHlwZXMgdG8gcGFjayBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHNldCBvZiBwcmltaXRpdmUgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgQUJJIHR5cGVzIGRlZmluZWQgaW4gYHR5cGVzYC5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHBhY2tlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUGFja2VkKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICBpZiAodHlwZXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogdHlwZXMubGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGRhdGEucHVzaChlbmNvZGVQYWNrZWQuZW5jb2RlKHR5cGUsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBIZXguY29uY2F0KC4uLmRhdGEpO1xufVxuKGZ1bmN0aW9uIChlbmNvZGVQYWNrZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgIGZ1bmN0aW9uIGVuY29kZSh0eXBlLCB2YWx1ZSwgaXNBcnJheSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB2YWx1ZTtcbiAgICAgICAgICAgIEFkZHJlc3MuYXNzZXJ0KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRMZWZ0KGFkZHJlc3MudG9Mb3dlckNhc2UoKSwgaXNBcnJheSA/IDMyIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIEhleC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdieXRlcycpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlID09PSAnYm9vbCcpXG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZExlZnQoSGV4LmZyb21Cb29sZWFuKHZhbHVlKSwgaXNBcnJheSA/IDMyIDogMSk7XG4gICAgICAgIGNvbnN0IGludE1hdGNoID0gdHlwZS5tYXRjaChTb2xpZGl0eS5pbnRlZ2VyUmVnZXgpO1xuICAgICAgICBpZiAoaW50TWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfdHlwZSwgYmFzZVR5cGUsIGJpdHMgPSAnMjU2J10gPSBpbnRNYXRjaDtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBOdW1iZXIucGFyc2VJbnQoYml0cykgLyA4O1xuICAgICAgICAgICAgcmV0dXJuIEhleC5mcm9tTnVtYmVyKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogaXNBcnJheSA/IDMyIDogc2l6ZSxcbiAgICAgICAgICAgICAgICBzaWduZWQ6IGJhc2VUeXBlID09PSAnaW50JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzTWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmJ5dGVzUmVnZXgpO1xuICAgICAgICBpZiAoYnl0ZXNNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBzaXplXSA9IGJ5dGVzTWF0Y2g7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KHNpemUpICE9PSAodmFsdWUubGVuZ3RoIC0gMikgLyAyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRTaXplOiBOdW1iZXIucGFyc2VJbnQoc2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkUmlnaHQodmFsdWUsIGlzQXJyYXkgPyAzMiA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmFycmF5UmVnZXgpO1xuICAgICAgICBpZiAoYXJyYXlNYXRjaCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBjaGlsZFR5cGVdID0gYXJyYXlNYXRjaDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goZW5jb2RlKGNoaWxkVHlwZSwgdmFsdWVbaV0sIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJzB4JztcbiAgICAgICAgICAgIHJldHVybiBIZXguY29uY2F0KC4uLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHlwZUVycm9yKHR5cGUpO1xuICAgIH1cbiAgICBlbmNvZGVQYWNrZWQuZW5jb2RlID0gZW5jb2RlO1xufSkoZW5jb2RlUGFja2VkIHx8IChlbmNvZGVQYWNrZWQgPSB7fSkpO1xuLyoqXG4gKiBGb3JtYXRzIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLkFiaVBhcmFtZXRlcnN9IGludG8gKipIdW1hbiBSZWFkYWJsZSBBQkkgUGFyYW1ldGVycyoqLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaVBhcmFtZXRlcnMuZm9ybWF0KFtcbiAqICAge1xuICogICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgIH0sXG4gKiBdKVxuICpcbiAqIGZvcm1hdHRlZFxuICogLy8gICAgXj9cbiAqXG4gKlxuICogYGBgXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBUaGUgQUJJIFBhcmFtZXRlcnMgdG8gZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBBQkkgUGFyYW1ldGVycyAgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xufVxuLyoqXG4gKiBQYXJzZXMgYXJiaXRyYXJ5ICoqSlNPTiBBQkkgUGFyYW1ldGVycyoqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIFBhcmFtZXRlcnMqKiBpbnRvIHR5cGVkIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLkFiaVBhcmFtZXRlcnN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSlNPTiBQYXJhbWV0ZXJzXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKFtcbiAqICAge1xuICogICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgIH0sXG4gKiBdKVxuICpcbiAqIHBhcmFtZXRlcnNcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEh1bWFuIFJlYWRhYmxlIFBhcmFtZXRlcnNcbiAqXG4gKiBIdW1hbiBSZWFkYWJsZSBBQkkgUGFyYW1ldGVycyBjYW4gYmUgcGFyc2VkIGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQWJpUGFyYW1ldGVycy5BYmlQYXJhbWV0ZXJzfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oJ2FkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQnKVxuICpcbiAqIHBhcmFtZXRlcnNcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeSBgc3RydWN0YHMgYWxvbmcgd2l0aCB5b3VyIGRlZmluaXRpb25zOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGFyYW1ldGVycyA9IEFiaVBhcmFtZXRlcnMuZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ0ZvbyBmb28sIGFkZHJlc3MgYmFyJyxcbiAqIF0pXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBBQkkgUGFyYW1ldGVycyB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBBQkkgUGFyYW1ldGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20ocGFyYW1ldGVycykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpICYmIHR5cGVvZiBwYXJhbWV0ZXJzWzBdID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVycyA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICByZXR1cm4gcGFyYW1ldGVycztcbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gdGhlIGRhdGEgc2l6ZSBpcyB0b28gc21hbGwgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4MDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinYwgMiBieXRlc1xuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkRhdGFTaXplVG9vU21hbGxFcnJvcjogRGF0YSBzaXplIG9mIDIgYnl0ZXMgaXMgdG9vIHNtYWxsIGZvciBnaXZlbiBwYXJhbWV0ZXJzLlxuICogLy8gQGVycm9yOiBQYXJhbXM6ICh1aW50MjU2KVxuICogLy8gQGVycm9yOiBEYXRhOiAgIDB4MDEwZiAoMiBieXRlcylcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYSB2YWxpZCBkYXRhIHNpemUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAndWludDI1NicgfV0sICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgMzIgYnl0ZXNcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRGF0YVNpemVUb29TbWFsbEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBkYXRhLCBwYXJhbWV0ZXJzLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBEYXRhIHNpemUgb2YgJHtzaXplfSBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgYFBhcmFtczogKCR7YWJpdHlwZS5mb3JtYXRBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpfSlgLFxuICAgICAgICAgICAgICAgIGBEYXRhOiAgICR7ZGF0YX0gKCR7c2l6ZX0gYnl0ZXMpYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5EYXRhU2l6ZVRvb1NtYWxsRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gemVybyBkYXRhIGlzIHByb3ZpZGVkLCBidXQgZGF0YSBpcyBleHBlY3RlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAndWludDI1NicgfV0sICcweCcpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4p2MIHplcm8gZGF0YVxuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkRhdGFTaXplVG9vU21hbGxFcnJvcjogRGF0YSBzaXplIG9mIDIgYnl0ZXMgaXMgdG9vIHNtYWxsIGZvciBnaXZlbiBwYXJhbWV0ZXJzLlxuICogLy8gQGVycm9yOiBQYXJhbXM6ICh1aW50MjU2KVxuICogLy8gQGVycm9yOiBEYXRhOiAgIDB4MDEwZiAoMiBieXRlcylcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgdmFsaWQgZGF0YS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSAzMiBieXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBaZXJvRGF0YUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdDYW5ub3QgZGVjb2RlIHplcm8gZGF0YSAoXCIweFwiKSB3aXRoIEFCSSBwYXJhbWV0ZXJzLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5aZXJvRGF0YUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBsZW5ndGggc3BlY2lmaWVkIGluIHRoZSBjb3JyZXNwb25kaW5nIEFCSSBwYXJhbWV0ZXIuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgndWludDI1NlszXScpLCBbWzY5biwgNDIwbl1dKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSBleHBlY3RlZDogMyAg4oaRIOKdjCBsZW5ndGg6IDJcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5BcnJheUxlbmd0aE1pc21hdGNoRXJyb3I6IEFCSSBlbmNvZGluZyBhcnJheSBsZW5ndGggbWlzbWF0Y2hcbiAqIC8vIEBlcnJvcjogZm9yIHR5cGUgYHVpbnQyNTZbM11gLiBFeHBlY3RlZDogYDNgLiBHaXZlbjogYDJgLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhbiBhcnJheSBvZiB0aGUgY29ycmVjdCBsZW5ndGguXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKFsndWludDI1NlszXSddKSwgW1s2OW4sIDQyMG4sIDY5bl1dKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIGxlbmd0aDogM1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheUxlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgQXJyYXkgbGVuZ3RoIG1pc21hdGNoIGZvciB0eXBlIFxcYCR7dHlwZX1cXGAuIEV4cGVjdGVkOiBcXGAke2V4cGVjdGVkTGVuZ3RofVxcYC4gR2l2ZW46IFxcYCR7Z2l2ZW5MZW5ndGh9XFxgLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5BcnJheUxlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHNpemUgb2YgdGhlIGJ5dGVzIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBzaXplIHNwZWNpZmllZCBpbiB0aGUgY29ycmVzcG9uZGluZyBBQkkgcGFyYW1ldGVyLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ2J5dGVzOCcpLCBbWycweGRlYWRiZWVmZGVhZGJlZWZkZWFkYmVlZiddXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgZXhwZWN0ZWQ6IDggYnl0ZXMgIOKGkSDinYwgc2l6ZTogMTIgYnl0ZXNcbiAqIC8vIEBlcnJvcjogQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcjogU2l6ZSBvZiBieXRlcyBcIjB4ZGVhZGJlZWZkZWFkYmVlZmRlYWRiZWVmXCJcbiAqIC8vIEBlcnJvcjogKGJ5dGVzMTIpIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHNpemUgKGJ5dGVzOCkuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGEgYnl0ZXMgdmFsdWUgb2YgdGhlIGNvcnJlY3Qgc2l6ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWydieXRlczgnXSksIFsnMHhkZWFkYmVlZmRlYWRiZWVmJ10pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIHNpemU6IDggYnl0ZXNcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRTaXplLCB2YWx1ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBvZiBieXRlcyBcIiR7dmFsdWV9XCIgKGJ5dGVzJHtIZXguc2l6ZSh2YWx1ZSl9KSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBzaXplIChieXRlcyR7ZXhwZWN0ZWRTaXplfSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGxlbmd0aCBvZiB0aGUgdmFsdWVzIHRvIGVuY29kZSBkb2VzIG5vdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBBQkkgcGFyYW1ldGVycy5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKFsnc3RyaW5nJywgJ3VpbnQyNTYnXSksIFsnaGVsbG8nXSlcbiAqIC8vIEBlcnJvcjogTGVuZ3RoTWlzbWF0Y2hFcnJvcjogQUJJIGVuY29kaW5nIHBhcmFtcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoLlxuICogLy8gQGVycm9yOiBFeHBlY3RlZCBsZW5ndGggKHBhcmFtcyk6IDJcbiAqIC8vIEBlcnJvcjogR2l2ZW4gbGVuZ3RoICh2YWx1ZXMpOiAxXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIHRoZSBjb3JyZWN0IG51bWJlciBvZiB2YWx1ZXMgdG8gZW5jb2RlLlxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYSBbdmFsaWQgQUJJIHR5cGVdKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2RldmVsb3AvYWJpLXNwZWMuaHRtbCN0eXBlcykuXG4gKi9cbmV4cG9ydCBjbGFzcyBMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZExlbmd0aCwgZ2l2ZW5MZW5ndGgsIH0pIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAgJ0FCSSBlbmNvZGluZyBwYXJhbWV0ZXJzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2guJyxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBsZW5ndGggKHBhcmFtZXRlcnMpOiAke2V4cGVjdGVkTGVuZ3RofWAsXG4gICAgICAgICAgICBgR2l2ZW4gbGVuZ3RoICh2YWx1ZXMpOiAke2dpdmVuTGVuZ3RofWAsXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5MZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSB2YWx1ZSBwcm92aWRlZCBpcyBub3QgYSB2YWxpZCBhcnJheSBhcyBzcGVjaWZpZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgQUJJIHBhcmFtZXRlci5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKFsndWludDI1NlszXSddKSwgWzY5XSlcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYW4gYXJyYXkgdmFsdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQXJyYXlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBub3QgYSB2YWxpZCBhcnJheS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuSW52YWxpZEFycmF5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gdGhlIEFCSSBwYXJhbWV0ZXIgdHlwZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICdsb2wnIH1dLCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinYwgaW52YWxpZCB0eXBlXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcjogVHlwZSBgbG9sYCBpcyBub3QgYSB2YWxpZCBBQkkgVHlwZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFR5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgICAgc3VwZXIoYFR5cGUgXFxgJHt0eXBlfVxcYCBpcyBub3QgYSB2YWxpZCBBQkkgVHlwZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpUGFyYW1ldGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AbiParameters.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AccessList.js":
/*!**************************************************!*\
  !*** ../node_modules/ox/_esm/core/AccessList.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidStorageKeySizeError: () => (/* binding */ InvalidStorageKeySizeError),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */\nfunction fromTupleList(accessList) {\n    const list = [];\n    for (let i = 0; i < accessList.length; i++) {\n        const [address, storageKeys] = accessList[i];\n        if (address)\n            _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, { strict: false });\n        list.push({\n            address: address,\n            storageKeys: storageKeys.map((key) => _Hash_js__WEBPACK_IMPORTED_MODULE_1__.validate(key) ? key : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.trimLeft(key)),\n        });\n    }\n    return list;\n}\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */\nfunction toTupleList(accessList) {\n    if (!accessList || accessList.length === 0)\n        return [];\n    const tuple = [];\n    for (const { address, storageKeys } of accessList) {\n        for (let j = 0; j < storageKeys.length; j++)\n            if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKeys[j]) !== 32)\n                throw new InvalidStorageKeySizeError({\n                    storageKey: storageKeys[j],\n                });\n        if (address)\n            _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, { strict: false });\n        tuple.push([address, storageKeys]);\n    }\n    return tuple;\n}\n/** Thrown when the size of a storage key is invalid. */\nclass InvalidStorageKeySizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ storageKey }) {\n        super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKey)} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AccessList.InvalidStorageKeySizeError'\n        });\n    }\n}\n//# sourceMappingURL=AccessList.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BY2Nlc3NMaXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0M7QUFDRjtBQUNKO0FBQ0Y7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQSxZQUFZLCtDQUFjLFlBQVksZUFBZTtBQUNyRDtBQUNBO0FBQ0Esa0RBQWtELDhDQUFhLGNBQWMsNkNBQVk7QUFDekYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDLHdCQUF3Qix3QkFBd0I7QUFDaEQsZ0JBQWdCLHlDQUFRO0FBQ3hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxZQUFZLCtDQUFjLFlBQVksZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDLGlEQUFnQjtBQUNoRSxrQkFBa0IsWUFBWTtBQUM5Qix1Q0FBdUMsV0FBVyx1Q0FBdUMseUNBQVEsY0FBYztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FjY2Vzc0xpc3QuanM/ZWQ1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIEFjY2VzcyBMaXN0IHR1cGxlcyBpbnRvIGEgb2JqZWN0LWZvcm1hdHRlZCBsaXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWNjZXNzTGlzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoW1xuICogICBbXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgW1xuICogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqICAgICBdLFxuICogICBdLFxuICogXSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICAgIHN0b3JhZ2VLZXlzOiBbXG4gKiAvLyBAbG9nOiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqIC8vIEBsb2c6ICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnLFxuICogLy8gQGxvZzogICAgIF0sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWNjZXNzTGlzdCAtIExpc3Qgb2YgdHVwbGVzLlxuICogQHJldHVybnMgQWNjZXNzIGxpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGVMaXN0KGFjY2Vzc0xpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2Nlc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFthZGRyZXNzLCBzdG9yYWdlS2V5c10gPSBhY2Nlc3NMaXN0W2ldO1xuICAgICAgICBpZiAoYWRkcmVzcylcbiAgICAgICAgICAgIEFkZHJlc3MuYXNzZXJ0KGFkZHJlc3MsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBzdG9yYWdlS2V5czogc3RvcmFnZUtleXMubWFwKChrZXkpID0+IEhhc2gudmFsaWRhdGUoa2V5KSA/IGtleSA6IEhleC50cmltTGVmdChrZXkpKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cnVjdHVyZWQgQWNjZXNzIExpc3QgaW50byBhIGxpc3Qgb2YgdHVwbGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWNjZXNzTGlzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KFtcbiAqICAge1xuICogICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgIHN0b3JhZ2VLZXlzOiBbXG4gKiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnXSxcbiAqICAgfSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgICBbXG4gKiAvLyBAbG9nOiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqIC8vIEBsb2c6ICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnLFxuICogLy8gQGxvZzogICAgIF0sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWNjZXNzTGlzdCAtIEFjY2VzcyBsaXN0LlxuICogQHJldHVybnMgTGlzdCBvZiB0dXBsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgaWYgKCFhY2Nlc3NMaXN0IHx8IGFjY2Vzc0xpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgdHVwbGUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgYWRkcmVzcywgc3RvcmFnZUtleXMgfSBvZiBhY2Nlc3NMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmFnZUtleXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBpZiAoSGV4LnNpemUoc3RvcmFnZUtleXNbal0pICE9PSAzMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5c1tqXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFkZHJlc3MpXG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIHR1cGxlLnB1c2goW2FkZHJlc3MsIHN0b3JhZ2VLZXlzXSk7XG4gICAgfVxuICAgIHJldHVybiB0dXBsZTtcbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiBhIHN0b3JhZ2Uga2V5IGlzIGludmFsaWQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHN0b3JhZ2VLZXkgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBmb3Igc3RvcmFnZSBrZXkgXCIke3N0b3JhZ2VLZXl9XCIgaXMgaW52YWxpZC4gRXhwZWN0ZWQgMzIgYnl0ZXMuIEdvdCAke0hleC5zaXplKHN0b3JhZ2VLZXkpfSBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FjY2Vzc0xpc3QuSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjY2Vzc0xpc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AccessList.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AccountProof.js":
/*!****************************************************!*\
  !*** ../node_modules/ox/_esm/core/AccountProof.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=AccountProof.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BY2NvdW50UHJvb2YuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BY2NvdW50UHJvb2YuanM/ODBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2NvdW50UHJvb2YuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AccountProof.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Address.js":
/*!***********************************************!*\
  !*** ../node_modules/ox/_esm/core/Address.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),\n/* harmony export */   InvalidChecksumError: () => (/* binding */ InvalidChecksumError),\n/* harmony export */   InvalidInputError: () => (/* binding */ InvalidInputError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromPublicKey: () => (/* binding */ fromPublicKey),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Caches_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Caches.js */ \"../node_modules/ox/_esm/core/Caches.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKey.js */ \"../node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\nconst addressRegex = /*#__PURE__*/ /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nfunction assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nfunction checksum(address) {\n    if (_Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.has(address))\n        return _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nfunction from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nfunction fromPublicKey(publicKey, options = {}) {\n    const address = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(`0x${_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nfunction isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nfunction validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nclass InvalidAddressError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nclass InvalidInputError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nclass InvalidChecksumError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\n//# sourceMappingURL=Address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDQTtBQUNKO0FBQ1U7QUFDNUMsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLGdEQUFlO0FBQ3ZCLGVBQWUsZ0RBQWU7QUFDOUIsc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxpQkFBaUIsK0NBQWMsQ0FBQyxpREFBZ0IsZ0JBQWdCLGFBQWE7QUFDN0U7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsSUFBSSxnREFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQseUJBQXlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlCQUF5QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHlCQUF5QjtBQUN0RjtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDTyw4Q0FBOEM7QUFDckQsb0JBQW9CLCtDQUFjLE1BQU0sZ0RBQWUscUJBQXFCO0FBQzVFLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixlQUFlO0FBQ3RDLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5QkFBeUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QyxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQsa0JBQWtCLGdCQUFnQjtBQUNsQywwQkFBMEIsUUFBUTtBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxpREFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLGlEQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BZGRyZXNzLmpzP2U3ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBDYWNoZXMgZnJvbSAnLi9DYWNoZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuL1B1YmxpY0tleS5qcyc7XG5jb25zdCBhZGRyZXNzUmVnZXggPSAvKiNfX1BVUkVfXyovIC9eMHhbYS1mQS1GMC05XXs0MH0kLztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuYXNzZXJ0KCcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIFwiMHhkZWFkYmVlZlwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBhc3NlcnQgaWYgaXQgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBc3NlcnRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmICghYWRkcmVzc1JlZ2V4LnRlc3QodmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICBhZGRyZXNzOiB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZElucHV0RXJyb3IoKSxcbiAgICAgICAgfSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGVja3N1bSh2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENoZWNrc3VtRXJyb3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNoZWNrc3VtIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmNoZWNrc3VtKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gY29tcHV0ZSB0aGUgY2hlY2tzdW0gZm9yLlxuICogQHJldHVybnMgVGhlIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja3N1bShhZGRyZXNzKSB7XG4gICAgaWYgKENhY2hlcy5jaGVja3N1bS5oYXMoYWRkcmVzcykpXG4gICAgICAgIHJldHVybiBDYWNoZXMuY2hlY2tzdW0uZ2V0KGFkZHJlc3MpO1xuICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgaGV4QWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGFzaCA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmZyb21TdHJpbmcoaGV4QWRkcmVzcyksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgY29uc3QgY2hhcmFjdGVycyA9IGhleEFkZHJlc3Muc3BsaXQoJycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoaGFzaFtpID4+IDFdID4+IDQgPj0gOCAmJiBjaGFyYWN0ZXJzW2ldKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2ldID0gY2hhcmFjdGVyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaFtpID4+IDFdICYgMHgwZikgPj0gOCAmJiBjaGFyYWN0ZXJzW2kgKyAxXSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyc1tpICsgMV0gPSBjaGFyYWN0ZXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGAweCR7Y2hhcmFjdGVycy5qb2luKCcnKX1gO1xuICAgIENhY2hlcy5jaGVja3N1bS5zZXQoYWRkcmVzcywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZ2lmaWVkIGFkZHJlc3MgdG8gYSB0eXBlZCAoY2hlY2tzdW1tZWQpIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJylcbiAqIC8vIEBsb2c6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsIHtcbiAqICAgY2hlY2tzdW06IGZhbHNlXG4gKiB9KVxuICogLy8gQGxvZzogJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnaGVsbG8nKVxuICogLy8gQGVycm9yOiBJbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIFwiMHhhXCIgaXMgaW52YWxpZC5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gQW4gYWRkcmVzcyBzdHJpbmcgdG8gY29udmVydCB0byBhIHR5cGVkIEFkZHJlc3MuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbnZlcnNpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBBZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtOiBjaGVja3N1bVZhbCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGFzc2VydChhZGRyZXNzKTtcbiAgICBpZiAoY2hlY2tzdW1WYWwpXG4gICAgICAgIHJldHVybiBjaGVja3N1bShhZGRyZXNzKTtcbiAgICByZXR1cm4gYWRkcmVzcztcbn1cbi8qKlxuICogQ29udmVydHMgYW4gRUNEU0EgcHVibGljIGtleSB0byBhbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MsIFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKFxuICogICAnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JyxcbiAqIClcbiAqIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkocHVibGljS2V5KVxuICogLy8gQGxvZzogJzB4ZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgRUNEU0EgcHVibGljIGtleSB0byBjb252ZXJ0IHRvIGFuIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb252ZXJzaW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30gY29ycmVzcG9uZGluZyB0byB0aGUgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21QdWJsaWNLZXkocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gSGFzaC5rZWNjYWsyNTYoYDB4JHtQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KS5zbGljZSg0KX1gKS5zdWJzdHJpbmcoMjYpO1xuICAgIHJldHVybiBmcm9tKGAweCR7YWRkcmVzc31gLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfSBhcmUgZXF1YWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5pc0VxdWFsKFxuICogICAnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJyxcbiAqICAgJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIClcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuaXNFcXVhbChcbiAqICAgJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsXG4gKiAgICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWYnXG4gKiApXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3NBIC0gVGhlIGZpcnN0IGFkZHJlc3MgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBhZGRyZXNzQiAtIFRoZSBzZWNvbmQgYWRkcmVzcyB0byBjb21wYXJlLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgYWRkcmVzc2VzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoYWRkcmVzc0EsIGFkZHJlc3NCKSB7XG4gICAgYXNzZXJ0KGFkZHJlc3NBLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgYXNzZXJ0KGFkZHJlc3NCLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgcmV0dXJuIGFkZHJlc3NBLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3NCLnRvTG93ZXJDYXNlKCk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYWRkcmVzcyBpcyBhIHZhbGlkIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MudmFsaWRhdGUoJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZScpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ2hlY2sgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHgxMjMnKVxuICogLy8gQGVycm9yOiBBZGRyZXNzLkludmFsaWRBZGRyZXNzRXJyb3I6IEFkZHJlc3MgYDB4MTIzYCBpcyBpbnZhbGlkLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQWRkcmVzc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhZGRyZXNzLCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBBZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIGludmFsaWQuYCwge1xuICAgICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkQWRkcmVzc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBpcyBub3QgYSAyMCBieXRlICg0MCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIpIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnB1dEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBZGRyZXNzIGlzIG5vdCBhIDIwIGJ5dGUgKDQwIGhleGFkZWNpbWFsIGNoYXJhY3RlcikgdmFsdWUuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBZGRyZXNzLkludmFsaWRJbnB1dEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBkb2VzIG5vdCBtYXRjaCBpdHMgY2hlY2tzdW0gY291bnRlcnBhcnQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZENoZWNrc3VtRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0FkZHJlc3MgZG9lcyBub3QgbWF0Y2ggaXRzIGNoZWNrc3VtIGNvdW50ZXJwYXJ0LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkQ2hlY2tzdW1FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Address.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/AesGcm.js":
/*!**********************************************!*\
  !*** ../node_modules/ox/_esm/core/AesGcm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   getKey: () => (/* binding */ getKey),\n/* harmony export */   ivLength: () => (/* binding */ ivLength),\n/* harmony export */   randomSalt: () => (/* binding */ randomSalt)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\nconst ivLength = 16;\n/**\n * Decrypts encrypted data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key)\n *\n * const decrypted = await AesGcm.decrypt(encrypted, key) // [!code focus]\n * // @log: Hex.fromString('i am a secret message')\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Decryption options.\n * @returns The decrypted data.\n */\nasync function decrypt(value, key, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const encrypted = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.from(value);\n    const iv = encrypted.slice(0, ivLength);\n    const data = encrypted.slice(ivLength);\n    const decrypted = await globalThis.crypto.subtle.decrypt({\n        name: 'AES-GCM',\n        iv,\n    }, key, _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.from(data));\n    const result = new Uint8Array(decrypted);\n    if (as === 'Bytes')\n        return result;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(result);\n}\n/**\n * Encrypts data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key) // [!code focus]\n * // @log: '0x5e257b25bcf53d5431e54e5a68ca0138306d31bb6154f35a97bb8ea18111e7d82bcf619d3c76c4650688bc5310eed80b8fc86d1e3e'\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Encryption options.\n * @returns The encrypted data.\n */\nasync function encrypt(value, key, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const iv = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.random(ivLength);\n    const encrypted = await globalThis.crypto.subtle.encrypt({\n        name: 'AES-GCM',\n        iv,\n    }, key, _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.from(value));\n    const result = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.concat(iv, new Uint8Array(encrypted));\n    if (as === 'Bytes')\n        return result;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(result);\n}\n/**\n * Derives an AES-GCM key from a password using PBKDF2.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * // @log: CryptoKey {}\n * ```\n *\n * @param options - Options for key derivation.\n * @returns The derived key.\n */\nasync function getKey(options) {\n    const { iterations = 900_000, password, salt = randomSalt(32) } = options;\n    const baseKey = await globalThis.crypto.subtle.importKey('raw', _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromString(password), { name: 'PBKDF2' }, false, ['deriveBits', 'deriveKey']);\n    const key = await globalThis.crypto.subtle.deriveKey({\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: 'SHA-256',\n    }, baseKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);\n    return key;\n}\n/**\n * Generates a random salt of the specified size.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const salt = AesGcm.randomSalt()\n * // @log: Uint8Array [123, 79, 183, 167, 163, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166]\n * ```\n *\n * @param size - The size of the salt to generate. Defaults to `32`.\n * @returns A random salt of the specified size.\n */\nfunction randomSalt(size = 32) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.random(size);\n}\n//# sourceMappingURL=AesGcm.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BZXNHY20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvQztBQUNKO0FBQ3pCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQ0FBK0M7QUFDdEQsWUFBWSxtREFBbUQ7QUFDL0Qsc0JBQXNCLDJDQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU8sMkNBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQ0FBK0M7QUFDdEQsWUFBWSxtREFBbUQ7QUFDL0QsZUFBZSw2Q0FBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU8sMkNBQVU7QUFDdEIsbUJBQW1CLDZDQUFZO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLHlDQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHdEQUF3RDtBQUNwRSxvRUFBb0UsaURBQWdCLGNBQWMsZ0JBQWdCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGFBQWEsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsNkNBQVk7QUFDdkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Flc0djbS5qcz8xZTVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmV4cG9ydCBjb25zdCBpdkxlbmd0aCA9IDE2O1xuLyoqXG4gKiBEZWNyeXB0cyBlbmNyeXB0ZWQgZGF0YSB1c2luZyBBRVMtR0NNLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWVzR2NtLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBrZXkgPSBhd2FpdCBBZXNHY20uZ2V0S2V5KHsgcGFzc3dvcmQ6ICdxd2VydHknIH0pXG4gKiBjb25zdCBzZWNyZXQgPSBIZXguZnJvbVN0cmluZygnaSBhbSBhIHNlY3JldCBtZXNzYWdlJylcbiAqXG4gKiBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBBZXNHY20uZW5jcnlwdChzZWNyZXQsIGtleSlcbiAqXG4gKiBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBBZXNHY20uZGVjcnlwdChlbmNyeXB0ZWQsIGtleSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogSGV4LmZyb21TdHJpbmcoJ2kgYW0gYSBzZWNyZXQgbWVzc2FnZScpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgZGF0YSB0byBlbmNyeXB0LlxuICogQHBhcmFtIGtleSAtIFRoZSBgQ3J5cHRvS2V5YCB0byB1c2UgZm9yIGVuY3J5cHRpb24uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY3J5cHRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQodmFsdWUsIGtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW5jcnlwdGVkID0gQnl0ZXMuZnJvbSh2YWx1ZSk7XG4gICAgY29uc3QgaXYgPSBlbmNyeXB0ZWQuc2xpY2UoMCwgaXZMZW5ndGgpO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNyeXB0ZWQuc2xpY2UoaXZMZW5ndGgpO1xuICAgIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgICAgbmFtZTogJ0FFUy1HQ00nLFxuICAgICAgICBpdixcbiAgICB9LCBrZXksIEJ5dGVzLmZyb20oZGF0YSkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZCk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBIZXguZnJvbShyZXN1bHQpO1xufVxuLyoqXG4gKiBFbmNyeXB0cyBkYXRhIHVzaW5nIEFFUy1HQ00uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZXNHY20sIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGtleSA9IGF3YWl0IEFlc0djbS5nZXRLZXkoeyBwYXNzd29yZDogJ3F3ZXJ0eScgfSlcbiAqIGNvbnN0IHNlY3JldCA9IEhleC5mcm9tU3RyaW5nKCdpIGFtIGEgc2VjcmV0IG1lc3NhZ2UnKVxuICpcbiAqIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IEFlc0djbS5lbmNyeXB0KHNlY3JldCwga2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHg1ZTI1N2IyNWJjZjUzZDU0MzFlNTRlNWE2OGNhMDEzODMwNmQzMWJiNjE1NGYzNWE5N2JiOGVhMTgxMTFlN2Q4MmJjZjYxOWQzYzc2YzQ2NTA2ODhiYzUzMTBlZWQ4MGI4ZmM4NmQxZTNlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGRhdGEgdG8gZW5jcnlwdC5cbiAqIEBwYXJhbSBrZXkgLSBUaGUgYENyeXB0b0tleWAgdG8gdXNlIGZvciBlbmNyeXB0aW9uLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0KHZhbHVlLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGl2ID0gQnl0ZXMucmFuZG9tKGl2TGVuZ3RoKTtcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuZW5jcnlwdCh7XG4gICAgICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICAgICAgaXYsXG4gICAgfSwga2V5LCBCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gQnl0ZXMuY29uY2F0KGl2LCBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIEhleC5mcm9tKHJlc3VsdCk7XG59XG4vKipcbiAqIERlcml2ZXMgYW4gQUVTLUdDTSBrZXkgZnJvbSBhIHBhc3N3b3JkIHVzaW5nIFBCS0RGMi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFlc0djbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGtleSA9IGF3YWl0IEFlc0djbS5nZXRLZXkoeyBwYXNzd29yZDogJ3F3ZXJ0eScgfSlcbiAqIC8vIEBsb2c6IENyeXB0b0tleSB7fVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBrZXkgZGVyaXZhdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBkZXJpdmVkIGtleS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEtleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpdGVyYXRpb25zID0gOTAwXzAwMCwgcGFzc3dvcmQsIHNhbHQgPSByYW5kb21TYWx0KDMyKSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiYXNlS2V5ID0gYXdhaXQgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgQnl0ZXMuZnJvbVN0cmluZyhwYXNzd29yZCksIHsgbmFtZTogJ1BCS0RGMicgfSwgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7XG4gICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICBzYWx0LFxuICAgICAgICBpdGVyYXRpb25zLFxuICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgfSwgYmFzZUtleSwgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICByZXR1cm4ga2V5O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gc2FsdCBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZXNHY20gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzYWx0ID0gQWVzR2NtLnJhbmRvbVNhbHQoKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTIzLCA3OSwgMTgzLCAxNjcsIDE2MywgMTM2LCAxMzYsIDE2LCAxNjgsIDEyNiwgMTMsIDE2NSwgMTcwLCAxNjYsIDEzNiwgMTM2LCAxNiwgMTY4LCAxMjYsIDEzLCAxNjUsIDE3MCwgMTY2LCAxMzYsIDEzNiwgMTYsIDE2OCwgMTI2LCAxMywgMTY1LCAxNzAsIDE2Nl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgb2YgdGhlIHNhbHQgdG8gZ2VuZXJhdGUuIERlZmF1bHRzIHRvIGAzMmAuXG4gKiBAcmV0dXJucyBBIHJhbmRvbSBzYWx0IG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVNhbHQoc2l6ZSA9IDMyKSB7XG4gICAgcmV0dXJuIEJ5dGVzLnJhbmRvbShzaXplKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFlc0djbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/AesGcm.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Authorization.js":
/*!*****************************************************!*\
  !*** ../node_modules/ox/_esm/core/Authorization.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"../node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"../node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction from(authorization, options = {}) {\n    if (typeof authorization.chainId === 'string')\n        return fromRpc(authorization);\n    return { ...authorization, ...options.signature };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nfunction fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nfunction fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    const signature = yParity && r && s ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([yParity, r, s]) : undefined;\n    return from({\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    });\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nfunction fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)\n        list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nfunction getSignPayload(authorization) {\n    return hash(authorization);\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nfunction hash(authorization) {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat('0x05', _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nfunction toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature),\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nfunction toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nfunction toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : '0x',\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : '0x',\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []),\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nfunction toTupleList(list) {\n    if (!list || list.length === 0)\n        return [];\n    const tupleList = [];\n    for (const authorization of list)\n        tupleList.push(toTuple(authorization));\n    return tupleList;\n}\n//# sourceMappingURL=Authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BdXRob3JpemF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNGO0FBQ0E7QUFDWTtBQUM1QztBQUNBLHNHQUFzRyxxQ0FBcUM7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOEJBQThCO0FBQ3BDLDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQ7QUFDTyx5Q0FBeUM7QUFDaEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QixPQUFPLHFDQUFxQztBQUN4RjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDTztBQUNQLFlBQVksMEJBQTBCO0FBQ3RDLHNCQUFzQixrREFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0MsT0FBTyw0QkFBNEI7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ087QUFDUDtBQUNBO0FB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QjtBQUN0QyxzQkFBc0Isa0RBQWlCO0FBQ3ZDO0FBQ0Esa0JBQWtCLCtDQUFjO0FBQ2hDO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCLHdCQUF3QixrREFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QixPQUFPLGlDQUFpQztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQXV0aG9yaXphdGlvbi5qcz8xMzRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBSbHAgZnJvbSAnLi9SbHAuanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4vU2lnbmF0dXJlLmpzJztcbi8qKlxuICogQ29udmVydHMgYW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gb2JqZWN0IGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogQW4gQXV0aG9yaXphdGlvbiBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gYW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgaW4gb2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogQSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gY2FuIGJlIGF0dGFjaGVkIHdpdGggdGhlIGBzaWduYXR1cmVgIG9wdGlvbi4gVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIHNpZ25pbmdcbiAqIGFuIEF1dGhvcml6YXRpb24gd2l0aCB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDQwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEF1dGhvcml6YXRpb24uZnJvbShhdXRob3JpemF0aW9uLCB7IHNpZ25hdHVyZSB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGluIG9iamVjdCBmb3JtYXQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEF1dGhvcml6YXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYXV0aG9yaXphdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBhdXRob3JpemF0aW9uLmNoYWluSWQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZnJvbVJwYyhhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4geyAuLi5hdXRob3JpemF0aW9uLCAuLi5vcHRpb25zLnNpZ25hdHVyZSB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5ScGN9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogJzB4MScsXG4gKiAgIG5vbmNlOiAnMHgxJyxcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCwgbm9uY2UgfSA9IGF1dGhvcml6YXRpb247XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoYXV0aG9yaXphdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogQmlnSW50KG5vbmNlKSxcbiAgICAgICAgLi4uc2lnbmF0dXJlLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3RScGN9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjTGlzdChbe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogJzB4MScsXG4gKiAgIG5vbmNlOiAnMHgxJyxcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqIH1dKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb25MaXN0IC0gVGhlIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbiBsaXN0LlxuICogQHJldHVybnMgQSBzaWduZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjTGlzdChhdXRob3JpemF0aW9uTGlzdCkge1xuICAgIHJldHVybiBhdXRob3JpemF0aW9uTGlzdC5tYXAoZnJvbVJwYyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGUoW1xuICogICAnMHgxJyxcbiAqICAgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgICcweDMnXG4gKiBdKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDNuXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhcHBlbmQgYSBTaWduYXR1cmUgdHVwbGUgdG8gdGhlIGVuZCBvZiBhbiBBdXRob3JpemF0aW9uIHR1cGxlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlKFtcbiAqICAgJzB4MScsXG4gKiAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICAnMHgzJyxcbiAqICAgJzB4MScsXG4gKiAgICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLFxuICogICAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyxcbiAqIF0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBub25jZTogM25cbiAqIC8vIEBsb2c6ICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgczogQmlnSW50KCcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnKSxcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZSAtIFRoZSBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZSh0dXBsZSkge1xuICAgIGNvbnN0IFtjaGFpbklkLCBhZGRyZXNzLCBub25jZSwgeVBhcml0eSwgciwgc10gPSB0dXBsZTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSB5UGFyaXR5ICYmIHIgJiYgcyA/IFNpZ25hdHVyZS5mcm9tVHVwbGUoW3lQYXJpdHksIHIsIHNdKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZnJvbSh7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IEJpZ0ludChub25jZSksXG4gICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGVMaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIFNpZ25hdHVyZSB0dXBsZSB0byB0aGUgZW5kIG9mIGFuIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnLCAnMHgxJywgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnLCAnMHgxJywgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZUxpc3QgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqIEByZXR1cm5zIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlTGlzdCh0dXBsZUxpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0dXBsZSBvZiB0dXBsZUxpc3QpXG4gICAgICAgIGxpc3QucHVzaChmcm9tVHVwbGUodHVwbGUpKTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNpZ24gcGF5bG9hZCBmb3IgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gaW4gW0VJUC03NzAyIGZvcm1hdF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKTogYGtlY2NhazI1NignMHgwNScgfHwgcmxwKFtjaGFpbl9pZCwgYWRkcmVzcywgbm9uY2VdKSlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgY29tcHV0aW5nIHRoZSBzaWduIHBheWxvYWQgZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LiBUaGlzIHBheWxvYWRcbiAqIGNhbiB0aGVuIGJlIHBhc3NlZCB0byBzaWduaW5nIGZ1bmN0aW9ucyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pIHtcbiAgICByZXR1cm4gaGFzaChhdXRob3JpemF0aW9uKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGhhc2ggZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IGluIFtFSVAtNzcwMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMik6IGBrZWNjYWsyNTYoJzB4MDUnIHx8IHJscChbY2hhaW5faWQsIGFkZHJlc3MsIG5vbmNlXSkpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBBdXRob3JpemF0aW9uLmhhc2goYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKiBAcmV0dXJucyBUaGUgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goYXV0aG9yaXphdGlvbikge1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihIZXguY29uY2F0KCcweDA1JywgUmxwLmZyb21IZXgodG9UdXBsZShhdXRob3JpemF0aW9uKSkpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi50b1JwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMW4sXG4gKiAgIHI6IDQ0OTQ0NjI3ODEzMDA3NzcyODk3MzkxNTMxMjMwMDgxNjk1MTAyNzAzMjg5MTIzMzMyMTg3Njk2MTE1MTgxMTA0NzM5MjM5MTk3NTE3bixcbiAqICAgczogMzY1Mjg1MDM1MDUxOTI0MzgzMDczNTUxNjQ0NDExMDQwMDEzMTA1NjY1MDUzNTE5ODAzNjkwODUyMDgxNzg3MTI2Nzg3OTkxODExMjBuLFxuICogICB5UGFyaXR5OiAwLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQW4gQXV0aG9yaXphdGlvbi5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlLCAuLi5zaWduYXR1cmUgfSA9IGF1dGhvcml6YXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBIZXguZnJvbU51bWJlcihub25jZSksXG4gICAgICAgIC4uLlNpZ25hdHVyZS50b1JwYyhzaWduYXR1cmUpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3RScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLnRvUnBjTGlzdChbe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH1dKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb25MaXN0IC0gQW4gQXV0aG9yaXphdGlvbiBMaXN0LlxuICogQHJldHVybnMgQW4gUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uIExpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKHRvUnBjKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgdHVwbGUgPSBBdXRob3JpemF0aW9uLnRvVHVwbGUoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDY5bixcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGNoYWluSWQgPyBIZXguZnJvbU51bWJlcihjaGFpbklkKSA6ICcweCcsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIG5vbmNlID8gSGV4LmZyb21OdW1iZXIobm9uY2UpIDogJzB4JyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1R1cGxlKHNpZ25hdHVyZSkgOiBbXSksXG4gICAgXTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGVMaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uXzEgPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKiBjb25zdCBhdXRob3JpemF0aW9uXzIgPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMyxcbiAqICAgbm9uY2U6IDIwbixcbiAqIH0pXG4gKlxuICogY29uc3QgdHVwbGUgPSBBdXRob3JpemF0aW9uLnRvVHVwbGVMaXN0KFthdXRob3JpemF0aW9uXzEsIGF1dGhvcml6YXRpb25fMl0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgW1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDY5bixcbiAqIC8vIEBsb2c6ICAgXSxcbiAqIC8vIEBsb2c6ICAgW1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgXSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsaXN0IC0gQW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKiBAcmV0dXJucyBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBsaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZUxpc3QobGlzdCkge1xuICAgIGlmICghbGlzdCB8fCBsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHR1cGxlTGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgYXV0aG9yaXphdGlvbiBvZiBsaXN0KVxuICAgICAgICB0dXBsZUxpc3QucHVzaCh0b1R1cGxlKGF1dGhvcml6YXRpb24pKTtcbiAgICByZXR1cm4gdHVwbGVMaXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aG9yaXphdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Authorization.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Base58.js":
/*!**********************************************!*\
  !*** ../node_modules/ox/_esm/core/Base58.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_base58_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/base58.js */ \"../node_modules/ox/_esm/core/internal/base58.js\");\n\n\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base58-encoded string.\n *\n * @example\n * ```ts twoslash\n * import { Base58, Bytes } from 'ox'\n *\n * const value = Base58.fromBytes(Bytes.fromString('Hello World!'))\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @param value - The byte array to encode.\n * @returns The Base58 encoded string.\n */\nfunction fromBytes(value) {\n    return _internal_base58_js__WEBPACK_IMPORTED_MODULE_0__.from(value);\n}\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base58-encoded string.\n *\n * @example\n * ```ts twoslash\n * import { Base58, Hex } from 'ox'\n *\n * const value = Base58.fromHex(Hex.fromString('Hello World!'))\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @param value - The byte array to encode.\n * @returns The Base58 encoded string.\n */\nfunction fromHex(value) {\n    return _internal_base58_js__WEBPACK_IMPORTED_MODULE_0__.from(value);\n}\n/**\n * Encodes a string to a Base58-encoded string.\n *\n * @example\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value = Base58.fromString('Hello World!')\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @param value - The string to encode.\n * @returns The Base58 encoded string.\n */\nfunction fromString(value) {\n    return _internal_base58_js__WEBPACK_IMPORTED_MODULE_0__.from(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromString(value));\n}\n/**\n * Decodes a Base58-encoded string to a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value = Base58.toBytes('2NEpo7TZRRrLZSi2U')\n * // @log: Uint8Array [ 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33 ]\n * ```\n *\n * @param value - The Base58 encoded string.\n * @returns The decoded byte array.\n */\nfunction toBytes(value) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(toHex(value));\n}\n/**\n * Decodes a Base58-encoded string to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value = Base58.toHex('2NEpo7TZRRrLZSi2U')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The Base58 encoded string.\n * @returns The decoded hex string.\n */\nfunction toHex(value) {\n    let integer = BigInt(0);\n    let pad = 0;\n    let checkPad = true;\n    for (let i = 0; i < value.length; i++) {\n        const char = value[i];\n        // check for leading 1s\n        if (checkPad && char === '1')\n            pad++;\n        else\n            checkPad = false;\n        // check for invalid characters\n        if (typeof _internal_base58_js__WEBPACK_IMPORTED_MODULE_0__.alphabetToInteger[char] !== 'bigint')\n            throw new Error('invalid base58 character: ' + char);\n        integer = integer * 58n;\n        integer = integer + _internal_base58_js__WEBPACK_IMPORTED_MODULE_0__.alphabetToInteger[char];\n    }\n    if (!pad)\n        return `0x${integer.toString(16)}`;\n    return `0x${'0'.repeat(pad * 2)}${integer.toString(16)}`;\n}\n/**\n * Decodes a Base58-encoded string to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value = Base58.toString('2NEpo7TZRRrLZSi2U')\n * // @log: 'Hello World!'\n * ```\n *\n * @param value - The Base58 encoded string.\n * @returns The decoded string.\n */\nfunction toString(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toString(toHex(value));\n}\n//# sourceMappingURL=Base58.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CYXNlNTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0o7QUFDaUI7QUFDakQ7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHFEQUFhO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxxREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxxREFBYSxDQUFDLGlEQUFnQjtBQUN6QztBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRUFBMEI7QUFDN0M7QUFDQTtBQUNBLDRCQUE0QixrRUFBMEI7QUFDdEQ7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekMsZ0JBQWdCLG9CQUFvQixFQUFFLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2Q0FBWTtBQUN2QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmFzZTU4LmpzP2NhNzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9iYXNlNTguanMnO1xuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U1OCwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U1OC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJykpXG4gKiAvLyBAbG9nOiAnMk5FcG83VFpSUnJMWlNpMlUnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYnl0ZSBhcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgQmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLmZyb20odmFsdWUpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHRvIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTU4LCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U1OC5mcm9tSGV4KEhleC5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKSlcbiAqIC8vIEBsb2c6ICcyTkVwbzdUWlJSckxaU2kyVSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBCYXNlNTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLmZyb20odmFsdWUpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIHRvIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTU4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNTguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJylcbiAqIC8vIEBsb2c6ICcyTkVwbzdUWlJSckxaU2kyVSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIEJhc2U1OCBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwuZnJvbShCeXRlcy5mcm9tU3RyaW5nKHZhbHVlKSk7XG59XG4vKipcbiAqIERlY29kZXMgYSBCYXNlNTgtZW5jb2RlZCBzdHJpbmcgdG8gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTU4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNTgudG9CeXRlcygnMk5FcG83VFpSUnJMWlNpMlUnKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbIDcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzMyBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgQmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgYnl0ZSBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh0b0hleCh2YWx1ZSkpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nIHRvIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U1OCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTU4LnRvSGV4KCcyTkVwbzdUWlJSckxaU2kyVScpXG4gKiAvLyBAbG9nOiAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgQmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgaGV4IHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgbGV0IGludGVnZXIgPSBCaWdJbnQoMCk7XG4gICAgbGV0IHBhZCA9IDA7XG4gICAgbGV0IGNoZWNrUGFkID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSB2YWx1ZVtpXTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGxlYWRpbmcgMXNcbiAgICAgICAgaWYgKGNoZWNrUGFkICYmIGNoYXIgPT09ICcxJylcbiAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGVja1BhZCA9IGZhbHNlO1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzXG4gICAgICAgIGlmICh0eXBlb2YgaW50ZXJuYWwuYWxwaGFiZXRUb0ludGVnZXJbY2hhcl0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2U1OCBjaGFyYWN0ZXI6ICcgKyBjaGFyKTtcbiAgICAgICAgaW50ZWdlciA9IGludGVnZXIgKiA1OG47XG4gICAgICAgIGludGVnZXIgPSBpbnRlZ2VyICsgaW50ZXJuYWwuYWxwaGFiZXRUb0ludGVnZXJbY2hhcl07XG4gICAgfVxuICAgIGlmICghcGFkKVxuICAgICAgICByZXR1cm4gYDB4JHtpbnRlZ2VyLnRvU3RyaW5nKDE2KX1gO1xuICAgIHJldHVybiBgMHgkeycwJy5yZXBlYXQocGFkICogMil9JHtpbnRlZ2VyLnRvU3RyaW5nKDE2KX1gO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTU4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNTgudG9TdHJpbmcoJzJORXBvN1RaUlJyTFpTaTJVJylcbiAqIC8vIEBsb2c6ICdIZWxsbyBXb3JsZCEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgQmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gSGV4LnRvU3RyaW5nKHRvSGV4KHZhbHVlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlNTguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Base58.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Base64.js":
/*!**********************************************!*\
  !*** ../node_modules/ox/_esm/core/Base64.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst integerToCharacter = /*#__PURE__*/ Object.fromEntries(Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').map((a, i) => [i, a.charCodeAt(0)]));\nconst characterToInteger = /*#__PURE__*/ {\n    ...Object.fromEntries(Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').map((a, i) => [a.charCodeAt(0), i])),\n    ['='.charCodeAt(0)]: 0,\n    ['-'.charCodeAt(0)]: 62,\n    ['_'.charCodeAt(0)]: 63,\n};\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The byte array to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nfunction fromBytes(value, options = {}) {\n    const { pad = true, url = false } = options;\n    const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4);\n    for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {\n        const y = (value[j] << 16) + (value[j + 1] << 8) + (value[j + 2] | 0);\n        encoded[i] = integerToCharacter[y >> 18];\n        encoded[i + 1] = integerToCharacter[(y >> 12) & 0x3f];\n        encoded[i + 2] = integerToCharacter[(y >> 6) & 0x3f];\n        encoded[i + 3] = integerToCharacter[y & 0x3f];\n    }\n    const k = value.length % 3;\n    const end = Math.floor(value.length / 3) * 4 + (k && k + 1);\n    let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end));\n    if (pad && k === 1)\n        base64 += '==';\n    if (pad && k === 2)\n        base64 += '=';\n    if (url)\n        base64 = base64.replaceAll('+', '-').replaceAll('/', '_');\n    return base64;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The hex value to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nfunction fromHex(value, options = {}) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(value), options);\n}\n/**\n * Encodes a string to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world')\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world', { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello wod', { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The string to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromString(value), options);\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.toBytes('aGVsbG8gd29ybGQ=')\n * // @log: Uint8Array([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(value) {\n    const base64 = value.replace(/=+$/, '');\n    const size = base64.length;\n    const decoded = new Uint8Array(size + 3);\n    encoder.encodeInto(base64 + '===', decoded);\n    for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {\n        const x = (characterToInteger[decoded[i]] << 18) +\n            (characterToInteger[decoded[i + 1]] << 12) +\n            (characterToInteger[decoded[i + 2]] << 6) +\n            characterToInteger[decoded[i + 3]];\n        decoded[j] = x >> 16;\n        decoded[j + 1] = (x >> 8) & 0xff;\n        decoded[j + 2] = x & 0xff;\n    }\n    const decodedSize = (size >> 2) * 3 + (size % 4 && (size % 4) - 1);\n    return new Uint8Array(decoded.buffer, 0, decodedSize);\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.toHex('aGVsbG8gd29ybGQ=')\n * // @log: 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Hex.Hex}.\n */\nfunction toHex(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(toBytes(value));\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.toString('aGVsbG8gd29ybGQ=')\n * // @log: 'hello world'\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded string.\n */\nfunction toString(value) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.toString(toBytes(value));\n}\n//# sourceMappingURL=Base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CYXNlNjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBb0M7QUFDSjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLHFFQUFxRSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQSxnRUFBZ0UsV0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQztBQUMzQyxxQkFBcUIsOENBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsbURBQW1ELFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUM7QUFDOUMscUJBQXFCLGlEQUFnQjtBQUNyQztBQUNBO0FBQ0EsMEZBQTBGLHFCQUFxQjtBQUMvRztBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGlCQUFpQjtBQUMzRztBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNPO0FBQ1AsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVywrQ0FBYztBQUN6QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmFzZTY0LmpzP2E0MDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuY29uc3QgZW5jb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGludGVnZXJUb0NoYXJhY3RlciA9IC8qI19fUFVSRV9fKi8gT2JqZWN0LmZyb21FbnRyaWVzKEFycmF5LmZyb20oJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKS5tYXAoKGEsIGkpID0+IFtpLCBhLmNoYXJDb2RlQXQoMCldKSk7XG5jb25zdCBjaGFyYWN0ZXJUb0ludGVnZXIgPSAvKiNfX1BVUkVfXyovIHtcbiAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbSgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLm1hcCgoYSwgaSkgPT4gW2EuY2hhckNvZGVBdCgwKSwgaV0pKSxcbiAgICBbJz0nLmNoYXJDb2RlQXQoMCldOiAwLFxuICAgIFsnLScuY2hhckNvZGVBdCgwKV06IDYyLFxuICAgIFsnXycuY2hhckNvZGVBdCgwKV06IDYzLFxufTtcbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgKHdpdGggb3B0aW9uYWwgcGFkZGluZyBhbmQvb3IgVVJMLXNhZmUgY2hhcmFjdGVycykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCYXNlNjQsIEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbUJ5dGVzKEJ5dGVzLmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRPSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgTm8gUGFkZGluZ1xuICpcbiAqIFR1cm4gb2ZmIFtwYWRkaW5nIG9mIGVuY29kZWQgZGF0YV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tMy4yKSB3aXRoIHRoZSBgcGFkYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSwgeyBwYWQ6IGZhbHNlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRJ1xuICogYGBgXG4gKlxuICogIyMjIFVSTC1zYWZlIEVuY29kaW5nXG4gKlxuICogVHVybiBvbiBbVVJMLXNhZmUgZW5jb2RpbmddKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTUpIChCYXNlNjQgVVJMKSB3aXRoIHRoZSBgdXJsYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbVN0cmluZygnaGVsbG8gd29/ZCcpLCB7IHVybDogdHJ1ZSB9KVxuICogLy8gQGxvZzogJ2FHVnNiRzhnZDI5Xzc3LTlaQT09J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJ5dGUgYXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwYWQgPSB0cnVlLCB1cmwgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMpICogNCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBpICs9IDQsIGogKz0gMykge1xuICAgICAgICBjb25zdCB5ID0gKHZhbHVlW2pdIDw8IDE2KSArICh2YWx1ZVtqICsgMV0gPDwgOCkgKyAodmFsdWVbaiArIDJdIHwgMCk7XG4gICAgICAgIGVuY29kZWRbaV0gPSBpbnRlZ2VyVG9DaGFyYWN0ZXJbeSA+PiAxOF07XG4gICAgICAgIGVuY29kZWRbaSArIDFdID0gaW50ZWdlclRvQ2hhcmFjdGVyWyh5ID4+IDEyKSAmIDB4M2ZdO1xuICAgICAgICBlbmNvZGVkW2kgKyAyXSA9IGludGVnZXJUb0NoYXJhY3RlclsoeSA+PiA2KSAmIDB4M2ZdO1xuICAgICAgICBlbmNvZGVkW2kgKyAzXSA9IGludGVnZXJUb0NoYXJhY3Rlclt5ICYgMHgzZl07XG4gICAgfVxuICAgIGNvbnN0IGsgPSB2YWx1ZS5sZW5ndGggJSAzO1xuICAgIGNvbnN0IGVuZCA9IE1hdGguZmxvb3IodmFsdWUubGVuZ3RoIC8gMykgKiA0ICsgKGsgJiYgayArIDEpO1xuICAgIGxldCBiYXNlNjQgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShlbmNvZGVkLmJ1ZmZlciwgMCwgZW5kKSk7XG4gICAgaWYgKHBhZCAmJiBrID09PSAxKVxuICAgICAgICBiYXNlNjQgKz0gJz09JztcbiAgICBpZiAocGFkICYmIGsgPT09IDIpXG4gICAgICAgIGJhc2U2NCArPSAnPSc7XG4gICAgaWYgKHVybClcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnJlcGxhY2VBbGwoJysnLCAnLScpLnJlcGxhY2VBbGwoJy8nLCAnXycpO1xuICAgIHJldHVybiBiYXNlNjQ7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdG8gYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgKHdpdGggb3B0aW9uYWwgcGFkZGluZyBhbmQvb3IgVVJMLXNhZmUgY2hhcmFjdGVycykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCYXNlNjQsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21IZXgoSGV4LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRPSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgTm8gUGFkZGluZ1xuICpcbiAqIFR1cm4gb2ZmIFtwYWRkaW5nIG9mIGVuY29kZWQgZGF0YV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tMy4yKSB3aXRoIHRoZSBgcGFkYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbUhleChIZXguZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSwgeyBwYWQ6IGZhbHNlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRJ1xuICogYGBgXG4gKlxuICogIyMjIFVSTC1zYWZlIEVuY29kaW5nXG4gKlxuICogVHVybiBvbiBbVVJMLXNhZmUgZW5jb2RpbmddKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTUpIChCYXNlNjQgVVJMKSB3aXRoIHRoZSBgdXJsYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbUhleChIZXguZnJvbVN0cmluZygnaGVsbG8gd29/ZCcpLCB7IHVybDogdHJ1ZSB9KVxuICogLy8gQGxvZzogJ2FHVnNiRzhnZDI5Xzc3LTlaQT09J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleCB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhCeXRlcy5mcm9tSGV4KHZhbHVlKSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgKHdpdGggb3B0aW9uYWwgcGFkZGluZyBhbmQvb3IgVVJMLXNhZmUgY2hhcmFjdGVycykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCYXNlNjQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRPSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgTm8gUGFkZGluZ1xuICpcbiAqIFR1cm4gb2ZmIFtwYWRkaW5nIG9mIGVuY29kZWQgZGF0YV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tMy4yKSB3aXRoIHRoZSBgcGFkYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJywgeyBwYWQ6IGZhbHNlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRJ1xuICogYGBgXG4gKlxuICogIyMjIFVSTC1zYWZlIEVuY29kaW5nXG4gKlxuICogVHVybiBvbiBbVVJMLXNhZmUgZW5jb2RpbmddKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTUpIChCYXNlNjQgVVJMKSB3aXRoIHRoZSBgdXJsYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21TdHJpbmcoJ2hlbGxvIHdvf2QnLCB7IHVybDogdHJ1ZSB9KVxuICogLy8gQGxvZzogJ2FHVnNiRzhnZDI5Xzc3LTlaQT09J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhCeXRlcy5mcm9tU3RyaW5nKHZhbHVlKSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgKHdpdGggb3B0aW9uYWwgcGFkZGluZyBhbmQvb3IgVVJMLXNhZmUgY2hhcmFjdGVycykgdG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC50b0J5dGVzKCdhR1ZzYkc4Z2QyOXliR1E9JylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZywgaGV4IHZhbHVlLCBvciBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBCYXNlNjQgZGVjb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgIGNvbnN0IGJhc2U2NCA9IHZhbHVlLnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBjb25zdCBzaXplID0gYmFzZTY0Lmxlbmd0aDtcbiAgICBjb25zdCBkZWNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSArIDMpO1xuICAgIGVuY29kZXIuZW5jb2RlSW50byhiYXNlNjQgKyAnPT09JywgZGVjb2RlZCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYmFzZTY0Lmxlbmd0aDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICAgICAgY29uc3QgeCA9IChjaGFyYWN0ZXJUb0ludGVnZXJbZGVjb2RlZFtpXV0gPDwgMTgpICtcbiAgICAgICAgICAgIChjaGFyYWN0ZXJUb0ludGVnZXJbZGVjb2RlZFtpICsgMV1dIDw8IDEyKSArXG4gICAgICAgICAgICAoY2hhcmFjdGVyVG9JbnRlZ2VyW2RlY29kZWRbaSArIDJdXSA8PCA2KSArXG4gICAgICAgICAgICBjaGFyYWN0ZXJUb0ludGVnZXJbZGVjb2RlZFtpICsgM11dO1xuICAgICAgICBkZWNvZGVkW2pdID0geCA+PiAxNjtcbiAgICAgICAgZGVjb2RlZFtqICsgMV0gPSAoeCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGRlY29kZWRbaiArIDJdID0geCAmIDB4ZmY7XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWRTaXplID0gKHNpemUgPj4gMikgKiAzICsgKHNpemUgJSA0ICYmIChzaXplICUgNCkgLSAxKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5idWZmZXIsIDAsIGRlY29kZWRTaXplKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyAod2l0aCBvcHRpb25hbCBwYWRkaW5nIGFuZC9vciBVUkwtc2FmZSBjaGFyYWN0ZXJzKSB0byB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCYXNlNjQsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LnRvSGV4KCdhR1ZzYkc4Z2QyOXliR1E9JylcbiAqIC8vIEBsb2c6IDB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZywgaGV4IHZhbHVlLCBvciBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBCYXNlNjQgZGVjb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHRvQnl0ZXModmFsdWUpKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyAod2l0aCBvcHRpb25hbCBwYWRkaW5nIGFuZC9vciBVUkwtc2FmZSBjaGFyYWN0ZXJzKSB0byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LnRvU3RyaW5nKCdhR1ZzYkc4Z2QyOXliR1E9JylcbiAqIC8vIEBsb2c6ICdoZWxsbyB3b3JsZCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcsIGhleCB2YWx1ZSwgb3IgYnl0ZSBhcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgQmFzZTY0IGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gQnl0ZXMudG9TdHJpbmcodG9CeXRlcyh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Base64.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/BinaryStateTree.js":
/*!*******************************************************!*\
  !*** ../node_modules/ox/_esm/core/BinaryStateTree.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   merkelize: () => (/* binding */ merkelize)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/blake3 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/blake3.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n\n\n/**\n * Creates a new Binary State Tree instance.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n * ```\n *\n * @returns A Binary State Tree.\n */\nfunction create() {\n    return {\n        root: emptyNode(),\n    };\n}\n/**\n * Inserts a key-value pair into the Binary State Tree.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree, Bytes } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n *\n * BinaryStateTree.insert( // [!code focus]\n *   tree, // [!code focus]\n *   Bytes.fromHex('0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'), // [!code focus]\n *   Bytes.fromHex('0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1') // [!code focus]\n * ) // [!code focus]\n * ```\n *\n * @param tree - Binary State Tree instance.\n * @param key - Key to insert.\n * @param value - Value to insert.\n */\nfunction insert(tree, key, value) {\n    const stem = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.slice(key, 0, 31);\n    const subIndex = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.slice(key, 31)[0];\n    if (tree.root.type === 'empty') {\n        tree.root = stemNode(stem);\n        tree.root.values[subIndex] = value;\n        return;\n    }\n    function inner(node_, stem, subIndex, value, depth) {\n        let node = node_;\n        if (node.type === 'empty') {\n            node = stemNode(stem);\n            node.values[subIndex] = value;\n            return node;\n        }\n        const stemBits = bytesToBits(stem);\n        if (node.type === 'stem') {\n            if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.isEqual(node.stem, stem)) {\n                node.values[subIndex] = value;\n                return node;\n            }\n            const existingStemBits = bytesToBits(node.stem);\n            return splitLeaf(node, stemBits, existingStemBits, subIndex, value, depth);\n        }\n        if (node.type === 'internal') {\n            const bit = stemBits[depth];\n            if (bit === 0) {\n                node.left = inner(node.left, stem, subIndex, value, depth + 1);\n            }\n            else {\n                node.right = inner(node.right, stem, subIndex, value, depth + 1);\n            }\n            return node;\n        }\n        return emptyNode();\n    }\n    tree.root = inner(tree.root, stem, subIndex, value, 0);\n}\n/**\n * Merkelizes a Binary State Tree.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree, Bytes } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n *\n * BinaryStateTree.insert(\n *   tree,\n *   Bytes.fromHex('0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'),\n *   Bytes.fromHex('0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1')\n * )\n *\n * const hash = BinaryStateTree.merkelize(tree) // [!code focus]\n * ```\n *\n * @param tree - Binary State Tree instance.\n * @returns Merkle hash.\n */\nfunction merkelize(tree) {\n    function inner(node) {\n        if (node.type === 'empty')\n            return new Uint8Array(32).fill(0);\n        if (node.type === 'internal') {\n            const hash_left = inner(node.left);\n            const hash_right = inner(node.right);\n            return hash(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.concat(hash_left, hash_right));\n        }\n        let level = node.values.map(hash);\n        while (level.length > 1) {\n            const level_ = [];\n            for (let i = 0; i < level.length; i += 2)\n                level_.push(hash(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.concat(level[i], level[i + 1])));\n            level = level_;\n        }\n        return hash(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.concat(node.stem, new Uint8Array(1).fill(0), level[0]));\n    }\n    return inner(tree.root);\n}\n/** @internal */\nfunction splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth) {\n    if (stemBits[depth] === existingStemBits[depth]) {\n        const internal = internalNode();\n        const bit = stemBits[depth];\n        if (bit === 0) {\n            internal.left = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth + 1);\n        }\n        else {\n            internal.right = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth + 1);\n        }\n        return internal;\n    }\n    const internal = internalNode();\n    const bit = stemBits[depth];\n    const stem = bitsToBytes(stemBits);\n    if (bit === 0) {\n        internal.left = stemNode(stem);\n        internal.left.values[subIndex] = value;\n        internal.right = leaf;\n    }\n    else {\n        internal.right = stemNode(stem);\n        internal.right.values[subIndex] = value;\n        internal.left = leaf;\n    }\n    return internal;\n}\n/** @internal */\nfunction emptyNode() {\n    return {\n        type: 'empty',\n    };\n}\n/** @internal */\nfunction internalNode() {\n    return {\n        left: emptyNode(),\n        right: emptyNode(),\n        type: 'internal',\n    };\n}\n/** @internal */\nfunction stemNode(stem) {\n    return {\n        stem,\n        values: Array.from({ length: 256 }, () => undefined),\n        type: 'stem',\n    };\n}\n/** @internal */\nfunction bytesToBits(bytes) {\n    const bits = [];\n    for (const byte of bytes)\n        for (let i = 0; i < 8; i++)\n            bits.push((byte >> (7 - i)) & 1);\n    return bits;\n}\n/** @internal */\nfunction bitsToBytes(bits) {\n    const byte_data = new Uint8Array(bits.length / 8);\n    for (let i = 0; i < bits.length; i += 8) {\n        let byte = 0;\n        for (let j = 0; j < 8; j++)\n            byte |= bits[i + j] << (7 - j);\n        byte_data[i / 8] = byte;\n    }\n    return byte_data;\n}\n/** @internal */\nfunction hash(bytes) {\n    if (!bytes)\n        return new Uint8Array(32).fill(0);\n    if (!bytes.some((byte) => byte !== 0))\n        return new Uint8Array(32).fill(0);\n    return (0,_noble_hashes_blake3__WEBPACK_IMPORTED_MODULE_1__.blake3)(bytes);\n}\n//# sourceMappingURL=BinaryStateTree.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CaW5hcnlTdGF0ZVRyZWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEM7QUFDVjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsNENBQVc7QUFDNUIscUJBQXFCLDRDQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUMsaUNBQWlDLDZDQUFZO0FBQzdDO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBTTtBQUNqQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmluYXJ5U3RhdGVUcmVlLmpzP2VhZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmxha2UzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9ibGFrZTMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQmluYXJ5IFN0YXRlIFRyZWUgaW5zdGFuY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCaW5hcnlTdGF0ZVRyZWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmVlID0gQmluYXJ5U3RhdGVUcmVlLmNyZWF0ZSgpXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIEJpbmFyeSBTdGF0ZSBUcmVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IGVtcHR5Tm9kZSgpLFxuICAgIH07XG59XG4vKipcbiAqIEluc2VydHMgYSBrZXktdmFsdWUgcGFpciBpbnRvIHRoZSBCaW5hcnkgU3RhdGUgVHJlZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJpbmFyeVN0YXRlVHJlZSwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmVlID0gQmluYXJ5U3RhdGVUcmVlLmNyZWF0ZSgpXG4gKlxuICogQmluYXJ5U3RhdGVUcmVlLmluc2VydCggLy8gWyFjb2RlIGZvY3VzXVxuICogICB0cmVlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIEJ5dGVzLmZyb21IZXgoJzB4ZTM0ZjE5OWIxOWIyYjRmNDdmNjg0NDI2MTlkNTU1NTI3ZDI0NGY3OGEzMjk3ZWE4OTMyNWY4NDNmODdiOGI1NCcpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIEJ5dGVzLmZyb21IZXgoJzB4ZDRmZDRlMTg5MTMyMjczMDM2NDQ5ZmM5ZTExMTk4YzczOTE2MWI0YzAxMTZhOWEyZGNjZGZhMWM0OTIwMDZmMScpIC8vIFshY29kZSBmb2N1c11cbiAqICkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRyZWUgLSBCaW5hcnkgU3RhdGUgVHJlZSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gaW5zZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0KHRyZWUsIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzdGVtID0gQnl0ZXMuc2xpY2Uoa2V5LCAwLCAzMSk7XG4gICAgY29uc3Qgc3ViSW5kZXggPSBCeXRlcy5zbGljZShrZXksIDMxKVswXTtcbiAgICBpZiAodHJlZS5yb290LnR5cGUgPT09ICdlbXB0eScpIHtcbiAgICAgICAgdHJlZS5yb290ID0gc3RlbU5vZGUoc3RlbSk7XG4gICAgICAgIHRyZWUucm9vdC52YWx1ZXNbc3ViSW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5uZXIobm9kZV8sIHN0ZW0sIHN1YkluZGV4LCB2YWx1ZSwgZGVwdGgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2RlXztcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgbm9kZSA9IHN0ZW1Ob2RlKHN0ZW0pO1xuICAgICAgICAgICAgbm9kZS52YWx1ZXNbc3ViSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGVtQml0cyA9IGJ5dGVzVG9CaXRzKHN0ZW0pO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnc3RlbScpIHtcbiAgICAgICAgICAgIGlmIChCeXRlcy5pc0VxdWFsKG5vZGUuc3RlbSwgc3RlbSkpIHtcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlc1tzdWJJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3RlbUJpdHMgPSBieXRlc1RvQml0cyhub2RlLnN0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHNwbGl0TGVhZihub2RlLCBzdGVtQml0cywgZXhpc3RpbmdTdGVtQml0cywgc3ViSW5kZXgsIHZhbHVlLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2ludGVybmFsJykge1xuICAgICAgICAgICAgY29uc3QgYml0ID0gc3RlbUJpdHNbZGVwdGhdO1xuICAgICAgICAgICAgaWYgKGJpdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IGlubmVyKG5vZGUubGVmdCwgc3RlbSwgc3ViSW5kZXgsIHZhbHVlLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IGlubmVyKG5vZGUucmlnaHQsIHN0ZW0sIHN1YkluZGV4LCB2YWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbXB0eU5vZGUoKTtcbiAgICB9XG4gICAgdHJlZS5yb290ID0gaW5uZXIodHJlZS5yb290LCBzdGVtLCBzdWJJbmRleCwgdmFsdWUsIDApO1xufVxuLyoqXG4gKiBNZXJrZWxpemVzIGEgQmluYXJ5IFN0YXRlIFRyZWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCaW5hcnlTdGF0ZVRyZWUsIEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJlZSA9IEJpbmFyeVN0YXRlVHJlZS5jcmVhdGUoKVxuICpcbiAqIEJpbmFyeVN0YXRlVHJlZS5pbnNlcnQoXG4gKiAgIHRyZWUsXG4gKiAgIEJ5dGVzLmZyb21IZXgoJzB4ZTM0ZjE5OWIxOWIyYjRmNDdmNjg0NDI2MTlkNTU1NTI3ZDI0NGY3OGEzMjk3ZWE4OTMyNWY4NDNmODdiOGI1NCcpLFxuICogICBCeXRlcy5mcm9tSGV4KCcweGQ0ZmQ0ZTE4OTEzMjI3MzAzNjQ0OWZjOWUxMTE5OGM3MzkxNjFiNGMwMTE2YTlhMmRjY2RmYTFjNDkyMDA2ZjEnKVxuICogKVxuICpcbiAqIGNvbnN0IGhhc2ggPSBCaW5hcnlTdGF0ZVRyZWUubWVya2VsaXplKHRyZWUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0cmVlIC0gQmluYXJ5IFN0YXRlIFRyZWUgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyBNZXJrbGUgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmtlbGl6ZSh0cmVlKSB7XG4gICAgZnVuY3Rpb24gaW5uZXIobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnZW1wdHknKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDApO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnaW50ZXJuYWwnKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoX2xlZnQgPSBpbm5lcihub2RlLmxlZnQpO1xuICAgICAgICAgICAgY29uc3QgaGFzaF9yaWdodCA9IGlubmVyKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2goQnl0ZXMuY29uY2F0KGhhc2hfbGVmdCwgaGFzaF9yaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZXZlbCA9IG5vZGUudmFsdWVzLm1hcChoYXNoKTtcbiAgICAgICAgd2hpbGUgKGxldmVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsXyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgICAgICBsZXZlbF8ucHVzaChoYXNoKEJ5dGVzLmNvbmNhdChsZXZlbFtpXSwgbGV2ZWxbaSArIDFdKSkpO1xuICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbF87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2goQnl0ZXMuY29uY2F0KG5vZGUuc3RlbSwgbmV3IFVpbnQ4QXJyYXkoMSkuZmlsbCgwKSwgbGV2ZWxbMF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGlubmVyKHRyZWUucm9vdCk7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzcGxpdExlYWYobGVhZiwgc3RlbUJpdHMsIGV4aXN0aW5nU3RlbUJpdHMsIHN1YkluZGV4LCB2YWx1ZSwgZGVwdGgpIHtcbiAgICBpZiAoc3RlbUJpdHNbZGVwdGhdID09PSBleGlzdGluZ1N0ZW1CaXRzW2RlcHRoXSkge1xuICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGludGVybmFsTm9kZSgpO1xuICAgICAgICBjb25zdCBiaXQgPSBzdGVtQml0c1tkZXB0aF07XG4gICAgICAgIGlmIChiaXQgPT09IDApIHtcbiAgICAgICAgICAgIGludGVybmFsLmxlZnQgPSBzcGxpdExlYWYobGVhZiwgc3RlbUJpdHMsIGV4aXN0aW5nU3RlbUJpdHMsIHN1YkluZGV4LCB2YWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludGVybmFsLnJpZ2h0ID0gc3BsaXRMZWFmKGxlYWYsIHN0ZW1CaXRzLCBleGlzdGluZ1N0ZW1CaXRzLCBzdWJJbmRleCwgdmFsdWUsIGRlcHRoICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVybmFsO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcm5hbCA9IGludGVybmFsTm9kZSgpO1xuICAgIGNvbnN0IGJpdCA9IHN0ZW1CaXRzW2RlcHRoXTtcbiAgICBjb25zdCBzdGVtID0gYml0c1RvQnl0ZXMoc3RlbUJpdHMpO1xuICAgIGlmIChiaXQgPT09IDApIHtcbiAgICAgICAgaW50ZXJuYWwubGVmdCA9IHN0ZW1Ob2RlKHN0ZW0pO1xuICAgICAgICBpbnRlcm5hbC5sZWZ0LnZhbHVlc1tzdWJJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaW50ZXJuYWwucmlnaHQgPSBsZWFmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWwucmlnaHQgPSBzdGVtTm9kZShzdGVtKTtcbiAgICAgICAgaW50ZXJuYWwucmlnaHQudmFsdWVzW3N1YkluZGV4XSA9IHZhbHVlO1xuICAgICAgICBpbnRlcm5hbC5sZWZ0ID0gbGVhZjtcbiAgICB9XG4gICAgcmV0dXJuIGludGVybmFsO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZW1wdHlOb2RlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdlbXB0eScsXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGludGVybmFsTm9kZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBlbXB0eU5vZGUoKSxcbiAgICAgICAgcmlnaHQ6IGVtcHR5Tm9kZSgpLFxuICAgICAgICB0eXBlOiAnaW50ZXJuYWwnLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBzdGVtTm9kZShzdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RlbSxcbiAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKCkgPT4gdW5kZWZpbmVkKSxcbiAgICAgICAgdHlwZTogJ3N0ZW0nLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBieXRlc1RvQml0cyhieXRlcykge1xuICAgIGNvbnN0IGJpdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYnl0ZXMpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICAgICAgYml0cy5wdXNoKChieXRlID4+ICg3IC0gaSkpICYgMSk7XG4gICAgcmV0dXJuIGJpdHM7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBiaXRzVG9CeXRlcyhiaXRzKSB7XG4gICAgY29uc3QgYnl0ZV9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoYml0cy5sZW5ndGggLyA4KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdHMubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgbGV0IGJ5dGUgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDg7IGorKylcbiAgICAgICAgICAgIGJ5dGUgfD0gYml0c1tpICsgal0gPDwgKDcgLSBqKTtcbiAgICAgICAgYnl0ZV9kYXRhW2kgLyA4XSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBieXRlX2RhdGE7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBoYXNoKGJ5dGVzKSB7XG4gICAgaWYgKCFieXRlcylcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDApO1xuICAgIGlmICghYnl0ZXMuc29tZSgoYnl0ZSkgPT4gYnl0ZSAhPT0gMCkpXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgzMikuZmlsbCgwKTtcbiAgICByZXR1cm4gYmxha2UzKGJ5dGVzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpbmFyeVN0YXRlVHJlZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/BinaryStateTree.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Blobs.js":
/*!*********************************************!*\
  !*** ../node_modules/ox/_esm/core/Blobs.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobSizeTooLargeError: () => (/* binding */ BlobSizeTooLargeError),\n/* harmony export */   EmptyBlobError: () => (/* binding */ EmptyBlobError),\n/* harmony export */   EmptyBlobVersionedHashesError: () => (/* binding */ EmptyBlobVersionedHashesError),\n/* harmony export */   InvalidVersionedHashSizeError: () => (/* binding */ InvalidVersionedHashSizeError),\n/* harmony export */   InvalidVersionedHashVersionError: () => (/* binding */ InvalidVersionedHashVersionError),\n/* harmony export */   bytesPerBlob: () => (/* binding */ bytesPerBlob),\n/* harmony export */   bytesPerFieldElement: () => (/* binding */ bytesPerFieldElement),\n/* harmony export */   commitmentToVersionedHash: () => (/* binding */ commitmentToVersionedHash),\n/* harmony export */   commitmentsToVersionedHashes: () => (/* binding */ commitmentsToVersionedHashes),\n/* harmony export */   fieldElementsPerBlob: () => (/* binding */ fieldElementsPerBlob),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   maxBytesPerTransaction: () => (/* binding */ maxBytesPerTransaction),\n/* harmony export */   sidecarsToVersionedHashes: () => (/* binding */ sidecarsToVersionedHashes),\n/* harmony export */   to: () => (/* binding */ to),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toCommitments: () => (/* binding */ toCommitments),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toProofs: () => (/* binding */ toProofs),\n/* harmony export */   toSidecars: () => (/* binding */ toSidecars),\n/* harmony export */   toVersionedHashes: () => (/* binding */ toVersionedHashes)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Kzg_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Kzg.js */ \"../node_modules/ox/_esm/core/Kzg.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/cursor.js */ \"../node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6;\n/** The number of bytes in a BLS scalar field element. */\nconst bytesPerFieldElement = 32;\n/** The number of field elements in a blob. */\nconst fieldElementsPerBlob = 4096;\n/** The number of bytes in a blob. */\nconst bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;\n/** Blob bytes limit per transaction. */\nconst maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction -\n    // terminator byte (0x80).\n    1 -\n    // zero byte (0x00) appended to each field element.\n    1 * fieldElementsPerBlob * blobsPerTransaction;\n/**\n * Transform a list of Commitments to Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments) // [!code focus]\n * // @log: ['0x...', '0x...']\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitments - A list of commitments.\n * @param options - Options.\n * @returns A list of Blob Versioned Hashes.\n */\nfunction commitmentsToVersionedHashes(commitments, options = {}) {\n    const { version } = options;\n    const as = options.as ?? (typeof commitments[0] === 'string' ? 'Hex' : 'Bytes');\n    const hashes = [];\n    for (const commitment of commitments) {\n        hashes.push(commitmentToVersionedHash(commitment, {\n            as,\n            version,\n        }));\n    }\n    return hashes;\n}\n/**\n * Transform a Commitment to its Blob Versioned Hash.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHash = Blobs.commitmentToVersionedHash(commitment) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hash with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hash with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitment - The commitment.\n * @param options - Options.\n * @returns The Blob Versioned Hash.\n */\nfunction commitmentToVersionedHash(commitment, options = {}) {\n    const { version = 1 } = options;\n    const as = options.as ?? (typeof commitment === 'string' ? 'Hex' : 'Bytes');\n    const versionedHash = _Hash_js__WEBPACK_IMPORTED_MODULE_0__.sha256(commitment, { as: 'Bytes' });\n    versionedHash.set([version], 0);\n    return (as === 'Bytes' ? versionedHash : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(versionedHash));\n}\n/**\n * Transforms arbitrary data to {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * ```\n *\n * @example\n * ### Creating Blobs from a String\n *\n * An example of creating Blobs from a string using  {@link ox#Hex.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello world!'))\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Blobs with the `as` option.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef', { as: 'Bytes' })\n * //    ^?\n *\n *\n * ```\n *\n * @param data - The data to convert to {@link ox#Blobs.Blobs}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.Blobs}.\n */\nfunction from(data, options = {}) {\n    const as = options.as ?? (typeof data === 'string' ? 'Hex' : 'Bytes');\n    const data_ = (typeof data === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(data) : data);\n    const size_ = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.size(data_);\n    if (!size_)\n        throw new EmptyBlobError();\n    if (size_ > maxBytesPerTransaction)\n        throw new BlobSizeTooLargeError({\n            maxSize: maxBytesPerTransaction,\n            size: size_,\n        });\n    const blobs = [];\n    let active = true;\n    let position = 0;\n    while (active) {\n        const blob = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_3__.create(new Uint8Array(bytesPerBlob));\n        let size = 0;\n        while (size < fieldElementsPerBlob) {\n            const bytes = data_.slice(position, position + (bytesPerFieldElement - 1));\n            // Push a zero byte so the field element doesn't overflow the BLS modulus.\n            blob.pushByte(0x00);\n            // Push the current segment of data bytes.\n            blob.pushBytes(bytes);\n            // If we detect that the current segment of data bytes is less than 31 bytes,\n            // we can stop processing and push a terminator byte to indicate the end of the blob.\n            if (bytes.length < 31) {\n                blob.pushByte(0x80);\n                active = false;\n                break;\n            }\n            size++;\n            position += 31;\n        }\n        blobs.push(blob);\n    }\n    return (as === 'Bytes'\n        ? blobs.map((x) => x.bytes)\n        : blobs.map((x) => _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(x.bytes)));\n}\n/**\n * Transforms a list of {@link ox#Blobs.BlobSidecars} to their Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param sidecars - The {@link ox#Blobs.BlobSidecars} to transform to Blob Versioned Hashes.\n * @param options - Options.\n * @returns The versioned hashes.\n */\nfunction sidecarsToVersionedHashes(sidecars, options = {}) {\n    const { version } = options;\n    const as = options.as ?? (typeof sidecars[0].blob === 'string' ? 'Hex' : 'Bytes');\n    const hashes = [];\n    for (const { commitment } of sidecars) {\n        hashes.push(commitmentToVersionedHash(commitment, {\n            as,\n            version,\n        }));\n    }\n    return hashes;\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with second argument.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs, 'Bytes')\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform.\n * @param to - The type to transform to.\n * @returns The originating data.\n */\nfunction to(blobs, to) {\n    const to_ = to ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n    const blobs_ = (typeof blobs[0] === 'string'\n        ? blobs.map((x) => _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(x))\n        : blobs);\n    const length = blobs_.reduce((length, blob) => length + blob.length, 0);\n    const data = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_3__.create(new Uint8Array(length));\n    let active = true;\n    for (const blob of blobs_) {\n        const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_3__.create(blob);\n        while (active && cursor.position < blob.length) {\n            // First byte will be a zero 0x00 byte  we can skip.\n            cursor.incrementPosition(1);\n            let consume = 31;\n            if (blob.length - cursor.position < 31)\n                consume = blob.length - cursor.position;\n            for (const _ in Array.from({ length: consume })) {\n                const byte = cursor.readByte();\n                const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);\n                if (isTerminator) {\n                    active = false;\n                    break;\n                }\n                data.pushByte(byte);\n            }\n        }\n    }\n    const trimmedData = data.bytes.slice(0, data.position);\n    return (to_ === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(trimmedData) : trimmedData);\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toHex(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n */\nfunction toHex(blobs) {\n    return to(blobs, 'Hex');\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toBytes(blobs) // [!code focus]\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n */\nfunction toBytes(blobs) {\n    return to(blobs, 'Bytes');\n}\n/**\n * Compute commitments from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, {\n *   as: 'Bytes', // [!code focus]\n *   kzg,\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform to commitments.\n * @param options - Options.\n * @returns The commitments.\n */\nfunction toCommitments(blobs, options) {\n    const { kzg } = options;\n    const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n    const blobs_ = (typeof blobs[0] === 'string'\n        ? blobs.map((x) => _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(x))\n        : blobs);\n    const commitments = [];\n    for (const blob of blobs_)\n        commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));\n    return (as === 'Bytes' ? commitments : commitments.map((x) => _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(x)));\n}\n/**\n * Compute the proofs for a list of {@link ox#Blobs.Blobs} and their commitments.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to compute proofs for.\n * @param options - Options.\n * @returns The Blob proofs.\n */\nfunction toProofs(blobs, options) {\n    const { kzg } = options;\n    const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n    const blobs_ = (typeof blobs[0] === 'string'\n        ? blobs.map((x) => _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(x))\n        : blobs);\n    const commitments = (typeof options.commitments[0] === 'string'\n        ? options.commitments.map((x) => _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(x))\n        : options.commitments);\n    const proofs = [];\n    for (let i = 0; i < blobs_.length; i++) {\n        const blob = blobs_[i];\n        const commitment = commitments[i];\n        proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));\n    }\n    return (as === 'Bytes' ? proofs : proofs.map((x) => _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(x)));\n}\n/**\n * Transforms {@link ox#Blobs.Blobs} into a {@link ox#Blobs.BlobSidecars} array.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * You can also provide your own commitments and proofs if you do not want `toSidecars`\n * to compute them.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg })\n *\n * const sidecars = Blobs.toSidecars(blobs, { commitments, kzg, proofs }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into {@link ox#Blobs.BlobSidecars}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.BlobSidecars}.\n */\nfunction toSidecars(blobs, options) {\n    const { kzg } = options;\n    const commitments = options.commitments ?? toCommitments(blobs, { kzg: kzg });\n    const proofs = options.proofs ??\n        toProofs(blobs, { commitments: commitments, kzg: kzg });\n    const sidecars = [];\n    for (let i = 0; i < blobs.length; i++)\n        sidecars.push({\n            blob: blobs[i],\n            commitment: commitments[i],\n            proof: proofs[i],\n        });\n    return sidecars;\n}\n/**\n * Compute Blob Versioned Hashes from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const versionedHashes = Blobs.toVersionedHashes(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into Blob Versioned Hashes.\n * @param options - Options.\n * @returns The Blob Versioned Hashes.\n */\nfunction toVersionedHashes(blobs, options) {\n    const commitments = toCommitments(blobs, options);\n    return commitmentsToVersionedHashes(commitments, options);\n}\n/** Thrown when the blob size is too large. */\nclass BlobSizeTooLargeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ maxSize, size }) {\n        super('Blob size is too large.', {\n            metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Blobs.BlobSizeTooLargeError'\n        });\n    }\n}\n/** Thrown when the blob is empty. */\nclass EmptyBlobError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Blob data must not be empty.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Blobs.EmptyBlobError'\n        });\n    }\n}\n/** Thrown when the blob versioned hashes are empty. */\nclass EmptyBlobVersionedHashesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Blob versioned hashes must not be empty.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Blobs.EmptyBlobVersionedHashesError'\n        });\n    }\n}\n/** Thrown when the blob versioned hash size is invalid. */\nclass InvalidVersionedHashSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ hash, size, }) {\n        super(`Versioned hash \"${hash}\" size is invalid.`, {\n            metaMessages: ['Expected: 32', `Received: ${size}`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Blobs.InvalidVersionedHashSizeError'\n        });\n    }\n}\n/** Thrown when the blob versioned hash version is invalid. */\nclass InvalidVersionedHashVersionError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ hash, version, }) {\n        super(`Versioned hash \"${hash}\" version is invalid.`, {\n            metaMessages: [\n                `Expected: ${_Kzg_js__WEBPACK_IMPORTED_MODULE_5__.versionedHashVersion}`,\n                `Received: ${version}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Blobs.InvalidVersionedHashVersionError'\n        });\n    }\n}\n//# sourceMappingURL=Blobs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbG9icy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ2U7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrREFBK0Q7QUFDdEUsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFD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d0QsS0FBSztBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTywrQ0FBK0MsaURBQWdCO0FBQ3RFLGtCQUFrQixnQkFBZ0I7QUFDbEMsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQSw2QkFBNkIseURBQXdCLENBQUM7QUFDdEQsNkJBQTZCLFFBQVE7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbG9icy5qcz83NDY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBLemcgZnJvbSAnLi9LemcuanMnO1xuaW1wb3J0ICogYXMgQ3Vyc29yIGZyb20gJy4vaW50ZXJuYWwvY3Vyc29yLmpzJztcbi8qKiBCbG9iIGxpbWl0IHBlciB0cmFuc2FjdGlvbi4gKi9cbmNvbnN0IGJsb2JzUGVyVHJhbnNhY3Rpb24gPSA2O1xuLyoqIFRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gYSBCTFMgc2NhbGFyIGZpZWxkIGVsZW1lbnQuICovXG5leHBvcnQgY29uc3QgYnl0ZXNQZXJGaWVsZEVsZW1lbnQgPSAzMjtcbi8qKiBUaGUgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzIGluIGEgYmxvYi4gKi9cbmV4cG9ydCBjb25zdCBmaWVsZEVsZW1lbnRzUGVyQmxvYiA9IDQwOTY7XG4vKiogVGhlIG51bWJlciBvZiBieXRlcyBpbiBhIGJsb2IuICovXG5leHBvcnQgY29uc3QgYnl0ZXNQZXJCbG9iID0gYnl0ZXNQZXJGaWVsZEVsZW1lbnQgKiBmaWVsZEVsZW1lbnRzUGVyQmxvYjtcbi8qKiBCbG9iIGJ5dGVzIGxpbWl0IHBlciB0cmFuc2FjdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBtYXhCeXRlc1BlclRyYW5zYWN0aW9uID0gYnl0ZXNQZXJCbG9iICogYmxvYnNQZXJUcmFuc2FjdGlvbiAtXG4gICAgLy8gdGVybWluYXRvciBieXRlICgweDgwKS5cbiAgICAxIC1cbiAgICAvLyB6ZXJvIGJ5dGUgKDB4MDApIGFwcGVuZGVkIHRvIGVhY2ggZmllbGQgZWxlbWVudC5cbiAgICAxICogZmllbGRFbGVtZW50c1BlckJsb2IgKiBibG9ic1BlclRyYW5zYWN0aW9uO1xuLyoqXG4gKiBUcmFuc2Zvcm0gYSBsaXN0IG9mIENvbW1pdG1lbnRzIHRvIEJsb2IgVmVyc2lvbmVkIEhhc2hlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMgfSBmcm9tICd2aWVtJ1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGNvbW1pdG1lbnRzID0gQmxvYnMudG9Db21taXRtZW50cyhibG9icywgeyBremcgfSlcbiAqIGNvbnN0IHZlcnNpb25lZEhhc2hlcyA9IEJsb2JzLmNvbW1pdG1lbnRzVG9WZXJzaW9uZWRIYXNoZXMoY29tbWl0bWVudHMpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFsnMHguLi4nLCAnMHguLi4nXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb25maWd1cmluZyBSZXR1cm4gVHlwZVxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGNvbmZpZ3VyZSB0aGUgcmV0dXJuIHR5cGUgZm9yIHRoZSBWZXJzaW9uZWQgSGFzaGVzIHdpdGggdGhlIGBhc2Agb3B0aW9uLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzIH0gZnJvbSAndmllbSdcbiAqIGltcG9ydCB7IGt6ZyB9IGZyb20gJy4va3pnJ1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiBjb25zdCBjb21taXRtZW50cyA9IEJsb2JzLnRvQ29tbWl0bWVudHMoYmxvYnMsIHsga3pnIH0pXG4gKiBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSBCbG9icy5jb21taXRtZW50c1RvVmVyc2lvbmVkSGFzaGVzKGNvbW1pdG1lbnRzLCB7XG4gKiAgIGFzOiAnQnl0ZXMnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KVxuICogLy8gQGxvZzogW1VpbnQ4QXJyYXkgWyAuLi4gXSwgVWludDhBcnJheSBbIC4uLiBdXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJzaW9uaW5nIEhhc2hlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGNvbmZpZ3VyZSB0aGUgdmVyc2lvbiBmb3IgdGhlIFZlcnNpb25lZCBIYXNoZXMgd2l0aCB0aGUgYHZlcnNpb25gIG9wdGlvbi5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9icyB9IGZyb20gJ3ZpZW0nXG4gKiBpbXBvcnQgeyBremcgfSBmcm9tICcuL2t6ZydcbiAqXG4gKiBjb25zdCBibG9icyA9IEJsb2JzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogY29uc3QgY29tbWl0bWVudHMgPSBCbG9icy50b0NvbW1pdG1lbnRzKGJsb2JzLCB7IGt6ZyB9KVxuICogY29uc3QgdmVyc2lvbmVkSGFzaGVzID0gQmxvYnMuY29tbWl0bWVudHNUb1ZlcnNpb25lZEhhc2hlcyhjb21taXRtZW50cywge1xuICogICB2ZXJzaW9uOiAyLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbW1pdG1lbnRzIC0gQSBsaXN0IG9mIGNvbW1pdG1lbnRzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgQSBsaXN0IG9mIEJsb2IgVmVyc2lvbmVkIEhhc2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdG1lbnRzVG9WZXJzaW9uZWRIYXNoZXMoY29tbWl0bWVudHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhcyA9IG9wdGlvbnMuYXMgPz8gKHR5cGVvZiBjb21taXRtZW50c1swXSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycpO1xuICAgIGNvbnN0IGhhc2hlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tbWl0bWVudCBvZiBjb21taXRtZW50cykge1xuICAgICAgICBoYXNoZXMucHVzaChjb21taXRtZW50VG9WZXJzaW9uZWRIYXNoKGNvbW1pdG1lbnQsIHtcbiAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaGVzO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBDb21taXRtZW50IHRvIGl0cyBCbG9iIFZlcnNpb25lZCBIYXNoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9icyB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IFtjb21taXRtZW50XSA9IEJsb2JzLnRvQ29tbWl0bWVudHMoYmxvYnMsIHsga3pnIH0pXG4gKiBjb25zdCB2ZXJzaW9uZWRIYXNoID0gQmxvYnMuY29tbWl0bWVudFRvVmVyc2lvbmVkSGFzaChjb21taXRtZW50KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbmZpZ3VyaW5nIFJldHVybiBUeXBlXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gY29uZmlndXJlIHRoZSByZXR1cm4gdHlwZSBmb3IgdGhlIFZlcnNpb25lZCBIYXNoIHdpdGggdGhlIGBhc2Agb3B0aW9uLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzIH0gZnJvbSAndmllbSdcbiAqIGltcG9ydCB7IGt6ZyB9IGZyb20gJy4va3pnJ1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiBjb25zdCBbY29tbWl0bWVudF0gPSBCbG9icy50b0NvbW1pdG1lbnRzKGJsb2JzLCB7IGt6ZyB9KVxuICogY29uc3QgdmVyc2lvbmVkSGFzaGVzID0gQmxvYnMuY29tbWl0bWVudFRvVmVyc2lvbmVkSGFzaChjb21taXRtZW50LCB7XG4gKiAgIGFzOiAnQnl0ZXMnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KVxuICogLy8gQGxvZzogW1VpbnQ4QXJyYXkgWyAuLi4gXSwgVWludDhBcnJheSBbIC4uLiBdXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJzaW9uaW5nIEhhc2hlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGNvbmZpZ3VyZSB0aGUgdmVyc2lvbiBmb3IgdGhlIFZlcnNpb25lZCBIYXNoIHdpdGggdGhlIGB2ZXJzaW9uYCBvcHRpb24uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMgfSBmcm9tICd2aWVtJ1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IFtjb21taXRtZW50XSA9IEJsb2JzLnRvQ29tbWl0bWVudHMoYmxvYnMsIHsga3pnIH0pXG4gKiBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSBCbG9icy5jb21taXRtZW50VG9WZXJzaW9uZWRIYXNoKGNvbW1pdG1lbnQsIHtcbiAqICAgdmVyc2lvbjogMiwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb21taXRtZW50IC0gVGhlIGNvbW1pdG1lbnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQmxvYiBWZXJzaW9uZWQgSGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdG1lbnRUb1ZlcnNpb25lZEhhc2goY29tbWl0bWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyB2ZXJzaW9uID0gMSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhcyA9IG9wdGlvbnMuYXMgPz8gKHR5cGVvZiBjb21taXRtZW50ID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyk7XG4gICAgY29uc3QgdmVyc2lvbmVkSGFzaCA9IEhhc2guc2hhMjU2KGNvbW1pdG1lbnQsIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgdmVyc2lvbmVkSGFzaC5zZXQoW3ZlcnNpb25dLCAwKTtcbiAgICByZXR1cm4gKGFzID09PSAnQnl0ZXMnID8gdmVyc2lvbmVkSGFzaCA6IEhleC5mcm9tQnl0ZXModmVyc2lvbmVkSGFzaCkpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFyYml0cmFyeSBkYXRhIHRvIHtAbGluayBveCNCbG9icy5CbG9ic30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbG9icyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENyZWF0aW5nIEJsb2JzIGZyb20gYSBTdHJpbmdcbiAqXG4gKiBBbiBleGFtcGxlIG9mIGNyZWF0aW5nIEJsb2JzIGZyb20gYSBzdHJpbmcgdXNpbmcgIHtAbGluayBveCNIZXguKGZyb206ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvYnMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbShIZXguZnJvbVN0cmluZygnSGVsbG8gd29ybGQhJykpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbmZpZ3VyaW5nIFJldHVybiBUeXBlXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gY29uZmlndXJlIHRoZSByZXR1cm4gdHlwZSBmb3IgdGhlIEJsb2JzIHdpdGggdGhlIGBhc2Agb3B0aW9uLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbG9icyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicsIHsgYXM6ICdCeXRlcycgfSlcbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gY29udmVydCB0byB7QGxpbmsgb3gjQmxvYnMuQmxvYnN9LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNCbG9icy5CbG9ic30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFzID0gb3B0aW9ucy5hcyA/PyAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBkYXRhXyA9ICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBCeXRlcy5mcm9tSGV4KGRhdGEpIDogZGF0YSk7XG4gICAgY29uc3Qgc2l6ZV8gPSBCeXRlcy5zaXplKGRhdGFfKTtcbiAgICBpZiAoIXNpemVfKVxuICAgICAgICB0aHJvdyBuZXcgRW1wdHlCbG9iRXJyb3IoKTtcbiAgICBpZiAoc2l6ZV8gPiBtYXhCeXRlc1BlclRyYW5zYWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgQmxvYlNpemVUb29MYXJnZUVycm9yKHtcbiAgICAgICAgICAgIG1heFNpemU6IG1heEJ5dGVzUGVyVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBzaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgYmxvYnMgPSBbXTtcbiAgICBsZXQgYWN0aXZlID0gdHJ1ZTtcbiAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgIHdoaWxlIChhY3RpdmUpIHtcbiAgICAgICAgY29uc3QgYmxvYiA9IEN1cnNvci5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoYnl0ZXNQZXJCbG9iKSk7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCBmaWVsZEVsZW1lbnRzUGVyQmxvYikge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhXy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAoYnl0ZXNQZXJGaWVsZEVsZW1lbnQgLSAxKSk7XG4gICAgICAgICAgICAvLyBQdXNoIGEgemVybyBieXRlIHNvIHRoZSBmaWVsZCBlbGVtZW50IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIEJMUyBtb2R1bHVzLlxuICAgICAgICAgICAgYmxvYi5wdXNoQnl0ZSgweDAwKTtcbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgc2VnbWVudCBvZiBkYXRhIGJ5dGVzLlxuICAgICAgICAgICAgYmxvYi5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgLy8gSWYgd2UgZGV0ZWN0IHRoYXQgdGhlIGN1cnJlbnQgc2VnbWVudCBvZiBkYXRhIGJ5dGVzIGlzIGxlc3MgdGhhbiAzMSBieXRlcyxcbiAgICAgICAgICAgIC8vIHdlIGNhbiBzdG9wIHByb2Nlc3NpbmcgYW5kIHB1c2ggYSB0ZXJtaW5hdG9yIGJ5dGUgdG8gaW5kaWNhdGUgdGhlIGVuZCBvZiB0aGUgYmxvYi5cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPCAzMSkge1xuICAgICAgICAgICAgICAgIGJsb2IucHVzaEJ5dGUoMHg4MCk7XG4gICAgICAgICAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSAzMTtcbiAgICAgICAgfVxuICAgICAgICBibG9icy5wdXNoKGJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gKGFzID09PSAnQnl0ZXMnXG4gICAgICAgID8gYmxvYnMubWFwKCh4KSA9PiB4LmJ5dGVzKVxuICAgICAgICA6IGJsb2JzLm1hcCgoeCkgPT4gSGV4LmZyb21CeXRlcyh4LmJ5dGVzKSkpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgbGlzdCBvZiB7QGxpbmsgb3gjQmxvYnMuQmxvYlNpZGVjYXJzfSB0byB0aGVpciBCbG9iIFZlcnNpb25lZCBIYXNoZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IHNpZGVjYXJzID0gQmxvYnMudG9TaWRlY2FycyhibG9icywgeyBremcgfSlcbiAqIGNvbnN0IHZlcnNpb25lZEhhc2hlcyA9IEJsb2JzLnNpZGVjYXJzVG9WZXJzaW9uZWRIYXNoZXMoc2lkZWNhcnMpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ29uZmlndXJpbmcgUmV0dXJuIFR5cGVcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBjb25maWd1cmUgdGhlIHJldHVybiB0eXBlIGZvciB0aGUgVmVyc2lvbmVkIEhhc2hlcyB3aXRoIHRoZSBgYXNgIG9wdGlvbi5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9icyB9IGZyb20gJ3ZpZW0nXG4gKiBpbXBvcnQgeyBremcgfSBmcm9tICcuL2t6ZydcbiAqXG4gKiBjb25zdCBibG9icyA9IEJsb2JzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogY29uc3Qgc2lkZWNhcnMgPSBCbG9icy50b1NpZGVjYXJzKGJsb2JzLCB7IGt6ZyB9KVxuICogY29uc3QgdmVyc2lvbmVkSGFzaGVzID0gQmxvYnMuc2lkZWNhcnNUb1ZlcnNpb25lZEhhc2hlcyhzaWRlY2Fycywge1xuICogICBhczogJ0J5dGVzJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSlcbiAqIC8vIEBsb2c6IFtVaW50OEFycmF5IFsgLi4uIF0sIFVpbnQ4QXJyYXkgWyAuLi4gXV1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmVyc2lvbmluZyBIYXNoZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBjb25maWd1cmUgdGhlIHZlcnNpb24gZm9yIHRoZSBWZXJzaW9uZWQgSGFzaGVzIHdpdGggdGhlIGB2ZXJzaW9uYCBvcHRpb24uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMgfSBmcm9tICd2aWVtJ1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IHNpZGVjYXJzID0gQmxvYnMudG9TaWRlY2FycyhibG9icywgeyBremcgfSlcbiAqIGNvbnN0IHZlcnNpb25lZEhhc2hlcyA9IEJsb2JzLnNpZGVjYXJzVG9WZXJzaW9uZWRIYXNoZXMoc2lkZWNhcnMsIHtcbiAqICAgdmVyc2lvbjogMiwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWRlY2FycyAtIFRoZSB7QGxpbmsgb3gjQmxvYnMuQmxvYlNpZGVjYXJzfSB0byB0cmFuc2Zvcm0gdG8gQmxvYiBWZXJzaW9uZWQgSGFzaGVzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIHZlcnNpb25lZCBoYXNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWRlY2Fyc1RvVmVyc2lvbmVkSGFzaGVzKHNpZGVjYXJzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHZlcnNpb24gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXMgPSBvcHRpb25zLmFzID8/ICh0eXBlb2Ygc2lkZWNhcnNbMF0uYmxvYiA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycpO1xuICAgIGNvbnN0IGhhc2hlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgeyBjb21taXRtZW50IH0gb2Ygc2lkZWNhcnMpIHtcbiAgICAgICAgaGFzaGVzLnB1c2goY29tbWl0bWVudFRvVmVyc2lvbmVkSGFzaChjb21taXRtZW50LCB7XG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2hlcztcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBPeC1zaGFwZWQge0BsaW5rIG94I0Jsb2JzLkJsb2JzfSBpbnRvIHRoZSBvcmlnaW5hdGluZyBkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvYnMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiBjb25zdCBkYXRhID0gQmxvYnMudG8oYmxvYnMpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweGRlYWRiZWVmJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb25maWd1cmluZyBSZXR1cm4gVHlwZVxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGNvbmZpZ3VyZSB0aGUgcmV0dXJuIHR5cGUgd2l0aCBzZWNvbmQgYXJndW1lbnQuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJsb2JzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGRhdGEgPSBCbG9icy50byhibG9icywgJ0J5dGVzJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWyAxMywgMTc0LCAxOTAsIDIzOSBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYmxvYnMgLSBUaGUge0BsaW5rIG94I0Jsb2JzLkJsb2JzfSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0gdG8gLSBUaGUgdHlwZSB0byB0cmFuc2Zvcm0gdG8uXG4gKiBAcmV0dXJucyBUaGUgb3JpZ2luYXRpbmcgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvKGJsb2JzLCB0bykge1xuICAgIGNvbnN0IHRvXyA9IHRvID8/ICh0eXBlb2YgYmxvYnNbMF0gPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBibG9ic18gPSAodHlwZW9mIGJsb2JzWzBdID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGJsb2JzLm1hcCgoeCkgPT4gQnl0ZXMuZnJvbUhleCh4KSlcbiAgICAgICAgOiBibG9icyk7XG4gICAgY29uc3QgbGVuZ3RoID0gYmxvYnNfLnJlZHVjZSgobGVuZ3RoLCBibG9iKSA9PiBsZW5ndGggKyBibG9iLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgZGF0YSA9IEN1cnNvci5jcmVhdGUobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSk7XG4gICAgbGV0IGFjdGl2ZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCBibG9iIG9mIGJsb2JzXykge1xuICAgICAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJsb2IpO1xuICAgICAgICB3aGlsZSAoYWN0aXZlICYmIGN1cnNvci5wb3NpdGlvbiA8IGJsb2IubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBieXRlIHdpbGwgYmUgYSB6ZXJvIDB4MDAgYnl0ZSDigJMgd2UgY2FuIHNraXAuXG4gICAgICAgICAgICBjdXJzb3IuaW5jcmVtZW50UG9zaXRpb24oMSk7XG4gICAgICAgICAgICBsZXQgY29uc3VtZSA9IDMxO1xuICAgICAgICAgICAgaWYgKGJsb2IubGVuZ3RoIC0gY3Vyc29yLnBvc2l0aW9uIDwgMzEpXG4gICAgICAgICAgICAgICAgY29uc3VtZSA9IGJsb2IubGVuZ3RoIC0gY3Vyc29yLnBvc2l0aW9uO1xuICAgICAgICAgICAgZm9yIChjb25zdCBfIGluIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbnN1bWUgfSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlID0gY3Vyc29yLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNUZXJtaW5hdG9yID0gYnl0ZSA9PT0gMHg4MCAmJiAhY3Vyc29yLmluc3BlY3RCeXRlcyhjdXJzb3IucmVtYWluaW5nKS5pbmNsdWRlcygweDgwKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoQnl0ZShieXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0cmltbWVkRGF0YSA9IGRhdGEuYnl0ZXMuc2xpY2UoMCwgZGF0YS5wb3NpdGlvbik7XG4gICAgcmV0dXJuICh0b18gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyh0cmltbWVkRGF0YSkgOiB0cmltbWVkRGF0YSk7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgT3gtc2hhcGVkIHtAbGluayBveCNCbG9icy5CbG9ic30gaW50byB0aGUgb3JpZ2luYXRpbmcgZGF0YS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJsb2JzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBibG9icyA9IEJsb2JzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogY29uc3QgZGF0YSA9IEJsb2JzLnRvSGV4KGJsb2JzKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHhkZWFkYmVlZidcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoYmxvYnMpIHtcbiAgICByZXR1cm4gdG8oYmxvYnMsICdIZXgnKTtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBPeC1zaGFwZWQge0BsaW5rIG94I0Jsb2JzLkJsb2JzfSBpbnRvIHRoZSBvcmlnaW5hdGluZyBkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQmxvYnMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiBjb25zdCBkYXRhID0gQmxvYnMudG9CeXRlcyhibG9icykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogVWludDhBcnJheSBbIDEzLCAxNzQsIDE5MCwgMjM5IF1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhibG9icykge1xuICAgIHJldHVybiB0byhibG9icywgJ0J5dGVzJyk7XG59XG4vKipcbiAqIENvbXB1dGUgY29tbWl0bWVudHMgZnJvbSBhIGxpc3Qgb2Yge0BsaW5rIG94I0Jsb2JzLkJsb2JzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IGt6ZyB9IGZyb20gJy4va3pnJ1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiBjb25zdCBjb21taXRtZW50cyA9IEJsb2JzLnRvQ29tbWl0bWVudHMoYmxvYnMsIHsga3pnIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ29uZmlndXJpbmcgUmV0dXJuIFR5cGVcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBjb25maWd1cmUgdGhlIHJldHVybiB0eXBlIHdpdGggdGhlIGBhc2Agb3B0aW9uLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBremcgfSBmcm9tICcuL2t6ZydcbiAqXG4gKiBjb25zdCBibG9icyA9IEJsb2JzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogY29uc3QgY29tbWl0bWVudHMgPSBCbG9icy50b0NvbW1pdG1lbnRzKGJsb2JzLCB7XG4gKiAgIGFzOiAnQnl0ZXMnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGt6ZyxcbiAqIH0pXG4gKiAvLyBAbG9nOiBbVWludDhBcnJheSBbIC4uLiBdLCBVaW50OEFycmF5IFsgLi4uIF1dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYmxvYnMgLSBUaGUge0BsaW5rIG94I0Jsb2JzLkJsb2JzfSB0byB0cmFuc2Zvcm0gdG8gY29tbWl0bWVudHMuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgY29tbWl0bWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NvbW1pdG1lbnRzKGJsb2JzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBremcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXMgPSBvcHRpb25zLmFzID8/ICh0eXBlb2YgYmxvYnNbMF0gPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBibG9ic18gPSAodHlwZW9mIGJsb2JzWzBdID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGJsb2JzLm1hcCgoeCkgPT4gQnl0ZXMuZnJvbUhleCh4KSlcbiAgICAgICAgOiBibG9icyk7XG4gICAgY29uc3QgY29tbWl0bWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJsb2Igb2YgYmxvYnNfKVxuICAgICAgICBjb21taXRtZW50cy5wdXNoKFVpbnQ4QXJyYXkuZnJvbShremcuYmxvYlRvS3pnQ29tbWl0bWVudChibG9iKSkpO1xuICAgIHJldHVybiAoYXMgPT09ICdCeXRlcycgPyBjb21taXRtZW50cyA6IGNvbW1pdG1lbnRzLm1hcCgoeCkgPT4gSGV4LmZyb21CeXRlcyh4KSkpO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBwcm9vZnMgZm9yIGEgbGlzdCBvZiB7QGxpbmsgb3gjQmxvYnMuQmxvYnN9IGFuZCB0aGVpciBjb21taXRtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMgfSBmcm9tICd2aWVtJ1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGNvbW1pdG1lbnRzID0gQmxvYnMudG9Db21taXRtZW50cyhibG9icywgeyBremcgfSlcbiAqIGNvbnN0IHByb29mcyA9IEJsb2JzLnRvUHJvb2ZzKGJsb2JzLCB7IGNvbW1pdG1lbnRzLCBremcgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJsb2JzIC0gVGhlIHtAbGluayBveCNCbG9icy5CbG9ic30gdG8gY29tcHV0ZSBwcm9vZnMgZm9yLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIEJsb2IgcHJvb2ZzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9vZnMoYmxvYnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGt6ZyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhcyA9IG9wdGlvbnMuYXMgPz8gKHR5cGVvZiBibG9ic1swXSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycpO1xuICAgIGNvbnN0IGJsb2JzXyA9ICh0eXBlb2YgYmxvYnNbMF0gPT09ICdzdHJpbmcnXG4gICAgICAgID8gYmxvYnMubWFwKCh4KSA9PiBCeXRlcy5mcm9tSGV4KHgpKVxuICAgICAgICA6IGJsb2JzKTtcbiAgICBjb25zdCBjb21taXRtZW50cyA9ICh0eXBlb2Ygb3B0aW9ucy5jb21taXRtZW50c1swXSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBvcHRpb25zLmNvbW1pdG1lbnRzLm1hcCgoeCkgPT4gQnl0ZXMuZnJvbUhleCh4KSlcbiAgICAgICAgOiBvcHRpb25zLmNvbW1pdG1lbnRzKTtcbiAgICBjb25zdCBwcm9vZnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2JzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBibG9iID0gYmxvYnNfW2ldO1xuICAgICAgICBjb25zdCBjb21taXRtZW50ID0gY29tbWl0bWVudHNbaV07XG4gICAgICAgIHByb29mcy5wdXNoKFVpbnQ4QXJyYXkuZnJvbShremcuY29tcHV0ZUJsb2JLemdQcm9vZihibG9iLCBjb21taXRtZW50KSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGFzID09PSAnQnl0ZXMnID8gcHJvb2ZzIDogcHJvb2ZzLm1hcCgoeCkgPT4gSGV4LmZyb21CeXRlcyh4KSkpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHtAbGluayBveCNCbG9icy5CbG9ic30gaW50byBhIHtAbGluayBveCNCbG9icy5CbG9iU2lkZWNhcnN9IGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9icyB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IHNpZGVjYXJzID0gQmxvYnMudG9TaWRlY2FycyhibG9icywgeyBremcgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIHlvdXIgb3duIGNvbW1pdG1lbnRzIGFuZCBwcm9vZnMgaWYgeW91IGRvIG5vdCB3YW50IGB0b1NpZGVjYXJzYFxuICogdG8gY29tcHV0ZSB0aGVtLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBremcgfSBmcm9tICcuL2t6ZydcbiAqXG4gKiBjb25zdCBibG9icyA9IEJsb2JzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogY29uc3QgY29tbWl0bWVudHMgPSBCbG9icy50b0NvbW1pdG1lbnRzKGJsb2JzLCB7IGt6ZyB9KVxuICogY29uc3QgcHJvb2ZzID0gQmxvYnMudG9Qcm9vZnMoYmxvYnMsIHsgY29tbWl0bWVudHMsIGt6ZyB9KVxuICpcbiAqIGNvbnN0IHNpZGVjYXJzID0gQmxvYnMudG9TaWRlY2FycyhibG9icywgeyBjb21taXRtZW50cywga3pnLCBwcm9vZnMgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJsb2JzIC0gVGhlIHtAbGluayBveCNCbG9icy5CbG9ic30gdG8gdHJhbnNmb3JtIGludG8ge0BsaW5rIG94I0Jsb2JzLkJsb2JTaWRlY2Fyc30uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0Jsb2JzLkJsb2JTaWRlY2Fyc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZGVjYXJzKGJsb2JzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBremcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY29tbWl0bWVudHMgPSBvcHRpb25zLmNvbW1pdG1lbnRzID8/IHRvQ29tbWl0bWVudHMoYmxvYnMsIHsga3pnOiBremcgfSk7XG4gICAgY29uc3QgcHJvb2ZzID0gb3B0aW9ucy5wcm9vZnMgPz9cbiAgICAgICAgdG9Qcm9vZnMoYmxvYnMsIHsgY29tbWl0bWVudHM6IGNvbW1pdG1lbnRzLCBremc6IGt6ZyB9KTtcbiAgICBjb25zdCBzaWRlY2FycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvYnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHNpZGVjYXJzLnB1c2goe1xuICAgICAgICAgICAgYmxvYjogYmxvYnNbaV0sXG4gICAgICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50c1tpXSxcbiAgICAgICAgICAgIHByb29mOiBwcm9vZnNbaV0sXG4gICAgICAgIH0pO1xuICAgIHJldHVybiBzaWRlY2Fycztcbn1cbi8qKlxuICogQ29tcHV0ZSBCbG9iIFZlcnNpb25lZCBIYXNoZXMgZnJvbSBhIGxpc3Qgb2Yge0BsaW5rIG94I0Jsb2JzLkJsb2JzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IGt6ZyB9IGZyb20gJy4va3pnJ1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSBCbG9icy50b1ZlcnNpb25lZEhhc2hlcyhibG9icywgeyBremcgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJsb2JzIC0gVGhlIHtAbGluayBveCNCbG9icy5CbG9ic30gdG8gdHJhbnNmb3JtIGludG8gQmxvYiBWZXJzaW9uZWQgSGFzaGVzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIEJsb2IgVmVyc2lvbmVkIEhhc2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVmVyc2lvbmVkSGFzaGVzKGJsb2JzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWl0bWVudHMgPSB0b0NvbW1pdG1lbnRzKGJsb2JzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29tbWl0bWVudHNUb1ZlcnNpb25lZEhhc2hlcyhjb21taXRtZW50cywgb3B0aW9ucyk7XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIGJsb2Igc2l6ZSBpcyB0b28gbGFyZ2UuICovXG5leHBvcnQgY2xhc3MgQmxvYlNpemVUb29MYXJnZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXhTaXplLCBzaXplIH0pIHtcbiAgICAgICAgc3VwZXIoJ0Jsb2Igc2l6ZSBpcyB0b28gbGFyZ2UuJywge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbYE1heDogJHttYXhTaXplfSBieXRlc2AsIGBHaXZlbjogJHtzaXplfSBieXRlc2BdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0Jsb2JzLkJsb2JTaXplVG9vTGFyZ2VFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBibG9iIGlzIGVtcHR5LiAqL1xuZXhwb3J0IGNsYXNzIEVtcHR5QmxvYkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdCbG9iIGRhdGEgbXVzdCBub3QgYmUgZW1wdHkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCbG9icy5FbXB0eUJsb2JFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBibG9iIHZlcnNpb25lZCBoYXNoZXMgYXJlIGVtcHR5LiAqL1xuZXhwb3J0IGNsYXNzIEVtcHR5QmxvYlZlcnNpb25lZEhhc2hlc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdCbG9iIHZlcnNpb25lZCBoYXNoZXMgbXVzdCBub3QgYmUgZW1wdHkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCbG9icy5FbXB0eUJsb2JWZXJzaW9uZWRIYXNoZXNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBibG9iIHZlcnNpb25lZCBoYXNoIHNpemUgaXMgaW52YWxpZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVmVyc2lvbmVkSGFzaFNpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgaGFzaCwgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgVmVyc2lvbmVkIGhhc2ggXCIke2hhc2h9XCIgc2l6ZSBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydFeHBlY3RlZDogMzInLCBgUmVjZWl2ZWQ6ICR7c2l6ZX1gXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCbG9icy5JbnZhbGlkVmVyc2lvbmVkSGFzaFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBibG9iIHZlcnNpb25lZCBoYXNoIHZlcnNpb24gaXMgaW52YWxpZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVmVyc2lvbmVkSGFzaFZlcnNpb25FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgaGFzaCwgdmVyc2lvbiwgfSkge1xuICAgICAgICBzdXBlcihgVmVyc2lvbmVkIGhhc2ggXCIke2hhc2h9XCIgdmVyc2lvbiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBFeHBlY3RlZDogJHtLemcudmVyc2lvbmVkSGFzaFZlcnNpb259YCxcbiAgICAgICAgICAgICAgICBgUmVjZWl2ZWQ6ICR7dmVyc2lvbn1gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCbG9icy5JbnZhbGlkVmVyc2lvbmVkSGFzaFZlcnNpb25FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmxvYnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Blobs.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Block.js":
/*!*********************************************!*\
  !*** ../node_modules/ox/_esm/core/Block.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Transaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transaction.js */ \"../node_modules/ox/_esm/core/Transaction.js\");\n/* harmony import */ var _Withdrawal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Withdrawal.js */ \"../node_modules/ox/_esm/core/Withdrawal.js\");\n\n\n\n/**\n * Converts a {@link ox#Block.Block} to an {@link ox#Block.Rpc}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Block } from 'ox'\n *\n * const block = Block.toRpc({\n *   // ...\n *   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n *   number: 19868020n,\n *   size: 520n\n *   timestamp: 1662222222n,\n *   // ...\n * })\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: '0xec6fc6',\n * // @log:   size: '0x208',\n * // @log:   timestamp: '0x63198f6f',\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * @param block - The Block to convert.\n * @returns An RPC Block.\n */\nfunction toRpc(block, _options = {}) {\n    const transactions = block.transactions.map((transaction) => {\n        if (typeof transaction === 'string')\n            return transaction;\n        return _Transaction_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(transaction);\n    });\n    return {\n        baseFeePerGas: typeof block.baseFeePerGas === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.baseFeePerGas)\n            : undefined,\n        blobGasUsed: typeof block.blobGasUsed === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.blobGasUsed)\n            : undefined,\n        excessBlobGas: typeof block.excessBlobGas === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.excessBlobGas)\n            : undefined,\n        extraData: block.extraData,\n        difficulty: typeof block.difficulty === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.difficulty)\n            : undefined,\n        gasLimit: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.gasLimit),\n        gasUsed: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.gasUsed),\n        hash: block.hash,\n        logsBloom: block.logsBloom,\n        miner: block.miner,\n        mixHash: block.mixHash,\n        nonce: block.nonce,\n        number: (typeof block.number === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.number)\n            : null),\n        parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n        parentHash: block.parentHash,\n        receiptsRoot: block.receiptsRoot,\n        sealFields: block.sealFields,\n        sha3Uncles: block.sha3Uncles,\n        size: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.size),\n        stateRoot: block.stateRoot,\n        timestamp: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.timestamp),\n        totalDifficulty: typeof block.totalDifficulty === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(block.totalDifficulty)\n            : undefined,\n        transactions,\n        transactionsRoot: block.transactionsRoot,\n        uncles: block.uncles,\n        withdrawals: block.withdrawals?.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_2__.toRpc),\n        withdrawalsRoot: block.withdrawalsRoot,\n    };\n}\n/**\n * Converts a {@link ox#Block.Rpc} to an {@link ox#Block.Block}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Block } from 'ox'\n *\n * const block = Block.fromRpc({\n *   // ...\n *   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n *   number: '0xec6fc6',\n *   size: '0x208',\n *   timestamp: '0x63198f6f',\n *   // ...\n * })\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: 19868020n,\n * // @log:   size: 520n,\n * // @log:   timestamp: 1662222222n,\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `Block.fromRpc` to fetch a block from the network and convert it to an {@link ox#Block.Block}.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Block } from 'ox'\n *\n * const block = await window.ethereum!\n *   .request({\n *     method: 'eth_getBlockByNumber',\n *     params: ['latest', false],\n *   })\n *   .then(Block.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: 19868020n,\n * // @log:   size: 520n,\n * // @log:   timestamp: 1662222222n,\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param block - The RPC block to convert.\n * @returns An instantiated {@link ox#Block.Block}.\n */\nfunction fromRpc(block, _options = {}) {\n    if (!block)\n        return null;\n    const transactions = block.transactions.map((transaction) => {\n        if (typeof transaction === 'string')\n            return transaction;\n        return _Transaction_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(transaction);\n    });\n    return {\n        ...block,\n        baseFeePerGas: block.baseFeePerGas\n            ? BigInt(block.baseFeePerGas)\n            : undefined,\n        blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n        difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n        excessBlobGas: block.excessBlobGas\n            ? BigInt(block.excessBlobGas)\n            : undefined,\n        gasLimit: BigInt(block.gasLimit ?? 0n),\n        gasUsed: BigInt(block.gasUsed ?? 0n),\n        number: block.number ? BigInt(block.number) : null,\n        size: BigInt(block.size ?? 0n),\n        stateRoot: block.stateRoot,\n        timestamp: BigInt(block.timestamp ?? 0n),\n        totalDifficulty: BigInt(block.totalDifficulty ?? 0n),\n        transactions,\n        withdrawals: block.withdrawals?.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_2__.fromRpc),\n    };\n}\n//# sourceMappingURL=Block.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbG9jay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnQztBQUNnQjtBQUNGO0FBQzlDO0FBQ0EsZUFBZSxzQkFBc0IsT0FBTyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFpQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsK0NBQWM7QUFDNUI7QUFDQTtBQUNBLGNBQWMsK0NBQWM7QUFDNUI7QUFDQTtBQUNBLGNBQWMsK0NBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQ0FBYztBQUM1QjtBQUNBLGtCQUFrQiwrQ0FBYztBQUNoQyxpQkFBaUIsK0NBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQ0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUFjO0FBQzVCO0FBQ0EsbUJBQW1CLCtDQUFjO0FBQ2pDO0FBQ0EsY0FBYywrQ0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpREFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQixPQUFPLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILHFCQUFxQjtBQUN4STtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDTyxxQ0FBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQW1CO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbURBQWtCO0FBQzlEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jsb2NrLmpzP2ZkYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFRyYW5zYWN0aW9uIGZyb20gJy4vVHJhbnNhY3Rpb24uanMnO1xuaW1wb3J0ICogYXMgV2l0aGRyYXdhbCBmcm9tICcuL1dpdGhkcmF3YWwuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNCbG9jay5CbG9ja30gdG8gYW4ge0BsaW5rIG94I0Jsb2NrLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2NrIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYmxvY2sgPSBCbG9jay50b1JwYyh7XG4gKiAgIC8vIC4uLlxuICogICBoYXNoOiAnMHhlYmMzNjQ0ODA0ZTQwNDBjMGE3NGM1YTViYmJjNmI0NmE3MWE1ZDQwMTBmZTBjOTJlYmIyZmRmNGE0M2VhNWRkJyxcbiAqICAgbnVtYmVyOiAxOTg2ODAyMG4sXG4gKiAgIHNpemU6IDUyMG5cbiAqICAgdGltZXN0YW1wOiAxNjYyMjIyMjIybixcbiAqICAgLy8gLi4uXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICAvLyAuLi5cbiAqIC8vIEBsb2c6ICAgaGFzaDogJzB4ZWJjMzY0NDgwNGU0MDQwYzBhNzRjNWE1YmJiYzZiNDZhNzFhNWQ0MDEwZmUwYzkyZWJiMmZkZjRhNDNlYTVkZCcsXG4gKiAvLyBAbG9nOiAgIG51bWJlcjogJzB4ZWM2ZmM2JyxcbiAqIC8vIEBsb2c6ICAgc2l6ZTogJzB4MjA4JyxcbiAqIC8vIEBsb2c6ICAgdGltZXN0YW1wOiAnMHg2MzE5OGY2ZicsXG4gKiAvLyBAbG9nOiAgIC8vIC4uLlxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJsb2NrIC0gVGhlIEJsb2NrIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMgQmxvY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhibG9jaywgX29wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24udG9ScGModHJhbnNhY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VGZWVQZXJHYXM6IHR5cGVvZiBibG9jay5iYXNlRmVlUGVyR2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyBIZXguZnJvbU51bWJlcihibG9jay5iYXNlRmVlUGVyR2FzKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGJsb2JHYXNVc2VkOiB0eXBlb2YgYmxvY2suYmxvYkdhc1VzZWQgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IEhleC5mcm9tTnVtYmVyKGJsb2NrLmJsb2JHYXNVc2VkKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHR5cGVvZiBibG9jay5leGNlc3NCbG9iR2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyBIZXguZnJvbU51bWJlcihibG9jay5leGNlc3NCbG9iR2FzKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxuICAgICAgICBkaWZmaWN1bHR5OiB0eXBlb2YgYmxvY2suZGlmZmljdWx0eSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8gSGV4LmZyb21OdW1iZXIoYmxvY2suZGlmZmljdWx0eSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBnYXNMaW1pdDogSGV4LmZyb21OdW1iZXIoYmxvY2suZ2FzTGltaXQpLFxuICAgICAgICBnYXNVc2VkOiBIZXguZnJvbU51bWJlcihibG9jay5nYXNVc2VkKSxcbiAgICAgICAgaGFzaDogYmxvY2suaGFzaCxcbiAgICAgICAgbG9nc0Jsb29tOiBibG9jay5sb2dzQmxvb20sXG4gICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcbiAgICAgICAgbWl4SGFzaDogYmxvY2subWl4SGFzaCxcbiAgICAgICAgbm9uY2U6IGJsb2NrLm5vbmNlLFxuICAgICAgICBudW1iZXI6ICh0eXBlb2YgYmxvY2subnVtYmVyID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyBIZXguZnJvbU51bWJlcihibG9jay5udW1iZXIpXG4gICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGJsb2NrLnBhcmVudEJlYWNvbkJsb2NrUm9vdCxcbiAgICAgICAgcGFyZW50SGFzaDogYmxvY2sucGFyZW50SGFzaCxcbiAgICAgICAgcmVjZWlwdHNSb290OiBibG9jay5yZWNlaXB0c1Jvb3QsXG4gICAgICAgIHNlYWxGaWVsZHM6IGJsb2NrLnNlYWxGaWVsZHMsXG4gICAgICAgIHNoYTNVbmNsZXM6IGJsb2NrLnNoYTNVbmNsZXMsXG4gICAgICAgIHNpemU6IEhleC5mcm9tTnVtYmVyKGJsb2NrLnNpemUpLFxuICAgICAgICBzdGF0ZVJvb3Q6IGJsb2NrLnN0YXRlUm9vdCxcbiAgICAgICAgdGltZXN0YW1wOiBIZXguZnJvbU51bWJlcihibG9jay50aW1lc3RhbXApLFxuICAgICAgICB0b3RhbERpZmZpY3VsdHk6IHR5cGVvZiBibG9jay50b3RhbERpZmZpY3VsdHkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IEhleC5mcm9tTnVtYmVyKGJsb2NrLnRvdGFsRGlmZmljdWx0eSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgIHRyYW5zYWN0aW9uc1Jvb3Q6IGJsb2NrLnRyYW5zYWN0aW9uc1Jvb3QsXG4gICAgICAgIHVuY2xlczogYmxvY2sudW5jbGVzLFxuICAgICAgICB3aXRoZHJhd2FsczogYmxvY2sud2l0aGRyYXdhbHM/Lm1hcChXaXRoZHJhd2FsLnRvUnBjKSxcbiAgICAgICAgd2l0aGRyYXdhbHNSb290OiBibG9jay53aXRoZHJhd2Fsc1Jvb3QsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjQmxvY2suUnBjfSB0byBhbiB7QGxpbmsgb3gjQmxvY2suQmxvY2t9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9jayB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrID0gQmxvY2suZnJvbVJwYyh7XG4gKiAgIC8vIC4uLlxuICogICBoYXNoOiAnMHhlYmMzNjQ0ODA0ZTQwNDBjMGE3NGM1YTViYmJjNmI0NmE3MWE1ZDQwMTBmZTBjOTJlYmIyZmRmNGE0M2VhNWRkJyxcbiAqICAgbnVtYmVyOiAnMHhlYzZmYzYnLFxuICogICBzaXplOiAnMHgyMDgnLFxuICogICB0aW1lc3RhbXA6ICcweDYzMTk4ZjZmJyxcbiAqICAgLy8gLi4uXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICAvLyAuLi5cbiAqIC8vIEBsb2c6ICAgaGFzaDogJzB4ZWJjMzY0NDgwNGU0MDQwYzBhNzRjNWE1YmJiYzZiNDZhNzFhNWQ0MDEwZmUwYzkyZWJiMmZkZjRhNDNlYTVkZCcsXG4gKiAvLyBAbG9nOiAgIG51bWJlcjogMTk4NjgwMjBuLFxuICogLy8gQGxvZzogICBzaXplOiA1MjBuLFxuICogLy8gQGxvZzogICB0aW1lc3RhbXA6IDE2NjIyMjIyMjJuLFxuICogLy8gQGxvZzogICAvLyAuLi5cbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRW5kLXRvLWVuZFxuICpcbiAqIEJlbG93IGlzIGFuIGVuZC10by1lbmQgZXhhbXBsZSBvZiB1c2luZyBgQmxvY2suZnJvbVJwY2AgdG8gZmV0Y2ggYSBibG9jayBmcm9tIHRoZSBuZXR3b3JrIGFuZCBjb252ZXJ0IGl0IHRvIGFuIHtAbGluayBveCNCbG9jay5CbG9ja30uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCAnb3gvd2luZG93J1xuICogaW1wb3J0IHsgQmxvY2sgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBibG9jayA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSFcbiAqICAgLnJlcXVlc3Qoe1xuICogICAgIG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAqICAgICBwYXJhbXM6IFsnbGF0ZXN0JywgZmFsc2VdLFxuICogICB9KVxuICogICAudGhlbihCbG9jay5mcm9tUnBjKSAvLyBbIWNvZGUgaGxdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIC8vIC4uLlxuICogLy8gQGxvZzogICBoYXNoOiAnMHhlYmMzNjQ0ODA0ZTQwNDBjMGE3NGM1YTViYmJjNmI0NmE3MWE1ZDQwMTBmZTBjOTJlYmIyZmRmNGE0M2VhNWRkJyxcbiAqIC8vIEBsb2c6ICAgbnVtYmVyOiAxOTg2ODAyMG4sXG4gKiAvLyBAbG9nOiAgIHNpemU6IDUyMG4sXG4gKiAvLyBAbG9nOiAgIHRpbWVzdGFtcDogMTY2MjIyMjIyMm4sXG4gKiAvLyBAbG9nOiAgIC8vIC4uLlxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogOjo6bm90ZVxuICpcbiAqIEZvciBzaW1wbGljaXR5LCB0aGUgYWJvdmUgZXhhbXBsZSB1c2VzIGB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdGAsIGJ1dCB5b3UgY2FuIHVzZSBhbnlcbiAqIHR5cGUgb2YgSlNPTi1SUEMgaW50ZXJmYWNlLlxuICpcbiAqIDo6OlxuICpcbiAqIEBwYXJhbSBibG9jayAtIFRoZSBSUEMgYmxvY2sgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjQmxvY2suQmxvY2t9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhibG9jaywgX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghYmxvY2spXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbVJwYyh0cmFuc2FjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgIGJhc2VGZWVQZXJHYXM6IGJsb2NrLmJhc2VGZWVQZXJHYXNcbiAgICAgICAgICAgID8gQmlnSW50KGJsb2NrLmJhc2VGZWVQZXJHYXMpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgYmxvYkdhc1VzZWQ6IGJsb2NrLmJsb2JHYXNVc2VkID8gQmlnSW50KGJsb2NrLmJsb2JHYXNVc2VkKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZGlmZmljdWx0eTogYmxvY2suZGlmZmljdWx0eSA/IEJpZ0ludChibG9jay5kaWZmaWN1bHR5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZXhjZXNzQmxvYkdhczogYmxvY2suZXhjZXNzQmxvYkdhc1xuICAgICAgICAgICAgPyBCaWdJbnQoYmxvY2suZXhjZXNzQmxvYkdhcylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBnYXNMaW1pdDogQmlnSW50KGJsb2NrLmdhc0xpbWl0ID8/IDBuKSxcbiAgICAgICAgZ2FzVXNlZDogQmlnSW50KGJsb2NrLmdhc1VzZWQgPz8gMG4pLFxuICAgICAgICBudW1iZXI6IGJsb2NrLm51bWJlciA/IEJpZ0ludChibG9jay5udW1iZXIpIDogbnVsbCxcbiAgICAgICAgc2l6ZTogQmlnSW50KGJsb2NrLnNpemUgPz8gMG4pLFxuICAgICAgICBzdGF0ZVJvb3Q6IGJsb2NrLnN0YXRlUm9vdCxcbiAgICAgICAgdGltZXN0YW1wOiBCaWdJbnQoYmxvY2sudGltZXN0YW1wID8/IDBuKSxcbiAgICAgICAgdG90YWxEaWZmaWN1bHR5OiBCaWdJbnQoYmxvY2sudG90YWxEaWZmaWN1bHR5ID8/IDBuKSxcbiAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICB3aXRoZHJhd2FsczogYmxvY2sud2l0aGRyYXdhbHM/Lm1hcChXaXRoZHJhd2FsLmZyb21ScGMpLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbG9jay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Block.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/BlockOverrides.js":
/*!******************************************************!*\
  !*** ../node_modules/ox/_esm/core/BlockOverrides.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Withdrawal.js */ \"../node_modules/ox/_esm/core/Withdrawal.js\");\n\n\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */\nfunction fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc),\n        }),\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */\nfunction toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbG9ja092ZXJyaWRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdDO0FBQ2M7QUFDOUM7QUFDQSxnQkFBZ0IsNkJBQTZCLE9BQU8sdUNBQXVDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyREFBMkQsbURBQWtCO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDLE9BQU8sNEJBQTRCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkJBQTJCLCtDQUFjO0FBQ3pDLFNBQVM7QUFDVDtBQUNBLHlCQUF5QiwrQ0FBYztBQUN2QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQiwrQ0FBYztBQUNwQyxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsK0NBQWM7QUFDbEMsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLCtDQUFjO0FBQ3RDLFNBQVM7QUFDVDtBQUNBLGtCQUFrQiwrQ0FBYztBQUNoQyxTQUFTO0FBQ1Q7QUFDQSx3REFBd0QsaURBQWdCO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbG9ja092ZXJyaWRlcy5qcz85Y2EwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBXaXRoZHJhd2FsIGZyb20gJy4vV2l0aGRyYXdhbC5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5ScGN9IHRvIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbG9ja092ZXJyaWRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrT3ZlcnJpZGVzID0gQmxvY2tPdmVycmlkZXMuZnJvbVJwYyh7XG4gKiAgIGJhc2VGZWVQZXJHYXM6ICcweDEnLFxuICogICBibG9iQmFzZUZlZTogJzB4MicsXG4gKiAgIGZlZVJlY2lwaWVudDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGdhc0xpbWl0OiAnMHg0JyxcbiAqICAgbnVtYmVyOiAnMHg1JyxcbiAqICAgcHJldlJhbmRhbzogJzB4NicsXG4gKiAgIHRpbWU6ICcweDEyMzQ1Njc4OTAnLFxuICogICB3aXRoZHJhd2FsczogW1xuICogICAgIHtcbiAqICAgICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgICAgYW1vdW50OiAnMHgxJyxcbiAqICAgICAgIGluZGV4OiAnMHgwJyxcbiAqICAgICAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBycGNCbG9ja092ZXJyaWRlcyAtIFRoZSBSUEMgYmxvY2sgb3ZlcnJpZGVzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLkJsb2NrT3ZlcnJpZGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMocnBjQmxvY2tPdmVycmlkZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyAmJiB7XG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUgJiYge1xuICAgICAgICAgICAgYmxvYkJhc2VGZWU6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ICYmIHtcbiAgICAgICAgICAgIGZlZVJlY2lwaWVudDogcnBjQmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50LFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0ICYmIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuZ2FzTGltaXQpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLm51bWJlciAmJiB7XG4gICAgICAgICAgICBudW1iZXI6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5udW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8gJiYge1xuICAgICAgICAgICAgcHJldlJhbmRhbzogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8pLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLnRpbWUgJiYge1xuICAgICAgICAgICAgdGltZTogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLnRpbWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzICYmIHtcbiAgICAgICAgICAgIHdpdGhkcmF3YWxzOiBycGNCbG9ja092ZXJyaWRlcy53aXRoZHJhd2Fscy5tYXAoV2l0aGRyYXdhbC5mcm9tUnBjKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLkJsb2NrT3ZlcnJpZGVzfSB0byBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJsb2NrT3ZlcnJpZGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYmxvY2tPdmVycmlkZXMgPSBCbG9ja092ZXJyaWRlcy50b1JwYyh7XG4gKiAgIGJhc2VGZWVQZXJHYXM6IDFuLFxuICogICBibG9iQmFzZUZlZTogMm4sXG4gKiAgIGZlZVJlY2lwaWVudDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGdhc0xpbWl0OiA0bixcbiAqICAgbnVtYmVyOiA1bixcbiAqICAgcHJldlJhbmRhbzogNm4sXG4gKiAgIHRpbWU6IDc4MTg3NDkzNTIwbixcbiAqICAgd2l0aGRyYXdhbHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICAgIGFtb3VudDogMW4sXG4gKiAgICAgICBpbmRleDogMCxcbiAqICAgICAgIHZhbGlkYXRvckluZGV4OiAxLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJsb2NrT3ZlcnJpZGVzIC0gVGhlIGJsb2NrIG92ZXJyaWRlcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gaW5zdGFudGlhdGVkIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5ScGN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoYmxvY2tPdmVycmlkZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgYmxvYkJhc2VGZWU6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ID09PSAnc3RyaW5nJyAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IGJsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5nYXNMaW1pdCksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLm51bWJlciA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5udW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMudGltZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgdGltZTogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMudGltZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMgJiYge1xuICAgICAgICAgICAgd2l0aGRyYXdhbHM6IGJsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzLm1hcChXaXRoZHJhd2FsLnRvUnBjKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2NrT3ZlcnJpZGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/BlockOverrides.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Bloom.js":
/*!*********************************************!*\
  !*** ../node_modules/ox/_esm/core/Bloom.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * Checks if an input is matched in the bloom filter.\n *\n * @example\n * ```ts twoslash\n * import { Bloom } from 'ox'\n *\n * Bloom.contains(\n *   '0x00000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002020000000000000000000000000000000000000000000008000000001000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n *   '0xef2d6d194084c2de36e0dabfce45d046b37d1106',\n * )\n * // @log: true\n * ```\n *\n * @param bloom - Bloom filter value.\n * @param input - Input to check.\n * @returns Whether the input is matched in the bloom filter.\n */\nfunction contains(bloom, input) {\n    const filter = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(bloom);\n    const hash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(input, { as: 'Bytes' });\n    for (const i of [0, 2, 4]) {\n        const bit = (hash[i + 1] + (hash[i] << 8)) & 0x7ff;\n        if ((filter[256 - 1 - Math.floor(bit / 8)] & (1 << (bit % 8))) === 0)\n            return false;\n    }\n    return true;\n}\n/**\n * Checks if a string is a valid bloom filter value.\n *\n * @example\n * ```ts twoslash\n * import { Bloom } from 'ox'\n *\n * Bloom.validate('0x')\n * // @log: false\n *\n * Bloom.validate('0x00000000000000000000008000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000044000200000000000000000002000000000000000000000040000000000000000000000000000020000000000000000000800000000000800000000000800000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000808002000000000400000000000000000000000060000000000000000000000000000000000000000000000100000000000002000000')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid bloom filter.\n */\nfunction validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 256;\n}\n//# sourceMappingURL=Bloom.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbG9vbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUNGO0FBQ0Y7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1CQUFtQiw4Q0FBYTtBQUNoQyxpQkFBaUIsK0NBQWMsVUFBVSxhQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDZDQUFZLFdBQVcseUNBQVE7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jsb29tLmpzPzdlZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDaGVja3MgaWYgYW4gaW5wdXQgaXMgbWF0Y2hlZCBpbiB0aGUgYmxvb20gZmlsdGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvb20gfSBmcm9tICdveCdcbiAqXG4gKiBCbG9vbS5jb250YWlucyhcbiAqICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAnMHhlZjJkNmQxOTQwODRjMmRlMzZlMGRhYmZjZTQ1ZDA0NmIzN2QxMTA2JyxcbiAqIClcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBibG9vbSAtIEJsb29tIGZpbHRlciB2YWx1ZS5cbiAqIEBwYXJhbSBpbnB1dCAtIElucHV0IHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgaW5wdXQgaXMgbWF0Y2hlZCBpbiB0aGUgYmxvb20gZmlsdGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnMoYmxvb20sIGlucHV0KSB7XG4gICAgY29uc3QgZmlsdGVyID0gQnl0ZXMuZnJvbUhleChibG9vbSk7XG4gICAgY29uc3QgaGFzaCA9IEhhc2gua2VjY2FrMjU2KGlucHV0LCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgIGZvciAoY29uc3QgaSBvZiBbMCwgMiwgNF0pIHtcbiAgICAgICAgY29uc3QgYml0ID0gKGhhc2hbaSArIDFdICsgKGhhc2hbaV0gPDwgOCkpICYgMHg3ZmY7XG4gICAgICAgIGlmICgoZmlsdGVyWzI1NiAtIDEgLSBNYXRoLmZsb29yKGJpdCAvIDgpXSAmICgxIDw8IChiaXQgJSA4KSkpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgYmxvb20gZmlsdGVyIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvb20gfSBmcm9tICdveCdcbiAqXG4gKiBCbG9vbS52YWxpZGF0ZSgnMHgnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqXG4gKiBCbG9vbS52YWxpZGF0ZSgnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0NDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwODAwMjAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMjAwMDAwMCcpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgYmxvb20gZmlsdGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiBIZXguc2l6ZSh2YWx1ZSkgPT09IDI1Njtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb29tLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Bloom.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Bls.js":
/*!*******************************************!*\
  !*** ../node_modules/ox/_esm/core/Bls.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aggregate: () => (/* binding */ aggregate),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/bls12-381 */ \"../node_modules/ox/node_modules/@noble/curves/esm/bls12-381.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/** Re-export of noble/curves BLS12-381 utilities. */\nconst noble = _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381;\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction aggregate(points) {\n    const group = typeof points[0]?.x === 'bigint' ? _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1 : _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2;\n    const point = points.reduce((acc, point) => acc.add(new group.ProjectivePoint(point.x, point.y, point.z)), group.ProjectivePoint.ZERO);\n    return {\n        x: point.px,\n        y: point.py,\n        z: point.pz,\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getPublicKey(options) {\n    const { privateKey, size = 'short-key:long-sig' } = options;\n    const group = size === 'short-key:long-sig' ? _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1 : _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2;\n    const { px, py, pz } = group.ProjectivePoint.fromPrivateKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2));\n    return { x: px, y: py, z: pz };\n}\n/**\n * Generates a random BLS12-381 private key.\n *\n * @example\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nfunction randomPrivateKey(options = {}) {\n    const { as = 'Hex' } = options;\n    const bytes = _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.utils.randomPrivateKey();\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction sign(options) {\n    const { payload, privateKey, suite, size = 'short-key:long-sig' } = options;\n    const payloadGroup = size === 'short-key:long-sig' ? _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2 : _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1;\n    const payloadPoint = payloadGroup.hashToCurve(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.from(payload), suite ? { DST: _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(suite) } : undefined);\n    const privateKeyGroup = size === 'short-key:long-sig' ? _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1 : _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2;\n    const signature = payloadPoint.multiply(privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)));\n    return {\n        x: signature.px,\n        y: signature.py,\n        z: signature.pz,\n    };\n}\n/**\n * Verifies a payload was signed by the provided public key(s).\n *\n * @example\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKey = Bls.randomPrivateKey()\n *\n * const publicKey = Bls.getPublicKey({ privateKey })\n * const signature = Bls.sign({ payload, privateKey })\n *\n * const verified = Bls.verify({ // [!code focus]\n *   payload, // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify Aggregated Signatures\n *\n * We can also pass a public key and signature that was aggregated with {@link ox#Bls.(aggregate:function)} to `Bls.verify`.\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKeys = Array.from({ length: 100 }, () => Bls.randomPrivateKey())\n *\n * const publicKeys = privateKeys.map((privateKey) =>\n *   Bls.getPublicKey({ privateKey }),\n * )\n * const signatures = privateKeys.map((privateKey) =>\n *   Bls.sign({ payload, privateKey }),\n * )\n *\n * const publicKey = Bls.aggregate(publicKeys) // [!code focus]\n * const signature = Bls.aggregate(signatures) // [!code focus]\n *\n * const valid = Bls.verify({ payload, publicKey, signature }) // [!code focus]\n * ```\n *\n * @param options - Verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nfunction verify(options) {\n    const { payload, suite } = options;\n    const publicKey = options.publicKey;\n    const signature = options.signature;\n    const isShortSig = typeof signature.x === 'bigint';\n    const group = isShortSig ? _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1 : _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2;\n    const payloadPoint = group.hashToCurve(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.from(payload), suite ? { DST: _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(suite) } : undefined);\n    const shortSigPairing = () => _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.pairingBatch([\n        {\n            g1: payloadPoint,\n            g2: new _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z),\n        },\n        {\n            g1: new _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1.ProjectivePoint(signature.x, signature.y, signature.z),\n            g2: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2.ProjectivePoint.BASE.negate(),\n        },\n    ]);\n    const longSigPairing = () => _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.pairingBatch([\n        {\n            g1: new _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z).negate(),\n            g2: payloadPoint,\n        },\n        {\n            g1: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1.ProjectivePoint.BASE,\n            g2: new _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2.ProjectivePoint(signature.x, signature.y, signature.z),\n        },\n    ]);\n    return _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.fields.Fp12.eql(isShortSig ? shortSigPairing() : longSigPairing(), _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.fields.Fp12.ONE);\n}\n//# sourceMappingURL=Bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTJEO0FBQ3ZCO0FBQ0o7QUFDaEM7QUFDTyxjQUFjLDhEQUFHO0FBQ3hCO0FBQ087QUFDUCxxREFBcUQsOERBQUcsTUFBTSw4REFBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDBDQUEwQztBQUN0RCxrREFBa0QsOERBQUcsTUFBTSw4REFBRztBQUM5RCxZQUFZLGFBQWEsdUNBQXVDLHlDQUFRO0FBQ3hFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxhQUFhO0FBQ3pCLGtCQUFrQiw4REFBRztBQUNyQjtBQUNBLGVBQWUsOENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDBEQUEwRDtBQUN0RSx5REFBeUQsOERBQUcsTUFBTSw4REFBRztBQUNyRSxrREFBa0QsMkNBQVUscUJBQXFCLEtBQUssaURBQWdCLFVBQVU7QUFDaEgsNERBQTRELDhEQUFHLE1BQU0sOERBQUc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRCxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLG1DQUFtQztBQUM1RztBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhEQUFHLE1BQU0sOERBQUc7QUFDM0MsMkNBQTJDLDJDQUFVLHFCQUFxQixLQUFLLGlEQUFnQixVQUFVO0FBQ3pHLGtDQUFrQyw4REFBRztBQUNyQztBQUNBO0FBQ0Esb0JBQW9CLDhEQUFHO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBLG9CQUFvQiw4REFBRztBQUN2QixnQkFBZ0IsOERBQUc7QUFDbkIsU0FBUztBQUNUO0FBQ0EsaUNBQWlDLDhEQUFHO0FBQ3BDO0FBQ0Esb0JBQW9CLDhEQUFHO0FBQ3ZCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0JBQWdCLDhEQUFHO0FBQ25CLG9CQUFvQiw4REFBRztBQUN2QixTQUFTO0FBQ1Q7QUFDQSxXQUFXLDhEQUFHLG9FQUFvRSw4REFBRztBQUNyRjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmxzLmpzP2FiYjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmxzMTJfMzgxIGFzIGJscyB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYmxzMTItMzgxJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKiBSZS1leHBvcnQgb2Ygbm9ibGUvY3VydmVzIEJMUzEyLTM4MSB1dGlsaXRpZXMuICovXG5leHBvcnQgY29uc3Qgbm9ibGUgPSBibHM7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZShwb2ludHMpIHtcbiAgICBjb25zdCBncm91cCA9IHR5cGVvZiBwb2ludHNbMF0/LnggPT09ICdiaWdpbnQnID8gYmxzLkcxIDogYmxzLkcyO1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzLnJlZHVjZSgoYWNjLCBwb2ludCkgPT4gYWNjLmFkZChuZXcgZ3JvdXAuUHJvamVjdGl2ZVBvaW50KHBvaW50LngsIHBvaW50LnksIHBvaW50LnopKSwgZ3JvdXAuUHJvamVjdGl2ZVBvaW50LlpFUk8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50LnB4LFxuICAgICAgICB5OiBwb2ludC5weSxcbiAgICAgICAgejogcG9pbnQucHosXG4gICAgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHByaXZhdGVLZXksIHNpemUgPSAnc2hvcnQta2V5Omxvbmctc2lnJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBncm91cCA9IHNpemUgPT09ICdzaG9ydC1rZXk6bG9uZy1zaWcnID8gYmxzLkcxIDogYmxzLkcyO1xuICAgIGNvbnN0IHsgcHgsIHB5LCBweiB9ID0gZ3JvdXAuUHJvamVjdGl2ZVBvaW50LmZyb21Qcml2YXRlS2V5KEhleC5mcm9tKHByaXZhdGVLZXkpLnNsaWNlKDIpKTtcbiAgICByZXR1cm4geyB4OiBweCwgeTogcHksIHo6IHB6IH07XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBCTFMxMi0zODEgcHJpdmF0ZSBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbHMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gQmxzLnJhbmRvbVByaXZhdGVLZXkoKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tUHJpdmF0ZUtleShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBibHMudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ24ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGF5bG9hZCwgcHJpdmF0ZUtleSwgc3VpdGUsIHNpemUgPSAnc2hvcnQta2V5Omxvbmctc2lnJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwYXlsb2FkR3JvdXAgPSBzaXplID09PSAnc2hvcnQta2V5Omxvbmctc2lnJyA/IGJscy5HMiA6IGJscy5HMTtcbiAgICBjb25zdCBwYXlsb2FkUG9pbnQgPSBwYXlsb2FkR3JvdXAuaGFzaFRvQ3VydmUoQnl0ZXMuZnJvbShwYXlsb2FkKSwgc3VpdGUgPyB7IERTVDogQnl0ZXMuZnJvbVN0cmluZyhzdWl0ZSkgfSA6IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcHJpdmF0ZUtleUdyb3VwID0gc2l6ZSA9PT0gJ3Nob3J0LWtleTpsb25nLXNpZycgPyBibHMuRzEgOiBibHMuRzI7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gcGF5bG9hZFBvaW50Lm11bHRpcGx5KHByaXZhdGVLZXlHcm91cC5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkuc2xpY2UoMikpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBzaWduYXR1cmUucHgsXG4gICAgICAgIHk6IHNpZ25hdHVyZS5weSxcbiAgICAgICAgejogc2lnbmF0dXJlLnB6LFxuICAgIH07XG59XG4vKipcbiAqIFZlcmlmaWVzIGEgcGF5bG9hZCB3YXMgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBwdWJsaWMga2V5KHMpLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJscywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IEhleC5yYW5kb20oMzIpXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gQmxzLnJhbmRvbVByaXZhdGVLZXkoKVxuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IEJscy5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBzaWduYXR1cmUgPSBCbHMuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IEJscy52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHVibGljS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJpZnkgQWdncmVnYXRlZCBTaWduYXR1cmVzXG4gKlxuICogV2UgY2FuIGFsc28gcGFzcyBhIHB1YmxpYyBrZXkgYW5kIHNpZ25hdHVyZSB0aGF0IHdhcyBhZ2dyZWdhdGVkIHdpdGgge0BsaW5rIG94I0Jscy4oYWdncmVnYXRlOmZ1bmN0aW9uKX0gdG8gYEJscy52ZXJpZnlgLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbHMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBIZXgucmFuZG9tKDMyKVxuICogY29uc3QgcHJpdmF0ZUtleXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKCkgPT4gQmxzLnJhbmRvbVByaXZhdGVLZXkoKSlcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXlzID0gcHJpdmF0ZUtleXMubWFwKChwcml2YXRlS2V5KSA9PlxuICogICBCbHMuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KSxcbiAqIClcbiAqIGNvbnN0IHNpZ25hdHVyZXMgPSBwcml2YXRlS2V5cy5tYXAoKHByaXZhdGVLZXkpID0+XG4gKiAgIEJscy5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleSB9KSxcbiAqIClcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBCbHMuYWdncmVnYXRlKHB1YmxpY0tleXMpIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHNpZ25hdHVyZSA9IEJscy5hZ2dyZWdhdGUoc2lnbmF0dXJlcykgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHZhbGlkID0gQmxzLnZlcmlmeSh7IHBheWxvYWQsIHB1YmxpY0tleSwgc2lnbmF0dXJlIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVmVyaWZpY2F0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwYXlsb2FkIHdhcyBzaWduZWQgYnkgdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGF5bG9hZCwgc3VpdGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcHVibGljS2V5ID0gb3B0aW9ucy5wdWJsaWNLZXk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gb3B0aW9ucy5zaWduYXR1cmU7XG4gICAgY29uc3QgaXNTaG9ydFNpZyA9IHR5cGVvZiBzaWduYXR1cmUueCA9PT0gJ2JpZ2ludCc7XG4gICAgY29uc3QgZ3JvdXAgPSBpc1Nob3J0U2lnID8gYmxzLkcxIDogYmxzLkcyO1xuICAgIGNvbnN0IHBheWxvYWRQb2ludCA9IGdyb3VwLmhhc2hUb0N1cnZlKEJ5dGVzLmZyb20ocGF5bG9hZCksIHN1aXRlID8geyBEU1Q6IEJ5dGVzLmZyb21TdHJpbmcoc3VpdGUpIH0gOiB1bmRlZmluZWQpO1xuICAgIGNvbnN0IHNob3J0U2lnUGFpcmluZyA9ICgpID0+IGJscy5wYWlyaW5nQmF0Y2goW1xuICAgICAgICB7XG4gICAgICAgICAgICBnMTogcGF5bG9hZFBvaW50LFxuICAgICAgICAgICAgZzI6IG5ldyBibHMuRzIuUHJvamVjdGl2ZVBvaW50KHB1YmxpY0tleS54LCBwdWJsaWNLZXkueSwgcHVibGljS2V5LnopLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBnMTogbmV3IGJscy5HMS5Qcm9qZWN0aXZlUG9pbnQoc2lnbmF0dXJlLngsIHNpZ25hdHVyZS55LCBzaWduYXR1cmUueiksXG4gICAgICAgICAgICBnMjogYmxzLkcyLlByb2plY3RpdmVQb2ludC5CQVNFLm5lZ2F0ZSgpLFxuICAgICAgICB9LFxuICAgIF0pO1xuICAgIGNvbnN0IGxvbmdTaWdQYWlyaW5nID0gKCkgPT4gYmxzLnBhaXJpbmdCYXRjaChbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGcxOiBuZXcgYmxzLkcxLlByb2plY3RpdmVQb2ludChwdWJsaWNLZXkueCwgcHVibGljS2V5LnksIHB1YmxpY0tleS56KS5uZWdhdGUoKSxcbiAgICAgICAgICAgIGcyOiBwYXlsb2FkUG9pbnQsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGcxOiBibHMuRzEuUHJvamVjdGl2ZVBvaW50LkJBU0UsXG4gICAgICAgICAgICBnMjogbmV3IGJscy5HMi5Qcm9qZWN0aXZlUG9pbnQoc2lnbmF0dXJlLngsIHNpZ25hdHVyZS55LCBzaWduYXR1cmUueiksXG4gICAgICAgIH0sXG4gICAgXSk7XG4gICAgcmV0dXJuIGJscy5maWVsZHMuRnAxMi5lcWwoaXNTaG9ydFNpZyA/IHNob3J0U2lnUGFpcmluZygpIDogbG9uZ1NpZ1BhaXJpbmcoKSwgYmxzLmZpZWxkcy5GcDEyLk9ORSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Bls.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/BlsPoint.js":
/*!************************************************!*\
  !*** ../node_modules/ox/_esm/core/BlsPoint.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/bls12-381 */ \"../node_modules/ox/node_modules/@noble/curves/esm/bls12-381.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n/**\n * Converts a BLS point to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ### Public Key to Bytes\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n * const publicKeyBytes = BlsPoint.toBytes(publicKey)\n * // @log: Uint8Array [172, 175, 255, ...]\n * ```\n *\n * @example\n * ### Signature to Bytes\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const signature = Bls.sign({ payload: '0x...', privateKey: '0x...' })\n * const signatureBytes = BlsPoint.toBytes(signature)\n * // @log: Uint8Array [172, 175, 255, ...]\n * ```\n *\n * @param point - The BLS point to convert.\n * @returns The bytes representation of the BLS point.\n */\nfunction toBytes(point) {\n    const group = typeof point.z === 'bigint' ? _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1 : _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2;\n    return new group.ProjectivePoint(point.x, point.y, point.z).toRawBytes();\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction toHex(point) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(toBytes(point));\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction fromBytes(bytes) {\n    const group = bytes.length === 48 ? _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G1 : _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_0__.bls12_381.G2;\n    const point = group.ProjectivePoint.fromHex(bytes);\n    return {\n        x: point.px,\n        y: point.py,\n        z: point.pz,\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction fromHex(hex, group) {\n    return fromBytes(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBytes(hex), group);\n}\n//# sourceMappingURL=BlsPoint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbHNQb2ludC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkQ7QUFDM0I7QUFDaEM7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxnQ0FBZ0MsdUNBQXVDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnREFBZ0QsOERBQUcsTUFBTSw4REFBRztBQUM1RDtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNPO0FBQ1Asd0NBQXdDLDhEQUFHLE1BQU0sOERBQUc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUJBQXFCLDRDQUFXO0FBQ2hDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbHNQb2ludC5qcz8xZjZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJsczEyXzM4MSBhcyBibHMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2JsczEyLTM4MSc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhIEJMUyBwb2ludCB0byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgUHVibGljIEtleSB0byBCeXRlc1xuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJscywgQmxzUG9pbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBCbHMuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBCbHNQb2ludC50b0J5dGVzKHB1YmxpY0tleSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzE3MiwgMTc1LCAyNTUsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2lnbmF0dXJlIHRvIEJ5dGVzXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxzLCBCbHNQb2ludCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IEJscy5zaWduKHsgcGF5bG9hZDogJzB4Li4uJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogY29uc3Qgc2lnbmF0dXJlQnl0ZXMgPSBCbHNQb2ludC50b0J5dGVzKHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzE3MiwgMTc1LCAyNTUsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwb2ludCAtIFRoZSBCTFMgcG9pbnQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQkxTIHBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhwb2ludCkge1xuICAgIGNvbnN0IGdyb3VwID0gdHlwZW9mIHBvaW50LnogPT09ICdiaWdpbnQnID8gYmxzLkcxIDogYmxzLkcyO1xuICAgIHJldHVybiBuZXcgZ3JvdXAuUHJvamVjdGl2ZVBvaW50KHBvaW50LngsIHBvaW50LnksIHBvaW50LnopLnRvUmF3Qnl0ZXMoKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgocG9pbnQpIHtcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyh0b0J5dGVzKHBvaW50KSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcykge1xuICAgIGNvbnN0IGdyb3VwID0gYnl0ZXMubGVuZ3RoID09PSA0OCA/IGJscy5HMSA6IGJscy5HMjtcbiAgICBjb25zdCBwb2ludCA9IGdyb3VwLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KGJ5dGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb2ludC5weCxcbiAgICAgICAgeTogcG9pbnQucHksXG4gICAgICAgIHo6IHBvaW50LnB6LFxuICAgIH07XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoaGV4LCBncm91cCkge1xuICAgIHJldHVybiBmcm9tQnl0ZXMoSGV4LnRvQnl0ZXMoaGV4KSwgZ3JvdXApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmxzUG9pbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/BlsPoint.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Bytes.js":
/*!*********************************************!*\
  !*** ../node_modules/ox/_esm/core/Bytes.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"../node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"../node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hex.js */ \"../node_modules/ox/_esm/core/internal/hex.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nfunction isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nfunction size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nclass InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nclass InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLGlEQUFnQjtBQUNqRSxrQkFBa0IseUJBQXlCO0FBQzNDLGlCQUFpQiw2QkFBNkIsRUFBRTtBQUNoRDtBQUNBLDRCQUE0QixVQUFVLEtBQUssOEJBQThCLFdBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CeXRlcy5qcz9hMDhmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9ieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9oZXggZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuY29uc3QgZGVjb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8qKlxuICogQXNzZXJ0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEJ5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYFVpbnQ4QXJyYXlgLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAoISgnQllURVNfUEVSX0VMRU1FTlQnIGluIHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSAxIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdVaW50OEFycmF5JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLmNvbmNhdChcbiAqICAgQnl0ZXMuZnJvbShbMV0pLFxuICogICBCeXRlcy5mcm9tKFs2OV0pLFxuICogICBCeXRlcy5mcm9tKFs0MjAsIDY5XSksXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsgMSwgNjksIDQyMCwgNjkgXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIENvbmNhdGVuYXRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBmcm9tIGEgYFVpbnQ4QXJyYXlgLCBhIGhleCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHVuc2lnbmVkIDgtYml0IGludGVnZXJzLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEJ5dGVzLmZyb21Cb29sZWFuYFxuICpcbiAqIC0gYEJ5dGVzLmZyb21TdHJpbmdgXG4gKlxuICogLSBgQnl0ZXMuZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbShbMjU1LCAxMjQsIDUsIDRdKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIyMiwgMTczLCAxOTAsIDIzOV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgIHJldHVybiBmcm9tQXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VycyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBCb29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgaGV4ID0gdmFsdWU7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfaGV4LmFzc2VydFNpemUodmFsdWUsIHNpemUpO1xuICAgICAgICBoZXggPSBIZXgucGFkUmlnaHQodmFsdWUsIHNpemUpO1xuICAgIH1cbiAgICBsZXQgaGV4U3RyaW5nID0gaGV4LnNsaWNlKDIpO1xuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMilcbiAgICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhleFN0cmluZy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGogPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBuaWJibGVMZWZ0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgY29uc3QgbmliYmxlUmlnaHQgPSBpbnRlcm5hbC5jaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBpZiAobmliYmxlTGVmdCA9PT0gdW5kZWZpbmVkIHx8IG5pYmJsZVJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJ5dGUgc2VxdWVuY2UgKFwiJHtoZXhTdHJpbmdbaiAtIDJdfSR7aGV4U3RyaW5nW2ogLSAxXX1cIiBpbiBcIiR7aGV4U3RyaW5nfVwiKS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1tpbmRleF0gPSBuaWJibGVMZWZ0ICogMTYgKyBuaWJibGVSaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21OdW1iZXIoNDIwKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMTY0XSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbU51bWJlcig0MjAsIHsgc2l6ZTogNCB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMSwgMTY0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBFbmNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmcm9tSGV4KGhleCk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gd29ybGQhJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyB3b3JsZCEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5pc0VxdWFsKEJ5dGVzLmZyb20oWzFdKSwgQnl0ZXMuZnJvbShbMV0pKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEJ5dGVzLmlzRXF1YWwoQnl0ZXMuZnJvbShbMV0pLCBCeXRlcy5mcm9tKFsyXSkpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzQSAtIEZpcnN0IHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcGFyYW0gYnl0ZXNCIC0gU2Vjb25kIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB2YWx1ZXMgYXJlIGVxdWFsLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoYnl0ZXNBLCBieXRlc0IpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhieXRlc0EsIGJ5dGVzQik7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tKFsxXSksIDQpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAwLCAxXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBTaXplIHRvIHBhZCB0aGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0by5cbiAqIEByZXR1cm5zIFBhZGRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHRoZSByaWdodCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZFJpZ2h0KEJ5dGVzLmZyb20oWzFdKSwgNClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFNpemUgdG8gcGFkIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvLlxuICogQHJldHVybnMgUGFkZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAncmlnaHQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJ5dGVzID0gQnl0ZXMucmFuZG9tKDMyKVxuICogLy8gQGxvZzogVWludDhBcnJheShbLi4uIHgzMl0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIC0gTGVuZ3RoIG9mIHRoZSByYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBnZW5lcmF0ZS5cbiAqIEByZXR1cm5zIFJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKGxlbmd0aCkge1xuICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGxlbmd0aCkpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5zaXplKEJ5dGVzLmZyb20oWzEsIDIsIDMsIDRdKSlcbiAqIC8vIEBsb2c6IDRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBTaXplIG9mIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG59XG4vKipcbiAqIFJldHVybnMgYSBzZWN0aW9uIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBnaXZlbiBhIHN0YXJ0L2VuZCBieXRlcyBvZmZzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNsaWNlKFxuICogICBCeXRlcy5mcm9tKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XSksXG4gKiAgIDEsXG4gKiAgIDQsXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsyLCAzLCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHBhcmFtIHN0YXJ0IC0gU3RhcnQgb2Zmc2V0LlxuICogQHBhcmFtIGVuZCAtIEVuZCBvZmZzZXQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNsaWNlIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBTbGljZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IHZhbHVlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBiaWdpbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQmlnSW50KEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRGVjb2RlZCBiaWdpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBIZXgudG9CaWdJbnQoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFsxXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1MZWZ0KGJ5dGVzXyk7XG4gICAgfVxuICAgIGlmIChieXRlc18ubGVuZ3RoID4gMSB8fCBieXRlc19bMF0gPiAxKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yKGJ5dGVzXyk7XG4gICAgcmV0dXJuIEJvb2xlYW4oYnl0ZXNfWzBdKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9IZXgoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvTnVtYmVyKEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b051bWJlcihoZXgsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMudG9TdHJpbmcoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzXyA9IGJ5dGVzO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlc18sIHNpemUpO1xuICAgICAgICBieXRlc18gPSB0cmltUmlnaHQoYnl0ZXNfKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ5dGVzXyk7XG59XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRyaW1MZWZ0KEJ5dGVzLmZyb20oWzAsIDAsIDAsIDAsIDEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFRyaW1tZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG4vKipcbiAqIFRyaW1zIHRyYWlsaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50cmltUmlnaHQoQnl0ZXMuZnJvbShbMSwgMiwgMywgMCwgMCwgMCwgMF0pKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgVHJpbW1lZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnZhbGlkYXRlKCcweCcpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICpcbiAqIEJ5dGVzLnZhbGlkYXRlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIGJ5dGVzIHZhbHVlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFs1XSkpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcjogQnl0ZXMgdmFsdWUgYFs1XWAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5cbiAqIC8vIEBlcnJvcjogVGhlIGJ5dGVzIGFycmF5IG11c3QgY29udGFpbiBhIHNpbmdsZSBieXRlIG9mIGVpdGhlciBhIGAwYCBvciBgMWAgdmFsdWUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGBCeXRlcyB2YWx1ZSBcXGAke2J5dGVzfVxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb20oJ2ZvbycpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcjogVmFsdWUgYGZvb2Agb2YgdHlwZSBgc3RyaW5nYCBpcyBhbiBpbnZhbGlkIEJ5dGVzIHZhbHVlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0J5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYEJ5dGVzYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzaXplIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnLCB7IHNpemU6IDggfSlcbiAqIC8vIEBlcnJvcjogQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3I6IFNpemUgY2Fubm90IGV4Y2VlZCBgOGAgYnl0ZXMuIEdpdmVuIHNpemU6IGAxMmAgYnl0ZXMuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgc2xpY2Ugb2Zmc2V0IGlzIG91dC1vZi1ib3VuZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNsaWNlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSwgNClcbiAqIC8vIEBlcnJvcjogQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yOiBTbGljZSBzdGFydGluZyBhdCBvZmZzZXQgYDRgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IGAzYCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0LCBwb3NpdGlvbiwgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2xpY2UgJHtwb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICdzdGFydGluZycgOiAnZW5kaW5nJ30gYXQgb2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBcXGAke3NpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHRoZSBwYWRkaW5nIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZExlZnQoQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJyksIDgpXG4gKiAvLyBAZXJyb3I6IFtCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I6IEJ5dGVzIHNpemUgKGAxMmApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChgOGApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemUsIHRhcmdldFNpemUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9IHNpemUgKFxcYCR7c2l6ZX1cXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXGAke3RhcmdldFNpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Caches.js":
/*!**********************************************!*\
  !*** ../node_modules/ox/_esm/core/Caches.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   clear: () => (/* binding */ clear)\n/* harmony export */ });\n/* harmony import */ var _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/lru.js */ \"../node_modules/ox/_esm/core/internal/lru.js\");\n\nconst caches = {\n    checksum: /*#__PURE__*/ new _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__.LruMap(8192),\n};\nconst checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nfunction clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9DYWNoZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJDO0FBQzNDO0FBQ0EsZ0NBQWdDLG9EQUFNO0FBQ3RDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9DYWNoZXMuanM/YWRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMcnVNYXAgfSBmcm9tICcuL2ludGVybmFsL2xydS5qcyc7XG5jb25zdCBjYWNoZXMgPSB7XG4gICAgY2hlY2tzdW06IC8qI19fUFVSRV9fKi8gbmV3IExydU1hcCg4MTkyKSxcbn07XG5leHBvcnQgY29uc3QgY2hlY2tzdW0gPSBjYWNoZXMuY2hlY2tzdW07XG4vKipcbiAqIENsZWFycyBhbGwgZ2xvYmFsIGNhY2hlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENhY2hlcyB9IGZyb20gJ294J1xuICogQ2FjaGVzLmNsZWFyKClcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiBPYmplY3QudmFsdWVzKGNhY2hlcykpXG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Caches.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/ContractAddress.js":
/*!*******************************************************!*\
  !*** ../node_modules/ox/_esm/core/ContractAddress.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromCreate: () => (/* binding */ fromCreate),\n/* harmony export */   fromCreate2: () => (/* binding */ fromCreate2)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"../node_modules/ox/_esm/core/Rlp.js\");\n\n\n\n\n\n/**\n * Computes Contract Address generated by the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) or [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ### CREATE\n *\n * Computes via the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @example\n * ### CREATE2\n *\n * Computes via the [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate2:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options.\n * @returns Contract Address.\n */\nfunction from(options) {\n    if (options.salt)\n        return fromCreate2(options);\n    return fromCreate(options);\n}\n/**\n * Computes contract address via [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n *\n * ContractAddress.fromCreate({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nfunction fromCreate(options) {\n    const from = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(_Address_js__WEBPACK_IMPORTED_MODULE_1__.from(options.from));\n    let nonce = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(options.nonce);\n    if (nonce[0] === 0)\n        nonce = new Uint8Array([]);\n    return _Address_js__WEBPACK_IMPORTED_MODULE_1__.from(`0x${_Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(_Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromBytes([from, nonce], { as: 'Hex' })).slice(26)}`);\n}\n/**\n * Computes contract address via [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n *\n * ContractAddress.fromCreate2({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nfunction fromCreate2(options) {\n    const from = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(_Address_js__WEBPACK_IMPORTED_MODULE_1__.from(options.from));\n    const salt = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.padLeft(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.validate(options.salt) ? options.salt : _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(options.salt), 32);\n    const bytecodeHash = (() => {\n        if ('bytecodeHash' in options) {\n            if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.validate(options.bytecodeHash))\n                return options.bytecodeHash;\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(options.bytecodeHash);\n        }\n        return _Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(options.bytecode, { as: 'Bytes' });\n    })();\n    return _Address_js__WEBPACK_IMPORTED_MODULE_1__.from(_Hex_js__WEBPACK_IMPORTED_MODULE_4__.slice(_Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.concat(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex('0xff'), from, salt, bytecodeHash), { as: 'Hex' }), 12));\n}\n//# sourceMappingURL=ContractAddress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Db250cmFjdEFkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBd0M7QUFDSjtBQUNGO0FBQ0Y7QUFDQTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SkFBeUosK0NBQStDO0FBQ3hNO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGdEQUFnRDtBQUM5STtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQiw4Q0FBYSxDQUFDLDZDQUFZO0FBQzNDLGdCQUFnQixpREFBZ0I7QUFDaEM7QUFDQTtBQUNBLFdBQVcsNkNBQVksTUFBTSwrQ0FBYyxDQUFDLDhDQUFhLGtCQUFrQixXQUFXLGFBQWE7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQiw4Q0FBYSxDQUFDLDZDQUFZO0FBQzNDLGlCQUFpQiw4Q0FBYSxDQUFDLCtDQUFjLGdDQUFnQyw4Q0FBYTtBQUMxRjtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCO0FBQ0EsbUJBQW1CLDhDQUFhO0FBQ2hDO0FBQ0EsZUFBZSwrQ0FBYyxxQkFBcUIsYUFBYTtBQUMvRCxLQUFLO0FBQ0wsV0FBVyw2Q0FBWSxDQUFDLDBDQUFTLENBQUMsK0NBQWMsQ0FBQyw2Q0FBWSxDQUFDLDhDQUFhLHVDQUF1QyxXQUFXO0FBQzdIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Db250cmFjdEFkZHJlc3MuanM/MGQ0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBSbHAgZnJvbSAnLi9SbHAuanMnO1xuLyoqXG4gKiBDb21wdXRlcyBDb250cmFjdCBBZGRyZXNzIGdlbmVyYXRlZCBieSB0aGUgW0NSRUFURV0oaHR0cHM6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNjg5NDMvY3JlYXRlLW9wY29kZS13aGF0LWRvZXMtaXQtcmVhbGx5LWRvLzY4OTQ1IzY4OTQ1KSBvciBbQ1JFQVRFMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMDE0KSBvcGNvZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDUkVBVEVcbiAqXG4gKiBDb21wdXRlcyB2aWEgdGhlIFtDUkVBVEVdKGh0dHBzOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzY4OTQzL2NyZWF0ZS1vcGNvZGUtd2hhdC1kb2VzLWl0LXJlYWxseS1kby82ODk0NSM2ODk0NSkgb3Bjb2RlLiBTaG9ydGhhbmQgZm9yIHtAbGluayBveCNDb250cmFjdEFkZHJlc3MuKGZyb21DcmVhdGU6ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQ29udHJhY3RBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKiBDb250cmFjdEFkZHJlc3MuZnJvbSh7XG4gKiAgIGZyb206ICcweDFhMWUwMjFhMzAyYzIzNzQ1M2QzZDQ1YzdiODJiMTljZWViN2UyZTYnLFxuICogICBub25jZTogMG4sXG4gKiB9KVxuICogLy8gQGxvZzogJzB4RkJBMzkxMkNhMDRkZDQ1OGM4NDNlMkVFMDg5NjdmQzA0ZjM1NzljMidcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ1JFQVRFMlxuICpcbiAqIENvbXB1dGVzIHZpYSB0aGUgW0NSRUFURTJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTAxNCkgb3Bjb2RlLiBTaG9ydGhhbmQgZm9yIHtAbGluayBveCNDb250cmFjdEFkZHJlc3MuKGZyb21DcmVhdGUyOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IENvbnRyYWN0QWRkcmVzcywgSGV4IH0gZnJvbSAnb3gnXG4gKiBDb250cmFjdEFkZHJlc3MuZnJvbSh7XG4gKiAgIGZyb206ICcweDFhMWUwMjFhMzAyYzIzNzQ1M2QzZDQ1YzdiODJiMTljZWViN2UyZTYnLFxuICogICBieXRlY29kZTogJzB4NjM5NDE5OGRmMTYwMDA1MjYxMDNmZjYwMjA2MDA0NjAxYzMzNWFmYTYwNDA1MTYwNjBmMycsXG4gKiAgIHNhbHQ6IEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpLFxuICogfSlcbiAqIC8vIEBsb2c6ICcweDU5ZmJCNTkzQUJlMjdDYjE5M2I2ZWU1QzVEQzdiYmRlMzEyMjkwYUInXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBDb250cmFjdCBBZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuc2FsdClcbiAgICAgICAgcmV0dXJuIGZyb21DcmVhdGUyKG9wdGlvbnMpO1xuICAgIHJldHVybiBmcm9tQ3JlYXRlKG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDb21wdXRlcyBjb250cmFjdCBhZGRyZXNzIHZpYSBbQ1JFQVRFXShodHRwczovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy82ODk0My9jcmVhdGUtb3Bjb2RlLXdoYXQtZG9lcy1pdC1yZWFsbHktZG8vNjg5NDUjNjg5NDUpIG9wY29kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IENvbnRyYWN0QWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIENvbnRyYWN0QWRkcmVzcy5mcm9tQ3JlYXRlKHtcbiAqICAgZnJvbTogJzB4MWExZTAyMWEzMDJjMjM3NDUzZDNkNDVjN2I4MmIxOWNlZWI3ZTJlNicsXG4gKiAgIG5vbmNlOiAwbixcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHhGQkEzOTEyQ2EwNGRkNDU4Yzg0M2UyRUUwODk2N2ZDMDRmMzU3OWMyJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciByZXRyaWV2aW5nIGFkZHJlc3MuXG4gKiBAcmV0dXJucyBDb250cmFjdCBBZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNyZWF0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgZnJvbSA9IEJ5dGVzLmZyb21IZXgoQWRkcmVzcy5mcm9tKG9wdGlvbnMuZnJvbSkpO1xuICAgIGxldCBub25jZSA9IEJ5dGVzLmZyb21OdW1iZXIob3B0aW9ucy5ub25jZSk7XG4gICAgaWYgKG5vbmNlWzBdID09PSAwKVxuICAgICAgICBub25jZSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICByZXR1cm4gQWRkcmVzcy5mcm9tKGAweCR7SGFzaC5rZWNjYWsyNTYoUmxwLmZyb21CeXRlcyhbZnJvbSwgbm9uY2VdLCB7IGFzOiAnSGV4JyB9KSkuc2xpY2UoMjYpfWApO1xufVxuLyoqXG4gKiBDb21wdXRlcyBjb250cmFjdCBhZGRyZXNzIHZpYSBbQ1JFQVRFMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMDE0KSBvcGNvZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBDb250cmFjdEFkZHJlc3MsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIENvbnRyYWN0QWRkcmVzcy5mcm9tQ3JlYXRlMih7XG4gKiAgIGZyb206ICcweDFhMWUwMjFhMzAyYzIzNzQ1M2QzZDQ1YzdiODJiMTljZWViN2UyZTYnLFxuICogICBieXRlY29kZTogJzB4NjM5NDE5OGRmMTYwMDA1MjYxMDNmZjYwMjA2MDA0NjAxYzMzNWFmYTYwNDA1MTYwNjBmMycsXG4gKiAgIHNhbHQ6IEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpLFxuICogfSlcbiAqIC8vIEBsb2c6ICcweDU5ZmJCNTkzQUJlMjdDYjE5M2I2ZWU1QzVEQzdiYmRlMzEyMjkwYUInXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHJldHJpZXZpbmcgYWRkcmVzcy5cbiAqIEByZXR1cm5zIENvbnRyYWN0IEFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ3JlYXRlMihvcHRpb25zKSB7XG4gICAgY29uc3QgZnJvbSA9IEJ5dGVzLmZyb21IZXgoQWRkcmVzcy5mcm9tKG9wdGlvbnMuZnJvbSkpO1xuICAgIGNvbnN0IHNhbHQgPSBCeXRlcy5wYWRMZWZ0KEJ5dGVzLnZhbGlkYXRlKG9wdGlvbnMuc2FsdCkgPyBvcHRpb25zLnNhbHQgOiBCeXRlcy5mcm9tSGV4KG9wdGlvbnMuc2FsdCksIDMyKTtcbiAgICBjb25zdCBieXRlY29kZUhhc2ggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoJ2J5dGVjb2RlSGFzaCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKEJ5dGVzLnZhbGlkYXRlKG9wdGlvbnMuYnl0ZWNvZGVIYXNoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5ieXRlY29kZUhhc2g7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZXMuZnJvbUhleChvcHRpb25zLmJ5dGVjb2RlSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KG9wdGlvbnMuYnl0ZWNvZGUsIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gQWRkcmVzcy5mcm9tKEhleC5zbGljZShIYXNoLmtlY2NhazI1NihCeXRlcy5jb25jYXQoQnl0ZXMuZnJvbUhleCgnMHhmZicpLCBmcm9tLCBzYWx0LCBieXRlY29kZUhhc2gpLCB7IGFzOiAnSGV4JyB9KSwgMTIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRyYWN0QWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/ContractAddress.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Ens.js":
/*!*******************************************!*\
  !*** ../node_modules/ox/_esm/core/Ens.js ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   labelhash: () => (/* binding */ labelhash),\n/* harmony export */   namehash: () => (/* binding */ namehash),\n/* harmony export */   normalize: () => (/* binding */ normalize)\n/* harmony export */ });\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"@adraffy/ens-normalize\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/ens.js */ \"../node_modules/ox/_esm/core/internal/ens.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__, _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__]);\n([_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__, _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n/**\n * Hashes ENS label.\n *\n * Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n * ```\n *\n * @param label - ENS label.\n * @returns ENS labelhash.\n */\nfunction labelhash(label) {\n    const result = new Uint8Array(32).fill(0);\n    if (!label)\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    return (_internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(label) || _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(label)));\n}\n/**\n * Hashes ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.namehash('wevm.eth')\n * // @log: '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n * ```\n *\n * @param name - ENS name.\n * @returns ENS namehash.\n */\nfunction namehash(name) {\n    let result = new Uint8Array(32).fill(0);\n    if (!name)\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    const labels = name.split('.');\n    // Iterate in reverse order building up hash\n    for (let i = labels.length - 1; i >= 0; i -= 1) {\n        const hashFromEncodedLabel = _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(labels[i]);\n        const hashed = hashFromEncodedLabel\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(hashFromEncodedLabel)\n            : _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(labels[i]), { as: 'Bytes' });\n        result = _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.concat(result, hashed), { as: 'Bytes' });\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n}\n/**\n * Normalizes ENS name according to [ENSIP-15](https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md).\n *\n * For more info see [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) on name processing.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.normalize('wevm.eth')\n * // @log: 'wevm.eth'\n * ```\n *\n * @param name - ENS name.\n * @returns Normalized ENS name.\n */\nfunction normalize(name) {\n    return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n}\n//# sourceMappingURL=Ens.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9FbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDbkI7QUFDRjtBQUNGO0FBQ2M7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esc1dBQXNXLG1DQUFtQztBQUN6WTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxlQUFlLDhDQUFhO0FBQzVCLFlBQVksNkRBQXdCLFdBQVcsK0NBQWMsQ0FBQywrQ0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1XQUFtVyxtQ0FBbUM7QUFDdFk7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZUFBZSw4Q0FBYTtBQUM1QjtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUMscUNBQXFDLDZEQUF3QjtBQUM3RDtBQUNBLGNBQWMsOENBQWE7QUFDM0IsY0FBYywrQ0FBYyxDQUFDLGlEQUFnQixlQUFlLGFBQWE7QUFDekUsaUJBQWlCLCtDQUFjLENBQUMsNkNBQVksb0JBQW9CLGFBQWE7QUFDN0U7QUFDQSxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcscUVBQWE7QUFDeEI7QUFDQSwrQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vucy5qcz81ODhhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tICdAYWRyYWZmeS9lbnMtbm9ybWFsaXplJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvZW5zLmpzJztcbi8qKlxuICogSGFzaGVzIEVOUyBsYWJlbC5cbiAqXG4gKiBTaW5jZSBFTlMgbGFiZWxzIHByb2hpYml0IGNlcnRhaW4gZm9yYmlkZGVuIGNoYXJhY3RlcnMgKGUuZy4gdW5kZXJzY29yZSkgYW5kIGhhdmUgb3RoZXIgdmFsaWRhdGlvbiBydWxlcywgeW91IGxpa2VseSB3YW50IHRvIFtub3JtYWxpemUgRU5TIGxhYmVsc10oaHR0cHM6Ly9kb2NzLmVucy5kb21haW5zL2NvbnRyYWN0LWFwaS1yZWZlcmVuY2UvbmFtZS1wcm9jZXNzaW5nI25vcm1hbGlzaW5nLW5hbWVzKSB3aXRoIFtVVFMtNDYgbm9ybWFsaXphdGlvbl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYpIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gYGxhYmVsaGFzaGAuIFlvdSBjYW4gdXNlIHRoZSBidWlsdC1pbiB7QGxpbmsgb3gjRW5zLihub3JtYWxpemU6ZnVuY3Rpb24pfSBmdW5jdGlvbiBmb3IgdGhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLmxhYmVsaGFzaCgnZXRoJylcbiAqICcweDRmNWI4MTI3ODlmYzYwNmJlMWIzYjE2OTA4ZGIxM2ZjN2E5YWRmN2NhNzI2NDFmODRkNzViNDcwNjlkM2Q3ZjAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGFiZWwgLSBFTlMgbGFiZWwuXG4gKiBAcmV0dXJucyBFTlMgbGFiZWxoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxoYXNoKGxhYmVsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7XG4gICAgaWYgKCFsYWJlbClcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMocmVzdWx0KTtcbiAgICByZXR1cm4gKGludGVybmFsLnVud3JhcExhYmVsaGFzaChsYWJlbCkgfHwgSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcobGFiZWwpKSk7XG59XG4vKipcbiAqIEhhc2hlcyBFTlMgbmFtZS5cbiAqXG4gKiBTaW5jZSBFTlMgbmFtZXMgcHJvaGliaXQgY2VydGFpbiBmb3JiaWRkZW4gY2hhcmFjdGVycyAoZS5nLiB1bmRlcnNjb3JlKSBhbmQgaGF2ZSBvdGhlciB2YWxpZGF0aW9uIHJ1bGVzLCB5b3UgbGlrZWx5IHdhbnQgdG8gW25vcm1hbGl6ZSBFTlMgbmFtZXNdKGh0dHBzOi8vZG9jcy5lbnMuZG9tYWlucy9jb250cmFjdC1hcGktcmVmZXJlbmNlL25hbWUtcHJvY2Vzc2luZyNub3JtYWxpc2luZy1uYW1lcykgd2l0aCBbVVRTLTQ2IG5vcm1hbGl6YXRpb25dKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2KSBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIGBuYW1laGFzaGAuIFlvdSBjYW4gdXNlIHRoZSBidWlsdC1pbiB7QGxpbmsgb3gjRW5zLihub3JtYWxpemU6ZnVuY3Rpb24pfSBmdW5jdGlvbiBmb3IgdGhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLm5hbWVoYXNoKCd3ZXZtLmV0aCcpXG4gKiAvLyBAbG9nOiAnMHhmMjQ2NjUxYzFiOWE2YjE0MWQxOWMyNjA0ZTlhNThmNTY3OTczODMzOTkwZjgzMGQ4ODI1MzRhNzQ3ODAxMzU5J1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBFTlMgbmFtZS5cbiAqIEByZXR1cm5zIEVOUyBuYW1laGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7XG4gICAgaWYgKCFuYW1lKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhyZXN1bHQpO1xuICAgIGNvbnN0IGxhYmVscyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAvLyBJdGVyYXRlIGluIHJldmVyc2Ugb3JkZXIgYnVpbGRpbmcgdXAgaGFzaFxuICAgIGZvciAobGV0IGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgaGFzaEZyb21FbmNvZGVkTGFiZWwgPSBpbnRlcm5hbC51bndyYXBMYWJlbGhhc2gobGFiZWxzW2ldKTtcbiAgICAgICAgY29uc3QgaGFzaGVkID0gaGFzaEZyb21FbmNvZGVkTGFiZWxcbiAgICAgICAgICAgID8gQnl0ZXMuZnJvbUhleChoYXNoRnJvbUVuY29kZWRMYWJlbClcbiAgICAgICAgICAgIDogSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyhsYWJlbHNbaV0pLCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgICAgICByZXN1bHQgPSBIYXNoLmtlY2NhazI1NihCeXRlcy5jb25jYXQocmVzdWx0LCBoYXNoZWQpLCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhyZXN1bHQpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIEVOUyBuYW1lIGFjY29yZGluZyB0byBbRU5TSVAtMTVdKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNkb21haW5zL2RvY3MvYmxvYi85ZWRmOTQ0M2RlNDMzM2EwZWE3ZWM2NThhODcwNjcyZDVkMTgwZDUzL2Vucy1pbXByb3ZlbWVudC1wcm9wb3NhbHMvZW5zaXAtMTUtbm9ybWFsaXphdGlvbi1zdGFuZGFyZC5tZCkuXG4gKlxuICogRm9yIG1vcmUgaW5mbyBzZWUgW0VOUyBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvY29udHJhY3QtYXBpLXJlZmVyZW5jZS9uYW1lLXByb2Nlc3Npbmcjbm9ybWFsaXNpbmctbmFtZXMpIG9uIG5hbWUgcHJvY2Vzc2luZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLm5vcm1hbGl6ZSgnd2V2bS5ldGgnKVxuICogLy8gQGxvZzogJ3dldm0uZXRoJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBFTlMgbmFtZS5cbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUobmFtZSkge1xuICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW5zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Ens.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Errors.js":
/*!**********************************************!*\
  !*** ../node_modules/ox/_esm/core/Errors.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"../node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nclass BaseError extends Error {\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause &&\n                'details' in options.cause &&\n                typeof options.cause.details === 'string')\n                return options.cause.details;\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = 'https://oxlib.sh';\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9FcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDTztBQUNQLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtEQUFVLEdBQUc7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvRXJyb3JzLmpzP2I3ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJy4vaW50ZXJuYWwvZXJyb3JzLmpzJztcbi8qKlxuICogQmFzZSBlcnJvciBjbGFzcyBpbmhlcml0ZWQgYnkgYWxsIGVycm9ycyB0aHJvd24gYnkgb3guXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFcnJvcnMgfSBmcm9tICdveCdcbiAqIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UuZGV0YWlscylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLnNob3J0TWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlICYmXG4gICAgICAgICAgICAgICAgJ2RldGFpbHMnIGluIG9wdGlvbnMuY2F1c2UgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jYXVzZS5kZXRhaWxzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2U/Lm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRldGFpbHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGRvY3NQYXRoID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRvY3NQYXRoIHx8IG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kb2NzUGF0aDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgZG9jc0Jhc2VVcmwgPSAnaHR0cHM6Ly9veGxpYi5zaCc7XG4gICAgICAgIGNvbnN0IGRvY3MgPSBgJHtkb2NzQmFzZVVybH0ke2RvY3NQYXRoID8/ICcnfWA7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkLicsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5tZXRhTWVzc2FnZXMgPyBbJycsIC4uLm9wdGlvbnMubWV0YU1lc3NhZ2VzXSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihkZXRhaWxzIHx8IGRvY3NQYXRoXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID8gYERldGFpbHM6ICR7ZGV0YWlsc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkb2NzUGF0aCA/IGBTZWU6ICR7ZG9jc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zLmNhdXNlID8geyBjYXVzZTogb3B0aW9ucy5jYXVzZSB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV0YWlsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQmFzZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogYG94QCR7Z2V0VmVyc2lvbigpfWBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgIH1cbiAgICB3YWxrKGZuKSB7XG4gICAgICAgIHJldHVybiB3YWxrKHRoaXMsIGZuKTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiB3YWxrKGVyciwgZm4pIHtcbiAgICBpZiAoZm4/LihlcnIpKVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgJ2NhdXNlJyBpbiBlcnIgJiYgZXJyLmNhdXNlKVxuICAgICAgICByZXR1cm4gd2FsayhlcnIuY2F1c2UsIGZuKTtcbiAgICByZXR1cm4gZm4gPyBudWxsIDogZXJyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Fee.js":
/*!*******************************************!*\
  !*** ../node_modules/ox/_esm/core/Fee.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=Fee.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9GZWUuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9GZWUuanM/ZTYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Fee.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Filter.js":
/*!**********************************************!*\
  !*** ../node_modules/ox/_esm/core/Filter.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Filter.Rpc} to an {@link ox#Filter.Filter}.\n *\n * @example\n * ```ts twoslash\n * import { Filter } from 'ox'\n *\n * const filter = Filter.fromRpc({\n *   address: '0xd3cda913deb6f67967b99d671a681250403edf27',\n *   fromBlock: 'latest',\n *   toBlock: '0x010f2c',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     null,\n *     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n *   ],\n * })\n * // @log: {\n * // @log:   address: '0xd3cda913deb6f67967b99d671a681250403edf27',\n * // @log:   fromBlock: 'latest',\n * // @log:   toBlock: 69420n,\n * // @log:   topics: [\n * // @log:     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n * // @log:     null,\n * // @log:     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n * // @log:   ],\n * // @log: }\n * ```\n *\n * @param filter - The RPC filter to convert.\n * @returns An instantiated {@link ox#Filter.Filter}.\n */\nfunction fromRpc(filter) {\n    const { fromBlock, toBlock } = filter;\n    return {\n        ...filter,\n        ...(fromBlock && {\n            fromBlock: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(fromBlock, { strict: false })\n                ? BigInt(fromBlock)\n                : fromBlock,\n        }),\n        ...(toBlock && {\n            toBlock: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(toBlock, { strict: false })\n                ? BigInt(toBlock)\n                : toBlock,\n        }),\n    };\n}\n/**\n * Converts a {@link ox#Filter.Filter} to a {@link ox#Filter.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent, Filter } from 'ox'\n *\n * const transfer = AbiEvent.from('event Transfer(address indexed, address indexed, uint256)')\n * const { topics } = AbiEvent.encode(transfer)\n *\n * const filter = Filter.toRpc({\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *   topics,\n * })\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   topics: [\n * // @log:     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n * // @log:   ],\n * // @log: }\n * ```\n *\n * @param filter - The filter to convert.\n * @returns An RPC filter.\n */\nfunction toRpc(filter) {\n    const { address, topics, fromBlock, toBlock } = filter;\n    return {\n        ...(address && { address }),\n        ...(topics && { topics }),\n        ...(typeof fromBlock !== 'undefined'\n            ? {\n                fromBlock: typeof fromBlock === 'bigint'\n                    ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(fromBlock)\n                    : fromBlock,\n            }\n            : {}),\n        ...(typeof toBlock !== 'undefined'\n            ? {\n                toBlock: typeof toBlock === 'bigint' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(toBlock) : toBlock,\n            }\n            : {}),\n    };\n}\n//# sourceMappingURL=Filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9GaWx0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQ2hDO0FBQ0EsZUFBZSxxQkFBcUIsT0FBTyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNPO0FBQ1AsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFZLGNBQWMsZUFBZTtBQUNoRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLDZDQUFZLFlBQVksZUFBZTtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCLE1BQU0sb0JBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQSx5QkFBeUIsU0FBUztBQUNsQyx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQWM7QUFDcEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsdURBQXVELCtDQUFjO0FBQ3JFO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0ZpbHRlci5qcz9hODE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I0ZpbHRlci5ScGN9IHRvIGFuIHtAbGluayBveCNGaWx0ZXIuRmlsdGVyfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEZpbHRlciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZpbHRlciA9IEZpbHRlci5mcm9tUnBjKHtcbiAqICAgYWRkcmVzczogJzB4ZDNjZGE5MTNkZWI2ZjY3OTY3Yjk5ZDY3MWE2ODEyNTA0MDNlZGYyNycsXG4gKiAgIGZyb21CbG9jazogJ2xhdGVzdCcsXG4gKiAgIHRvQmxvY2s6ICcweDAxMGYyYycsXG4gKiAgIHRvcGljczogW1xuICogICAgICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnLFxuICogICAgIG51bGwsXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGMwNGQ5ZTkyNzhlYzVlNGQ0MjQ0NzZkM2ViZWM3MGNiNWQ2NDhkMScsXG4gKiAgIF0sXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhkM2NkYTkxM2RlYjZmNjc5NjdiOTlkNjcxYTY4MTI1MDQwM2VkZjI3JyxcbiAqIC8vIEBsb2c6ICAgZnJvbUJsb2NrOiAnbGF0ZXN0JyxcbiAqIC8vIEBsb2c6ICAgdG9CbG9jazogNjk0MjBuLFxuICogLy8gQGxvZzogICB0b3BpY3M6IFtcbiAqIC8vIEBsb2c6ICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqIC8vIEBsb2c6ICAgICBudWxsLFxuICogLy8gQGxvZzogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjMDRkOWU5Mjc4ZWM1ZTRkNDI0NDc2ZDNlYmVjNzBjYjVkNjQ4ZDEnLFxuICogLy8gQGxvZzogICBdLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGZpbHRlciAtIFRoZSBSUEMgZmlsdGVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I0ZpbHRlci5GaWx0ZXJ9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhmaWx0ZXIpIHtcbiAgICBjb25zdCB7IGZyb21CbG9jaywgdG9CbG9jayB9ID0gZmlsdGVyO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgLi4uKGZyb21CbG9jayAmJiB7XG4gICAgICAgICAgICBmcm9tQmxvY2s6IEhleC52YWxpZGF0ZShmcm9tQmxvY2ssIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgICAgICAgICAgICAgID8gQmlnSW50KGZyb21CbG9jaylcbiAgICAgICAgICAgICAgICA6IGZyb21CbG9jayxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0b0Jsb2NrICYmIHtcbiAgICAgICAgICAgIHRvQmxvY2s6IEhleC52YWxpZGF0ZSh0b0Jsb2NrLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgICAgICAgICAgICAgICA/IEJpZ0ludCh0b0Jsb2NrKVxuICAgICAgICAgICAgICAgIDogdG9CbG9jayxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjRmlsdGVyLkZpbHRlcn0gdG8gYSB7QGxpbmsgb3gjRmlsdGVyLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFdmVudCwgRmlsdGVyIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNmZXIgPSBBYmlFdmVudC5mcm9tKCdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQsIGFkZHJlc3MgaW5kZXhlZCwgdWludDI1NiknKVxuICogY29uc3QgeyB0b3BpY3MgfSA9IEFiaUV2ZW50LmVuY29kZSh0cmFuc2ZlcilcbiAqXG4gKiBjb25zdCBmaWx0ZXIgPSBGaWx0ZXIudG9ScGMoe1xuICogICBhZGRyZXNzOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgdG9waWNzLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4ZmJhMzkxMmNhMDRkZDQ1OGM4NDNlMmVlMDg5NjdmYzA0ZjM1NzljMicsXG4gKiAvLyBAbG9nOiAgIHRvcGljczogW1xuICogLy8gQGxvZzogICAgICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnLFxuICogLy8gQGxvZzogICBdLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQyBmaWx0ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhmaWx0ZXIpIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIHRvcGljcywgZnJvbUJsb2NrLCB0b0Jsb2NrIH0gPSBmaWx0ZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKGFkZHJlc3MgJiYgeyBhZGRyZXNzIH0pLFxuICAgICAgICAuLi4odG9waWNzICYmIHsgdG9waWNzIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGZyb21CbG9jayAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGZyb21CbG9jazogdHlwZW9mIGZyb21CbG9jayA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBIZXguZnJvbU51bWJlcihmcm9tQmxvY2spXG4gICAgICAgICAgICAgICAgICAgIDogZnJvbUJsb2NrLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgdG9CbG9jayAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHRvQmxvY2s6IHR5cGVvZiB0b0Jsb2NrID09PSAnYmlnaW50JyA/IEhleC5mcm9tTnVtYmVyKHRvQmxvY2spIDogdG9CbG9jayxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Filter.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Hash.js":
/*!********************************************!*\
  !*** ../node_modules/ox/_esm/core/Hash.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nfunction sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nfunction validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNKO0FBQ0w7QUFDMUI7QUFDSjtBQUNoQztBQUNBLDhFQUE4RSxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxtREFBbUQ7QUFDL0Qsa0JBQWtCLDhEQUFlLENBQUMsMkNBQVU7QUFDNUM7QUFDQTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBLCtFQUErRSxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxtREFBbUQ7QUFDL0Qsa0JBQWtCLGtFQUFlLENBQUMsMkNBQVU7QUFDNUM7QUFDQTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBLDZFQUE2RSxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxtREFBbUQ7QUFDL0Qsa0JBQWtCLDREQUFZLENBQUMsMkNBQVU7QUFDekM7QUFDQTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsNkNBQVksV0FBVyx5Q0FBUTtBQUMxQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSGFzaC5qcz9kMDg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJpcGVtZDE2MCBhcyBub2JsZV9yaXBlbWQxNjAgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MCc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IGFzIG5vYmxlX2tlY2NhazI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBzaGEyNTYgYXMgbm9ibGVfc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbS2VjY2FrMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMykgaGFzaCBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSByZS1leHBvcnQgb2YgYGtlY2Nha18yNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogJzB4ZDRmZDRlMTg5MTMyMjczMDM2NDQ5ZmM5ZTExMTk4YzczOTE2MWI0YzAxMTZhOWEyZGNjZGZhMWM0OTIwMDZmMSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ2FsY3VsYXRlIEhhc2ggb2YgYSBTdHJpbmdcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb25maWd1cmUgUmV0dXJuIFR5cGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gua2VjY2FrMjU2KCcweGRlYWRiZWVmJywgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBLZWNjYWsyNTYgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1Nih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBub2JsZV9rZWNjYWsyNTYoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgW1JpcGVtZDE2MF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUklQRU1EKSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBgcmlwZW1kMTYwYCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gucmlwZW1kMTYwKCcweGRlYWRiZWVmJylcbiAqIC8vICcweDIyNjgyMWMyZjU0MjNlMTFmZTlhZjY4YmQyODVjMjQ5ZGIyZTRiNWEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFJpcGVtZDE2MCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX3JpcGVtZDE2MChCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbU2hhMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMjU2KSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBgc2hhMjU2YCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2guc2hhMjU2KCcweGRlYWRiZWVmJylcbiAqIC8vICcweDVmNzhjMzMyNzRlNDNmYTlkZTU2NTkyNjVjMWQ5MTdlMjVjMDM3MjJkY2IwYjhkMjdkYjhkNWZlYWE4MTM5NTMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFNoYTI1NiBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX3NoYTI1NihCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoYXNoIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogSGFzaC52YWxpZGF0ZSgnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiBIZXguc2l6ZSh2YWx1ZSkgPT09IDMyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/HdKey.js":
/*!*********************************************!*\
  !*** ../node_modules/ox/_esm/core/HdKey.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromExtendedKey: () => (/* binding */ fromExtendedKey),\n/* harmony export */   fromJson: () => (/* binding */ fromJson),\n/* harmony export */   fromSeed: () => (/* binding */ fromSeed),\n/* harmony export */   path: () => (/* binding */ path)\n/* harmony export */ });\n/* harmony import */ var _scure_bip32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @scure/bip32 */ \"../node_modules/@scure/bip32/lib/esm/index.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _internal_hdKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hdKey.js */ \"../node_modules/ox/_esm/core/internal/hdKey.js\");\n\n\n\n/**\n * Creates a HD Key from an extended private key.\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const hdKey = HdKey.fromExtendedKey('...')\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param extendedKey - The extended private key.\n * @returns The HD Key.\n */\nfunction fromExtendedKey(extendedKey) {\n    const key = _scure_bip32__WEBPACK_IMPORTED_MODULE_0__.HDKey.fromExtendedKey(extendedKey);\n    return _internal_hdKey_js__WEBPACK_IMPORTED_MODULE_1__.fromScure(key);\n}\n/**\n * Creates a HD Key from a JSON object containing an extended private key (`xpriv`).\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const hdKey = HdKey.fromJson({ xpriv: '...' })\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param json - The JSON object containing an extended private key (`xpriv`).\n * @returns The HD Key.\n */\nfunction fromJson(json) {\n    return _internal_hdKey_js__WEBPACK_IMPORTED_MODULE_1__.fromScure(_scure_bip32__WEBPACK_IMPORTED_MODULE_0__.HDKey.fromJSON(json));\n}\n/**\n * Creates a HD Key from a master seed.\n *\n * @example\n * ```ts twoslash\n * import { HdKey, Mnemonic } from 'ox'\n *\n * const seed = Mnemonic.toSeed('test test test test test test test test test test test junk')\n * const hdKey = HdKey.fromSeed(seed)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`.\n *\n * ```ts twoslash\n * import { HdKey, Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.toSeed('test test test test test test test test test test test junk')\n * const hdKey = HdKey.fromSeed(mnemonic).derive(HdKey.path())\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param seed - The master seed to create the HD Key from.\n * @param options - Creation options.\n * @returns The HD Key.\n */\nfunction fromSeed(seed, options = {}) {\n    const { versions } = options;\n    const key = _scure_bip32__WEBPACK_IMPORTED_MODULE_0__.HDKey.fromMasterSeed(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.from(seed), versions);\n    return _internal_hdKey_js__WEBPACK_IMPORTED_MODULE_1__.fromScure(key);\n}\n/**\n * Creates an Ethereum-based BIP-44 HD path.\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const path = HdKey.path({ account: 1, index: 2 })\n * // @log: \"m/44'/60'/1'/0/2\"\n * ```\n *\n * @param options - Path options.\n * @returns The path.\n */\nfunction path(options = {}) {\n    const { account = 0, change = 0, index = 0 } = options;\n    return `m/44'/60'/${account}'/${change}/${index}`;\n}\n//# sourceMappingURL=HdKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IZEtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFDO0FBQ0Q7QUFDWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsK0NBQUs7QUFDckIsV0FBVyx5REFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx5REFBa0IsQ0FBQywrQ0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0NBQW9DO0FBQzNDLFlBQVksV0FBVztBQUN2QixnQkFBZ0IsK0NBQUssZ0JBQWdCLDJDQUFVO0FBQy9DLFdBQVcseURBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMEJBQTBCO0FBQ2pDLFlBQVkscUNBQXFDO0FBQ2pELHdCQUF3QixRQUFRLElBQUksT0FBTyxHQUFHLE1BQU07QUFDcEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hkS2V5LmpzPzc3YzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSERLZXkgfSBmcm9tICdAc2N1cmUvYmlwMzInO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2hkS2V5LmpzJztcbi8qKlxuICogQ3JlYXRlcyBhIEhEIEtleSBmcm9tIGFuIGV4dGVuZGVkIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGRLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBoZEtleSA9IEhkS2V5LmZyb21FeHRlbmRlZEtleSgnLi4uJylcbiAqXG4gKiBjb25zb2xlLmxvZyhoZEtleS5wcml2YXRlS2V5KVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGV4dGVuZGVkS2V5IC0gVGhlIGV4dGVuZGVkIHByaXZhdGUga2V5LlxuICogQHJldHVybnMgVGhlIEhEIEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FeHRlbmRlZEtleShleHRlbmRlZEtleSkge1xuICAgIGNvbnN0IGtleSA9IEhES2V5LmZyb21FeHRlbmRlZEtleShleHRlbmRlZEtleSk7XG4gICAgcmV0dXJuIGludGVybmFsLmZyb21TY3VyZShrZXkpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgSEQgS2V5IGZyb20gYSBKU09OIG9iamVjdCBjb250YWluaW5nIGFuIGV4dGVuZGVkIHByaXZhdGUga2V5IChgeHByaXZgKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhkS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgaGRLZXkgPSBIZEtleS5mcm9tSnNvbih7IHhwcml2OiAnLi4uJyB9KVxuICpcbiAqIGNvbnNvbGUubG9nKGhkS2V5LnByaXZhdGVLZXkpXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ganNvbiAtIFRoZSBKU09OIG9iamVjdCBjb250YWluaW5nIGFuIGV4dGVuZGVkIHByaXZhdGUga2V5IChgeHByaXZgKS5cbiAqIEByZXR1cm5zIFRoZSBIRCBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSnNvbihqc29uKSB7XG4gICAgcmV0dXJuIGludGVybmFsLmZyb21TY3VyZShIREtleS5mcm9tSlNPTihqc29uKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBIRCBLZXkgZnJvbSBhIG1hc3RlciBzZWVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGRLZXksIE1uZW1vbmljIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VlZCA9IE1uZW1vbmljLnRvU2VlZCgndGVzdCB0ZXN0IHRlc3QgdGVzdCB0ZXN0IHRlc3QgdGVzdCB0ZXN0IHRlc3QgdGVzdCB0ZXN0IGp1bmsnKVxuICogY29uc3QgaGRLZXkgPSBIZEtleS5mcm9tU2VlZChzZWVkKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBQYXRoIERlcml2YXRpb25cbiAqXG4gKiBZb3UgY2FuIGRlcml2ZSBhIEhEIEtleSBhdCBhIHNwZWNpZmljIHBhdGggdXNpbmcgYGRlcml2ZWAuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhkS2V5LCBNbmVtb25pYyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMudG9TZWVkKCd0ZXN0IHRlc3QgdGVzdCB0ZXN0IHRlc3QgdGVzdCB0ZXN0IHRlc3QgdGVzdCB0ZXN0IHRlc3QganVuaycpXG4gKiBjb25zdCBoZEtleSA9IEhkS2V5LmZyb21TZWVkKG1uZW1vbmljKS5kZXJpdmUoSGRLZXkucGF0aCgpKVxuICpcbiAqIGNvbnNvbGUubG9nKGhkS2V5LnByaXZhdGVLZXkpXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VlZCAtIFRoZSBtYXN0ZXIgc2VlZCB0byBjcmVhdGUgdGhlIEhEIEtleSBmcm9tLlxuICogQHBhcmFtIG9wdGlvbnMgLSBDcmVhdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEhEIEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TZWVkKHNlZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgdmVyc2lvbnMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qga2V5ID0gSERLZXkuZnJvbU1hc3RlclNlZWQoQnl0ZXMuZnJvbShzZWVkKSwgdmVyc2lvbnMpO1xuICAgIHJldHVybiBpbnRlcm5hbC5mcm9tU2N1cmUoa2V5KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBFdGhlcmV1bS1iYXNlZCBCSVAtNDQgSEQgcGF0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhkS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGF0aCA9IEhkS2V5LnBhdGgoeyBhY2NvdW50OiAxLCBpbmRleDogMiB9KVxuICogLy8gQGxvZzogXCJtLzQ0Jy82MCcvMScvMC8yXCJcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gUGF0aCBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHBhdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXRoKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYWNjb3VudCA9IDAsIGNoYW5nZSA9IDAsIGluZGV4ID0gMCB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gYG0vNDQnLzYwJy8ke2FjY291bnR9Jy8ke2NoYW5nZX0vJHtpbmRleH1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGRLZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/HdKey.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Hex.js":
/*!*******************************************!*\
  !*** ../node_modules/ox/_esm/core/Hex.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"../node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"../node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"../node_modules/ox/_esm/core/internal/hex.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nfunction isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nfunction random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nfunction toBoolean(hex, options = {}) {\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nclass IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nclass InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nclass InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nclass InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nclass InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWlDLGlEQUFnQjtBQUN4RDtBQUNBLDhCQUE4QixNQUFNLHdCQUF3QixrQkFBa0I7QUFDOUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxpREFBZ0I7QUFDdkQsa0JBQWtCLG9CQUFvQjtBQUN0QyxzQ0FBc0MsUUFBUSwwQkFBMEIsVUFBVTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFLGtCQUFrQix5QkFBeUI7QUFDM0MsdUJBQXVCLDhDQUE4QyxjQUFjLE9BQU8sK0JBQStCLEtBQUs7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLGlEQUFnQjtBQUNqRSxrQkFBa0IseUJBQXlCO0FBQzNDLGlCQUFpQiw2QkFBNkIsRUFBRTtBQUNoRDtBQUNBLDRCQUE0QixVQUFVLEtBQUssOEJBQThCLFdBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IZXguanM/OWE4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9ieXRlcyBmcm9tICcuL2ludGVybmFsL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvaGV4LmpzJztcbmNvbnN0IGVuY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgaGV4ZXMgPSAvKiNfX1BVUkVfXyovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBBc3NlcnRzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkSGV4VmFsdWVUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiAvLyBAZXJyb3I6IEhleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4XFwke3N0cmluZ31cImAuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKCEvXjB4WzAtOWEtZkEtRl0qJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFZhbHVlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguY29uY2F0KCcweDEyMycsICcweDQ1NicpXG4gKiAvLyBAbG9nOiAnMHgxMjM0NTYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCguLi52YWx1ZXMpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgucmVwbGFjZSgnMHgnLCAnJyksICcnKX1gO1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgZnJvbSBhIGhleCBzdHJpbmcgb3Ige0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUbyBpbnN0YW50aWF0ZSBmcm9tIGEgKipCb29sZWFuKiosICoqU3RyaW5nKiosIG9yICoqTnVtYmVyKiosIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBIZXguZnJvbUJvb2xlYW5gXG4gKlxuICogLSBgSGV4LmZyb21TdHJpbmdgXG4gKlxuICogLSBgSGV4LmZyb21OdW1iZXJgXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb20oJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbShCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHZhbHVlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4odHJ1ZSlcbiAqIC8vIEBsb2c6ICcweDEnXG4gKlxuICogSGV4LmZyb21Cb29sZWFuKGZhbHNlKVxuICogLy8gQGxvZzogJzB4MCdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBib29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZXggPSBgMHgke051bWJlcih2YWx1ZSl9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyaW5nICs9IGhleGVzW3ZhbHVlW2ldXTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ31gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZFJpZ2h0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciBvciBiaWdpbnQgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMClcbiAqIC8vIEBsb2c6ICcweDFhNCdcbiAqXG4gKiBIZXguZnJvbU51bWJlcig0MjAsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIG9yIGJpZ2ludCB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZV8gPSBCaWdJbnQodmFsdWUpO1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgbWF4VmFsdWUgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuIC0gMW4pKSAtIDFuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZSkgKiA4bikgLSAxbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXhWYWx1ZSA9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgfVxuICAgIGNvbnN0IG1pblZhbHVlID0gdHlwZW9mIG1heFZhbHVlID09PSAnYmlnaW50JyAmJiBzaWduZWQgPyAtbWF4VmFsdWUgLSAxbiA6IDA7XG4gICAgaWYgKChtYXhWYWx1ZSAmJiB2YWx1ZV8gPiBtYXhWYWx1ZSkgfHwgdmFsdWVfIDwgbWluVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/ICduJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICBtYXg6IG1heFZhbHVlID8gYCR7bWF4VmFsdWV9JHtzdWZmaXh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1pbjogYCR7bWluVmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICB2YWx1ZTogYCR7dmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gKHNpZ25lZCAmJiB2YWx1ZV8gPCAwID8gKDFuIDw8IEJpZ0ludChzaXplICogOCkpICsgQmlnSW50KHZhbHVlXykgOiB2YWx1ZV8pLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ1ZhbHVlfWA7XG4gICAgaWYgKHNpemUpXG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgc2l6ZSk7XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJylcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiAzMiB9KVxuICogLy8gJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhlbmNvZGVyLmVuY29kZSh2YWx1ZSksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmlzRXF1YWwoJzB4ZGVhZGJlZWYnLCAnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LmlzRXF1YWwoJzB4ZGEnLCAnMHhiYScpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleEEgLSBUaGUgZmlyc3Qge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIGhleEIgLSBUaGUgc2Vjb25kIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdvIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoaGV4QSwgaGV4Qikge1xuICAgIHJldHVybiBlcXVhbEJ5dGVzKEJ5dGVzLmZyb21IZXgoaGV4QSksIEJ5dGVzLmZyb21IZXgoaGV4QikpO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDEyMzQnLCA0KVxuICogLy8gQGxvZzogJzB4MDAwMDEyMzQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgKGluIGJ5dGVzKSBvZiB0aGUgb3V0cHV0IGhleCB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdGhlIHJpZ2h0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRSaWdodCgnMHgxMjM0JywgNClcbiAqIC8vIEBsb2c6ICcweDEyMzQwMDAwJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIChpbiBieXRlcykgb2YgdGhlIG91dHB1dCBoZXggdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFJpZ2h0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemUgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBoZXggPSBIZXgucmFuZG9tKDMyKVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICogYGBgXG4gKlxuICogQHJldHVybnMgUmFuZG9tIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKEJ5dGVzLnJhbmRvbShsZW5ndGgpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGdpdmVuIGEgc3RhcnQvZW5kIGJ5dGVzIG9mZnNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgMSwgNClcbiAqIC8vIEBsb2c6ICcweDIzNDU2NydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gc2xpY2UuXG4gKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnQgb2Zmc2V0IChpbiBieXRlcykuXG4gKiBAcGFyYW0gZW5kIC0gVGhlIGVuZCBvZmZzZXQgKGluIGJ5dGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzbGljZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gYDB4JHt2YWx1ZVxuICAgICAgICAucmVwbGFjZSgnMHgnLCAnJylcbiAgICAgICAgLnNsaWNlKChzdGFydCA/PyAwKSAqIDIsIChlbmQgPz8gdmFsdWUubGVuZ3RoKSAqIDIpfWA7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIChpbiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2l6ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiA0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgKGluIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xufVxuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudHJpbUxlZnQoJzB4MDAwMDAwMDBkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiAnMHhkZWFkYmVlZidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdHJpbS5cbiAqIEByZXR1cm5zIFRoZSB0cmltbWVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG4vKipcbiAqIFRyaW1zIHRyYWlsaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudHJpbVJpZ2h0KCcweGRlYWRiZWVmMDAwMDAwMDAnKVxuICogLy8gQGxvZzogJzB4ZGVhZGJlZWYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRyaW0uXG4gKiBAcmV0dXJucyBUaGUgdHJpbW1lZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIEJpZ0ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0JpZ0ludCgnMHgxYTQnKVxuICogLy8gQGxvZzogNDIwblxuICpcbiAqIEhleC50b0JpZ0ludCgnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0JywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgQmlnSW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCB9ID0gb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xuICAgIGlmICghc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc2l6ZSA9IChoZXgubGVuZ3RoIC0gMikgLyAyO1xuICAgIGNvbnN0IG1heF91bnNpZ25lZCA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4pKSAtIDFuO1xuICAgIGNvbnN0IG1heF9zaWduZWQgPSBtYXhfdW5zaWduZWQgPj4gMW47XG4gICAgaWYgKHZhbHVlIDw9IG1heF9zaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgLSBtYXhfdW5zaWduZWQgLSAxbjtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDEnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCBoZXhfID0gdHJpbUxlZnQoaGV4KTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChoZXhfID09PSAnMHgxJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEludmFsaWRIZXhCb29sZWFuRXJyb3IoaGV4KTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBIZXgudG9CeXRlcygnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvTnVtYmVyKCcweDFhNCcpXG4gKiAvLyBAbG9nOiA0MjBcbiAqXG4gKiBIZXgudG9OdW1iZXIoJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCcsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IDQyMFxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgbnVtYmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXNpZ25lZCAmJiAhc2l6ZSlcbiAgICAgICAgcmV0dXJuIE51bWJlcihoZXgpO1xuICAgIHJldHVybiBOdW1iZXIodG9CaWdJbnQoaGV4LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b1N0cmluZygnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJ0hlbGxvIHdvcmxkISdcbiAqXG4gKiBIZXgudG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIHtcbiAqICBzaXplOiAzMixcbiAqIH0pXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXMgPSBCeXRlcy5mcm9tSGV4KGhleCk7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfYnl0ZXMuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzID0gQnl0ZXMudHJpbVJpZ2h0KGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LnZhbGlkYXRlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEge0BsaW5rIG94I0hleC5IZXh9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSwgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBpbnRlZ2VyIGlzIG91dCBvZiByYW5nZSwgYW5kIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGhleCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMDE4MjczODkxMjczMTI4MzcxMjkzNzEyOSlcbiAqIC8vIEBlcnJvcjogSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3I6IE51bWJlciBcXGA0LjIwMTgyNzM4OTEyNzMxMjZlKzI2XFxgIGlzIG5vdCBpbiBzYWZlIHVuc2lnbmVkIGludGVnZXIgcmFuZ2UgKGAwYCB0byBgOTAwNzE5OTI1NDc0MDk5MWApXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVnZXJPdXRPZlJhbmdlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1heCwgbWluLCBzaWduZWQsIHNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBOdW1iZXIgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGluIHNhZmUke3NpemUgPyBgICR7c2l6ZSAqIDh9LWJpdGAgOiAnJ30ke3NpZ25lZCA/ICcgc2lnbmVkJyA6ICcgdW5zaWduZWQnfSBpbnRlZ2VyIHJhbmdlICR7bWF4ID8gYChcXGAke21pbn1cXGAgdG8gXFxgJHttYXh9XFxgKWAgOiBgKGFib3ZlIFxcYCR7bWlufVxcYClgfWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGhleCB2YWx1ZSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvQm9vbGVhbignMHhhJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhCb29sZWFuRXJyb3I6IEhleCB2YWx1ZSBgXCIweGFcImAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5cbiAqIC8vIEBlcnJvcjogVGhlIGhleCB2YWx1ZSBtdXN0IGJlIGBcIjB4MFwiYCAoZmFsc2UpIG9yIGBcIjB4MVwiYCAodHJ1ZSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhCb29sZWFuRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihoZXgpIHtcbiAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcXGBcIiR7aGV4fVwiXFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBoZXggdmFsdWUgbXVzdCBiZSBgXCIweDBcImAgKGZhbHNlKSBvciBgXCIweDFcImAgKHRydWUpLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoMSlcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhUeXBlRXJyb3I6IFZhbHVlIGAxYCBvZiB0eXBlIGBudW1iZXJgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0hleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4JHtzdHJpbmd9XCJgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoJzB4MDEyMzQ1Njc4OWFiY2RlZmcnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZEhleFZhbHVlRXJyb3I6IFZhbHVlIGAweDAxMjM0NTY3ODlhYmNkZWZnYCBpcyBhbiBpbnZhbGlkIGhleCB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogSGV4IHZhbHVlcyBtdXN0IHN0YXJ0IHdpdGggYFwiMHhcImAgYW5kIGNvbnRhaW4gb25seSBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzICgwLTksIGEtZiwgQS1GKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEhleFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0hleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgaXMgYW4gb2RkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbUhleCgnMHhhYmNkZScpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkTGVuZ3RoRXJyb3I6IEhleCB2YWx1ZSBgXCIweGFiY2RlXCJgIGlzIGFuIG9kZCBsZW5ndGggKDUgbmliYmxlcykuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRMZW5ndGhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke3ZhbHVlfVwiXFxgIGlzIGFuIG9kZCBsZW5ndGggKCR7dmFsdWUubGVuZ3RoIC0gMn0gbmliYmxlcykuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0l0IG11c3QgYmUgYW4gZXZlbiBsZW5ndGguJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRMZW5ndGhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgdmFsdWUgZXhjZWVkcyB0aGUgZXhwZWN0ZWQgbWF4IHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiA4IH0pXG4gKiAvLyBAZXJyb3I6IEhleC5TaXplT3ZlcmZsb3dFcnJvcjogU2l6ZSBjYW5ub3QgZXhjZWVkIGA4YCBieXRlcy4gR2l2ZW4gc2l6ZTogYDEyYCBieXRlcy5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzbGljZSBvZmZzZXQgZXhjZWVkcyB0aGUgYm91bmRzIG9mIHRoZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgNilcbiAqIC8vIEBlcnJvcjogSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcjogU2xpY2Ugc3RhcnRpbmcgYXQgb2Zmc2V0IGA2YCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBgNWApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzaXplIG9mIHRoZSB2YWx1ZSBleGNlZWRzIHRoZSBwYWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDFhNGUxMmE0NWEyMTMyMzEyM2FhYTg3YTg5N2E4OTdhODk4YTY1NjdhNTc4YTg2N2E5ODc3OGE2NjdhODVhODc1YTg3YTZhNzg3YTY1YTY3NWE2YTknLCAzMilcbiAqIC8vIEBlcnJvcjogSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjogSGV4IHNpemUgKGA0M2ApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChgMzJgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBzaXplIChcXGAke3NpemV9XFxgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoXFxgJHt0YXJnZXRTaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Json.js":
/*!********************************************!*\
  !*** ../node_modules/ox/_esm/core/Json.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Kc29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsNkJBQTZCLGdGQUFnRjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyxnRkFBZ0Y7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxS0FBcUs7QUFDcks7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Kc29uLmpzPzA3OTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmlnSW50U3VmZml4ID0gJyNfX2JpZ2ludCc7XG4vKipcbiAqIFBhcnNlcyBhIEpTT04gc3RyaW5nLCB3aXRoIHN1cHBvcnQgZm9yIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSnNvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGpzb24gPSBKc29uLnBhcnNlKCd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6XCI2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMCNfX2JpZ2ludFwifScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGZvbzogJ2JhcicsXG4gKiAvLyBAbG9nOiAgIGJhejogNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjBuXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RyaW5nIC0gVGhlIHZhbHVlIHRvIHBhcnNlLlxuICogQHBhcmFtIHJldml2ZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShzdHJpbmcsIHJldml2ZXIpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcsIChrZXksIHZhbHVlXykgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlXztcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoYmlnSW50U3VmZml4KSlcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUuc2xpY2UoMCwgLWJpZ0ludFN1ZmZpeC5sZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gcmV2aXZlcihrZXksIHZhbHVlKSA6IHZhbHVlO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTdHJpbmdpZmllcyBhIHZhbHVlIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLCB3aXRoIHN1cHBvcnQgZm9yIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSnNvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGpzb24gPSBKc29uLnN0cmluZ2lmeSh7XG4gKiAgIGZvbzogJ2JhcicsXG4gKiAgIGJhejogNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjBuLFxuICogfSlcbiAqIC8vIEBsb2c6ICd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6XCI2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMCNfX2JpZ2ludFwifSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdHJpbmdpZnkuXG4gKiBAcGFyYW0gcmVwbGFjZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy4gSXQgaXMgcGFzc2VkIHRoZSBrZXkgYW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSwgYW5kIG11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0byBiZSB1c2VkIGluIHRoZSBKU09OIHN0cmluZy4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGUgcHJvcGVydHkgaXMgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgSlNPTiBzdHJpbmcuXG4gKiBAcGFyYW0gc3BhY2UgLSBBIHN0cmluZyBvciBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgSlNPTiBzdHJpbmcuIElmIGl0IGlzIGEgbnVtYmVyLCBpdCBpbmRpY2F0ZXMgdGhlIG51bWJlciBvZiBzcGFjZXMgdG8gdXNlIGFzIGluZGVudGF0aW9uOyBpZiBpdCBpcyBhIHN0cmluZyAoZS5nLiBgJ1xcdCdgKSwgaXQgdXNlcyB0aGUgc3RyaW5nIGFzIHRoZSBpbmRlbnRhdGlvbiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUaGUgSlNPTiBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlcihrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIGJpZ0ludFN1ZmZpeDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIHNwYWNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpzb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Keystore.js":
/*!************************************************!*\
  !*** ../node_modules/ox/_esm/core/Keystore.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async),\n/* harmony export */   scrypt: () => (/* binding */ scrypt),\n/* harmony export */   scryptAsync: () => (/* binding */ scryptAsync)\n/* harmony export */ });\n/* harmony import */ var _noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/ciphers/aes */ \"@noble/ciphers/aes\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/scrypt */ \"../node_modules/ox/node_modules/@noble/hashes/esm/scrypt.js\");\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_0__]);\n_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n/**\n * Decrypts a [JSON keystore](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * into a private key.\n *\n * Supports the following key derivation functions (KDFs):\n * - {@link ox#Keystore.(pbkdf2:function)}\n * - {@link ox#Keystore.(scrypt:function)}\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * // Derive key from password.\n * const key = Keystore.pbkdf2({ password: 'testpassword' })\n *\n * // Decrypt the private key.\n * const privateKey = await Keystore.decrypt(keystore, key)\n * // @log: \"0x...\"\n * ```\n *\n * @param keystore - JSON keystore.\n * @param key - Key to use for decryption.\n * @param options - Decryption options.\n * @returns Decrypted private key.\n */\nasync function decrypt(keystore, key, options = {}) {\n    const { as = 'Hex' } = options;\n    const key_ = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(`0x${key.key()}`);\n    const encKey = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.slice(key_, 0, 16);\n    const macKey = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.slice(key_, 16, 32);\n    const ciphertext = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(`0x${keystore.crypto.ciphertext}`);\n    const mac = _Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.concat(macKey, ciphertext));\n    if (!_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.isEqual(mac, _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(`0x${keystore.crypto.mac}`)))\n        throw new Error('corrupt keystore');\n    const data = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_0__.ctr)(encKey, key.iv).decrypt(ciphertext);\n    if (as === 'Hex')\n        return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(data);\n    return data;\n}\n/**\n * Encrypts a private key as a [JSON keystore](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * using a derived key.\n *\n * Supports the following key derivation functions (KDFs):\n * - {@link ox#Keystore.(pbkdf2:function)}\n * - {@link ox#Keystore.(scrypt:function)}\n *\n * @example\n * ```ts twoslash\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // Generate a random private key.\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * // Derive key from password.\n * const key = Keystore.pbkdf2({ password: 'testpassword' })\n *\n * // Encrypt the private key.\n * const encrypted = await Keystore.encrypt(privateKey, key)\n * // @log: {\n * // @log:   \"crypto\": {\n * // @log:     \"cipher\": \"aes-128-ctr\",\n * // @log:     \"ciphertext\": \"...\",\n * // @log:     \"cipherparams\": {\n * // @log:       \"iv\": \"...\",\n * // @log:     },\n * // @log:     \"kdf\": \"pbkdf2\",\n * // @log:     \"kdfparams\": {\n * // @log:       \"salt\": \"...\",\n * // @log:       \"dklen\": 32,\n * // @log:       \"prf\": \"hmac-sha256\",\n * // @log:       \"c\": 262144,\n * // @log:     },\n * // @log:     \"mac\": \"...\",\n * // @log:   },\n * // @log:   \"id\": \"...\",\n * // @log:   \"version\": 3,\n * // @log: }\n * ```\n *\n * @param privateKey - Private key to encrypt.\n * @param key - Key to use for encryption.\n * @param options - Encryption options.\n * @returns Encrypted keystore.\n */\nasync function encrypt(privateKey, key, options = {}) {\n    const { id = crypto.randomUUID() } = options;\n    const key_ = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(`0x${key.key()}`);\n    const value_ = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey);\n    const encKey = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.slice(key_, 0, 16);\n    const macKey = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.slice(key_, 16, 32);\n    const ciphertext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_0__.ctr)(encKey, key.iv).encrypt(value_);\n    const mac = _Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.concat(macKey, ciphertext));\n    return {\n        crypto: {\n            cipher: 'aes-128-ctr',\n            ciphertext: _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(ciphertext).slice(2),\n            cipherparams: { iv: _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(key.iv).slice(2) },\n            kdf: key.kdf,\n            kdfparams: key.kdfparams,\n            mac: _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(mac).slice(2),\n        },\n        id,\n        version: 3,\n    };\n}\n/**\n * Derives a key from a password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const key = Keystore.pbkdf2({ password: 'testpassword' })\n * ```\n *\n * @param options - PBKDF2 options.\n * @returns PBKDF2 key.\n */\nfunction pbkdf2(options) {\n    const { iv, iterations = 262_144, password } = options;\n    const salt = options.salt ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(options.salt) : _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.random(32);\n    const key = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex((0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__.pbkdf2)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_4__.sha256, password, salt, { c: iterations, dkLen: 32 })).slice(2);\n    return defineKey({\n        iv,\n        key: () => key,\n        kdfparams: {\n            c: iterations,\n            dklen: 32,\n            prf: 'hmac-sha256',\n            salt: _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(salt).slice(2),\n        },\n        kdf: 'pbkdf2',\n    });\n}\n/**\n * Derives a key from a password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const key = await Keystore.pbkdf2Async({ password: 'testpassword' })\n * ```\n *\n * @param options - PBKDF2 options.\n * @returns PBKDF2 key.\n */\nasync function pbkdf2Async(options) {\n    const { iv, iterations = 262_144, password } = options;\n    const salt = options.salt ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(options.salt) : _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.random(32);\n    const key = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(await (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__.pbkdf2Async)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_4__.sha256, password, salt, {\n        c: iterations,\n        dkLen: 32,\n    })).slice(2);\n    return defineKey({\n        iv,\n        key: () => key,\n        kdfparams: {\n            c: iterations,\n            dklen: 32,\n            prf: 'hmac-sha256',\n            salt: _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(salt).slice(2),\n        },\n        kdf: 'pbkdf2',\n    });\n}\n/**\n * Derives a key from a password using [scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const key = Keystore.scrypt({ password: 'testpassword' })\n * ```\n *\n * @param options - Scrypt options.\n * @returns Scrypt key.\n */\nfunction scrypt(options) {\n    const { iv, n = 262_144, password } = options;\n    const p = 8;\n    const r = 1;\n    const salt = options.salt ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(options.salt) : _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.random(32);\n    const key = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex((0,_noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_5__.scrypt)(password, salt, { N: n, dkLen: 32, r, p })).slice(2);\n    return defineKey({\n        iv,\n        key: () => key,\n        kdfparams: {\n            dklen: 32,\n            n,\n            p,\n            r,\n            salt: _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(salt).slice(2),\n        },\n        kdf: 'scrypt',\n    });\n}\n/**\n * Derives a key from a password using [scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const key = await Keystore.scryptAsync({ password: 'testpassword' })\n * ```\n *\n * @param options - Scrypt options.\n * @returns Scrypt key.\n */\nasync function scryptAsync(options) {\n    const { iv, n = 262_144, password } = options;\n    const p = 8;\n    const r = 1;\n    const salt = options.salt ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(options.salt) : _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.random(32);\n    const key = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(await (0,_noble_hashes_scrypt__WEBPACK_IMPORTED_MODULE_5__.scryptAsync)(password, salt, { N: n, dkLen: 32, r, p })).slice(2);\n    return defineKey({\n        iv,\n        key: () => key,\n        kdfparams: {\n            dklen: 32,\n            n,\n            p,\n            r,\n            salt: _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toHex(salt).slice(2),\n        },\n        kdf: 'scrypt',\n    });\n}\n///////////////////////////////////////////////////////////////////////////\n/** @internal */\nfunction defineKey(key) {\n    const iv = key.iv ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(key.iv) : _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.random(16);\n    return { ...key, iv };\n}\n//# sourceMappingURL=Keystore.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9LZXlzdG9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUM7QUFDd0Q7QUFDQTtBQUNyRDtBQUNSO0FBQ0Y7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsS0FBSztBQUNyQztBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0RBQWtEO0FBQ3pELFlBQVksYUFBYTtBQUN6QixpQkFBaUIsMkNBQVUsTUFBTSxVQUFVO0FBQzNDLG1CQUFtQiw0Q0FBVztBQUM5QixtQkFBbUIsNENBQVc7QUFDOUIsdUJBQXVCLDJDQUFVLE1BQU0sMkJBQTJCO0FBQ2xFLGdCQUFnQiwrQ0FBYyxDQUFDLDZDQUFZO0FBQzNDLFNBQVMsOENBQWEsTUFBTSwyQ0FBVSxNQUFNLG9CQUFvQjtBQUNoRTtBQUNBLGlCQUFpQix1REFBRztBQUNwQjtBQUNBLGVBQWUsNENBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvREFBb0Q7QUFDM0QsWUFBWSwyQkFBMkI7QUFDdkMsaUJBQWlCLDJDQUFVLE1BQU0sVUFBVTtBQUMzQyxtQkFBbUIsMkNBQVU7QUFDN0IsbUJBQW1CLDRDQUFXO0FBQzlCLG1CQUFtQiw0Q0FBVztBQUM5Qix1QkFBdUIsdURBQUc7QUFDMUIsZ0JBQWdCLCtDQUFjLENBQUMsNkNBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUFXO0FBQ25DLDRCQUE0QixJQUFJLDRDQUFXLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0EsaUJBQWlCLDRDQUFXO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUNBQXFDO0FBQ2pELGdDQUFnQywyQ0FBVSxpQkFBaUIsNkNBQVk7QUFDdkUsZ0JBQWdCLDRDQUFXLENBQUMsNERBQVksQ0FBQyxzREFBTSxvQkFBb0IsMEJBQTBCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFXO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSw0Q0FBNEMsMEJBQTBCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUNBQXFDO0FBQ2pELGdDQUFnQywyQ0FBVSxpQkFBaUIsNkNBQVk7QUFDdkUsZ0JBQWdCLDRDQUFXLE9BQU8saUVBQWlCLENBQUMsc0RBQU07QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBVztBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0EsZ0NBQWdDLDJDQUFVLGlCQUFpQiw2Q0FBWTtBQUN2RSxnQkFBZ0IsNENBQVcsQ0FBQyw0REFBWSxtQkFBbUIsdUJBQXVCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQVc7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBLGdDQUFnQywyQ0FBVSxpQkFBaUIsNkNBQVk7QUFDdkUsZ0JBQWdCLDRDQUFXLE9BQU8saUVBQWlCLG1CQUFtQix1QkFBdUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBVztBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkNBQVUsV0FBVyw2Q0FBWTtBQUN6RCxhQUFhO0FBQ2I7QUFDQSxvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0tleXN0b3JlLmpzPzA5MzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3RyIH0gZnJvbSAnQG5vYmxlL2NpcGhlcnMvYWVzJztcbmltcG9ydCB7IHBia2RmMkFzeW5jIGFzIHBia2RmMkFzeW5jX25vYmxlLCBwYmtkZjIgYXMgcGJrZGYyX25vYmxlLCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcGJrZGYyJztcbmltcG9ydCB7IHNjcnlwdEFzeW5jIGFzIHNjcnlwdEFzeW5jX25vYmxlLCBzY3J5cHQgYXMgc2NyeXB0X25vYmxlLCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2NyeXB0JztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbi8qKlxuICogRGVjcnlwdHMgYSBbSlNPTiBrZXlzdG9yZV0oaHR0cHM6Ly9ldGhlcmV1bS5vcmcvZW4vZGV2ZWxvcGVycy9kb2NzL2RhdGEtc3RydWN0dXJlcy1hbmQtZW5jb2Rpbmcvd2ViMy1zZWNyZXQtc3RvcmFnZS8pXG4gKiBpbnRvIGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogU3VwcG9ydHMgdGhlIGZvbGxvd2luZyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbnMgKEtERnMpOlxuICogLSB7QGxpbmsgb3gjS2V5c3RvcmUuKHBia2RmMjpmdW5jdGlvbil9XG4gKiAtIHtAbGluayBveCNLZXlzdG9yZS4oc2NyeXB0OmZ1bmN0aW9uKX1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgS2V5c3RvcmUsIFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIC8vIEpTT04ga2V5c3RvcmUuXG4gKiBjb25zdCBrZXlzdG9yZSA9IHsgY3J5cHRvOiB7IC4uLiB9LCBpZDogJy4uLicsIHZlcnNpb246IDMgfVxuICpcbiAqIC8vIERlcml2ZSBrZXkgZnJvbSBwYXNzd29yZC5cbiAqIGNvbnN0IGtleSA9IEtleXN0b3JlLnBia2RmMih7IHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkJyB9KVxuICpcbiAqIC8vIERlY3J5cHQgdGhlIHByaXZhdGUga2V5LlxuICogY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IEtleXN0b3JlLmRlY3J5cHQoa2V5c3RvcmUsIGtleSlcbiAqIC8vIEBsb2c6IFwiMHguLi5cIlxuICogYGBgXG4gKlxuICogQHBhcmFtIGtleXN0b3JlIC0gSlNPTiBrZXlzdG9yZS5cbiAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gdXNlIGZvciBkZWNyeXB0aW9uLlxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNyeXB0ZWQgcHJpdmF0ZSBrZXkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0KGtleXN0b3JlLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnSGV4JyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBrZXlfID0gQnl0ZXMuZnJvbShgMHgke2tleS5rZXkoKX1gKTtcbiAgICBjb25zdCBlbmNLZXkgPSBCeXRlcy5zbGljZShrZXlfLCAwLCAxNik7XG4gICAgY29uc3QgbWFjS2V5ID0gQnl0ZXMuc2xpY2Uoa2V5XywgMTYsIDMyKTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gQnl0ZXMuZnJvbShgMHgke2tleXN0b3JlLmNyeXB0by5jaXBoZXJ0ZXh0fWApO1xuICAgIGNvbnN0IG1hYyA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmNvbmNhdChtYWNLZXksIGNpcGhlcnRleHQpKTtcbiAgICBpZiAoIUJ5dGVzLmlzRXF1YWwobWFjLCBCeXRlcy5mcm9tKGAweCR7a2V5c3RvcmUuY3J5cHRvLm1hY31gKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29ycnVwdCBrZXlzdG9yZScpO1xuICAgIGNvbnN0IGRhdGEgPSBjdHIoZW5jS2V5LCBrZXkuaXYpLmRlY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgaWYgKGFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEJ5dGVzLnRvSGV4KGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBFbmNyeXB0cyBhIHByaXZhdGUga2V5IGFzIGEgW0pTT04ga2V5c3RvcmVdKGh0dHBzOi8vZXRoZXJldW0ub3JnL2VuL2RldmVsb3BlcnMvZG9jcy9kYXRhLXN0cnVjdHVyZXMtYW5kLWVuY29kaW5nL3dlYjMtc2VjcmV0LXN0b3JhZ2UvKVxuICogdXNpbmcgYSBkZXJpdmVkIGtleS5cbiAqXG4gKiBTdXBwb3J0cyB0aGUgZm9sbG93aW5nIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9ucyAoS0RGcyk6XG4gKiAtIHtAbGluayBveCNLZXlzdG9yZS4ocGJrZGYyOmZ1bmN0aW9uKX1cbiAqIC0ge0BsaW5rIG94I0tleXN0b3JlLihzY3J5cHQ6ZnVuY3Rpb24pfVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgS2V5c3RvcmUsIFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIC8vIEdlbmVyYXRlIGEgcmFuZG9tIHByaXZhdGUga2V5LlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqXG4gKiAvLyBEZXJpdmUga2V5IGZyb20gcGFzc3dvcmQuXG4gKiBjb25zdCBrZXkgPSBLZXlzdG9yZS5wYmtkZjIoeyBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZCcgfSlcbiAqXG4gKiAvLyBFbmNyeXB0IHRoZSBwcml2YXRlIGtleS5cbiAqIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IEtleXN0b3JlLmVuY3J5cHQocHJpdmF0ZUtleSwga2V5KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBcImNyeXB0b1wiOiB7XG4gKiAvLyBAbG9nOiAgICAgXCJjaXBoZXJcIjogXCJhZXMtMTI4LWN0clwiLFxuICogLy8gQGxvZzogICAgIFwiY2lwaGVydGV4dFwiOiBcIi4uLlwiLFxuICogLy8gQGxvZzogICAgIFwiY2lwaGVycGFyYW1zXCI6IHtcbiAqIC8vIEBsb2c6ICAgICAgIFwiaXZcIjogXCIuLi5cIixcbiAqIC8vIEBsb2c6ICAgICB9LFxuICogLy8gQGxvZzogICAgIFwia2RmXCI6IFwicGJrZGYyXCIsXG4gKiAvLyBAbG9nOiAgICAgXCJrZGZwYXJhbXNcIjoge1xuICogLy8gQGxvZzogICAgICAgXCJzYWx0XCI6IFwiLi4uXCIsXG4gKiAvLyBAbG9nOiAgICAgICBcImRrbGVuXCI6IDMyLFxuICogLy8gQGxvZzogICAgICAgXCJwcmZcIjogXCJobWFjLXNoYTI1NlwiLFxuICogLy8gQGxvZzogICAgICAgXCJjXCI6IDI2MjE0NCxcbiAqIC8vIEBsb2c6ICAgICB9LFxuICogLy8gQGxvZzogICAgIFwibWFjXCI6IFwiLi4uXCIsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIFwiaWRcIjogXCIuLi5cIixcbiAqIC8vIEBsb2c6ICAgXCJ2ZXJzaW9uXCI6IDMsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSAtIFByaXZhdGUga2V5IHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0ga2V5IC0gS2V5IHRvIHVzZSBmb3IgZW5jcnlwdGlvbi5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgRW5jcnlwdGVkIGtleXN0b3JlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChwcml2YXRlS2V5LCBrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgaWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGtleV8gPSBCeXRlcy5mcm9tKGAweCR7a2V5LmtleSgpfWApO1xuICAgIGNvbnN0IHZhbHVlXyA9IEJ5dGVzLmZyb20ocHJpdmF0ZUtleSk7XG4gICAgY29uc3QgZW5jS2V5ID0gQnl0ZXMuc2xpY2Uoa2V5XywgMCwgMTYpO1xuICAgIGNvbnN0IG1hY0tleSA9IEJ5dGVzLnNsaWNlKGtleV8sIDE2LCAzMik7XG4gICAgY29uc3QgY2lwaGVydGV4dCA9IGN0cihlbmNLZXksIGtleS5pdikuZW5jcnlwdCh2YWx1ZV8pO1xuICAgIGNvbnN0IG1hYyA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmNvbmNhdChtYWNLZXksIGNpcGhlcnRleHQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjcnlwdG86IHtcbiAgICAgICAgICAgIGNpcGhlcjogJ2Flcy0xMjgtY3RyJyxcbiAgICAgICAgICAgIGNpcGhlcnRleHQ6IEJ5dGVzLnRvSGV4KGNpcGhlcnRleHQpLnNsaWNlKDIpLFxuICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7IGl2OiBCeXRlcy50b0hleChrZXkuaXYpLnNsaWNlKDIpIH0sXG4gICAgICAgICAgICBrZGY6IGtleS5rZGYsXG4gICAgICAgICAgICBrZGZwYXJhbXM6IGtleS5rZGZwYXJhbXMsXG4gICAgICAgICAgICBtYWM6IEJ5dGVzLnRvSGV4KG1hYykuc2xpY2UoMiksXG4gICAgICAgIH0sXG4gICAgICAgIGlkLFxuICAgICAgICB2ZXJzaW9uOiAzLFxuICAgIH07XG59XG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkIHVzaW5nIFtQQktERjJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BCS0RGMikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBLZXlzdG9yZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGtleSA9IEtleXN0b3JlLnBia2RmMih7IHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBQQktERjIgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFBCS0RGMiBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjIob3B0aW9ucykge1xuICAgIGNvbnN0IHsgaXYsIGl0ZXJhdGlvbnMgPSAyNjJfMTQ0LCBwYXNzd29yZCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzYWx0ID0gb3B0aW9ucy5zYWx0ID8gQnl0ZXMuZnJvbShvcHRpb25zLnNhbHQpIDogQnl0ZXMucmFuZG9tKDMyKTtcbiAgICBjb25zdCBrZXkgPSBCeXRlcy50b0hleChwYmtkZjJfbm9ibGUoc2hhMjU2LCBwYXNzd29yZCwgc2FsdCwgeyBjOiBpdGVyYXRpb25zLCBka0xlbjogMzIgfSkpLnNsaWNlKDIpO1xuICAgIHJldHVybiBkZWZpbmVLZXkoe1xuICAgICAgICBpdixcbiAgICAgICAga2V5OiAoKSA9PiBrZXksXG4gICAgICAgIGtkZnBhcmFtczoge1xuICAgICAgICAgICAgYzogaXRlcmF0aW9ucyxcbiAgICAgICAgICAgIGRrbGVuOiAzMixcbiAgICAgICAgICAgIHByZjogJ2htYWMtc2hhMjU2JyxcbiAgICAgICAgICAgIHNhbHQ6IEJ5dGVzLnRvSGV4KHNhbHQpLnNsaWNlKDIpLFxuICAgICAgICB9LFxuICAgICAgICBrZGY6ICdwYmtkZjInLFxuICAgIH0pO1xufVxuLyoqXG4gKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZCB1c2luZyBbUEJLREYyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QQktERjIpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgS2V5c3RvcmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBrZXkgPSBhd2FpdCBLZXlzdG9yZS5wYmtkZjJBc3luYyh7IHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBQQktERjIgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFBCS0RGMiBrZXkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpdiwgaXRlcmF0aW9ucyA9IDI2Ml8xNDQsIHBhc3N3b3JkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHNhbHQgPSBvcHRpb25zLnNhbHQgPyBCeXRlcy5mcm9tKG9wdGlvbnMuc2FsdCkgOiBCeXRlcy5yYW5kb20oMzIpO1xuICAgIGNvbnN0IGtleSA9IEJ5dGVzLnRvSGV4KGF3YWl0IHBia2RmMkFzeW5jX25vYmxlKHNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHtcbiAgICAgICAgYzogaXRlcmF0aW9ucyxcbiAgICAgICAgZGtMZW46IDMyLFxuICAgIH0pKS5zbGljZSgyKTtcbiAgICByZXR1cm4gZGVmaW5lS2V5KHtcbiAgICAgICAgaXYsXG4gICAgICAgIGtleTogKCkgPT4ga2V5LFxuICAgICAgICBrZGZwYXJhbXM6IHtcbiAgICAgICAgICAgIGM6IGl0ZXJhdGlvbnMsXG4gICAgICAgICAgICBka2xlbjogMzIsXG4gICAgICAgICAgICBwcmY6ICdobWFjLXNoYTI1NicsXG4gICAgICAgICAgICBzYWx0OiBCeXRlcy50b0hleChzYWx0KS5zbGljZSgyKSxcbiAgICAgICAgfSxcbiAgICAgICAga2RmOiAncGJrZGYyJyxcbiAgICB9KTtcbn1cbi8qKlxuICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQgdXNpbmcgW3NjcnlwdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NyeXB0KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEtleXN0b3JlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qga2V5ID0gS2V5c3RvcmUuc2NyeXB0KHsgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQnIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNjcnlwdCBvcHRpb25zLlxuICogQHJldHVybnMgU2NyeXB0IGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcnlwdChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpdiwgbiA9IDI2Ml8xNDQsIHBhc3N3b3JkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHAgPSA4O1xuICAgIGNvbnN0IHIgPSAxO1xuICAgIGNvbnN0IHNhbHQgPSBvcHRpb25zLnNhbHQgPyBCeXRlcy5mcm9tKG9wdGlvbnMuc2FsdCkgOiBCeXRlcy5yYW5kb20oMzIpO1xuICAgIGNvbnN0IGtleSA9IEJ5dGVzLnRvSGV4KHNjcnlwdF9ub2JsZShwYXNzd29yZCwgc2FsdCwgeyBOOiBuLCBka0xlbjogMzIsIHIsIHAgfSkpLnNsaWNlKDIpO1xuICAgIHJldHVybiBkZWZpbmVLZXkoe1xuICAgICAgICBpdixcbiAgICAgICAga2V5OiAoKSA9PiBrZXksXG4gICAgICAgIGtkZnBhcmFtczoge1xuICAgICAgICAgICAgZGtsZW46IDMyLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgc2FsdDogQnl0ZXMudG9IZXgoc2FsdCkuc2xpY2UoMiksXG4gICAgICAgIH0sXG4gICAgICAgIGtkZjogJ3NjcnlwdCcsXG4gICAgfSk7XG59XG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkIHVzaW5nIFtzY3J5cHRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjcnlwdCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBLZXlzdG9yZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGtleSA9IGF3YWl0IEtleXN0b3JlLnNjcnlwdEFzeW5jKHsgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQnIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNjcnlwdCBvcHRpb25zLlxuICogQHJldHVybnMgU2NyeXB0IGtleS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjcnlwdEFzeW5jKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGl2LCBuID0gMjYyXzE0NCwgcGFzc3dvcmQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcCA9IDg7XG4gICAgY29uc3QgciA9IDE7XG4gICAgY29uc3Qgc2FsdCA9IG9wdGlvbnMuc2FsdCA/IEJ5dGVzLmZyb20ob3B0aW9ucy5zYWx0KSA6IEJ5dGVzLnJhbmRvbSgzMik7XG4gICAgY29uc3Qga2V5ID0gQnl0ZXMudG9IZXgoYXdhaXQgc2NyeXB0QXN5bmNfbm9ibGUocGFzc3dvcmQsIHNhbHQsIHsgTjogbiwgZGtMZW46IDMyLCByLCBwIH0pKS5zbGljZSgyKTtcbiAgICByZXR1cm4gZGVmaW5lS2V5KHtcbiAgICAgICAgaXYsXG4gICAgICAgIGtleTogKCkgPT4ga2V5LFxuICAgICAgICBrZGZwYXJhbXM6IHtcbiAgICAgICAgICAgIGRrbGVuOiAzMixcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIHNhbHQ6IEJ5dGVzLnRvSGV4KHNhbHQpLnNsaWNlKDIpLFxuICAgICAgICB9LFxuICAgICAgICBrZGY6ICdzY3J5cHQnLFxuICAgIH0pO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBkZWZpbmVLZXkoa2V5KSB7XG4gICAgY29uc3QgaXYgPSBrZXkuaXYgPyBCeXRlcy5mcm9tKGtleS5pdikgOiBCeXRlcy5yYW5kb20oMTYpO1xuICAgIHJldHVybiB7IC4uLmtleSwgaXYgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtleXN0b3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Keystore.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Kzg.js":
/*!*******************************************!*\
  !*** ../node_modules/ox/_esm/core/Kzg.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   versionedHashVersion: () => (/* binding */ versionedHashVersion)\n/* harmony export */ });\n/** @see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters */\nconst versionedHashVersion = 1;\n/**\n * Defines a KZG interface.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import * as cKzg from 'c-kzg'\n * import { Kzg } from 'ox'\n * import { Paths } from 'ox/trusted-setups'\n *\n * cKzg.loadTrustedSetup(Paths.mainnet)\n *\n * const kzg = Kzg.from(cKzg)\n * ```\n *\n * @param value - The KZG object to convert.\n * @returns The KZG interface object.\n */\nfunction from(value) {\n    const { blobToKzgCommitment, computeBlobKzgProof } = value;\n    return {\n        blobToKzgCommitment,\n        computeBlobKzgProof,\n    };\n}\n//# sourceMappingURL=Kzg.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9LemcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvS3pnLmpzPzM0YjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvYmxvYi9tYXN0ZXIvRUlQUy9laXAtNDg0NC5tZCNwYXJhbWV0ZXJzICovXG5leHBvcnQgY29uc3QgdmVyc2lvbmVkSGFzaFZlcnNpb24gPSAxO1xuLyoqXG4gKiBEZWZpbmVzIGEgS1pHIGludGVyZmFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0ICogYXMgY0t6ZyBmcm9tICdjLWt6ZydcbiAqIGltcG9ydCB7IEt6ZyB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgUGF0aHMgfSBmcm9tICdveC90cnVzdGVkLXNldHVwcydcbiAqXG4gKiBjS3pnLmxvYWRUcnVzdGVkU2V0dXAoUGF0aHMubWFpbm5ldClcbiAqXG4gKiBjb25zdCBremcgPSBLemcuZnJvbShjS3pnKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIEtaRyBvYmplY3QgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBLWkcgaW50ZXJmYWNlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBjb25zdCB7IGJsb2JUb0t6Z0NvbW1pdG1lbnQsIGNvbXB1dGVCbG9iS3pnUHJvb2YgfSA9IHZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJsb2JUb0t6Z0NvbW1pdG1lbnQsXG4gICAgICAgIGNvbXB1dGVCbG9iS3pnUHJvb2YsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUt6Zy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Kzg.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Log.js":
/*!*******************************************!*\
  !*** ../node_modules/ox/_esm/core/Log.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Log.Rpc} to an {@link ox#Log.Log}.\n *\n * @example\n * ```ts twoslash\n * import { Log } from 'ox'\n *\n * const log = Log.fromRpc({\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x0000000000000000000000000000000000000000000000000000000000000000',\n *     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n *     '0x000000000000000000000000000000000000000000000000000000000000025b',\n *   ],\n *   data: '0x',\n *   blockHash:\n *     '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n *   blockNumber: '0x12d846c',\n *   transactionHash:\n *     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n *   transactionIndex: '0x91',\n *   logIndex: '0x10f',\n *   removed: false,\n * })\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an example of how to use `Log.fromRpc` to instantiate a {@link ox#Log.Log} from an RPC log.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex, Log } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 indexed value)',\n * )\n *\n * const { topics } = AbiEvent.encode(transfer)\n *\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n *\n * const log = Log.fromRpc(logs[0]) // [!code focus]\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param log - The RPC log to convert.\n * @returns An instantiated {@link ox#Log.Log}.\n */\nfunction fromRpc(log, _options = {}) {\n    return {\n        ...log,\n        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n        logIndex: log.logIndex ? Number(log.logIndex) : null,\n        transactionIndex: log.transactionIndex\n            ? Number(log.transactionIndex)\n            : null,\n    };\n}\n/**\n * Converts a {@link ox#Log.Log} to a {@link ox#Log.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Log } from 'ox'\n *\n * const log = Log.toRpc({\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *   blockHash:\n *     '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n *   blockNumber: 19760236n,\n *   data: '0x',\n *   logIndex: 271,\n *   removed: false,\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x0000000000000000000000000000000000000000000000000000000000000000',\n *     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n *     '0x000000000000000000000000000000000000000000000000000000000000025b',\n *   ],\n *   transactionHash:\n *     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n *   transactionIndex: 145,\n * })\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: '0x012d846c',\n * // @log:   data: '0x',\n * // @log:   logIndex: '0x010f',\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n * // @log:     '0x0000000000000000000000000000000000000000000000000000000000000000',\n * // @log:     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n * // @log:     '0x000000000000000000000000000000000000000000000000000000000000025b',\n * // @log:   ],\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: '0x91',\n * // @log: }\n * ```\n *\n * @param log - The log to convert.\n * @returns An RPC log.\n */\nfunction toRpc(log, _options = {}) {\n    return {\n        address: log.address,\n        blockHash: log.blockHash,\n        blockNumber: typeof log.blockNumber === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(log.blockNumber)\n            : null,\n        data: log.data,\n        logIndex: typeof log.logIndex === 'number' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(log.logIndex) : null,\n        topics: log.topics,\n        transactionHash: log.transactionHash,\n        transactionIndex: typeof log.transactionIndex === 'number'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(log.transactionIndex)\n            : null,\n        removed: log.removed,\n    };\n}\n//# sourceMappingURL=Log.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Mb2cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQ2hDO0FBQ0EsZUFBZSxrQkFBa0IsT0FBTyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsa0JBQWtCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNPLG1DQUFtQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCLE1BQU0saUJBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUFjO0FBQzVCO0FBQ0E7QUFDQSxxREFBcUQsK0NBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQ0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvTG9nLmpzPzdjNTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjTG9nLlJwY30gdG8gYW4ge0BsaW5rIG94I0xvZy5Mb2d9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgTG9nIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbG9nID0gTG9nLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgdG9waWNzOiBbXG4gKiAgICAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZicsXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGMwNGQ5ZTkyNzhlYzVlNGQ0MjQ0NzZkM2ViZWM3MGNiNWQ2NDhkMScsXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDI1YicsXG4gKiAgIF0sXG4gKiAgIGRhdGE6ICcweCcsXG4gKiAgIGJsb2NrSGFzaDpcbiAqICAgICAnMHhhYmU2OTEzNGU4MGExMmY2YTkzZDBhYTE4MjE1YjViODZjMmZiMzM4YmFlOTExNzkwY2EzNzRhODcxNmUwMWE0JyxcbiAqICAgYmxvY2tOdW1iZXI6ICcweDEyZDg0NmMnLFxuICogICB0cmFuc2FjdGlvbkhhc2g6XG4gKiAgICAgJzB4Y2ZhNTJkYjBiYzJjYjViZGNiMmM1YmQ4ODE2ZGY3YTJmMDE4YTBlMzk2NGFiMWVmNGQ3OTRjZjMyNzk2NmU5MycsXG4gKiAgIHRyYW5zYWN0aW9uSW5kZXg6ICcweDkxJyxcbiAqICAgbG9nSW5kZXg6ICcweDEwZicsXG4gKiAgIHJlbW92ZWQ6IGZhbHNlLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4ZmJhMzkxMmNhMDRkZDQ1OGM4NDNlMmVlMDg5NjdmYzA0ZjM1NzljMicsXG4gKiAvLyBAbG9nOiAgIGJsb2NrSGFzaDogJzB4YWJlNjkxMzRlODBhMTJmNmE5M2QwYWExODIxNWI1Yjg2YzJmYjMzOGJhZTkxMTc5MGNhMzc0YTg3MTZlMDFhNCcsXG4gKiAvLyBAbG9nOiAgIGJsb2NrTnVtYmVyOiAxOTc2MDIzNm4sXG4gKiAvLyBAbG9nOiAgIGRhdGE6ICcweCcsXG4gKiAvLyBAbG9nOiAgIGxvZ0luZGV4OiAyNzEsXG4gKiAvLyBAbG9nOiAgIHJlbW92ZWQ6IGZhbHNlLFxuICogLy8gQGxvZzogICB0b3BpY3M6IFtcbiAqIC8vIEBsb2c6ICAgICBcIjB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZlwiLFxuICogLy8gQGxvZzogICAgIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gKiAvLyBAbG9nOiAgICAgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjMDRkOWU5Mjc4ZWM1ZTRkNDI0NDc2ZDNlYmVjNzBjYjVkNjQ4ZDFcIixcbiAqIC8vIEBsb2c6ICAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDI1YlwiLFxuICogLy8gQGxvZzogICB0cmFuc2FjdGlvbkhhc2g6XG4gKiAvLyBAbG9nOiAgICAgJzB4Y2ZhNTJkYjBiYzJjYjViZGNiMmM1YmQ4ODE2ZGY3YTJmMDE4YTBlMzk2NGFiMWVmNGQ3OTRjZjMyNzk2NmU5MycsXG4gKiAvLyBAbG9nOiAgIHRyYW5zYWN0aW9uSW5kZXg6IDE0NSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRW5kLXRvLWVuZFxuICpcbiAqIEJlbG93IGlzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHVzZSBgTG9nLmZyb21ScGNgIHRvIGluc3RhbnRpYXRlIGEge0BsaW5rIG94I0xvZy5Mb2d9IGZyb20gYW4gUlBDIGxvZy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBBYmlFdmVudCwgSGV4LCBMb2cgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmFuc2ZlciA9IEFiaUV2ZW50LmZyb20oXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIGluZGV4ZWQgZnJvbSwgYWRkcmVzcyBpbmRleGVkIHRvLCB1aW50MjU2IGluZGV4ZWQgdmFsdWUpJyxcbiAqIClcbiAqXG4gKiBjb25zdCB7IHRvcGljcyB9ID0gQWJpRXZlbnQuZW5jb2RlKHRyYW5zZmVyKVxuICpcbiAqIGNvbnN0IGxvZ3MgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0hLnJlcXVlc3Qoe1xuICogICBtZXRob2Q6ICdldGhfZ2V0TG9ncycsXG4gKiAgIHBhcmFtczogW1xuICogICAgIHtcbiAqICAgICAgIGFkZHJlc3M6ICcweGZiYTM5MTJjYTA0ZGQ0NThjODQzZTJlZTA4OTY3ZmMwNGYzNTc5YzInLFxuICogICAgICAgZnJvbUJsb2NrOiBIZXguZnJvbU51bWJlcigxOTc2MDIzNW4pLFxuICogICAgICAgdG9CbG9jazogSGV4LmZyb21OdW1iZXIoMTk3NjAyNDBuKSxcbiAqICAgICAgIHRvcGljcyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqXG4gKiBjb25zdCBsb2cgPSBMb2cuZnJvbVJwYyhsb2dzWzBdKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweGZiYTM5MTJjYTA0ZGQ0NThjODQzZTJlZTA4OTY3ZmMwNGYzNTc5YzInLFxuICogLy8gQGxvZzogICBibG9ja0hhc2g6ICcweGFiZTY5MTM0ZTgwYTEyZjZhOTNkMGFhMTgyMTViNWI4NmMyZmIzMzhiYWU5MTE3OTBjYTM3NGE4NzE2ZTAxYTQnLFxuICogLy8gQGxvZzogICBibG9ja051bWJlcjogMTk3NjAyMzZuLFxuICogLy8gQGxvZzogICBkYXRhOiAnMHgnLFxuICogLy8gQGxvZzogICBsb2dJbmRleDogMjcxLFxuICogLy8gQGxvZzogICByZW1vdmVkOiBmYWxzZSxcbiAqIC8vIEBsb2c6ICAgdG9waWNzOiBbXG4gKiAvLyBAbG9nOiAgICAgXCIweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWZcIixcbiAqIC8vIEBsb2c6ICAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICogLy8gQGxvZzogICAgIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzA0ZDllOTI3OGVjNWU0ZDQyNDQ3NmQzZWJlYzcwY2I1ZDY0OGQxXCIsXG4gKiAvLyBAbG9nOiAgICAgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyNWJcIixcbiAqIC8vIEBsb2c6ICAgdHJhbnNhY3Rpb25IYXNoOlxuICogLy8gQGxvZzogICAgICcweGNmYTUyZGIwYmMyY2I1YmRjYjJjNWJkODgxNmRmN2EyZjAxOGEwZTM5NjRhYjFlZjRkNzk0Y2YzMjc5NjZlOTMnLFxuICogLy8gQGxvZzogICB0cmFuc2FjdGlvbkluZGV4OiAxNDUsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRm9yIHNpbXBsaWNpdHksIHRoZSBhYm92ZSBleGFtcGxlIHVzZXMgYHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0YCwgYnV0IHlvdSBjYW4gdXNlIGFueVxuICogdHlwZSBvZiBKU09OLVJQQyBpbnRlcmZhY2UuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGxvZyAtIFRoZSBSUEMgbG9nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I0xvZy5Mb2d9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhsb2csIF9vcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5sb2csXG4gICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIgPyBCaWdJbnQobG9nLmJsb2NrTnVtYmVyKSA6IG51bGwsXG4gICAgICAgIGxvZ0luZGV4OiBsb2cubG9nSW5kZXggPyBOdW1iZXIobG9nLmxvZ0luZGV4KSA6IG51bGwsXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4XG4gICAgICAgICAgICA/IE51bWJlcihsb2cudHJhbnNhY3Rpb25JbmRleClcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNMb2cuTG9nfSB0byBhIHtAbGluayBveCNMb2cuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IExvZyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGxvZyA9IExvZy50b1JwYyh7XG4gKiAgIGFkZHJlc3M6ICcweGZiYTM5MTJjYTA0ZGQ0NThjODQzZTJlZTA4OTY3ZmMwNGYzNTc5YzInLFxuICogICBibG9ja0hhc2g6XG4gKiAgICAgJzB4YWJlNjkxMzRlODBhMTJmNmE5M2QwYWExODIxNWI1Yjg2YzJmYjMzOGJhZTkxMTc5MGNhMzc0YTg3MTZlMDFhNCcsXG4gKiAgIGJsb2NrTnVtYmVyOiAxOTc2MDIzNm4sXG4gKiAgIGRhdGE6ICcweCcsXG4gKiAgIGxvZ0luZGV4OiAyNzEsXG4gKiAgIHJlbW92ZWQ6IGZhbHNlLFxuICogICB0b3BpY3M6IFtcbiAqICAgICAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzA0ZDllOTI3OGVjNWU0ZDQyNDQ3NmQzZWJlYzcwY2I1ZDY0OGQxJyxcbiAqICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjViJyxcbiAqICAgXSxcbiAqICAgdHJhbnNhY3Rpb25IYXNoOlxuICogICAgICcweGNmYTUyZGIwYmMyY2I1YmRjYjJjNWJkODgxNmRmN2EyZjAxOGEwZTM5NjRhYjFlZjRkNzk0Y2YzMjc5NjZlOTMnLFxuICogICB0cmFuc2FjdGlvbkluZGV4OiAxNDUsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqIC8vIEBsb2c6ICAgYmxvY2tIYXNoOiAnMHhhYmU2OTEzNGU4MGExMmY2YTkzZDBhYTE4MjE1YjViODZjMmZiMzM4YmFlOTExNzkwY2EzNzRhODcxNmUwMWE0JyxcbiAqIC8vIEBsb2c6ICAgYmxvY2tOdW1iZXI6ICcweDAxMmQ4NDZjJyxcbiAqIC8vIEBsb2c6ICAgZGF0YTogJzB4JyxcbiAqIC8vIEBsb2c6ICAgbG9nSW5kZXg6ICcweDAxMGYnLFxuICogLy8gQGxvZzogICByZW1vdmVkOiBmYWxzZSxcbiAqIC8vIEBsb2c6ICAgdG9waWNzOiBbXG4gKiAvLyBAbG9nOiAgICAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZicsXG4gKiAvLyBAbG9nOiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGMwNGQ5ZTkyNzhlYzVlNGQ0MjQ0NzZkM2ViZWM3MGNiNWQ2NDhkMScsXG4gKiAvLyBAbG9nOiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDI1YicsXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiAgIHRyYW5zYWN0aW9uSGFzaDpcbiAqIC8vIEBsb2c6ICAgICAnMHhjZmE1MmRiMGJjMmNiNWJkY2IyYzViZDg4MTZkZjdhMmYwMThhMGUzOTY0YWIxZWY0ZDc5NGNmMzI3OTY2ZTkzJyxcbiAqIC8vIEBsb2c6ICAgdHJhbnNhY3Rpb25JbmRleDogJzB4OTEnLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGxvZyAtIFRoZSBsb2cgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQyBsb2cuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhsb2csIF9vcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICBibG9ja051bWJlcjogdHlwZW9mIGxvZy5ibG9ja051bWJlciA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8gSGV4LmZyb21OdW1iZXIobG9nLmJsb2NrTnVtYmVyKVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgbG9nSW5kZXg6IHR5cGVvZiBsb2cubG9nSW5kZXggPT09ICdudW1iZXInID8gSGV4LmZyb21OdW1iZXIobG9nLmxvZ0luZGV4KSA6IG51bGwsXG4gICAgICAgIHRvcGljczogbG9nLnRvcGljcyxcbiAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiB0eXBlb2YgbG9nLnRyYW5zYWN0aW9uSW5kZXggPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IEhleC5mcm9tTnVtYmVyKGxvZy50cmFuc2FjdGlvbkluZGV4KVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICByZW1vdmVkOiBsb2cucmVtb3ZlZCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Log.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Mnemonic.js":
/*!************************************************!*\
  !*** ../node_modules/ox/_esm/core/Mnemonic.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   czech: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.czech),\n/* harmony export */   english: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.english),\n/* harmony export */   french: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.french),\n/* harmony export */   italian: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.italian),\n/* harmony export */   japanese: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.japanese),\n/* harmony export */   korean: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.korean),\n/* harmony export */   path: () => (/* reexport safe */ _HdKey_js__WEBPACK_IMPORTED_MODULE_1__.path),\n/* harmony export */   portuguese: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.portuguese),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   simplifiedChinese: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.simplifiedChinese),\n/* harmony export */   spanish: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.spanish),\n/* harmony export */   toHdKey: () => (/* binding */ toHdKey),\n/* harmony export */   toPrivateKey: () => (/* binding */ toPrivateKey),\n/* harmony export */   toSeed: () => (/* binding */ toSeed),\n/* harmony export */   traditionalChinese: () => (/* reexport safe */ _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__.traditionalChinese),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _scure_bip39__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @scure/bip39 */ \"../node_modules/@scure/bip39/esm/index.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _HdKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HdKey.js */ \"../node_modules/ox/_esm/core/HdKey.js\");\n/* harmony import */ var _internal_mnemonic_wordlists_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/mnemonic/wordlists.js */ \"../node_modules/ox/_esm/core/internal/mnemonic/wordlists.js\");\n\n\n\n\n\n/**\n * Generates a random mnemonic.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * // @log: 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * ```\n *\n * @param wordlist - The wordlist to use.\n * @param options - Generation options.\n * @returns The mnemonic.\n */\nfunction random(wordlist, options = {}) {\n    const { strength = 128 } = options;\n    return (0,_scure_bip39__WEBPACK_IMPORTED_MODULE_0__.generateMnemonic)(wordlist, strength);\n}\n/**\n * Converts a mnemonic to a HD Key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic).derive(Mnemonic.path({ index: 1 }))\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The HD Key.\n */\nfunction toHdKey(mnemonic, options = {}) {\n    const { passphrase } = options;\n    const seed = toSeed(mnemonic, { passphrase });\n    return _HdKey_js__WEBPACK_IMPORTED_MODULE_1__.fromSeed(seed);\n}\n/**\n * Converts a mnemonic to a private key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic)\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Paths\n *\n * You can derive a private key at a specific path using the `path` option.\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic, {\n *   path: Mnemonic.path({ index: 1 }) // 'm/44'/60'/0'/0/1' // [!code focus]\n * })\n * // @log: '0x...'\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The private key.\n */\nfunction toPrivateKey(mnemonic, options = {}) {\n    const { path = _HdKey_js__WEBPACK_IMPORTED_MODULE_1__.path(), passphrase } = options;\n    const hdKey = toHdKey(mnemonic, { passphrase }).derive(path);\n    if (options.as === 'Bytes')\n        return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.from(hdKey.privateKey);\n    return hdKey.privateKey;\n}\n/**\n * Converts a mnemonic to a master seed.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const seed = Mnemonic.toSeed(mnemonic)\n * // @log: Uint8Array [...64 bytes]\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The master seed.\n */\nfunction toSeed(mnemonic, options = {}) {\n    const { passphrase } = options;\n    const seed = (0,_scure_bip39__WEBPACK_IMPORTED_MODULE_0__.mnemonicToSeedSync)(mnemonic, passphrase);\n    if (options.as === 'Hex')\n        return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toHex(seed);\n    return seed;\n}\n/**\n * Checks if a mnemonic is valid, given a wordlist.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.validate(\n *   'buyer zoo end danger ice capable shrug naive twist relief mass bonus',\n *   Mnemonic.english\n * )\n * // @log: true\n * ```\n *\n * @param mnemonic - The mnemonic to validate.\n * @param wordlist - The wordlist to use.\n * @returns Whether the mnemonic is valid.\n */\nfunction validate(mnemonic, wordlist) {\n    return (0,_scure_bip39__WEBPACK_IMPORTED_MODULE_0__.validateMnemonic)(mnemonic, wordlist);\n}\n//# sourceMappingURL=Mnemonic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9NbmVtb25pYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RjtBQUNuRDtBQUNBO0FBQ0Y7QUFDZ0k7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxpQkFBaUI7QUFDN0IsV0FBVyw4REFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QyxZQUFZLGFBQWE7QUFDekIsb0NBQW9DLFlBQVk7QUFDaEQsV0FBVywrQ0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRDQUE0QztBQUNuRCxZQUFZLE9BQU8sMkNBQVUsaUJBQWlCO0FBQzlDLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0EsZUFBZSwyQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLGFBQWE7QUFDekIsaUJBQWlCLGdFQUFrQjtBQUNuQztBQUNBLGVBQWUsNENBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDhEQUFnQjtBQUMzQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvTW5lbW9uaWMuanM/ZWU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW5lcmF0ZU1uZW1vbmljLCBtbmVtb25pY1RvU2VlZFN5bmMsIHZhbGlkYXRlTW5lbW9uaWMsIH0gZnJvbSAnQHNjdXJlL2JpcDM5JztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGRLZXkgZnJvbSAnLi9IZEtleS5qcyc7XG5leHBvcnQgeyBwYXRoIH0gZnJvbSAnLi9IZEtleS5qcyc7XG5leHBvcnQgeyBlbmdsaXNoLCBjemVjaCwgZnJlbmNoLCBpdGFsaWFuLCBqYXBhbmVzZSwga29yZWFuLCBwb3J0dWd1ZXNlLCBzaW1wbGlmaWVkQ2hpbmVzZSwgc3BhbmlzaCwgdHJhZGl0aW9uYWxDaGluZXNlLCB9IGZyb20gJy4vaW50ZXJuYWwvbW5lbW9uaWMvd29yZGxpc3RzLmpzJztcbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIG1uZW1vbmljLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLnJhbmRvbShNbmVtb25pYy5lbmdsaXNoKVxuICogLy8gQGxvZzogJ2J1eWVyIHpvbyBlbmQgZGFuZ2VyIGljZSBjYXBhYmxlIHNocnVnIG5haXZlIHR3aXN0IHJlbGllZiBtYXNzIGJvbnVzJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHdvcmRsaXN0IC0gVGhlIHdvcmRsaXN0IHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gR2VuZXJhdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIG1uZW1vbmljLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKHdvcmRsaXN0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmVuZ3RoID0gMTI4IH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCBzdHJlbmd0aCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbW5lbW9uaWMgdG8gYSBIRCBLZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBNbmVtb25pYyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IG1uZW1vbmljID0gTW5lbW9uaWMucmFuZG9tKE1uZW1vbmljLmVuZ2xpc2gpXG4gKiBjb25zdCBoZEtleSA9IE1uZW1vbmljLnRvSGRLZXkobW5lbW9uaWMpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFBhdGggRGVyaXZhdGlvblxuICpcbiAqIFlvdSBjYW4gZGVyaXZlIGEgSEQgS2V5IGF0IGEgc3BlY2lmaWMgcGF0aCB1c2luZyBgZGVyaXZlYDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLnJhbmRvbShNbmVtb25pYy5lbmdsaXNoKVxuICogY29uc3QgaGRLZXkgPSBNbmVtb25pYy50b0hkS2V5KG1uZW1vbmljKS5kZXJpdmUoTW5lbW9uaWMucGF0aCh7IGluZGV4OiAxIH0pKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG1uZW1vbmljIC0gVGhlIG1uZW1vbmljIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbnZlcnNpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBIRCBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hkS2V5KG1uZW1vbmljLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHBhc3NwaHJhc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VlZCA9IHRvU2VlZChtbmVtb25pYywgeyBwYXNzcGhyYXNlIH0pO1xuICAgIHJldHVybiBIZEtleS5mcm9tU2VlZChzZWVkKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBtbmVtb25pYyB0byBhIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLnJhbmRvbShNbmVtb25pYy5lbmdsaXNoKVxuICogY29uc3QgcHJpdmF0ZUtleSA9IE1uZW1vbmljLnRvUHJpdmF0ZUtleShtbmVtb25pYylcbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgUGF0aHNcbiAqXG4gKiBZb3UgY2FuIGRlcml2ZSBhIHByaXZhdGUga2V5IGF0IGEgc3BlY2lmaWMgcGF0aCB1c2luZyB0aGUgYHBhdGhgIG9wdGlvbi5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLnJhbmRvbShNbmVtb25pYy5lbmdsaXNoKVxuICogY29uc3QgcHJpdmF0ZUtleSA9IE1uZW1vbmljLnRvUHJpdmF0ZUtleShtbmVtb25pYywge1xuICogICBwYXRoOiBNbmVtb25pYy5wYXRoKHsgaW5kZXg6IDEgfSkgLy8gJ20vNDQnLzYwJy8wJy8wLzEnIC8vIFshY29kZSBmb2N1c11cbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbW5lbW9uaWMgLSBUaGUgbW5lbW9uaWMgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29udmVyc2lvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Qcml2YXRlS2V5KG1uZW1vbmljLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHBhdGggPSBIZEtleS5wYXRoKCksIHBhc3NwaHJhc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaGRLZXkgPSB0b0hkS2V5KG1uZW1vbmljLCB7IHBhc3NwaHJhc2UgfSkuZGVyaXZlKHBhdGgpO1xuICAgIGlmIChvcHRpb25zLmFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gQnl0ZXMuZnJvbShoZEtleS5wcml2YXRlS2V5KTtcbiAgICByZXR1cm4gaGRLZXkucHJpdmF0ZUtleTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBtbmVtb25pYyB0byBhIG1hc3RlciBzZWVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBtbmVtb25pYyA9IE1uZW1vbmljLnJhbmRvbShNbmVtb25pYy5lbmdsaXNoKVxuICogY29uc3Qgc2VlZCA9IE1uZW1vbmljLnRvU2VlZChtbmVtb25pYylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWy4uLjY0IGJ5dGVzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG1uZW1vbmljIC0gVGhlIG1uZW1vbmljIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbnZlcnNpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBtYXN0ZXIgc2VlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU2VlZChtbmVtb25pYywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwYXNzcGhyYXNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHNlZWQgPSBtbmVtb25pY1RvU2VlZFN5bmMobW5lbW9uaWMsIHBhc3NwaHJhc2UpO1xuICAgIGlmIChvcHRpb25zLmFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEJ5dGVzLnRvSGV4KHNlZWQpO1xuICAgIHJldHVybiBzZWVkO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBtbmVtb25pYyBpcyB2YWxpZCwgZ2l2ZW4gYSB3b3JkbGlzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IE1uZW1vbmljIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbW5lbW9uaWMgPSBNbmVtb25pYy52YWxpZGF0ZShcbiAqICAgJ2J1eWVyIHpvbyBlbmQgZGFuZ2VyIGljZSBjYXBhYmxlIHNocnVnIG5haXZlIHR3aXN0IHJlbGllZiBtYXNzIGJvbnVzJyxcbiAqICAgTW5lbW9uaWMuZW5nbGlzaFxuICogKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIG1uZW1vbmljIC0gVGhlIG1uZW1vbmljIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHdvcmRsaXN0IC0gVGhlIHdvcmRsaXN0IHRvIHVzZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG1uZW1vbmljIGlzIHZhbGlkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1uZW1vbmljLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Mnemonic.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/P256.js":
/*!********************************************!*\
  !*** ../node_modules/ox/_esm/core/P256.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/p256 */ \"../node_modules/ox/node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"../node_modules/ox/_esm/core/PublicKey.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/entropy.js */ \"../node_modules/ox/_esm/core/internal/entropy.js\");\n\n\n\n\n\n/** Re-export of noble/curves P256 utilities. */\nconst noble = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1;\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nfunction getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.ProjectivePoint.fromPrivateKey(typeof privateKey === 'string'\n        ? privateKey.slice(2)\n        : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nfunction randomPrivateKey(options = {}) {\n    const { as = 'Hex' } = options;\n    const bytes = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.utils.randomPrivateKey();\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nfunction recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const payload_ = payload instanceof Uint8Array ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(payload) : payload;\n    const point = signature_.recoverPublicKey(payload_.substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nfunction sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_3__.extraEntropy, hash, payload, privateKey, } = options;\n    const { r, s, recovery } = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.sign(payload instanceof Uint8Array ? payload : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(payload), privateKey instanceof Uint8Array ? privateKey : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(privateKey), {\n        extraEntropy: typeof extraEntropy === 'boolean'\n            ? extraEntropy\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...(hash ? { prehash: true } : {}),\n    });\n    return {\n        r,\n        s,\n        yParity: recovery,\n    };\n}\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nfunction verify(options) {\n    const { hash, payload, publicKey, signature } = options;\n    return _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.verify(signature, payload instanceof Uint8Array ? payload : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).substring(2), ...(hash ? [{ prehash: true, lowS: true }] : []));\n}\n//# sourceMappingURL=P256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9QMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQStDO0FBQ1g7QUFDSjtBQUNZO0FBQ0s7QUFDakQ7QUFDTyxjQUFjLHlEQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSx5Q0FBeUMscUJBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksYUFBYTtBQUN6QixrQkFBa0IseURBQVM7QUFDM0I7QUFDQSxVQUFVLDhDQUFhO0FBQ3ZCLFdBQVcsK0NBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDLFlBQVksYUFBYTtBQUN6QixrQkFBa0IseURBQVM7QUFDM0I7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksZ0JBQWdCO0FBQzVCLDJCQUEyQix5REFBUztBQUNwQyxxREFBcUQsOENBQWE7QUFDbEU7QUFDQSxXQUFXLCtDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDTztBQUNQLFlBQVksZUFBZSw4REFBb0IsK0JBQStCO0FBQzlFLFlBQVksaUJBQWlCLEVBQUUseURBQVMsZ0RBQWdELDhDQUFhLDJEQUEyRCw4Q0FBYTtBQUM3SztBQUNBO0FBQ0EsY0FBYyx5Q0FBUTtBQUN0QjtBQUNBLHFCQUFxQixnQkFBZ0IsSUFBSTtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRCxpQ0FBaUMsbUNBQW1DO0FBQ3BFO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHNDQUFzQztBQUNsRCxXQUFXLHlEQUFTLDZEQUE2RCw4Q0FBYSxXQUFXLGdEQUFlLHdDQUF3QywyQkFBMkI7QUFDM0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1AyNTYuanM/OTQ5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2cjEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3AyNTYnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgUHVibGljS2V5IGZyb20gJy4vUHVibGljS2V5LmpzJztcbmltcG9ydCAqIGFzIEVudHJvcHkgZnJvbSAnLi9pbnRlcm5hbC9lbnRyb3B5LmpzJztcbi8qKiBSZS1leHBvcnQgb2Ygbm9ibGUvY3VydmVzIFAyNTYgdXRpbGl0aWVzLiAqL1xuZXhwb3J0IGNvbnN0IG5vYmxlID0gc2VjcDI1NnIxO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgUDI1NiBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBwcm92aWRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQMjU2LmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29tcHV0ZSB0aGUgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIFRoZSBjb21wdXRlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHByaXZhdGVLZXkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2cjEuUHJvamVjdGl2ZVBvaW50LmZyb21Qcml2YXRlS2V5KHR5cGVvZiBwcml2YXRlS2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHByaXZhdGVLZXkuc2xpY2UoMilcbiAgICAgICAgOiBIZXguZnJvbUJ5dGVzKHByaXZhdGVLZXkpLnNsaWNlKDIpKTtcbiAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocG9pbnQpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gUDI1NiBFQ0RTQSBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gUDI1Ni5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHByaXZhdGUga2V5LlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBwcml2YXRlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVByaXZhdGVLZXkob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gc2VjcDI1NnIxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBSZWNvdmVycyB0aGUgc2lnbmluZyBwdWJsaWMga2V5IGZyb20gdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gUDI1Ni5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUDI1Ni5yZWNvdmVyUHVibGljS2V5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHJlY292ZXJlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IG5ldyBzZWNwMjU2cjEuU2lnbmF0dXJlKEJpZ0ludChyKSwgQmlnSW50KHMpKS5hZGRSZWNvdmVyeUJpdCh5UGFyaXR5KTtcbiAgICBjb25zdCBwYXlsb2FkXyA9IHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gSGV4LmZyb21CeXRlcyhwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgY29uc3QgcG9pbnQgPSBzaWduYXR1cmVfLnJlY292ZXJQdWJsaWNLZXkocGF5bG9hZF8uc3Vic3RyaW5nKDIpKTtcbiAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocG9pbnQpO1xufVxuLyoqXG4gKiBTaWducyB0aGUgcGF5bG9hZCB3aXRoIHRoZSBwcm92aWRlZCBwcml2YXRlIGtleSBhbmQgcmV0dXJucyBhIFAyNTYgc2lnbmF0dXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFAyNTYuc2lnbih7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEVDRFNBIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ24ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgZXh0cmFFbnRyb3B5ID0gRW50cm9weS5leHRyYUVudHJvcHksIGhhc2gsIHBheWxvYWQsIHByaXZhdGVLZXksIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgciwgcywgcmVjb3ZlcnkgfSA9IHNlY3AyNTZyMS5zaWduKHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gcGF5bG9hZCA6IEJ5dGVzLmZyb21IZXgocGF5bG9hZCksIHByaXZhdGVLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gcHJpdmF0ZUtleSA6IEJ5dGVzLmZyb21IZXgocHJpdmF0ZUtleSksIHtcbiAgICAgICAgZXh0cmFFbnRyb3B5OiB0eXBlb2YgZXh0cmFFbnRyb3B5ID09PSAnYm9vbGVhbidcbiAgICAgICAgICAgID8gZXh0cmFFbnRyb3B5XG4gICAgICAgICAgICA6IEhleC5mcm9tKGV4dHJhRW50cm9weSkuc2xpY2UoMiksXG4gICAgICAgIGxvd1M6IHRydWUsXG4gICAgICAgIC4uLihoYXNoID8geyBwcmVoYXNoOiB0cnVlIH0gOiB7fSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgeVBhcml0eTogcmVjb3ZlcnksXG4gICAgfTtcbn1cbi8qKlxuICogVmVyaWZpZXMgYSBwYXlsb2FkIHdhcyBzaWduZWQgYnkgdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBQMjU2LnJhbmRvbVByaXZhdGVLZXkoKVxuICogY29uc3QgcHVibGljS2V5ID0gUDI1Ni5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBzaWduYXR1cmUgPSBQMjU2LnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IFAyNTYudmVyaWZ5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwdWJsaWNLZXksIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgdmVyaWZpY2F0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwYXlsb2FkIHdhcyBzaWduZWQgYnkgdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgaGFzaCwgcGF5bG9hZCwgcHVibGljS2V5LCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHNlY3AyNTZyMS52ZXJpZnkoc2lnbmF0dXJlLCBwYXlsb2FkIGluc3RhbmNlb2YgVWludDhBcnJheSA/IHBheWxvYWQgOiBCeXRlcy5mcm9tSGV4KHBheWxvYWQpLCBQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KS5zdWJzdHJpbmcoMiksIC4uLihoYXNoID8gW3sgcHJlaGFzaDogdHJ1ZSwgbG93UzogdHJ1ZSB9XSA6IFtdKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/P256.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/PersonalMessage.js":
/*!*******************************************************!*\
  !*** ../node_modules/ox/_esm/core/PersonalMessage.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n/**\n * Encodes a personal sign message in [ERC-191 format](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e): `0x19  \"Ethereum Signed Message:\\n\" + message.length  message`.\n *\n * @example\n * ```ts twoslash\n * import { Hex, PersonalMessage } from 'ox'\n *\n * const data = PersonalMessage.encode(Hex.fromString('hello world'))\n * // @log: '0x19457468657265756d205369676e6564204d6573736167653a0a313168656c6c6f20776f726c64'\n * // @log: (0x19  'Ethereum Signed Message:\\n11'  'hello world')\n * ```\n *\n * @param data - The data to encode.\n * @returns The encoded personal sign message.\n */\nfunction encode(data) {\n    const message = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(data);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(\n    // Personal Sign Format: `0x19  \"Ethereum Signed Message:\\n\"  message.length  message`\n    '0x19', _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromString('Ethereum Signed Message:\\n' + _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(message)), message);\n}\n/**\n * Gets the payload to use for signing an [ERC-191 formatted](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e) personal message.\n *\n * @example\n * ```ts twoslash\n * import { Hex, PersonalMessage, Secp256k1 } from 'ox'\n *\n * const payload = PersonalMessage.getSignPayload(Hex.fromString('hello world')) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param data - The data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nfunction getSignPayload(data) {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(encode(data));\n}\n//# sourceMappingURL=PersonalMessage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9QZXJzb25hbE1lc3NhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNGO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQix5Q0FBUTtBQUM1QixXQUFXLDJDQUFVO0FBQ3JCO0FBQ0EsWUFBWSwrQ0FBYyxnQ0FBZ0MseUNBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhCQUE4QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLCtDQUFjO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9QZXJzb25hbE1lc3NhZ2UuanM/YWRiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBFbmNvZGVzIGEgcGVyc29uYWwgc2lnbiBtZXNzYWdlIGluIFtFUkMtMTkxIGZvcm1hdF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xOTEjdmVyc2lvbi0weDQ1LWUpOiBgMHgxOSDigJYgXCJFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIiArIG1lc3NhZ2UubGVuZ3RoIOKAliBtZXNzYWdlYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCwgUGVyc29uYWxNZXNzYWdlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IFBlcnNvbmFsTWVzc2FnZS5lbmNvZGUoSGV4LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnMHgxOTQ1NzQ2ODY1NzI2NTc1NmQyMDUzNjk2NzZlNjU2NDIwNGQ2NTczNzM2MTY3NjUzYTBhMzEzMTY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnXG4gKiAvLyBAbG9nOiAoMHgxOSDigJYgJ0V0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbjExJyDigJYgJ2hlbGxvIHdvcmxkJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgcGVyc29uYWwgc2lnbiBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gSGV4LmZyb20oZGF0YSk7XG4gICAgcmV0dXJuIEhleC5jb25jYXQoXG4gICAgLy8gUGVyc29uYWwgU2lnbiBGb3JtYXQ6IGAweDE5IOKAliBcIkV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiIOKAliBtZXNzYWdlLmxlbmd0aCDigJYgbWVzc2FnZWBcbiAgICAnMHgxOScsIEhleC5mcm9tU3RyaW5nKCdFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4nICsgSGV4LnNpemUobWVzc2FnZSkpLCBtZXNzYWdlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgcGF5bG9hZCB0byB1c2UgZm9yIHNpZ25pbmcgYW4gW0VSQy0xOTEgZm9ybWF0dGVkXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE5MSN2ZXJzaW9uLTB4NDUtZSkgcGVyc29uYWwgbWVzc2FnZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCwgUGVyc29uYWxNZXNzYWdlLCBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gUGVyc29uYWxNZXNzYWdlLmdldFNpZ25QYXlsb2FkKEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIGdldCB0aGUgc2lnbiBwYXlsb2FkIGZvci5cbiAqIEByZXR1cm5zIFRoZSBwYXlsb2FkIHRvIHVzZSBmb3Igc2lnbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGRhdGEpIHtcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoZW5jb2RlKGRhdGEpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlcnNvbmFsTWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/PersonalMessage.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Provider.js":
/*!************************************************!*\
  !*** ../node_modules/ox/_esm/core/Provider.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AtomicReadyWalletRejectedUpgradeError: () => (/* binding */ AtomicReadyWalletRejectedUpgradeError),\n/* harmony export */   AtomicityNotSupportedError: () => (/* binding */ AtomicityNotSupportedError),\n/* harmony export */   BundleTooLargeError: () => (/* binding */ BundleTooLargeError),\n/* harmony export */   ChainDisconnectedError: () => (/* binding */ ChainDisconnectedError),\n/* harmony export */   DisconnectedError: () => (/* binding */ DisconnectedError),\n/* harmony export */   DuplicateIdError: () => (/* binding */ DuplicateIdError),\n/* harmony export */   IsUndefinedError: () => (/* binding */ IsUndefinedError),\n/* harmony export */   ProviderRpcError: () => (/* binding */ ProviderRpcError),\n/* harmony export */   SwitchChainError: () => (/* binding */ SwitchChainError),\n/* harmony export */   UnauthorizedError: () => (/* binding */ UnauthorizedError),\n/* harmony export */   UnknownBundleIdError: () => (/* binding */ UnknownBundleIdError),\n/* harmony export */   UnsupportedChainIdError: () => (/* binding */ UnsupportedChainIdError),\n/* harmony export */   UnsupportedMethodError: () => (/* binding */ UnsupportedMethodError),\n/* harmony export */   UnsupportedNonOptionalCapabilityError: () => (/* binding */ UnsupportedNonOptionalCapabilityError),\n/* harmony export */   UserRejectedRequestError: () => (/* binding */ UserRejectedRequestError),\n/* harmony export */   createEmitter: () => (/* binding */ createEmitter),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   parseError: () => (/* binding */ parseError)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"eventemitter3\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _RpcResponse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RpcResponse.js */ \"../node_modules/ox/_esm/core/RpcResponse.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([eventemitter3__WEBPACK_IMPORTED_MODULE_0__]);\neventemitter3__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nclass ProviderRpcError extends Error {\n    constructor(code, message) {\n        super(message);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ProviderRpcError'\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.code = code;\n        this.details = message;\n    }\n}\n/** The user rejected the request. */\nclass UserRejectedRequestError extends ProviderRpcError {\n    constructor({ message = 'The user rejected the request.', } = {}) {\n        super(4001, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 4001\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.UserRejectedRequestError'\n        });\n    }\n}\nObject.defineProperty(UserRejectedRequestError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4001\n});\n/** The requested method and/or account has not been authorized by the user. */\nclass UnauthorizedError extends ProviderRpcError {\n    constructor({ message = 'The requested method and/or account has not been authorized by the user.', } = {}) {\n        super(4100, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 4100\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.UnauthorizedError'\n        });\n    }\n}\nObject.defineProperty(UnauthorizedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4100\n});\n/** The provider does not support the requested method. */\nclass UnsupportedMethodError extends ProviderRpcError {\n    constructor({ message = 'The provider does not support the requested method.', } = {}) {\n        super(4200, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 4200\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.UnsupportedMethodError'\n        });\n    }\n}\nObject.defineProperty(UnsupportedMethodError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4200\n});\n/** The provider is disconnected from all chains. */\nclass DisconnectedError extends ProviderRpcError {\n    constructor({ message = 'The provider is disconnected from all chains.', } = {}) {\n        super(4900, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 4900\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.DisconnectedError'\n        });\n    }\n}\nObject.defineProperty(DisconnectedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4900\n});\n/** The provider is not connected to the requested chain. */\nclass ChainDisconnectedError extends ProviderRpcError {\n    constructor({ message = 'The provider is not connected to the requested chain.', } = {}) {\n        super(4901, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 4901\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.ChainDisconnectedError'\n        });\n    }\n}\nObject.defineProperty(ChainDisconnectedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4901\n});\n/** An error occurred when attempting to switch chain. */\nclass SwitchChainError extends ProviderRpcError {\n    constructor({ message = 'An error occurred when attempting to switch chain.', } = {}) {\n        super(4902, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 4902\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.SwitchChainError'\n        });\n    }\n}\nObject.defineProperty(SwitchChainError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4902\n});\n/** This Wallet does not support a capability that was not marked as optional. */\nclass UnsupportedNonOptionalCapabilityError extends ProviderRpcError {\n    constructor({ message = 'This Wallet does not support a capability that was not marked as optional.', } = {}) {\n        super(5700, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5700\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.UnsupportedNonOptionalCapabilityError'\n        });\n    }\n}\nObject.defineProperty(UnsupportedNonOptionalCapabilityError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 5700\n});\n/** This Wallet does not support the requested chain ID. */\nclass UnsupportedChainIdError extends ProviderRpcError {\n    constructor({ message = 'This Wallet does not support the requested chain ID.', } = {}) {\n        super(5710, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5710\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.UnsupportedChainIdError'\n        });\n    }\n}\nObject.defineProperty(UnsupportedChainIdError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 5710\n});\n/** There is already a bundle submitted with this ID. */\nclass DuplicateIdError extends ProviderRpcError {\n    constructor({ message = 'There is already a bundle submitted with this ID.', } = {}) {\n        super(5720, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5720\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.DuplicateIdError'\n        });\n    }\n}\nObject.defineProperty(DuplicateIdError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 5720\n});\n/** This bundle id is unknown / has not been submitted. */\nclass UnknownBundleIdError extends ProviderRpcError {\n    constructor({ message = 'This bundle id is unknown / has not been submitted.', } = {}) {\n        super(5730, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5730\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.UnknownBundleIdError'\n        });\n    }\n}\nObject.defineProperty(UnknownBundleIdError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 5730\n});\n/** The call bundle is too large for the Wallet to process. */\nclass BundleTooLargeError extends ProviderRpcError {\n    constructor({ message = 'The call bundle is too large for the Wallet to process.', } = {}) {\n        super(5740, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5740\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.BundleTooLargeError'\n        });\n    }\n}\nObject.defineProperty(BundleTooLargeError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 5740\n});\n/** The Wallet can support atomicity after an upgrade, but the user rejected the upgrade. */\nclass AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {\n    constructor({ message = 'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.', } = {}) {\n        super(5750, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5750\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.AtomicReadyWalletRejectedUpgradeError'\n        });\n    }\n}\nObject.defineProperty(AtomicReadyWalletRejectedUpgradeError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 5750\n});\n/** The wallet does not support atomic execution but the request requires it. */\nclass AtomicityNotSupportedError extends ProviderRpcError {\n    constructor({ message = 'The wallet does not support atomic execution but the request requires it.', } = {}) {\n        super(5760, message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5760\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.AtomicityNotSupportedError'\n        });\n    }\n}\nObject.defineProperty(AtomicityNotSupportedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 5760\n});\n/**\n * Creates an EIP-1193 flavored event emitter to be injected onto a Provider.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox' // [!code focus]\n *\n * // 1. Instantiate a Provider Emitter. // [!code focus]\n * const emitter = Provider.createEmitter() // [!code focus]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider. // [!code focus]\n *   ...emitter, // [!code focus]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events. // [!code focus]\n * emitter.emit('accountsChanged', ['0x...']) // [!code focus]\n * ```\n *\n * @returns An event emitter.\n */\nfunction createEmitter() {\n    const emitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n    return {\n        get eventNames() {\n            return emitter.eventNames.bind(emitter);\n        },\n        get listenerCount() {\n            return emitter.listenerCount.bind(emitter);\n        },\n        get listeners() {\n            return emitter.listeners.bind(emitter);\n        },\n        addListener: emitter.addListener.bind(emitter),\n        emit: emitter.emit.bind(emitter),\n        off: emitter.off.bind(emitter),\n        on: emitter.on.bind(emitter),\n        once: emitter.once.bind(emitter),\n        removeAllListeners: emitter.removeAllListeners.bind(emitter),\n        removeListener: emitter.removeListener.bind(emitter),\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction from(provider, options = {}) {\n    const { includeEvents = true } = options;\n    if (!provider)\n        throw new IsUndefinedError();\n    return {\n        ...(includeEvents\n            ? {\n                on: provider.on?.bind(provider),\n                removeListener: provider.removeListener?.bind(provider),\n            }\n            : {}),\n        async request(args) {\n            try {\n                const result = await provider.request(args);\n                if (result &&\n                    typeof result === 'object' &&\n                    'jsonrpc' in result)\n                    return _RpcResponse_js__WEBPACK_IMPORTED_MODULE_1__.parse(result);\n                return result;\n            }\n            catch (error) {\n                throw parseError(error);\n            }\n        },\n    };\n}\n/**\n * Parses an error into a Provider error instance.\n *\n * @example\n * ```ts twoslash\n * import { Provider } from 'ox'\n *\n * const error = Provider.parseError({ code: 4200, message: 'foo' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - The error object to parse.\n * @returns An error instance.\n */\nfunction parseError(error) {\n    const error_ = _RpcResponse_js__WEBPACK_IMPORTED_MODULE_1__.parseError(error);\n    if (error_ instanceof _RpcResponse_js__WEBPACK_IMPORTED_MODULE_1__.InternalError) {\n        if (!error_.data)\n            return error_;\n        const { code } = error_.data;\n        if (code === DisconnectedError.code)\n            return new DisconnectedError(error_);\n        if (code === ChainDisconnectedError.code)\n            return new ChainDisconnectedError(error_);\n        if (code === UserRejectedRequestError.code)\n            return new UserRejectedRequestError(error_);\n        if (code === UnauthorizedError.code)\n            return new UnauthorizedError(error_);\n        if (code === UnsupportedMethodError.code)\n            return new UnsupportedMethodError(error_);\n        if (code === SwitchChainError.code)\n            return new SwitchChainError(error_);\n        if (code === AtomicReadyWalletRejectedUpgradeError.code)\n            return new AtomicReadyWalletRejectedUpgradeError(error_);\n        if (code === AtomicityNotSupportedError.code)\n            return new AtomicityNotSupportedError(error_);\n        if (code === BundleTooLargeError.code)\n            return new BundleTooLargeError(error_);\n        if (code === UnknownBundleIdError.code)\n            return new UnknownBundleIdError(error_);\n        if (code === DuplicateIdError.code)\n            return new DuplicateIdError(error_);\n        if (code === UnsupportedChainIdError.code)\n            return new UnsupportedChainIdError(error_);\n        if (code === UnsupportedNonOptionalCapabilityError.code)\n            return new UnsupportedNonOptionalCapabilityError(error_);\n    }\n    return error_;\n}\n/** Thrown when the provider is undefined. */\nclass IsUndefinedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('`provider` is undefined.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Provider.IsUndefinedError'\n        });\n    }\n}\n//# sourceMappingURL=Provider.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDUDtBQUNVO0FBQ3pDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQiw4Q0FBOEMsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1Asa0JBQWtCLHdGQUF3RixJQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUCxrQkFBa0IsbUVBQW1FLElBQUk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQLGtCQUFrQiw2REFBNkQsSUFBSTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1Asa0JBQWtC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QWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsdURBQXNCO0FBQ3pDLDBCQUEwQiwwREFBeUI7QUFDbkQ7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQixpREFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUHJvdmlkZXIuanM/ZTU2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBScGNSZXNwb25zZSBmcm9tICcuL1JwY1Jlc3BvbnNlLmpzJztcbmV4cG9ydCBjbGFzcyBQcm92aWRlclJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQcm92aWRlclJwY0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IG1lc3NhZ2U7XG4gICAgfVxufVxuLyoqIFRoZSB1c2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LiAqL1xuZXhwb3J0IGNsYXNzIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9ICdUaGUgdXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC4nLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoNDAwMSwgbWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDQwMDFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQcm92aWRlci5Vc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IsIFwiY29kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IDQwMDFcbn0pO1xuLyoqIFRoZSByZXF1ZXN0ZWQgbWV0aG9kIGFuZC9vciBhY2NvdW50IGhhcyBub3QgYmVlbiBhdXRob3JpemVkIGJ5IHRoZSB1c2VyLiAqL1xuZXhwb3J0IGNsYXNzIFVuYXV0aG9yaXplZEVycm9yIGV4dGVuZHMgUHJvdmlkZXJScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gJ1RoZSByZXF1ZXN0ZWQgbWV0aG9kIGFuZC9vciBhY2NvdW50IGhhcyBub3QgYmVlbiBhdXRob3JpemVkIGJ5IHRoZSB1c2VyLicsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcig0MTAwLCBtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNDEwMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1Byb3ZpZGVyLlVuYXV0aG9yaXplZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVW5hdXRob3JpemVkRXJyb3IsIFwiY29kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IDQxMDBcbn0pO1xuLyoqIFRoZSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgbWV0aG9kLiAqL1xuZXhwb3J0IGNsYXNzIFVuc3VwcG9ydGVkTWV0aG9kRXJyb3IgZXh0ZW5kcyBQcm92aWRlclJwY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSAnVGhlIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBtZXRob2QuJywgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKDQyMDAsIG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA0MjAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHJvdmlkZXIuVW5zdXBwb3J0ZWRNZXRob2RFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVuc3VwcG9ydGVkTWV0aG9kRXJyb3IsIFwiY29kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IDQyMDBcbn0pO1xuLyoqIFRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgY2hhaW5zLiAqL1xuZXhwb3J0IGNsYXNzIERpc2Nvbm5lY3RlZEVycm9yIGV4dGVuZHMgUHJvdmlkZXJScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gJ1RoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgY2hhaW5zLicsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcig0OTAwLCBtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNDkwMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1Byb3ZpZGVyLkRpc2Nvbm5lY3RlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGlzY29ubmVjdGVkRXJyb3IsIFwiY29kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IDQ5MDBcbn0pO1xuLyoqIFRoZSBwcm92aWRlciBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSByZXF1ZXN0ZWQgY2hhaW4uICovXG5leHBvcnQgY2xhc3MgQ2hhaW5EaXNjb25uZWN0ZWRFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9ICdUaGUgcHJvdmlkZXIgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgcmVxdWVzdGVkIGNoYWluLicsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcig0OTAxLCBtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNDkwMVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1Byb3ZpZGVyLkNoYWluRGlzY29ubmVjdGVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFpbkRpc2Nvbm5lY3RlZEVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiA0OTAxXG59KTtcbi8qKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIGF0dGVtcHRpbmcgdG8gc3dpdGNoIGNoYWluLiAqL1xuZXhwb3J0IGNsYXNzIFN3aXRjaENoYWluRXJyb3IgZXh0ZW5kcyBQcm92aWRlclJwY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSAnQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiBhdHRlbXB0aW5nIHRvIHN3aXRjaCBjaGFpbi4nLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoNDkwMiwgbWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDQ5MDJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQcm92aWRlci5Td2l0Y2hDaGFpbkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3dpdGNoQ2hhaW5FcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogNDkwMlxufSk7XG4vKiogVGhpcyBXYWxsZXQgZG9lcyBub3Qgc3VwcG9ydCBhIGNhcGFiaWxpdHkgdGhhdCB3YXMgbm90IG1hcmtlZCBhcyBvcHRpb25hbC4gKi9cbmV4cG9ydCBjbGFzcyBVbnN1cHBvcnRlZE5vbk9wdGlvbmFsQ2FwYWJpbGl0eUVycm9yIGV4dGVuZHMgUHJvdmlkZXJScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gJ1RoaXMgV2FsbGV0IGRvZXMgbm90IHN1cHBvcnQgYSBjYXBhYmlsaXR5IHRoYXQgd2FzIG5vdCBtYXJrZWQgYXMgb3B0aW9uYWwuJywgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKDU3MDAsIG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA1NzAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHJvdmlkZXIuVW5zdXBwb3J0ZWROb25PcHRpb25hbENhcGFiaWxpdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVuc3VwcG9ydGVkTm9uT3B0aW9uYWxDYXBhYmlsaXR5RXJyb3IsIFwiY29kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IDU3MDBcbn0pO1xuLyoqIFRoaXMgV2FsbGV0IGRvZXMgbm90IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBjaGFpbiBJRC4gKi9cbmV4cG9ydCBjbGFzcyBVbnN1cHBvcnRlZENoYWluSWRFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9ICdUaGlzIFdhbGxldCBkb2VzIG5vdCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgY2hhaW4gSUQuJywgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKDU3MTAsIG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA1NzEwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHJvdmlkZXIuVW5zdXBwb3J0ZWRDaGFpbklkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbnN1cHBvcnRlZENoYWluSWRFcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogNTcxMFxufSk7XG4vKiogVGhlcmUgaXMgYWxyZWFkeSBhIGJ1bmRsZSBzdWJtaXR0ZWQgd2l0aCB0aGlzIElELiAqL1xuZXhwb3J0IGNsYXNzIER1cGxpY2F0ZUlkRXJyb3IgZXh0ZW5kcyBQcm92aWRlclJwY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSAnVGhlcmUgaXMgYWxyZWFkeSBhIGJ1bmRsZSBzdWJtaXR0ZWQgd2l0aCB0aGlzIElELicsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcig1NzIwLCBtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNTcyMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1Byb3ZpZGVyLkR1cGxpY2F0ZUlkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsaWNhdGVJZEVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiA1NzIwXG59KTtcbi8qKiBUaGlzIGJ1bmRsZSBpZCBpcyB1bmtub3duIC8gaGFzIG5vdCBiZWVuIHN1Ym1pdHRlZC4gKi9cbmV4cG9ydCBjbGFzcyBVbmtub3duQnVuZGxlSWRFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9ICdUaGlzIGJ1bmRsZSBpZCBpcyB1bmtub3duIC8gaGFzIG5vdCBiZWVuIHN1Ym1pdHRlZC4nLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoNTczMCwgbWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDU3MzBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQcm92aWRlci5Vbmtub3duQnVuZGxlSWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVua25vd25CdW5kbGVJZEVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiA1NzMwXG59KTtcbi8qKiBUaGUgY2FsbCBidW5kbGUgaXMgdG9vIGxhcmdlIGZvciB0aGUgV2FsbGV0IHRvIHByb2Nlc3MuICovXG5leHBvcnQgY2xhc3MgQnVuZGxlVG9vTGFyZ2VFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9ICdUaGUgY2FsbCBidW5kbGUgaXMgdG9vIGxhcmdlIGZvciB0aGUgV2FsbGV0IHRvIHByb2Nlc3MuJywgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKDU3NDAsIG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA1NzQwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHJvdmlkZXIuQnVuZGxlVG9vTGFyZ2VFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1bmRsZVRvb0xhcmdlRXJyb3IsIFwiY29kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IDU3NDBcbn0pO1xuLyoqIFRoZSBXYWxsZXQgY2FuIHN1cHBvcnQgYXRvbWljaXR5IGFmdGVyIGFuIHVwZ3JhZGUsIGJ1dCB0aGUgdXNlciByZWplY3RlZCB0aGUgdXBncmFkZS4gKi9cbmV4cG9ydCBjbGFzcyBBdG9taWNSZWFkeVdhbGxldFJlamVjdGVkVXBncmFkZUVycm9yIGV4dGVuZHMgUHJvdmlkZXJScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gJ1RoZSBXYWxsZXQgY2FuIHN1cHBvcnQgYXRvbWljaXR5IGFmdGVyIGFuIHVwZ3JhZGUsIGJ1dCB0aGUgdXNlciByZWplY3RlZCB0aGUgdXBncmFkZS4nLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoNTc1MCwgbWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDU3NTBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQcm92aWRlci5BdG9taWNSZWFkeVdhbGxldFJlamVjdGVkVXBncmFkZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXRvbWljUmVhZHlXYWxsZXRSZWplY3RlZFVwZ3JhZGVFcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogNTc1MFxufSk7XG4vKiogVGhlIHdhbGxldCBkb2VzIG5vdCBzdXBwb3J0IGF0b21pYyBleGVjdXRpb24gYnV0IHRoZSByZXF1ZXN0IHJlcXVpcmVzIGl0LiAqL1xuZXhwb3J0IGNsYXNzIEF0b21pY2l0eU5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgUHJvdmlkZXJScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gJ1RoZSB3YWxsZXQgZG9lcyBub3Qgc3VwcG9ydCBhdG9taWMgZXhlY3V0aW9uIGJ1dCB0aGUgcmVxdWVzdCByZXF1aXJlcyBpdC4nLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoNTc2MCwgbWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDU3NjBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQcm92aWRlci5BdG9taWNpdHlOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF0b21pY2l0eU5vdFN1cHBvcnRlZEVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiA1NzYwXG59KTtcbi8qKlxuICogQ3JlYXRlcyBhbiBFSVAtMTE5MyBmbGF2b3JlZCBldmVudCBlbWl0dGVyIHRvIGJlIGluamVjdGVkIG9udG8gYSBQcm92aWRlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgUHJvdmlkZXIsIFJwY1JlcXVlc3QsIFJwY1Jlc3BvbnNlIH0gZnJvbSAnb3gnIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiAvLyAxLiBJbnN0YW50aWF0ZSBhIFByb3ZpZGVyIEVtaXR0ZXIuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IGVtaXR0ZXIgPSBQcm92aWRlci5jcmVhdGVFbWl0dGVyKCkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHN0b3JlID0gUnBjUmVxdWVzdC5jcmVhdGVTdG9yZSgpXG4gKlxuICogY29uc3QgcHJvdmlkZXIgPSBQcm92aWRlci5mcm9tKHtcbiAqICAgLy8gMi4gUGFzcyB0aGUgRW1pdHRlciB0byB0aGUgUHJvdmlkZXIuIC8vIFshY29kZSBmb2N1c11cbiAqICAgLi4uZW1pdHRlciwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBhc3luYyByZXF1ZXN0KGFyZ3MpIHtcbiAqICAgICByZXR1cm4gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vMS5ycGMudGhpcmR3ZWIuY29tJywge1xuICogICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc3RvcmUucHJlcGFyZShhcmdzKSksXG4gKiAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAqICAgICAgIGhlYWRlcnM6IHtcbiAqICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAqICAgICAgIH0sXG4gKiAgICAgfSlcbiAqICAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpXG4gKiAgICAgICAudGhlbihScGNSZXNwb25zZS5wYXJzZSlcbiAqICAgfSxcbiAqIH0pXG4gKlxuICogLy8gMy4gRW1pdCBQcm92aWRlciBFdmVudHMuIC8vIFshY29kZSBmb2N1c11cbiAqIGVtaXR0ZXIuZW1pdCgnYWNjb3VudHNDaGFuZ2VkJywgWycweC4uLiddKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBbiBldmVudCBlbWl0dGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBldmVudE5hbWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnROYW1lcy5iaW5kKGVtaXR0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgbGlzdGVuZXJDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQuYmluZChlbWl0dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGxpc3RlbmVycygpIHtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycy5iaW5kKGVtaXR0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRMaXN0ZW5lcjogZW1pdHRlci5hZGRMaXN0ZW5lci5iaW5kKGVtaXR0ZXIpLFxuICAgICAgICBlbWl0OiBlbWl0dGVyLmVtaXQuYmluZChlbWl0dGVyKSxcbiAgICAgICAgb2ZmOiBlbWl0dGVyLm9mZi5iaW5kKGVtaXR0ZXIpLFxuICAgICAgICBvbjogZW1pdHRlci5vbi5iaW5kKGVtaXR0ZXIpLFxuICAgICAgICBvbmNlOiBlbWl0dGVyLm9uY2UuYmluZChlbWl0dGVyKSxcbiAgICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBlbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycy5iaW5kKGVtaXR0ZXIpLFxuICAgICAgICByZW1vdmVMaXN0ZW5lcjogZW1pdHRlci5yZW1vdmVMaXN0ZW5lci5iaW5kKGVtaXR0ZXIpLFxuICAgIH07XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20ocHJvdmlkZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgaW5jbHVkZUV2ZW50cyA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFwcm92aWRlcilcbiAgICAgICAgdGhyb3cgbmV3IElzVW5kZWZpbmVkRXJyb3IoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4oaW5jbHVkZUV2ZW50c1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgb246IHByb3ZpZGVyLm9uPy5iaW5kKHByb3ZpZGVyKSxcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcjogcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXI/LmJpbmQocHJvdmlkZXIpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgJ2pzb25ycGMnIGluIHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJwY1Jlc3BvbnNlLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IHBhcnNlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBhcnNlcyBhbiBlcnJvciBpbnRvIGEgUHJvdmlkZXIgZXJyb3IgaW5zdGFuY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVycm9yID0gUHJvdmlkZXIucGFyc2VFcnJvcih7IGNvZGU6IDQyMDAsIG1lc3NhZ2U6ICdmb28nIH0pXG4gKlxuICogZXJyb3JcbiAqIC8vIF4/XG4gKlxuICogYGBgXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB0byBwYXJzZS5cbiAqIEByZXR1cm5zIEFuIGVycm9yIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IGVycm9yXyA9IFJwY1Jlc3BvbnNlLnBhcnNlRXJyb3IoZXJyb3IpO1xuICAgIGlmIChlcnJvcl8gaW5zdGFuY2VvZiBScGNSZXNwb25zZS5JbnRlcm5hbEVycm9yKSB7XG4gICAgICAgIGlmICghZXJyb3JfLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gZXJyb3JfO1xuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yXy5kYXRhO1xuICAgICAgICBpZiAoY29kZSA9PT0gRGlzY29ubmVjdGVkRXJyb3IuY29kZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlzY29ubmVjdGVkRXJyb3IoZXJyb3JfKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IENoYWluRGlzY29ubmVjdGVkRXJyb3IuY29kZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5EaXNjb25uZWN0ZWRFcnJvcihlcnJvcl8pO1xuICAgICAgICBpZiAoY29kZSA9PT0gVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcihlcnJvcl8pO1xuICAgICAgICBpZiAoY29kZSA9PT0gVW5hdXRob3JpemVkRXJyb3IuY29kZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5hdXRob3JpemVkRXJyb3IoZXJyb3JfKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFVuc3VwcG9ydGVkTWV0aG9kRXJyb3IuY29kZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5zdXBwb3J0ZWRNZXRob2RFcnJvcihlcnJvcl8pO1xuICAgICAgICBpZiAoY29kZSA9PT0gU3dpdGNoQ2hhaW5FcnJvci5jb2RlKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTd2l0Y2hDaGFpbkVycm9yKGVycm9yXyk7XG4gICAgICAgIGlmIChjb2RlID09PSBBdG9taWNSZWFkeVdhbGxldFJlamVjdGVkVXBncmFkZUVycm9yLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0b21pY1JlYWR5V2FsbGV0UmVqZWN0ZWRVcGdyYWRlRXJyb3IoZXJyb3JfKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IEF0b21pY2l0eU5vdFN1cHBvcnRlZEVycm9yLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0b21pY2l0eU5vdFN1cHBvcnRlZEVycm9yKGVycm9yXyk7XG4gICAgICAgIGlmIChjb2RlID09PSBCdW5kbGVUb29MYXJnZUVycm9yLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1bmRsZVRvb0xhcmdlRXJyb3IoZXJyb3JfKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFVua25vd25CdW5kbGVJZEVycm9yLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVua25vd25CdW5kbGVJZEVycm9yKGVycm9yXyk7XG4gICAgICAgIGlmIChjb2RlID09PSBEdXBsaWNhdGVJZEVycm9yLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IER1cGxpY2F0ZUlkRXJyb3IoZXJyb3JfKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFVuc3VwcG9ydGVkQ2hhaW5JZEVycm9yLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuc3VwcG9ydGVkQ2hhaW5JZEVycm9yKGVycm9yXyk7XG4gICAgICAgIGlmIChjb2RlID09PSBVbnN1cHBvcnRlZE5vbk9wdGlvbmFsQ2FwYWJpbGl0eUVycm9yLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuc3VwcG9ydGVkTm9uT3B0aW9uYWxDYXBhYmlsaXR5RXJyb3IoZXJyb3JfKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yXztcbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZXIgaXMgdW5kZWZpbmVkLiAqL1xuZXhwb3J0IGNsYXNzIElzVW5kZWZpbmVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2Bwcm92aWRlcmAgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHJvdmlkZXIuSXNVbmRlZmluZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Provider.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/PublicKey.js":
/*!*************************************************!*\
  !*** ../node_modules/ox/_esm/core/PublicKey.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidCompressedPrefixError: () => (/* binding */ InvalidCompressedPrefixError),\n/* harmony export */   InvalidError: () => (/* binding */ InvalidError),\n/* harmony export */   InvalidPrefixError: () => (/* binding */ InvalidPrefixError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidUncompressedPrefixError: () => (/* binding */ InvalidUncompressedPrefixError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   compress: () => (/* binding */ compress),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Json.js */ \"../node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false ||\n        (typeof x === 'bigint' && typeof y === 'bigint')) {\n        if (prefix !== 4)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidUncompressedPrefixError(),\n            });\n        return;\n    }\n    // Compressed\n    if (compressed === true ||\n        (typeof x === 'bigint' && typeof y === 'undefined')) {\n        if (prefix !== 3 && prefix !== 2)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidCompressedPrefixError(),\n            });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({ publicKey });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nfunction compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x,\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nfunction from(value) {\n    const publicKey = (() => {\n        if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(value))\n            return fromHex(value);\n        if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.validate(value))\n            return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === 'bigint' && typeof y === 'bigint')\n            return { prefix: prefix ?? 0x04, x, y };\n        return { prefix, x };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromBytes(publicKey) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromHex(publicKey) {\n    if (publicKey.length !== 132 &&\n        publicKey.length !== 130 &&\n        publicKey.length !== 68)\n        throw new InvalidSerializedSizeError({ publicKey });\n    if (publicKey.length === 130) {\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 32));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y,\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y,\n        };\n    }\n    const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n    const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x,\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toBytes(publicKey, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(includePrefix ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(prefix, { size: 1 }) : '0x', _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(x, { size: 32 }), \n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(y, { size: 32 }) : '0x');\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nclass InvalidError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${_Json_js__WEBPACK_IMPORTED_MODULE_3__.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                'Public key must contain:',\n                '- an `x` and `prefix` value (compressed)',\n                '- an `x`, `y`, and `prefix` value (uncompressed)',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidError'\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */\nclass InvalidPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ prefix, cause }) {\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nclass InvalidCompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 2 or 3 for compressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidCompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nclass InvalidUncompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 4 for uncompressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidUncompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(publicKey))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidSerializedSizeError'\n        });\n    }\n}\n//# sourceMappingURL=PublicKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9QdWJsaWNLZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNOO0FBQ0U7QUFDbEM7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QyxZQUFZLGFBQWE7QUFDekIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QixlQUFlLDZCQUE2QixHQUFHLHFCQUFxQixNQUFNLGlCQUFpQjtBQUNsSjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtB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Z0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sNkNBQTZDLGlEQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMsaURBQWdCO0FBQ2hFLGtCQUFrQixXQUFXO0FBQzdCLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIseUNBQVEsQ0FBQyx5Q0FBUSxjQUFjO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUHVibGljS2V5LmpzPzhiMTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogUHVibGljS2V5LmFzc2VydCh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeTogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogfSlcbiAqIC8vIEBlcnJvcjogUHVibGljS2V5LkludmFsaWRFcnJvcjogVmFsdWUgXFxge1wieVwiOlwiMVwifVxcYCBpcyBub3QgYSB2YWxpZCBwdWJsaWMga2V5LlxuICogLy8gQGVycm9yOiBQdWJsaWMga2V5IG11c3QgY29udGFpbjpcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKVxuICogLy8gQGVycm9yOiAtIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb21wcmVzc2VkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgLy8gVW5jb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICdiaWdpbnQnKSkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHRydWUgfHxcbiAgICAgICAgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09IDMgJiYgcHJlZml4ICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVW5rbm93bi9pbnZhbGlkXG4gICAgdGhyb3cgbmV3IEludmFsaWRFcnJvcih7IHB1YmxpY0tleSB9KTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgY29tcHJlc3NlZCA9IFB1YmxpY0tleS5jb21wcmVzcyhwdWJsaWNLZXkpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiAzLFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gY29tcHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3MocHVibGljS2V5KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiB5ICUgMm4gPT09IDBuID8gMiA6IDMsXG4gICAgICAgIHgsXG4gICAgfTtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgdHlwZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IG9iamVjdCBmcm9tIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgcHVibGljIGtleSB2YWx1ZSB0byBpbnN0YW50aWF0ZS5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgICAgICBpZiAoQnl0ZXMudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCA/PyAweDA0LCB4LCB5IH07XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgeCB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMjgsIDMsIDEzMSwgLi4uXSkpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHB1YmxpY0tleSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tSGV4KCcweDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiA0LFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVzZXJpYWxpemluZyBhIENvbXByZXNzZWQgUHVibGljIEtleVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUhleCgnMHgwMzgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDMsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMTMyICYmXG4gICAgICAgIHB1YmxpY0tleS5sZW5ndGggIT09IDEzMCAmJlxuICAgICAgICBwdWJsaWNLZXkubGVuZ3RoICE9PSA2OClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgcHVibGljS2V5IH0pO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzApIHtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAwLCAzMikpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMyLCA2NCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiA0LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzIpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gTnVtYmVyKEhleC5zbGljZShwdWJsaWNLZXksIDAsIDEpKTtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMzLCA2NSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IE51bWJlcihIZXguc2xpY2UocHVibGljS2V5LCAwLCAxKSk7XG4gICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgeCxcbiAgICB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGJ5dGVzID0gUHVibGljS2V5LnRvQnl0ZXMocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMjgsIDMsIDEzMSwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgocHVibGljS2V5LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoZXggPSBQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGFzc2VydChwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgY29uc3QgeyBpbmNsdWRlUHJlZml4ID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwdWJsaWNLZXlfID0gSGV4LmNvbmNhdChpbmNsdWRlUHJlZml4ID8gSGV4LmZyb21OdW1iZXIocHJlZml4LCB7IHNpemU6IDEgfSkgOiAnMHgnLCBIZXguZnJvbU51bWJlcih4LCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgcHVibGljIGtleSBpcyBub3QgY29tcHJlc3NlZCwgYWRkIHRoZSB5IGNvb3JkaW5hdGUuXG4gICAgdHlwZW9mIHkgPT09ICdiaWdpbnQnID8gSGV4LmZyb21OdW1iZXIoeSwgeyBzaXplOiAzMiB9KSA6ICcweCcpO1xuICAgIHJldHVybiBwdWJsaWNLZXlfO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0uIFJldHVybnMgYHRydWVgIGlmIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gUHVibGljS2V5LnZhbGlkYXRlKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB5OiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQocHVibGljS2V5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHB1YmxpYyBrZXkgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIFB1YmxpY0tleS5hc3NlcnQoeyB5OiAxbiB9KVxuICogLy8gQGVycm9yOiBQdWJsaWNLZXkuSW52YWxpZEVycm9yOiBWYWx1ZSBge1wieVwiOjFufWAgaXMgbm90IGEgdmFsaWQgcHVibGljIGtleS5cbiAqIC8vIEBlcnJvcjogUHVibGljIGtleSBtdXN0IGNvbnRhaW46XG4gKiAvLyBAZXJyb3I6IC0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZClcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAsIGB5YCwgYW5kIGBwcmVmaXhgIHZhbHVlICh1bmNvbXByZXNzZWQpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHVibGljS2V5IH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7SnNvbi5zdHJpbmdpZnkocHVibGljS2V5KX1cXGAgaXMgbm90IGEgdmFsaWQgcHVibGljIGtleS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnUHVibGljIGtleSBtdXN0IGNvbnRhaW46JyxcbiAgICAgICAgICAgICAgICAnLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKScsXG4gICAgICAgICAgICAgICAgJy0gYW4gYHhgLCBgeWAsIGFuZCBgcHJlZml4YCB2YWx1ZSAodW5jb21wcmVzc2VkKScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiBhIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4LCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBQcmVmaXggXCIke3ByZWZpeH1cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgcHVibGljIGtleSBoYXMgYW4gaW52YWxpZCBwcmVmaXggZm9yIGEgY29tcHJlc3NlZCBwdWJsaWMga2V5LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1ByZWZpeCBtdXN0IGJlIDIgb3IgMyBmb3IgY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkQ29tcHJlc3NlZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4IGZvciBhbiB1bmNvbXByZXNzZWQgcHVibGljIGtleS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1ByZWZpeCBtdXN0IGJlIDQgZm9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgcHVibGljIGtleSBoYXMgYW4gaW52YWxpZCBzZXJpYWxpemVkIHNpemUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3B1YmxpY0tleX1cXGAgaXMgYW4gaW52YWxpZCBwdWJsaWMga2V5IHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiAzMyBieXRlcyAoY29tcHJlc3NlZCArIHByZWZpeCksIDY0IGJ5dGVzICh1bmNvbXByZXNzZWQpIG9yIDY1IGJ5dGVzICh1bmNvbXByZXNzZWQgKyBwcmVmaXgpLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20ocHVibGljS2V5KSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHVibGljS2V5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/PublicKey.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Rlp.js":
/*!*******************************************!*\
  !*** ../node_modules/ox/_esm/core/Rlp.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: () => (/* binding */ decodeRlpCursor),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   readLength: () => (/* binding */ readLength),\n/* harmony export */   readList: () => (/* binding */ readList),\n/* harmony export */   to: () => (/* binding */ to),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"../node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nfunction toBytes(value) {\n    return to(value, 'Bytes');\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value) {\n    return to(value, 'Hex');\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */\nfunction to(value, to) {\n    const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes');\n    const bytes = (() => {\n        if (typeof value === 'string') {\n            if (value.length > 3 && value.length % 2 !== 0)\n                throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY,\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */\n/** @internal */\nfunction decodeRlpCursor(cursor, to = 'Hex') {\n    if (cursor.bytes.length === 0)\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes);\n    const prefix = cursor.readByte();\n    if (prefix < 0x80)\n        cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes);\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */\nfunction readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80)\n        return 1;\n    if (prefix <= offset + 55)\n        return prefix - offset;\n    if (prefix === offset + 55 + 1)\n        return cursor.readUint8();\n    if (prefix === offset + 55 + 2)\n        return cursor.readUint16();\n    if (prefix === offset + 55 + 3)\n        return cursor.readUint24();\n    if (prefix === offset + 55 + 4)\n        return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Invalid RLP prefix');\n}\n/** @internal */\nfunction readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while (cursor.position - position < length)\n        value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromBytes(bytes, options = {}) {\n    const { as = 'Bytes' } = options;\n    return from(bytes, { as });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromHex(hex, options = {}) {\n    const { as = 'Hex' } = options;\n    return from(hex, { as });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes))\n        return getEncodableList(bytes.map((x) => getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (() => {\n        if (bodyLength <= 55)\n            return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            }\n            else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1)\n                    cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2)\n                    cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3)\n                    cursor.pushUint24(bodyLength);\n                else\n                    cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list) {\n                encode(cursor);\n            }\n        },\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (() => {\n        if (bytes.length === 1 && bytes[0] < 0x80)\n            return 1;\n        if (bytes.length <= 55)\n            return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            }\n            else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            }\n            else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1)\n                    cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2)\n                    cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3)\n                    cursor.pushUint24(bytes.length);\n                else\n                    cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        },\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length < 2 ** 8)\n        return 1;\n    if (length < 2 ** 16)\n        return 2;\n    if (length < 2 ** 24)\n        return 3;\n    if (length < 2 ** 32)\n        return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Length is too large.');\n}\n//# sourceMappingURL=Rlp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFnQjtBQUM5QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzP2JmNzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEN1cnNvciBmcm9tICcuL2ludGVybmFsL2N1cnNvci5qcyc7XG4vKipcbiAqIERlY29kZXMgYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICogUmxwLnRvQnl0ZXMoJzB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIFVpbnQ4QXJyYXkoWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvKHZhbHVlLCAnQnl0ZXMnKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqIFJscC50b0hleCgnMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdG8odmFsdWUsICdIZXgnKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvKHZhbHVlLCB0bykge1xuICAgIGNvbnN0IHRvXyA9IHRvID8/ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBieXRlcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMyAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBIZXguSW52YWxpZExlbmd0aEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkoKTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzLCB7XG4gICAgICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvXyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0byA9ICdIZXgnKSB7XG4gICAgaWYgKGN1cnNvci5ieXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAodG8gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpIDogY3Vyc29yLmJ5dGVzKTtcbiAgICBjb25zdCBwcmVmaXggPSBjdXJzb3IucmVhZEJ5dGUoKTtcbiAgICBpZiAocHJlZml4IDwgMHg4MClcbiAgICAgICAgY3Vyc29yLmRlY3JlbWVudFBvc2l0aW9uKDEpO1xuICAgIC8vIGJ5dGVzXG4gICAgaWYgKHByZWZpeCA8IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHg4MCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoYnl0ZXMpIDogYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBsaXN0XG4gICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHhjMCk7XG4gICAgcmV0dXJuIHJlYWRMaXN0KGN1cnNvciwgbGVuZ3RoLCB0byk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMHg4MCAmJiBwcmVmaXggPCAweDgwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAocHJlZml4IDw9IG9mZnNldCArIDU1KVxuICAgICAgICByZXR1cm4gcHJlZml4IC0gb2Zmc2V0O1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMSlcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDgoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDIpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQxNigpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMylcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDI0KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyA0KVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MzIoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignSW52YWxpZCBSTFAgcHJlZml4Jyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExpc3QoY3Vyc29yLCBsZW5ndGgsIHRvKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjdXJzb3IucG9zaXRpb247XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvc2l0aW9uIC0gcG9zaXRpb24gPCBsZW5ndGgpXG4gICAgICAgIHZhbHVlLnB1c2goZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8pKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb20oJzB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcsIHsgYXM6ICdIZXgnIH0pXG4gKiAvLyBAbG9nOiAweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICpcbiAqIFJscC5mcm9tKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSwgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmNvZGFibGUgPSBnZXRFbmNvZGFibGUodmFsdWUpO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoZW5jb2RhYmxlLmxlbmd0aCkpO1xuICAgIGVuY29kYWJsZS5lbmNvZGUoY3Vyc29yKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpO1xuICAgIHJldHVybiBjdXJzb3IuYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGJ5dGVzLCB7IGFzIH0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tSGV4KCcweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gQGxvZzogMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGhleCwgeyBhcyB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlKGJ5dGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKVxuICAgICAgICByZXR1cm4gZ2V0RW5jb2RhYmxlTGlzdChieXRlcy5tYXAoKHgpID0+IGdldEVuY29kYWJsZSh4KSkpO1xuICAgIHJldHVybiBnZXRFbmNvZGFibGVCeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGVMaXN0KGxpc3QpIHtcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gbGlzdC5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpemVPZkJvZHlMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYm9keUxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpXG4gICAgICAgICAgICByZXR1cm4gMSArIGJvZHlMZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQm9keUxlbmd0aCArIGJvZHlMZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4YzAgKyBib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgNTUgKyBzaXplT2ZCb2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVuY29kZSB9IG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGUoY3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXNPckhleCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGJ5dGVzT3JIZXggPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChieXRlc09ySGV4KSA6IGJ5dGVzT3JIZXg7XG4gICAgY29uc3Qgc2l6ZU9mQnl0ZXNMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBieXRlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQnl0ZXNMZW5ndGggKyBieXRlcy5sZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDEgJiYgYnl0ZXNbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIDU1ICsgc2l6ZU9mQnl0ZXNMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2l6ZU9mTGVuZ3RoKGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPCAyICoqIDgpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChsZW5ndGggPCAyICoqIDE2KVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAobGVuZ3RoIDwgMiAqKiAyNClcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgaWYgKGxlbmd0aCA8IDIgKiogMzIpXG4gICAgICAgIHJldHVybiA0O1xuICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdMZW5ndGggaXMgdG9vIGxhcmdlLicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmxwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Rlp.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/RpcRequest.js":
/*!**************************************************!*\
  !*** ../node_modules/ox/_esm/core/RpcRequest.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/**\n * Creates a JSON-RPC request store to build requests with an incrementing `id`.\n *\n * Returns a type-safe `prepare` function to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request_1 = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n * // @log: { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber' }\n *\n * const request_2 = store.prepare({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       to: '0x0000000000000000000000000000000000000000',\n *       data: '0xdeadbeef',\n *     },\n *   ],\n * })\n * // @log: { id: 1, jsonrpc: '2.0', method: 'eth_call', params: [{ to: '0x0000000000000000000000000000000000000000', data: '0xdeadbeef' }] }\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using the {@link ox#RpcSchema.From} type.\n *\n * ```ts twoslash\n * import { RpcSchema, RpcRequest } from 'ox'\n *\n * type Schema = RpcSchema.From<{ // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobar' // [!code focus]\n *     params: [number] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * } | { // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobaz' // [!code focus]\n *     params: [string] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * }> // [!code focus]\n *\n * const store = RpcRequest.createStore<Schema>() // [!code focus]\n *\n * const request = store.prepare({\n *   method: 'eth_foobar', // [!code focus]\n *   // ^?\n *   params: [42],\n * })\n * ```\n *\n * @param options - Request store options.\n * @returns The request store\n */\nfunction createStore(options = {}) {\n    let id = options.id ?? 0;\n    return {\n        prepare(options) {\n            return from({\n                id: id++,\n                ...options,\n            });\n        },\n        get id() {\n            return id;\n        },\n    };\n}\n/**\n * A type-safe interface to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * :::warning\n *\n * You will likely want to use {@link ox#RpcRequest.(createStore:function)} instead as it will also manage `id`s and uses this function internally.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Build a request object.\n * const request = RpcRequest.from({ // [!code focus]\n *   id: 0, // [!code focus]\n *   method: 'eth_estimateGas', // [!code focus]\n *   params: [ // [!code focus]\n *     { // [!code focus]\n *       from: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]\n *       to: '0x0D44f617435088c947F00B31160f64b074e412B4', // [!code focus]\n *       value: '0x69420', // [!code focus]\n *     }, // [!code focus]\n *   ], // [!code focus]\n * }) // [!code focus]\n *\n * // 2. Send the JSON-RPC request via HTTP.\n * const gas = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 3. Parse the JSON-RPC response into a type-safe result.\n *  .then((response) => RpcResponse.parse(response, { request }))\n * ```\n *\n * @param options - JSON-RPC request options.\n * @returns The fully-formed JSON-RPC request object.\n */\nfunction from(options) {\n    return {\n        ...options,\n        jsonrpc: '2.0',\n    };\n}\n//# sourceMappingURL=RpcRequest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9ScGNSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0osY0FBYyxzREFBc0Qsc0VBQXNFO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UseUJBQXlCO0FBQzdGO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBLGtDQUFrQztBQUNsQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssSUFBSTtBQUNULGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRDQUE0QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUnBjUmVxdWVzdC5qcz8yNmViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlcyBhIEpTT04tUlBDIHJlcXVlc3Qgc3RvcmUgdG8gYnVpbGQgcmVxdWVzdHMgd2l0aCBhbiBpbmNyZW1lbnRpbmcgYGlkYC5cbiAqXG4gKiBSZXR1cm5zIGEgdHlwZS1zYWZlIGBwcmVwYXJlYCBmdW5jdGlvbiB0byBidWlsZCBhIEpTT04tUlBDIHJlcXVlc3Qgb2JqZWN0IGFzIHBlciB0aGUgW0pTT04tUlBDIDIuMCBzcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uI3JlcXVlc3Rfb2JqZWN0KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJwY1JlcXVlc3QgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzdG9yZSA9IFJwY1JlcXVlc3QuY3JlYXRlU3RvcmUoKVxuICpcbiAqIGNvbnN0IHJlcXVlc3RfMSA9IHN0b3JlLnByZXBhcmUoe1xuICogICBtZXRob2Q6ICdldGhfYmxvY2tOdW1iZXInLFxuICogfSlcbiAqIC8vIEBsb2c6IHsgaWQ6IDAsIGpzb25ycGM6ICcyLjAnLCBtZXRob2Q6ICdldGhfYmxvY2tOdW1iZXInIH1cbiAqXG4gKiBjb25zdCByZXF1ZXN0XzIgPSBzdG9yZS5wcmVwYXJlKHtcbiAqICAgbWV0aG9kOiAnZXRoX2NhbGwnLFxuICogICBwYXJhbXM6IFtcbiAqICAgICB7XG4gKiAgICAgICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7IGlkOiAxLCBqc29ucnBjOiAnMi4wJywgbWV0aG9kOiAnZXRoX2NhbGwnLCBwYXJhbXM6IFt7IHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgZGF0YTogJzB4ZGVhZGJlZWYnIH1dIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVHlwZS1zYWZlIEN1c3RvbSBTY2hlbWFzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gZGVmaW5lIHlvdXIgb3duIHR5cGUtc2FmZSBzY2hlbWEgYnkgdXNpbmcgdGhlIHtAbGluayBveCNScGNTY2hlbWEuRnJvbX0gdHlwZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjU2NoZW1hLCBScGNSZXF1ZXN0IH0gZnJvbSAnb3gnXG4gKlxuICogdHlwZSBTY2hlbWEgPSBScGNTY2hlbWEuRnJvbTx7IC8vIFshY29kZSBmb2N1c11cbiAqICAgUmVxdWVzdDogeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgICAgbWV0aG9kOiAnZXRoX2Zvb2JhcicgLy8gWyFjb2RlIGZvY3VzXVxuICogICAgIHBhcmFtczogW251bWJlcl0gLy8gWyFjb2RlIGZvY3VzXVxuICogICB9IC8vIFshY29kZSBmb2N1c11cbiAqICAgUmV0dXJuVHlwZTogc3RyaW5nIC8vIFshY29kZSBmb2N1c11cbiAqIH0gfCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgUmVxdWVzdDogeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgICAgbWV0aG9kOiAnZXRoX2Zvb2JheicgLy8gWyFjb2RlIGZvY3VzXVxuICogICAgIHBhcmFtczogW3N0cmluZ10gLy8gWyFjb2RlIGZvY3VzXVxuICogICB9IC8vIFshY29kZSBmb2N1c11cbiAqICAgUmV0dXJuVHlwZTogc3RyaW5nIC8vIFshY29kZSBmb2N1c11cbiAqIH0+IC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzdG9yZSA9IFJwY1JlcXVlc3QuY3JlYXRlU3RvcmU8U2NoZW1hPigpIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHJlcGFyZSh7XG4gKiAgIG1ldGhvZDogJ2V0aF9mb29iYXInLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIC8vIF4/XG4gKiAgIHBhcmFtczogWzQyXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgc3RvcmUgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSByZXF1ZXN0IHN0b3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yZShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgaWQgPSBvcHRpb25zLmlkID8/IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlcGFyZShvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbSh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkKyssXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQSB0eXBlLXNhZmUgaW50ZXJmYWNlIHRvIGJ1aWxkIGEgSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QgYXMgcGVyIHRoZSBbSlNPTi1SUEMgMi4wIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmpzb25ycGMub3JnL3NwZWNpZmljYXRpb24jcmVxdWVzdF9vYmplY3QpLlxuICpcbiAqIDo6Ondhcm5pbmdcbiAqXG4gKiBZb3Ugd2lsbCBsaWtlbHkgd2FudCB0byB1c2Uge0BsaW5rIG94I1JwY1JlcXVlc3QuKGNyZWF0ZVN0b3JlOmZ1bmN0aW9uKX0gaW5zdGVhZCBhcyBpdCB3aWxsIGFsc28gbWFuYWdlIGBpZGBzIGFuZCB1c2VzIHRoaXMgZnVuY3Rpb24gaW50ZXJuYWxseS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJwY1JlcXVlc3QsIFJwY1Jlc3BvbnNlIH0gZnJvbSAnb3gnXG4gKlxuICogLy8gMS4gQnVpbGQgYSByZXF1ZXN0IG9iamVjdC5cbiAqIGNvbnN0IHJlcXVlc3QgPSBScGNSZXF1ZXN0LmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGlkOiAwLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1ldGhvZDogJ2V0aF9lc3RpbWF0ZUdhcycsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGFyYW1zOiBbIC8vIFshY29kZSBmb2N1c11cbiAqICAgICB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgICAgIGZyb206ICcweGQyMTM1Q2ZCMjE2Yjc0MTA5Nzc1MjM2RTM2ZDRiNDMzRjFERjUwN0InLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgICAgICB0bzogJzB4MEQ0NGY2MTc0MzUwODhjOTQ3RjAwQjMxMTYwZjY0YjA3NGU0MTJCNCcsIC8vIFshY29kZSBmb2N1c11cbiAqICAgICAgIHZhbHVlOiAnMHg2OTQyMCcsIC8vIFshY29kZSBmb2N1c11cbiAqICAgICB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIF0sIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiAvLyAyLiBTZW5kIHRoZSBKU09OLVJQQyByZXF1ZXN0IHZpYSBIVFRQLlxuICogY29uc3QgZ2FzID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vMS5ycGMudGhpcmR3ZWIuY29tJywge1xuICogICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAqICAgaGVhZGVyczoge1xuICogICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gKiAgIH0sXG4gKiAgIG1ldGhvZDogJ1BPU1QnLFxuICogfSlcbiAqICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAqICAvLyAzLiBQYXJzZSB0aGUgSlNPTi1SUEMgcmVzcG9uc2UgaW50byBhIHR5cGUtc2FmZSByZXN1bHQuXG4gKiAgLnRoZW4oKHJlc3BvbnNlKSA9PiBScGNSZXNwb25zZS5wYXJzZShyZXNwb25zZSwgeyByZXF1ZXN0IH0pKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBKU09OLVJQQyByZXF1ZXN0IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZnVsbHktZm9ybWVkIEpTT04tUlBDIHJlcXVlc3Qgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJwY1JlcXVlc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/RpcRequest.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/RpcResponse.js":
/*!***************************************************!*\
  !*** ../node_modules/ox/_esm/core/RpcResponse.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   InternalError: () => (/* binding */ InternalError),\n/* harmony export */   InvalidInputError: () => (/* binding */ InvalidInputError),\n/* harmony export */   InvalidParamsError: () => (/* binding */ InvalidParamsError),\n/* harmony export */   InvalidRequestError: () => (/* binding */ InvalidRequestError),\n/* harmony export */   LimitExceededError: () => (/* binding */ LimitExceededError),\n/* harmony export */   MethodNotFoundError: () => (/* binding */ MethodNotFoundError),\n/* harmony export */   MethodNotSupportedError: () => (/* binding */ MethodNotSupportedError),\n/* harmony export */   ParseError: () => (/* binding */ ParseError),\n/* harmony export */   ResourceNotFoundError: () => (/* binding */ ResourceNotFoundError),\n/* harmony export */   ResourceUnavailableError: () => (/* binding */ ResourceUnavailableError),\n/* harmony export */   TransactionRejectedError: () => (/* binding */ TransactionRejectedError),\n/* harmony export */   VersionNotSupportedError: () => (/* binding */ VersionNotSupportedError),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseError: () => (/* binding */ parseError)\n/* harmony export */ });\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction from(response, options = {}) {\n    const { request } = options;\n    return {\n        ...response,\n        id: response.id ?? request?.id,\n        jsonrpc: response.jsonrpc ?? request.jsonrpc,\n    };\n}\n/**\n * A type-safe interface to parse a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object), and extract the result.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::tip\n *\n * If you don't need the return type, you can omit the options entirely.\n *\n * ```ts twoslash\n * // @noErrors\n * import { RpcResponse } from 'ox'\n *\n * const block = await fetch('https://1.rpc.thirdweb.com', {})\n *  .then((response) => response.json())\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code --]\n *  .then(RpcResponse.parse) // [!code ++]\n * ```\n * :::\n *\n * @example\n * ### Raw Mode\n *\n * If `raw` is `true`, the response will be returned as an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n *\n * const response = RpcResponse.parse({}, {\n *   request,\n *   raw: true, // [!code hl]\n * })\n *\n * response.result\n * //       ^?\n *\n *\n * response.error\n * //       ^?\n *\n *\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nfunction parse(response, options = {}) {\n    const { raw = false } = options;\n    const response_ = response;\n    if (raw)\n        return response;\n    if (response_.error)\n        throw parseError(response_.error);\n    return response_.result;\n}\n/**\n * Parses an error into a RPC Error instance.\n *\n * @example\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const error = RpcResponse.parseError({ code: -32000, message: 'unsupported method' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - Error.\n * @returns RPC Error instance.\n */\nfunction parseError(error) {\n    const error_ = error;\n    if (error_ instanceof Error && !('code' in error_))\n        return new InternalError({\n            cause: error_,\n            data: error_,\n            message: error_.message,\n        });\n    const { code } = error_;\n    if (code === InternalError.code)\n        return new InternalError(error_);\n    if (code === InvalidInputError.code)\n        return new InvalidInputError(error_);\n    if (code === InvalidParamsError.code)\n        return new InvalidParamsError(error_);\n    if (code === InvalidRequestError.code)\n        return new InvalidRequestError(error_);\n    if (code === LimitExceededError.code)\n        return new LimitExceededError(error_);\n    if (code === MethodNotFoundError.code)\n        return new MethodNotFoundError(error_);\n    if (code === MethodNotSupportedError.code)\n        return new MethodNotSupportedError(error_);\n    if (code === ParseError.code)\n        return new ParseError(error_);\n    if (code === ResourceNotFoundError.code)\n        return new ResourceNotFoundError(error_);\n    if (code === ResourceUnavailableError.code)\n        return new ResourceUnavailableError(error_);\n    if (code === TransactionRejectedError.code)\n        return new TransactionRejectedError(error_);\n    if (code === VersionNotSupportedError.code)\n        return new VersionNotSupportedError(error_);\n    return new InternalError({\n        cause: error_ instanceof Error ? error_ : undefined,\n        data: error_,\n        message: error_.message,\n    });\n}\n/** Thrown when a JSON-RPC error has occurred. */\nclass BaseError extends Error {\n    constructor(errorObject) {\n        const { cause, code, message, data } = errorObject;\n        super(message, { cause });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.BaseError'\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cause = cause;\n        this.code = code;\n        this.data = data;\n    }\n}\n/** Thrown when the input to a JSON-RPC method is invalid. */\nclass InvalidInputError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: InvalidInputError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Missing or invalid parameters.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32000\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.InvalidInputError'\n        });\n    }\n}\nObject.defineProperty(InvalidInputError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32000\n});\n/** Thrown when a JSON-RPC resource is not found. */\nclass ResourceNotFoundError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: ResourceNotFoundError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Requested resource not found.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32001\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.ResourceNotFoundError'\n        });\n    }\n}\nObject.defineProperty(ResourceNotFoundError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32001\n});\n/** Thrown when a JSON-RPC resource is unavailable. */\nclass ResourceUnavailableError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: ResourceUnavailableError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Requested resource not available.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32002\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.ResourceUnavailableError'\n        });\n    }\n}\nObject.defineProperty(ResourceUnavailableError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32002\n});\n/** Thrown when a JSON-RPC transaction is rejected. */\nclass TransactionRejectedError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: TransactionRejectedError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Transaction creation failed.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32003\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.TransactionRejectedError'\n        });\n    }\n}\nObject.defineProperty(TransactionRejectedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32003\n});\n/** Thrown when a JSON-RPC method is not supported. */\nclass MethodNotSupportedError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: MethodNotSupportedError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Method is not implemented.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32004\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.MethodNotSupportedError'\n        });\n    }\n}\nObject.defineProperty(MethodNotSupportedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32004\n});\n/** Thrown when a rate-limit is exceeded. */\nclass LimitExceededError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: LimitExceededError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Rate limit exceeded.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32005\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.LimitExceededError'\n        });\n    }\n}\nObject.defineProperty(LimitExceededError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32005\n});\n/** Thrown when a JSON-RPC version is not supported. */\nclass VersionNotSupportedError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: VersionNotSupportedError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'JSON-RPC version not supported.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32006\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.VersionNotSupportedError'\n        });\n    }\n}\nObject.defineProperty(VersionNotSupportedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32006\n});\n/** Thrown when a JSON-RPC request is invalid. */\nclass InvalidRequestError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: InvalidRequestError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Input is not a valid JSON-RPC request.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32600\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.InvalidRequestError'\n        });\n    }\n}\nObject.defineProperty(InvalidRequestError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32600\n});\n/** Thrown when a JSON-RPC method is not found. */\nclass MethodNotFoundError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: MethodNotFoundError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Method does not exist.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32601\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.MethodNotFoundError'\n        });\n    }\n}\nObject.defineProperty(MethodNotFoundError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32601\n});\n/** Thrown when the parameters to a JSON-RPC method are invalid. */\nclass InvalidParamsError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: InvalidParamsError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Invalid method parameters.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32602\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.InvalidParamsError'\n        });\n    }\n}\nObject.defineProperty(InvalidParamsError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32602\n});\n/** Thrown when an internal JSON-RPC error has occurred. */\nclass InternalError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            cause: parameters.cause,\n            code: InternalError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Internal JSON-RPC error.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32603\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.InternalError'\n        });\n    }\n}\nObject.defineProperty(InternalError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32603\n});\n/** Thrown when a JSON-RPC response is invalid. */\nclass ParseError extends BaseError {\n    constructor(parameters = {}) {\n        super({\n            code: ParseError.code,\n            data: parameters.data,\n            message: parameters.message ?? 'Failed to parse JSON-RPC response.',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: -32700\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcResponse.ParseError'\n        });\n    }\n}\nObject.defineProperty(ParseError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32700\n});\n//# sourceMappingURL=RpcResponse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9ScGNSZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDTyxvQ0FBb0M7QUFDM0MsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUM7QUFDNUMsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBLDBDQUEwQyw2Q0FBNkM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3Qyx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUnBjUmVzcG9uc2UuanM/NTgwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20ocmVzcG9uc2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcmVxdWVzdCB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgaWQ6IHJlc3BvbnNlLmlkID8/IHJlcXVlc3Q/LmlkLFxuICAgICAgICBqc29ucnBjOiByZXNwb25zZS5qc29ucnBjID8/IHJlcXVlc3QuanNvbnJwYyxcbiAgICB9O1xufVxuLyoqXG4gKiBBIHR5cGUtc2FmZSBpbnRlcmZhY2UgdG8gcGFyc2UgYSBKU09OLVJQQyByZXNwb25zZSBvYmplY3QgYXMgcGVyIHRoZSBbSlNPTi1SUEMgMi4wIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmpzb25ycGMub3JnL3NwZWNpZmljYXRpb24jcmVzcG9uc2Vfb2JqZWN0KSwgYW5kIGV4dHJhY3QgdGhlIHJlc3VsdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJwY1JlcXVlc3QsIFJwY1Jlc3BvbnNlIH0gZnJvbSAnb3gnXG4gKlxuICogLy8gMS4gQ3JlYXRlIGEgcmVxdWVzdCBzdG9yZS5cbiAqIGNvbnN0IHN0b3JlID0gUnBjUmVxdWVzdC5jcmVhdGVTdG9yZSgpXG4gKlxuICogLy8gMi4gR2V0IGEgcmVxdWVzdCBvYmplY3QuXG4gKiBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHJlcGFyZSh7XG4gKiAgIG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAqICAgcGFyYW1zOiBbJzB4MScsIGZhbHNlXSxcbiAqIH0pXG4gKlxuICogLy8gMy4gU2VuZCB0aGUgSlNPTi1SUEMgcmVxdWVzdCB2aWEgSFRUUC5cbiAqIGNvbnN0IGJsb2NrID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vMS5ycGMudGhpcmR3ZWIuY29tJywge1xuICogICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAqICAgaGVhZGVyczoge1xuICogICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gKiAgIH0sXG4gKiAgIG1ldGhvZDogJ1BPU1QnLFxuICogfSlcbiAqICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAqICAvLyA0LiBQYXJzZSB0aGUgSlNPTi1SUEMgcmVzcG9uc2UgaW50byBhIHR5cGUtc2FmZSByZXN1bHQuIC8vIFshY29kZSBmb2N1c11cbiAqICAudGhlbigocmVzcG9uc2UpID0+IFJwY1Jlc3BvbnNlLnBhcnNlKHJlc3BvbnNlLCB7IHJlcXVlc3QgfSkpIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBibG9jayAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBJZiB5b3UgZG9uJ3QgbmVlZCB0aGUgcmV0dXJuIHR5cGUsIHlvdSBjYW4gb21pdCB0aGUgb3B0aW9ucyBlbnRpcmVseS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBScGNSZXNwb25zZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vMS5ycGMudGhpcmR3ZWIuY29tJywge30pXG4gKiAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gKiAgLnRoZW4oKHJlc3BvbnNlKSA9PiBScGNSZXNwb25zZS5wYXJzZShyZXNwb25zZSwgeyByZXF1ZXN0IH0pKSAvLyBbIWNvZGUgLS1dXG4gKiAgLnRoZW4oUnBjUmVzcG9uc2UucGFyc2UpIC8vIFshY29kZSArK11cbiAqIGBgYFxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBSYXcgTW9kZVxuICpcbiAqIElmIGByYXdgIGlzIGB0cnVlYCwgdGhlIHJlc3BvbnNlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gb2JqZWN0IHdpdGggYHJlc3VsdGAgYW5kIGBlcnJvcmAgcHJvcGVydGllcyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGUgYHJlc3VsdGAgZGlyZWN0bHkgYW5kIHRocm93aW5nIGVycm9ycy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgUnBjUmVzcG9uc2UgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzdG9yZSA9IFJwY1JlcXVlc3QuY3JlYXRlU3RvcmUoKVxuICpcbiAqIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wcmVwYXJlKHtcbiAqICAgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJyxcbiAqIH0pXG4gKlxuICogY29uc3QgcmVzcG9uc2UgPSBScGNSZXNwb25zZS5wYXJzZSh7fSwge1xuICogICByZXF1ZXN0LFxuICogICByYXc6IHRydWUsIC8vIFshY29kZSBobF1cbiAqIH0pXG4gKlxuICogcmVzcG9uc2UucmVzdWx0XG4gKiAvLyAgICAgICBeP1xuICpcbiAqXG4gKiByZXNwb25zZS5lcnJvclxuICogLy8gICAgICAgXj9cbiAqXG4gKlxuICogYGBgXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gT3BhcXVlIEpTT04tUlBDIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gUGFyc2luZyBvcHRpb25zLlxuICogQHJldHVybnMgVHlwZWQgSlNPTi1SUEMgcmVzdWx0LCBvciByZXNwb25zZSBvYmplY3QgKGlmIGByYXdgIGlzIGB0cnVlYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShyZXNwb25zZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyByYXcgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXNwb25zZV8gPSByZXNwb25zZTtcbiAgICBpZiAocmF3KVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgaWYgKHJlc3BvbnNlXy5lcnJvcilcbiAgICAgICAgdGhyb3cgcGFyc2VFcnJvcihyZXNwb25zZV8uZXJyb3IpO1xuICAgIHJldHVybiByZXNwb25zZV8ucmVzdWx0O1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gZXJyb3IgaW50byBhIFJQQyBFcnJvciBpbnN0YW5jZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJwY1Jlc3BvbnNlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZXJyb3IgPSBScGNSZXNwb25zZS5wYXJzZUVycm9yKHsgY29kZTogLTMyMDAwLCBtZXNzYWdlOiAndW5zdXBwb3J0ZWQgbWV0aG9kJyB9KVxuICpcbiAqIGVycm9yXG4gKiAvLyBeP1xuICpcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlcnJvciAtIEVycm9yLlxuICogQHJldHVybnMgUlBDIEVycm9yIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IGVycm9yXyA9IGVycm9yO1xuICAgIGlmIChlcnJvcl8gaW5zdGFuY2VvZiBFcnJvciAmJiAhKCdjb2RlJyBpbiBlcnJvcl8pKVxuICAgICAgICByZXR1cm4gbmV3IEludGVybmFsRXJyb3Ioe1xuICAgICAgICAgICAgY2F1c2U6IGVycm9yXyxcbiAgICAgICAgICAgIGRhdGE6IGVycm9yXyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yXy5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yXztcbiAgICBpZiAoY29kZSA9PT0gSW50ZXJuYWxFcnJvci5jb2RlKVxuICAgICAgICByZXR1cm4gbmV3IEludGVybmFsRXJyb3IoZXJyb3JfKTtcbiAgICBpZiAoY29kZSA9PT0gSW52YWxpZElucHV0RXJyb3IuY29kZSlcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkSW5wdXRFcnJvcihlcnJvcl8pO1xuICAgIGlmIChjb2RlID09PSBJbnZhbGlkUGFyYW1zRXJyb3IuY29kZSlcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkUGFyYW1zRXJyb3IoZXJyb3JfKTtcbiAgICBpZiAoY29kZSA9PT0gSW52YWxpZFJlcXVlc3RFcnJvci5jb2RlKVxuICAgICAgICByZXR1cm4gbmV3IEludmFsaWRSZXF1ZXN0RXJyb3IoZXJyb3JfKTtcbiAgICBpZiAoY29kZSA9PT0gTGltaXRFeGNlZWRlZEVycm9yLmNvZGUpXG4gICAgICAgIHJldHVybiBuZXcgTGltaXRFeGNlZWRlZEVycm9yKGVycm9yXyk7XG4gICAgaWYgKGNvZGUgPT09IE1ldGhvZE5vdEZvdW5kRXJyb3IuY29kZSlcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2ROb3RGb3VuZEVycm9yKGVycm9yXyk7XG4gICAgaWYgKGNvZGUgPT09IE1ldGhvZE5vdFN1cHBvcnRlZEVycm9yLmNvZGUpXG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kTm90U3VwcG9ydGVkRXJyb3IoZXJyb3JfKTtcbiAgICBpZiAoY29kZSA9PT0gUGFyc2VFcnJvci5jb2RlKVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlRXJyb3IoZXJyb3JfKTtcbiAgICBpZiAoY29kZSA9PT0gUmVzb3VyY2VOb3RGb3VuZEVycm9yLmNvZGUpXG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VOb3RGb3VuZEVycm9yKGVycm9yXyk7XG4gICAgaWYgKGNvZGUgPT09IFJlc291cmNlVW5hdmFpbGFibGVFcnJvci5jb2RlKVxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlVW5hdmFpbGFibGVFcnJvcihlcnJvcl8pO1xuICAgIGlmIChjb2RlID09PSBUcmFuc2FjdGlvblJlamVjdGVkRXJyb3IuY29kZSlcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlamVjdGVkRXJyb3IoZXJyb3JfKTtcbiAgICBpZiAoY29kZSA9PT0gVmVyc2lvbk5vdFN1cHBvcnRlZEVycm9yLmNvZGUpXG4gICAgICAgIHJldHVybiBuZXcgVmVyc2lvbk5vdFN1cHBvcnRlZEVycm9yKGVycm9yXyk7XG4gICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKHtcbiAgICAgICAgY2F1c2U6IGVycm9yXyBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3JfIDogdW5kZWZpbmVkLFxuICAgICAgICBkYXRhOiBlcnJvcl8sXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yXy5tZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqIFRocm93biB3aGVuIGEgSlNPTi1SUEMgZXJyb3IgaGFzIG9jY3VycmVkLiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvck9iamVjdCkge1xuICAgICAgICBjb25zdCB7IGNhdXNlLCBjb2RlLCBtZXNzYWdlLCBkYXRhIH0gPSBlcnJvck9iamVjdDtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1JwY1Jlc3BvbnNlLkJhc2VFcnJvcidcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBpbnB1dCB0byBhIEpTT04tUlBDIG1ldGhvZCBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnB1dEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY29kZTogSW52YWxpZElucHV0RXJyb3IuY29kZSxcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtZXRlcnMuZGF0YSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHBhcmFtZXRlcnMubWVzc2FnZSA/PyAnTWlzc2luZyBvciBpbnZhbGlkIHBhcmFtZXRlcnMuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IC0zMjAwMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1JwY1Jlc3BvbnNlLkludmFsaWRJbnB1dEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW52YWxpZElucHV0RXJyb3IsIFwiY29kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IC0zMjAwMFxufSk7XG4vKiogVGhyb3duIHdoZW4gYSBKU09OLVJQQyByZXNvdXJjZSBpcyBub3QgZm91bmQuICovXG5leHBvcnQgY2xhc3MgUmVzb3VyY2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY29kZTogUmVzb3VyY2VOb3RGb3VuZEVycm9yLmNvZGUsXG4gICAgICAgICAgICBkYXRhOiBwYXJhbWV0ZXJzLmRhdGEsXG4gICAgICAgICAgICBtZXNzYWdlOiBwYXJhbWV0ZXJzLm1lc3NhZ2UgPz8gJ1JlcXVlc3RlZCByZXNvdXJjZSBub3QgZm91bmQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IC0zMjAwMVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1JwY1Jlc3BvbnNlLlJlc291cmNlTm90Rm91bmRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc291cmNlTm90Rm91bmRFcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogLTMyMDAxXG59KTtcbi8qKiBUaHJvd24gd2hlbiBhIEpTT04tUlBDIHJlc291cmNlIGlzIHVuYXZhaWxhYmxlLiAqL1xuZXhwb3J0IGNsYXNzIFJlc291cmNlVW5hdmFpbGFibGVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvZGU6IFJlc291cmNlVW5hdmFpbGFibGVFcnJvci5jb2RlLFxuICAgICAgICAgICAgZGF0YTogcGFyYW1ldGVycy5kYXRhLFxuICAgICAgICAgICAgbWVzc2FnZTogcGFyYW1ldGVycy5tZXNzYWdlID8/ICdSZXF1ZXN0ZWQgcmVzb3VyY2Ugbm90IGF2YWlsYWJsZS4nLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogLTMyMDAyXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUnBjUmVzcG9uc2UuUmVzb3VyY2VVbmF2YWlsYWJsZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzb3VyY2VVbmF2YWlsYWJsZUVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAtMzIwMDJcbn0pO1xuLyoqIFRocm93biB3aGVuIGEgSlNPTi1SUEMgdHJhbnNhY3Rpb24gaXMgcmVqZWN0ZWQuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZWplY3RlZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY29kZTogVHJhbnNhY3Rpb25SZWplY3RlZEVycm9yLmNvZGUsXG4gICAgICAgICAgICBkYXRhOiBwYXJhbWV0ZXJzLmRhdGEsXG4gICAgICAgICAgICBtZXNzYWdlOiBwYXJhbWV0ZXJzLm1lc3NhZ2UgPz8gJ1RyYW5zYWN0aW9uIGNyZWF0aW9uIGZhaWxlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogLTMyMDAzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUnBjUmVzcG9uc2UuVHJhbnNhY3Rpb25SZWplY3RlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25SZWplY3RlZEVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAtMzIwMDNcbn0pO1xuLyoqIFRocm93biB3aGVuIGEgSlNPTi1SUEMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQuICovXG5leHBvcnQgY2xhc3MgTWV0aG9kTm90U3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjb2RlOiBNZXRob2ROb3RTdXBwb3J0ZWRFcnJvci5jb2RlLFxuICAgICAgICAgICAgZGF0YTogcGFyYW1ldGVycy5kYXRhLFxuICAgICAgICAgICAgbWVzc2FnZTogcGFyYW1ldGVycy5tZXNzYWdlID8/ICdNZXRob2QgaXMgbm90IGltcGxlbWVudGVkLicsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAtMzIwMDRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdScGNSZXNwb25zZS5NZXRob2ROb3RTdXBwb3J0ZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ldGhvZE5vdFN1cHBvcnRlZEVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAtMzIwMDRcbn0pO1xuLyoqIFRocm93biB3aGVuIGEgcmF0ZS1saW1pdCBpcyBleGNlZWRlZC4gKi9cbmV4cG9ydCBjbGFzcyBMaW1pdEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjb2RlOiBMaW1pdEV4Y2VlZGVkRXJyb3IuY29kZSxcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtZXRlcnMuZGF0YSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHBhcmFtZXRlcnMubWVzc2FnZSA/PyAnUmF0ZSBsaW1pdCBleGNlZWRlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogLTMyMDA1XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUnBjUmVzcG9uc2UuTGltaXRFeGNlZWRlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGltaXRFeGNlZWRlZEVycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAtMzIwMDVcbn0pO1xuLyoqIFRocm93biB3aGVuIGEgSlNPTi1SUEMgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkLiAqL1xuZXhwb3J0IGNsYXNzIFZlcnNpb25Ob3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvZGU6IFZlcnNpb25Ob3RTdXBwb3J0ZWRFcnJvci5jb2RlLFxuICAgICAgICAgICAgZGF0YTogcGFyYW1ldGVycy5kYXRhLFxuICAgICAgICAgICAgbWVzc2FnZTogcGFyYW1ldGVycy5tZXNzYWdlID8/ICdKU09OLVJQQyB2ZXJzaW9uIG5vdCBzdXBwb3J0ZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IC0zMjAwNlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1JwY1Jlc3BvbnNlLlZlcnNpb25Ob3RTdXBwb3J0ZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnNpb25Ob3RTdXBwb3J0ZWRFcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogLTMyMDA2XG59KTtcbi8qKiBUaHJvd24gd2hlbiBhIEpTT04tUlBDIHJlcXVlc3QgaXMgaW52YWxpZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUmVxdWVzdEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY29kZTogSW52YWxpZFJlcXVlc3RFcnJvci5jb2RlLFxuICAgICAgICAgICAgZGF0YTogcGFyYW1ldGVycy5kYXRhLFxuICAgICAgICAgICAgbWVzc2FnZTogcGFyYW1ldGVycy5tZXNzYWdlID8/ICdJbnB1dCBpcyBub3QgYSB2YWxpZCBKU09OLVJQQyByZXF1ZXN0LicsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAtMzI2MDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdScGNSZXNwb25zZS5JbnZhbGlkUmVxdWVzdEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW52YWxpZFJlcXVlc3RFcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogLTMyNjAwXG59KTtcbi8qKiBUaHJvd24gd2hlbiBhIEpTT04tUlBDIG1ldGhvZCBpcyBub3QgZm91bmQuICovXG5leHBvcnQgY2xhc3MgTWV0aG9kTm90Rm91bmRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvZGU6IE1ldGhvZE5vdEZvdW5kRXJyb3IuY29kZSxcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtZXRlcnMuZGF0YSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHBhcmFtZXRlcnMubWVzc2FnZSA/PyAnTWV0aG9kIGRvZXMgbm90IGV4aXN0LicsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAtMzI2MDFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdScGNSZXNwb25zZS5NZXRob2ROb3RGb3VuZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWV0aG9kTm90Rm91bmRFcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogLTMyNjAxXG59KTtcbi8qKiBUaHJvd24gd2hlbiB0aGUgcGFyYW1ldGVycyB0byBhIEpTT04tUlBDIG1ldGhvZCBhcmUgaW52YWxpZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUGFyYW1zRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjb2RlOiBJbnZhbGlkUGFyYW1zRXJyb3IuY29kZSxcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtZXRlcnMuZGF0YSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHBhcmFtZXRlcnMubWVzc2FnZSA/PyAnSW52YWxpZCBtZXRob2QgcGFyYW1ldGVycy4nLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogLTMyNjAyXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUnBjUmVzcG9uc2UuSW52YWxpZFBhcmFtc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW52YWxpZFBhcmFtc0Vycm9yLCBcImNvZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAtMzI2MDJcbn0pO1xuLyoqIFRocm93biB3aGVuIGFuIGludGVybmFsIEpTT04tUlBDIGVycm9yIGhhcyBvY2N1cnJlZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY2F1c2U6IHBhcmFtZXRlcnMuY2F1c2UsXG4gICAgICAgICAgICBjb2RlOiBJbnRlcm5hbEVycm9yLmNvZGUsXG4gICAgICAgICAgICBkYXRhOiBwYXJhbWV0ZXJzLmRhdGEsXG4gICAgICAgICAgICBtZXNzYWdlOiBwYXJhbWV0ZXJzLm1lc3NhZ2UgPz8gJ0ludGVybmFsIEpTT04tUlBDIGVycm9yLicsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAtMzI2MDNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdScGNSZXNwb25zZS5JbnRlcm5hbEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZXJuYWxFcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogLTMyNjAzXG59KTtcbi8qKiBUaHJvd24gd2hlbiBhIEpTT04tUlBDIHJlc3BvbnNlIGlzIGludmFsaWQuICovXG5leHBvcnQgY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvZGU6IFBhcnNlRXJyb3IuY29kZSxcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtZXRlcnMuZGF0YSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHBhcmFtZXRlcnMubWVzc2FnZSA/PyAnRmFpbGVkIHRvIHBhcnNlIEpTT04tUlBDIHJlc3BvbnNlLicsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAtMzI3MDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdScGNSZXNwb25zZS5QYXJzZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyc2VFcnJvciwgXCJjb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogLTMyNzAwXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJwY1Jlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/RpcResponse.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/RpcSchema.js":
/*!*************************************************!*\
  !*** ../node_modules/ox/_esm/core/RpcSchema.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/**\n * Instantiates a statically typed Schema. This is a runtime-noop function, and is purposed\n * to be used as a type-level tag to be used with {@link ox#Provider.(from:function)} or\n * {@link ox#RpcTransport.(fromHttp:function)}.\n *\n * @example\n * ### Using with `Provider.from`\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n */\nfunction from() {\n    return null;\n}\n//# sourceMappingURL=RpcSchema.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9ScGNTY2hlbWEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxtREFBbUQsbUNBQW1DO0FBQ3RGLElBQUksMENBQTBDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1JwY1NjaGVtYS5qcz8wZGU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW5zdGFudGlhdGVzIGEgc3RhdGljYWxseSB0eXBlZCBTY2hlbWEuIFRoaXMgaXMgYSBydW50aW1lLW5vb3AgZnVuY3Rpb24sIGFuZCBpcyBwdXJwb3NlZFxuICogdG8gYmUgdXNlZCBhcyBhIHR5cGUtbGV2ZWwgdGFnIHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgb3gjUHJvdmlkZXIuKGZyb206ZnVuY3Rpb24pfSBvclxuICoge0BsaW5rIG94I1JwY1RyYW5zcG9ydC4oZnJvbUh0dHA6ZnVuY3Rpb24pfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFVzaW5nIHdpdGggYFByb3ZpZGVyLmZyb21gXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBQcm92aWRlciwgUnBjU2NoZW1hIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2NoZW1hID0gUnBjU2NoZW1hLmZyb208XG4gKiAgIHwgUnBjU2NoZW1hLkRlZmF1bHRcbiAqICAgfCB7XG4gKiAgICAgICBSZXF1ZXN0OiB7XG4gKiAgICAgICAgIG1ldGhvZDogJ2FiZV9mb28nLFxuICogICAgICAgICBwYXJhbXM6IFtpZDogbnVtYmVyXSxcbiAqICAgICAgIH1cbiAqICAgICAgIFJldHVyblR5cGU6IHN0cmluZ1xuICogICAgIH1cbiAqICAgfCB7XG4gKiAgICAgICBSZXF1ZXN0OiB7XG4gKiAgICAgICAgIG1ldGhvZDogJ2FiZV9iYXInLFxuICogICAgICAgICBwYXJhbXM6IFtpZDogc3RyaW5nXSxcbiAqICAgICAgIH1cbiAqICAgICAgIFJldHVyblR5cGU6IHN0cmluZ1xuICogICAgIH1cbiAqID4oKVxuICpcbiAqIGNvbnN0IHByb3ZpZGVyID0gUHJvdmlkZXIuZnJvbSh3aW5kb3cuZXRoZXJldW0sIHsgc2NoZW1hIH0pXG4gKlxuICogY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZScgfSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF58XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJwY1NjaGVtYS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/RpcSchema.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/RpcTransport.js":
/*!****************************************************!*\
  !*** ../node_modules/ox/_esm/core/RpcTransport.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   MalformedResponseError: () => (/* binding */ MalformedResponseError),\n/* harmony export */   fromHttp: () => (/* binding */ fromHttp)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/errors.js */ \"../node_modules/ox/_esm/core/internal/errors.js\");\n/* harmony import */ var _internal_promise_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/promise.js */ \"../node_modules/ox/_esm/core/internal/promise.js\");\n/* harmony import */ var _internal_rpcTransport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/rpcTransport.js */ \"../node_modules/ox/_esm/core/internal/rpcTransport.js\");\n\n\n\n\n/**\n * Creates a HTTP JSON-RPC Transport from a URL.\n *\n * @example\n * ```ts twoslash\n * import { RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n *\n * const blockNumber = await transport.request({ method: 'eth_blockNumber' })\n * // @log: '0x1a2b3c'\n * ```\n *\n * @param url - URL to perform the JSON-RPC requests to.\n * @param options - Transport options.\n * @returns HTTP JSON-RPC Transport.\n */\nfunction fromHttp(url, options = {}) {\n    return _internal_rpcTransport_js__WEBPACK_IMPORTED_MODULE_0__.create({\n        async request(body_, options_) {\n            const { fetchFn = options.fetchFn ?? fetch, fetchOptions: fetchOptions_ = options.fetchOptions, timeout = options.timeout ?? 10_000, } = options_;\n            const body = JSON.stringify(body_);\n            const fetchOptions = typeof fetchOptions_ === 'function'\n                ? await fetchOptions_(body_)\n                : fetchOptions_;\n            const response = await _internal_promise_js__WEBPACK_IMPORTED_MODULE_1__.withTimeout(({ signal }) => {\n                const init = {\n                    ...fetchOptions,\n                    body,\n                    headers: {\n                        'Content-Type': 'application/json',\n                        ...fetchOptions?.headers,\n                    },\n                    method: fetchOptions?.method ?? 'POST',\n                    signal: fetchOptions?.signal ?? (timeout > 0 ? signal : null),\n                };\n                const request = new Request(url, init);\n                return fetchFn(request);\n            }, {\n                timeout,\n                signal: true,\n            });\n            const data = await (async () => {\n                if (response.headers.get('Content-Type')?.startsWith('application/json'))\n                    return response.json();\n                return response.text().then((data) => {\n                    try {\n                        return JSON.parse(data || '{}');\n                    }\n                    catch (err) {\n                        if (response.ok)\n                            throw new MalformedResponseError({\n                                response: data,\n                            });\n                        return { error: data };\n                    }\n                });\n            })();\n            if (!response.ok)\n                throw new HttpError({\n                    body,\n                    details: JSON.stringify(data.error) ?? response.statusText,\n                    response,\n                    url,\n                });\n            return data;\n        },\n    }, { raw: options.raw });\n}\n/** Thrown when a HTTP request fails. */\nclass HttpError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ body, details, response, url, }) {\n        super('HTTP request failed.', {\n            details,\n            metaMessages: [\n                `Status: ${response.status}`,\n                `URL: ${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_3__.getUrl)(url)}`,\n                body ? `Body: ${JSON.stringify(body)}` : undefined,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcTransport.HttpError'\n        });\n    }\n}\n/** Thrown when a HTTP response is malformed. */\nclass MalformedResponseError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ response }) {\n        super('HTTP Response could not be parsed as JSON.', {\n            metaMessages: [`Response: ${response}`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'RpcTransport.MalformedResponseError'\n        });\n    }\n}\n//# sourceMappingURL=RpcTransport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9ScGNUcmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzQztBQUNRO0FBQ0c7QUFDTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQkFBMkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsV0FBVyw2REFBZTtBQUMxQjtBQUNBLG9CQUFvQiwrSEFBK0g7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkRBQW1CLElBQUksUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakM7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLLElBQUksa0JBQWtCO0FBQzNCO0FBQ0E7QUFDTyx3QkFBd0IsaURBQWdCO0FBQy9DLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQyx3QkFBd0IsMkRBQU0sTUFBTTtBQUNwQyxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08scUNBQXFDLGlEQUFnQjtBQUM1RCxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1JwY1RyYW5zcG9ydC5qcz82ZjI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBnZXRVcmwgfSBmcm9tICcuL2ludGVybmFsL2Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBwcm9taXNlIGZyb20gJy4vaW50ZXJuYWwvcHJvbWlzZS5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL3JwY1RyYW5zcG9ydC5qcyc7XG4vKipcbiAqIENyZWF0ZXMgYSBIVFRQIEpTT04tUlBDIFRyYW5zcG9ydCBmcm9tIGEgVVJMLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjVHJhbnNwb3J0IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNwb3J0ID0gUnBjVHJhbnNwb3J0LmZyb21IdHRwKCdodHRwczovLzEucnBjLnRoaXJkd2ViLmNvbScpXG4gKlxuICogY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0cmFuc3BvcnQucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9ibG9ja051bWJlcicgfSlcbiAqIC8vIEBsb2c6ICcweDFhMmIzYydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1cmwgLSBVUkwgdG8gcGVyZm9ybSB0aGUgSlNPTi1SUEMgcmVxdWVzdHMgdG8uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRyYW5zcG9ydCBvcHRpb25zLlxuICogQHJldHVybnMgSFRUUCBKU09OLVJQQyBUcmFuc3BvcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSHR0cCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5jcmVhdGUoe1xuICAgICAgICBhc3luYyByZXF1ZXN0KGJvZHlfLCBvcHRpb25zXykge1xuICAgICAgICAgICAgY29uc3QgeyBmZXRjaEZuID0gb3B0aW9ucy5mZXRjaEZuID8/IGZldGNoLCBmZXRjaE9wdGlvbnM6IGZldGNoT3B0aW9uc18gPSBvcHRpb25zLmZldGNoT3B0aW9ucywgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCA/PyAxMF8wMDAsIH0gPSBvcHRpb25zXztcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5Xyk7XG4gICAgICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB0eXBlb2YgZmV0Y2hPcHRpb25zXyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gYXdhaXQgZmV0Y2hPcHRpb25zXyhib2R5XylcbiAgICAgICAgICAgICAgICA6IGZldGNoT3B0aW9uc187XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHByb21pc2Uud2l0aFRpbWVvdXQoKHsgc2lnbmFsIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5mZXRjaE9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogZmV0Y2hPcHRpb25zPy5tZXRob2QgPz8gJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGZldGNoT3B0aW9ucz8uc2lnbmFsID8/ICh0aW1lb3V0ID4gMCA/IHNpZ25hbCA6IG51bGwpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRm4ocmVxdWVzdCk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICBzaWduYWw6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk/LnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2pzb24nKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEgfHwgJ3t9Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNYWxmb3JtZWRSZXNwb25zZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZGF0YSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogSlNPTi5zdHJpbmdpZnkoZGF0YS5lcnJvcikgPz8gcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgIH0sIHsgcmF3OiBvcHRpb25zLnJhdyB9KTtcbn1cbi8qKiBUaHJvd24gd2hlbiBhIEhUVFAgcmVxdWVzdCBmYWlscy4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGJvZHksIGRldGFpbHMsIHJlc3BvbnNlLCB1cmwsIH0pIHtcbiAgICAgICAgc3VwZXIoJ0hUVFAgcmVxdWVzdCBmYWlsZWQuJywge1xuICAgICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICAgICAgICAgICAgYFVSTDogJHtnZXRVcmwodXJsKX1gLFxuICAgICAgICAgICAgICAgIGJvZHkgPyBgQm9keTogJHtKU09OLnN0cmluZ2lmeShib2R5KX1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdScGNUcmFuc3BvcnQuSHR0cEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYSBIVFRQIHJlc3BvbnNlIGlzIG1hbGZvcm1lZC4gKi9cbmV4cG9ydCBjbGFzcyBNYWxmb3JtZWRSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyByZXNwb25zZSB9KSB7XG4gICAgICAgIHN1cGVyKCdIVFRQIFJlc3BvbnNlIGNvdWxkIG5vdCBiZSBwYXJzZWQgYXMgSlNPTi4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtgUmVzcG9uc2U6ICR7cmVzcG9uc2V9YF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUnBjVHJhbnNwb3J0Lk1hbGZvcm1lZFJlc3BvbnNlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJwY1RyYW5zcG9ydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/RpcTransport.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Secp256k1.js":
/*!*************************************************!*\
  !*** ../node_modules/ox/_esm/core/Secp256k1.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"../node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"../node_modules/ox/_esm/core/PublicKey.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/entropy.js */ \"../node_modules/ox/_esm/core/internal/entropy.js\");\n\n\n\n\n\n\n/** Re-export of noble/curves secp256k1 utilities. */\nconst noble = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1;\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nfunction getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromPrivateKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nfunction randomPrivateKey(options = {}) {\n    const { as = 'Hex' } = options;\n    const bytes = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.randomPrivateKey();\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nfunction recoverAddress(options) {\n    return _Address_js__WEBPACK_IMPORTED_MODULE_3__.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nfunction recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const point = signature_.recoverPublicKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(payload).substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nfunction sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__.extraEntropy, hash, payload, privateKey, } = options;\n    const { r, s, recovery } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(_Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(privateKey), {\n        extraEntropy: typeof extraEntropy === 'boolean'\n            ? extraEntropy\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...(hash ? { prehash: true } : {}),\n    });\n    return {\n        r,\n        s,\n        yParity: recovery,\n    };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nfunction verify(options) {\n    const { address, hash, payload, publicKey, signature } = options;\n    if (address)\n        return _Address_js__WEBPACK_IMPORTED_MODULE_3__.isEqual(address, recoverAddress({ payload, signature }));\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(signature, _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toBytes(publicKey), ...(hash ? [{ prehash: true, lowS: true }] : []));\n}\n//# sourceMappingURL=Secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNaO0FBQ0o7QUFDSjtBQUNZO0FBQ0s7QUFDakQ7QUFDTyxjQUFjLDhEQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksYUFBYTtBQUN6QixrQkFBa0IsOERBQVMsZ0NBQWdDLHlDQUFRO0FBQ25FLFdBQVcsK0NBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDLFlBQVksYUFBYTtBQUN6QixrQkFBa0IsOERBQVM7QUFDM0I7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLHNDQUFzQyw0Q0FBNEM7QUFDbEY7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLGdCQUFnQjtBQUM1QiwyQkFBMkIsOERBQVM7QUFDcEMsOENBQThDLHlDQUFRO0FBQ3RELFdBQVcsK0NBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNPO0FBQ1AsWUFBWSxlQUFlLDhEQUFvQiwrQkFBK0I7QUFDOUUsWUFBWSxpQkFBaUIsRUFBRSw4REFBUyxNQUFNLDJDQUFVLFdBQVcsMkNBQVU7QUFDN0U7QUFDQTtBQUNBLGNBQWMseUNBQVE7QUFDdEI7QUFDQSxxQkFBcUIsZ0JBQWdCLElBQUk7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRCxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLCtDQUErQztBQUMzRDtBQUNBLGVBQWUsZ0RBQWUsMkJBQTJCLG9CQUFvQjtBQUM3RSxXQUFXLDhEQUFTLG1CQUFtQiwyQ0FBVSxXQUFXLGtEQUFpQiwyQkFBMkIsMkJBQTJCO0FBQ25JO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TZWNwMjU2azEuanM/MzM4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBQdWJsaWNLZXkgZnJvbSAnLi9QdWJsaWNLZXkuanMnO1xuaW1wb3J0ICogYXMgRW50cm9weSBmcm9tICcuL2ludGVybmFsL2VudHJvcHkuanMnO1xuLyoqIFJlLWV4cG9ydCBvZiBub2JsZS9jdXJ2ZXMgc2VjcDI1NmsxIHV0aWxpdGllcy4gKi9cbmV4cG9ydCBjb25zdCBub2JsZSA9IHNlY3AyNTZrMTtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNlY3AyNTZrMSBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBwcm92aWRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbXB1dGUgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tUHJpdmF0ZUtleShIZXguZnJvbShwcml2YXRlS2V5KS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tKHBvaW50KTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIEVDRFNBIHByaXZhdGUga2V5IG9uIHRoZSBzZWNwMjU2azEgY3VydmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tUHJpdmF0ZUtleShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIFJlY292ZXJzIHRoZSBzaWduaW5nIGFkZHJlc3MgZnJvbSB0aGUgc2lnbmVkIHBheWxvYWQgYW5kIHNpZ25hdHVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgYWRkcmVzcyA9IFNlY3AyNTZrMS5yZWNvdmVyQWRkcmVzcyh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSByZWNvdmVyZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQWRkcmVzcy5mcm9tUHVibGljS2V5KHJlY292ZXJQdWJsaWNLZXkob3B0aW9ucykpO1xufVxuLyoqXG4gKiBSZWNvdmVycyB0aGUgc2lnbmluZyBwdWJsaWMga2V5IGZyb20gdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5yZWNvdmVyUHVibGljS2V5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHJlY292ZXJlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IG5ldyBzZWNwMjU2azEuU2lnbmF0dXJlKEJpZ0ludChyKSwgQmlnSW50KHMpKS5hZGRSZWNvdmVyeUJpdCh5UGFyaXR5KTtcbiAgICBjb25zdCBwb2ludCA9IHNpZ25hdHVyZV8ucmVjb3ZlclB1YmxpY0tleShIZXguZnJvbShwYXlsb2FkKS5zdWJzdHJpbmcoMikpO1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShwb2ludCk7XG59XG4vKipcbiAqIFNpZ25zIHRoZSBwYXlsb2FkIHdpdGggdGhlIHByb3ZpZGVkIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwcml2YXRlS2V5OiAnMHguLi4nIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25pbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBFQ0RTQSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGV4dHJhRW50cm9weSA9IEVudHJvcHkuZXh0cmFFbnRyb3B5LCBoYXNoLCBwYXlsb2FkLCBwcml2YXRlS2V5LCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5IH0gPSBzZWNwMjU2azEuc2lnbihCeXRlcy5mcm9tKHBheWxvYWQpLCBCeXRlcy5mcm9tKHByaXZhdGVLZXkpLCB7XG4gICAgICAgIGV4dHJhRW50cm9weTogdHlwZW9mIGV4dHJhRW50cm9weSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IGV4dHJhRW50cm9weVxuICAgICAgICAgICAgOiBIZXguZnJvbShleHRyYUVudHJvcHkpLnNsaWNlKDIpLFxuICAgICAgICBsb3dTOiB0cnVlLFxuICAgICAgICAuLi4oaGFzaCA/IHsgcHJlaGFzaDogdHJ1ZSB9IDoge30pLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgICAgIHlQYXJpdHk6IHJlY292ZXJ5LFxuICAgIH07XG59XG4vKipcbiAqIFZlcmlmaWVzIGEgcGF5bG9hZCB3YXMgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBhZGRyZXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmVyaWZ5IHdpdGggRXRoZXJldW0gQWRkcmVzc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IHZlcmlmaWVkID0gU2VjcDI1NmsxLnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgYWRkcmVzczogJzB4ZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJpZnkgd2l0aCBQdWJsaWMgS2V5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSAnMHguLi4nXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBTZWNwMjU2azEuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KVxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IFNlY3AyNTZrMS52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSB2ZXJpZmljYXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHBheWxvYWQgd2FzIHNpZ25lZCBieSB0aGUgcHJvdmlkZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBoYXNoLCBwYXlsb2FkLCBwdWJsaWNLZXksIHNpZ25hdHVyZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoYWRkcmVzcylcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuaXNFcXVhbChhZGRyZXNzLCByZWNvdmVyQWRkcmVzcyh7IHBheWxvYWQsIHNpZ25hdHVyZSB9KSk7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkoc2lnbmF0dXJlLCBCeXRlcy5mcm9tKHBheWxvYWQpLCBQdWJsaWNLZXkudG9CeXRlcyhwdWJsaWNLZXkpLCAuLi4oaGFzaCA/IFt7IHByZWhhc2g6IHRydWUsIGxvd1M6IHRydWUgfV0gOiBbXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Secp256k1.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Signature.js":
/*!*************************************************!*\
  !*** ../node_modules/ox/_esm/core/Signature.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: () => (/* binding */ InvalidRError),\n/* harmony export */   InvalidSError: () => (/* binding */ InvalidSError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidVError: () => (/* binding */ InvalidVError),\n/* harmony export */   InvalidYParityError: () => (/* binding */ InvalidYParityError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromDerBytes: () => (/* binding */ fromDerBytes),\n/* harmony export */   fromDerHex: () => (/* binding */ fromDerHex),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromLegacy: () => (/* binding */ fromLegacy),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toDerBytes: () => (/* binding */ toDerBytes),\n/* harmony export */   toDerHex: () => (/* binding */ toDerHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toLegacy: () => (/* binding */ toLegacy),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   vToYParity: () => (/* binding */ vToYParity),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   yParityToV: () => (/* binding */ yParityToV)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"../node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"../node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"../node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (typeof signature.s === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (recovered && typeof signature.yParity === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidRError({ value: signature.r });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidSError({ value: signature.s });\n    if (typeof signature.yParity === 'number' &&\n        signature.yParity !== 0 &&\n        signature.yParity !== 1)\n        throw new InvalidYParityError({ value: signature.yParity });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132)\n        throw new InvalidSerializedSizeError({ signature });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (() => {\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity))\n            return undefined;\n        try {\n            return vToYParity(yParity);\n        }\n        catch {\n            throw new InvalidYParityError({ value: yParity });\n        }\n    })();\n    if (typeof yParity === 'undefined')\n        return {\n            r,\n            s,\n        };\n    return {\n        r,\n        s,\n        yParity,\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nfunction extract(value) {\n    if (typeof value.r === 'undefined')\n        return undefined;\n    if (typeof value.s === 'undefined')\n        return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nfunction from(signature) {\n    const signature_ = (() => {\n        if (typeof signature === 'string')\n            return fromHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature);\n        if (typeof signature.r === 'string')\n            return fromRpc(signature);\n        if (signature.v)\n            return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...(typeof signature.yParity !== 'undefined'\n                ? { yParity: signature.yParity }\n                : {}),\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return { r, s };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromRpc(signature) {\n    const yParity = (() => {\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === 'number' && typeof yParity !== 'number')\n            yParity = vToYParity(v);\n        if (typeof yParity !== 'number')\n            throw new InvalidYParityError({ value: signature.yParity });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity,\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === '0x' ? 0n : BigInt(r),\n        s: s === '0x' ? 0n : BigInt(s),\n        yParity: yParity === '0x' ? 0 : Number(yParity),\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }), \n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n        ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), { size: 1 })\n        : '0x');\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nfunction toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nfunction toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }),\n        yParity: yParity === 0 ? '0x0' : '0x1',\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nfunction toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? '0x01' : '0x',\n        r === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s)),\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nfunction vToYParity(v) {\n    if (v === 0 || v === 27)\n        return 0;\n    if (v === 1 || v === 28)\n        return 1;\n    if (v >= 35)\n        return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({ value: v });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nfunction yParityToV(yParity) {\n    if (yParity === 0)\n        return 27;\n    if (yParity === 1)\n        return 28;\n    throw new InvalidYParityError({ value: yParity });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                'Expected: 64 bytes or 65 bytes.',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSerializedSizeError'\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nclass MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Signature \\`${_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.MissingPropertiesError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */\nclass InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidRError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */\nclass InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nclass InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidYParityError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */\nclass InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidVError'\n        });\n    }\n}\n//# sourceMappingURL=Signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TaWduYXR1cmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDaEI7QUFDRTtBQUNOO0FBQ0U7QUFDUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUM7QUFDOUMsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDJDQUEyQyxXQUFXO0FBQ3RELDBDQUEwQyxvREFBbUI7QUFDN0Qsa0NBQWtDLG9CQUFvQjtBQUN0RCwwQ0FBMEMsb0RBQW1CO0FBQzdELGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBCQUEwQjtBQUNsRTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQiw2QkFBNkIsNkJBQTZCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNPO0FBQ1AsbUJBQW1CLDhDQUFhO0FBQ2hDO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCLDZCQUE2Qiw2QkFBNkI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNPO0FBQ1A7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRCxxQkFBcUIsMENBQVM7QUFDOUIscUJBQXFCLDBDQUFTO0FBQzlCO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMs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Q3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ08seUNBQXlDLGlEQUFnQjtBQUNoRSxrQkFBa0IsV0FBVztBQUM3Qix5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EsNEJBQTRCLHlDQUFRLENBQUMseUNBQVEsY0FBYztBQUMzRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxpREFBZ0I7QUFDNUQsa0JBQWtCLFdBQVc7QUFDN0IsNkJBQTZCLCtDQUFjLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsaURBQWdCO0FBQ25ELGtCQUFrQixPQUFPO0FBQ3pCLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLGlEQUFnQjtBQUNuRCxrQkFBa0IsT0FBTztBQUN6Qix5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQsa0JBQWtCLE9BQU87QUFDekIseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsaURBQWdCO0FBQ25ELGtCQUFrQixPQUFPO0FBQ3pCLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzP2U5OTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbmltcG9ydCAqIGFzIFNvbGlkaXR5IGZyb20gJy4vU29saWRpdHkuanMnO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSBTaWduYXR1cmUgaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuYXNzZXJ0KHtcbiAqICAgcjogLTQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogSW52YWxpZFNpZ25hdHVyZVJFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYC01NDkuLi5uYCBpcyBhbiBpbnZhbGlkIHIgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IHIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LlxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChzaWduYXR1cmUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcmVjb3ZlcmVkIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgaWYgKHJlY292ZXJlZCAmJiB0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAoc2lnbmF0dXJlLnIgPCAwbiB8fCBzaWduYXR1cmUuciA+IFNvbGlkaXR5Lm1heFVpbnQyNTYpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUkVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS5yIH0pO1xuICAgIGlmIChzaWduYXR1cmUucyA8IDBuIHx8IHNpZ25hdHVyZS5zID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnMgfSk7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgc2lnbmF0dXJlLnlQYXJpdHkgIT09IDAgJiZcbiAgICAgICAgc2lnbmF0dXJlLnlQYXJpdHkgIT09IDEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS55UGFyaXR5IH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHNpZ25hdHVyZSBpbnRvIGEgc3RydWN0dXJlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEyOCwgMywgMTMxLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHsgcjogNTIzMS4uLm4sIHM6IDM1MjIuLi5uLCB5UGFyaXR5OiAwIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gc2lnbmF0dXJlIGludG8gYSBzdHJ1Y3R1cmVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tSGV4KCcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnKVxuICogLy8gQGxvZzogeyByOiA1MjMxLi4ubiwgczogMzUyMi4uLm4sIHlQYXJpdHk6IDAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoc2lnbmF0dXJlKSB7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMCAmJiBzaWduYXR1cmUubGVuZ3RoICE9PSAxMzIpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBjb25zdCByID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJpZ0ludChIZXguc2xpY2Uoc2lnbmF0dXJlLCAzMiwgNjQpKTtcbiAgICBjb25zdCB5UGFyaXR5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgeVBhcml0eSA9IE51bWJlcihgMHgke3NpZ25hdHVyZS5zbGljZSgxMzApfWApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHlQYXJpdHkpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2VG9ZUGFyaXR5KHlQYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHlQYXJpdHkgfSk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGlmICh0eXBlb2YgeVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB5UGFyaXR5LFxuICAgIH07XG59XG4vKipcbiAqIEV4dHJhY3RzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGZyb20gYW4gYXJiaXRyYXJ5IG9iamVjdCB0aGF0IG1heSBpbmNsdWRlIHNpZ25hdHVyZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZXh0cmFjdCh7XG4gKiAgIGJhejogJ2JhcnJ5JyxcbiAqICAgZm9vOiAnYmFyJyxcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiAgIHplYnJhOiAnc3RyaXBlcycsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMVxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFyYml0cmFyeSBvYmplY3QgdG8gZXh0cmFjdCB0aGUgc2lnbmF0dXJlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZXh0cmFjdGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZyb20odmFsdWUpO1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB0eXBlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gb2JqZWN0IGZyb20gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0sIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSwge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSwgb3Ige0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSgnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODAxJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDEsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gTGVnYWN5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDczMjM0NTcwMDc0NTM2NTcyMDc4ODk3MzAyNDM4MjY5NjU3NjE5MjIyOTY1OTk2ODA0NzM4ODY1ODgyODcwMTU3NTU2NTI3MDEwNzJuLFxuICogICBzOiA1NzIyODgwMzIwMjcyNzEzMTUwMjk0OTM1ODMxMzQ1NjA3MTI4MDQ4ODE4NDI3MDI1ODI5MzY3NDI0MjEyNDM0MDExMzgyNDg4Mjc4OG4sXG4gKiAgIHY6IDI3LFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDczMjM0NTcwMDc0NTM2NTcyMDc4ODk3MzAyNDM4MjY5NjU3NjE5MjIyOTY1OTk2ODA0NzM4ODY1ODgyODcwMTU3NTU2NTI3MDEwNzJuLFxuICogLy8gQGxvZzogICBzOiA1NzIyODgwMzIwMjcyNzEzMTUwMjk0OTM1ODMxMzQ1NjA3MTI4MDQ4ODE4NDI3MDI1ODI5MzY3NDI0MjEyNDM0MDExMzgyNDg4Mjc4OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDBcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHZhbHVlIHRvIGluc3RhbnRpYXRlLlxuICogQHJldHVybnMgVGhlIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUhleChzaWduYXR1cmUpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tQnl0ZXMoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbVJwYyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlLnYpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUxlZ2FjeShzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgICAgIC4uLih0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB7IHlQYXJpdHk6IHNpZ25hdHVyZS55UGFyaXR5IH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGFzc2VydChzaWduYXR1cmVfKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlXztcbn1cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tRGVyQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEzMiwgNTEsIDIzLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZXJCeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZnJvbURlckhleChIZXguZnJvbUJ5dGVzKHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tRGVySGV4KCcweDMwNDQwMjIwNmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjAyMjA0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZXJIZXgoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21ERVIoSGV4LmZyb20oc2lnbmF0dXJlKS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIHsgciwgcyB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbGVnYWN5ID0gU2lnbmF0dXJlLmZyb21MZWdhY3koeyByOiAxbiwgczogMm4sIHY6IDI4IH0pXG4gKiAvLyBAbG9nOiB7IHI6IDFuLCBzOiAybiwgeVBhcml0eTogMSB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTGVnYWN5KHNpZ25hdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IHNpZ25hdHVyZS5yLFxuICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgeVBhcml0eTogdlRvWVBhcml0eShzaWduYXR1cmUudiksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tUnBjKHtcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuUnBjfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHlQYXJpdHkgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2ID0gc2lnbmF0dXJlLnYgPyBOdW1iZXIoc2lnbmF0dXJlLnYpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeVBhcml0eSA9IHNpZ25hdHVyZS55UGFyaXR5ID8gTnVtYmVyKHNpZ25hdHVyZS55UGFyaXR5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeVBhcml0eSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB5UGFyaXR5ID0gdlRvWVBhcml0eSh2KTtcbiAgICAgICAgaWYgKHR5cGVvZiB5UGFyaXR5ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS55UGFyaXR5IH0pO1xuICAgICAgICByZXR1cm4geVBhcml0eTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IEJpZ0ludChzaWduYXR1cmUuciksXG4gICAgICAgIHM6IEJpZ0ludChzaWduYXR1cmUucyksXG4gICAgICAgIHlQYXJpdHksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tVHVwbGUoWycweDAxJywgJzB4N2InLCAnMHgxYzgnXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogMTIzbixcbiAqIC8vIEBsb2c6ICAgczogNDU2bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZSh0dXBsZSkge1xuICAgIGNvbnN0IFt5UGFyaXR5LCByLCBzXSA9IHR1cGxlO1xuICAgIHJldHVybiBmcm9tKHtcbiAgICAgICAgcjogciA9PT0gJzB4JyA/IDBuIDogQmlnSW50KHIpLFxuICAgICAgICBzOiBzID09PSAnMHgnID8gMG4gOiBCaWdJbnQocyksXG4gICAgICAgIHlQYXJpdHk6IHlQYXJpdHkgPT09ICcweCcgPyAwIDogTnVtYmVyKHlQYXJpdHkpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9CeXRlcyh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxXG4gKiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTAyLCAxNiwgMTAsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvSGV4KHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODFjJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZSk7XG4gICAgY29uc3QgciA9IHNpZ25hdHVyZS5yO1xuICAgIGNvbnN0IHMgPSBzaWduYXR1cmUucztcbiAgICBjb25zdCBzaWduYXR1cmVfID0gSGV4LmNvbmNhdChIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgc2lnbmF0dXJlIGlzIHJlY292ZXJlZCwgYWRkIHRoZSByZWNvdmVyeSBieXRlIHRvIHRoZSBzaWduYXR1cmUuXG4gICAgdHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJ1xuICAgICAgICA/IEhleC5mcm9tTnVtYmVyKHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLCB7IHNpemU6IDEgfSlcbiAgICAgICAgOiAnMHgnKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlXztcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gREVSLWVuY29kZWQgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlX2RlciA9IFNpZ25hdHVyZS50b0RlckJ5dGVzKHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzEzMiwgNTEsIDIzLCAuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVyQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoc2lnbmF0dXJlLnIsIHNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gc2lnLnRvREVSUmF3Qnl0ZXMoKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gREVSLWVuY29kZWQgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlX2RlciA9IFNpZ25hdHVyZS50b0RlckhleChzaWduYXR1cmUpXG4gKiAvLyBAbG9nOiAnMHgzMDQ0MDIyMDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmYwMjIwNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiOCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZXJIZXgoc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoc2lnbmF0dXJlLnIsIHNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gYDB4JHtzaWcudG9ERVJIZXgoKX1gO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbGVnYWN5ID0gU2lnbmF0dXJlLnRvTGVnYWN5KHsgcjogMW4sIHM6IDJuLCB5UGFyaXR5OiAxIH0pXG4gKiAvLyBAbG9nOiB7IHI6IDFuLCBzOiAybiwgdjogMjggfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB2OiB5UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvUnBjKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICBzOiBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICB5UGFyaXR5OiB5UGFyaXR5ID09PSAwID8gJzB4MCcgOiAnMHgxJyxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBhIHNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0gdG8gYmUgdXNlZCBmb3Igc2lnbmF0dXJlcyBpbiBUcmFuc2FjdGlvbiBFbnZlbG9wZXMsIEVJUC03NzAyIEF1dGhvcml6YXRpb24gTGlzdHMsIGV0Yy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZVR1cGxlID0gU2lnbmF0dXJlLnRvVHVwbGUoe1xuICogICByOiAxMjNuLFxuICogICBzOiA0NTZuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IFt5UGFyaXR5OiAnMHgwMScsIHI6ICcweDdiJywgczogJzB4MWM4J11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiBbXG4gICAgICAgIHlQYXJpdHkgPyAnMHgwMScgOiAnMHgnLFxuICAgICAgICByID09PSAwbiA/ICcweCcgOiBIZXgudHJpbUxlZnQoSGV4LmZyb21OdW1iZXIocikpLFxuICAgICAgICBzID09PSAwbiA/ICcweCcgOiBIZXgudHJpbUxlZnQoSGV4LmZyb21OdW1iZXIocykpLFxuICAgIF07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIFNpZ25hdHVyZS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZS52YWxpZGF0ZSh7XG4gKiAgIHI6IC00OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgRUNEU0EgYHZgIHZhbHVlIHRvIGEgYHlQYXJpdHlgIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeVBhcml0eSA9IFNpZ25hdHVyZS52VG9ZUGFyaXR5KDI4KVxuICogLy8gQGxvZzogMVxuICogYGBgXG4gKlxuICogQHBhcmFtIHYgLSBUaGUgRUNEU0EgYHZgIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYHlQYXJpdHlgIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdlRvWVBhcml0eSh2KSB7XG4gICAgaWYgKHYgPT09IDAgfHwgdiA9PT0gMjcpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh2ID09PSAxIHx8IHYgPT09IDI4KVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodiA+PSAzNSlcbiAgICAgICAgcmV0dXJuIHYgJSAyID09PSAwID8gMSA6IDA7XG4gICAgdGhyb3cgbmV3IEludmFsaWRWRXJyb3IoeyB2YWx1ZTogdiB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBFQ0RTQSBgdmAgdmFsdWUgdG8gYSBgeVBhcml0eWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1YoMSlcbiAqIC8vIEBsb2c6IDI4XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geVBhcml0eSAtIFRoZSBFQ0RTQSBgeVBhcml0eWAgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgdmAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5UGFyaXR5VG9WKHlQYXJpdHkpIHtcbiAgICBpZiAoeVBhcml0eSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDI3O1xuICAgIGlmICh5UGFyaXR5ID09PSAxKVxuICAgICAgICByZXR1cm4gMjg7XG4gICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2VyaWFsaXplZCBzaWduYXR1cmUgaXMgb2YgYW4gaW52YWxpZCBzaXplLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtzaWduYXR1cmV9XFxgIGlzIGFuIGludmFsaWQgc2lnbmF0dXJlIHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiA2NCBieXRlcyBvciA2NSBieXRlcy4nLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCAke0hleC5zaXplKEhleC5mcm9tKHNpZ25hdHVyZSkpfSBieXRlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGlzIG1pc3NpbmcgZWl0aGVyIGFuIGByYCwgYHNgLCBvciBgeVBhcml0eWAgcHJvcGVydHkuICovXG5leHBvcnQgY2xhc3MgTWlzc2luZ1Byb3BlcnRpZXNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2lnbmF0dXJlIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpZ25hdHVyZSBcXGAke0pzb24uc3RyaW5naWZ5KHNpZ25hdHVyZSl9XFxgIGlzIG1pc3NpbmcgZWl0aGVyIGFuIFxcYHJcXGAsIFxcYHNcXGAsIG9yIFxcYHlQYXJpdHlcXGAgcHJvcGVydHkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuTWlzc2luZ1Byb3BlcnRpZXNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHJgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRSRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgciB2YWx1ZS4gciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHNgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgcyB2YWx1ZS4gcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHlQYXJpdHlgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRZUGFyaXR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgeS1wYXJpdHkgdmFsdWUuIFktcGFyaXR5IG11c3QgYmUgMCBvciAxLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRZUGFyaXR5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGB2YCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHYgdmFsdWUuIHYgbXVzdCBiZSAyNywgMjggb3IgPj0zNS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkVkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Signature.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Siwe.js":
/*!********************************************!*\
  !*** ../node_modules/ox/_esm/core/Siwe.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidMessageFieldError: () => (/* binding */ InvalidMessageFieldError),\n/* harmony export */   createMessage: () => (/* binding */ createMessage),\n/* harmony export */   domainRegex: () => (/* binding */ domainRegex),\n/* harmony export */   generateNonce: () => (/* binding */ generateNonce),\n/* harmony export */   ipRegex: () => (/* binding */ ipRegex),\n/* harmony export */   isUri: () => (/* binding */ isUri),\n/* harmony export */   localhostRegex: () => (/* binding */ localhostRegex),\n/* harmony export */   nonceRegex: () => (/* binding */ nonceRegex),\n/* harmony export */   parseMessage: () => (/* binding */ parseMessage),\n/* harmony export */   prefixRegex: () => (/* binding */ prefixRegex),\n/* harmony export */   schemeRegex: () => (/* binding */ schemeRegex),\n/* harmony export */   suffixRegex: () => (/* binding */ suffixRegex),\n/* harmony export */   validateMessage: () => (/* binding */ validateMessage)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _internal_uid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/uid.js */ \"../node_modules/ox/_esm/core/internal/uid.js\");\n\n\n\nconst domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;\nconst ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;\nconst localhostRegex = /^localhost(:[0-9]{1,5})?$/;\nconst nonceRegex = /^[a-zA-Z0-9]{8,}$/;\nconst schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;\n// https://regexr.com/80gdj\nconst prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?<address>0x[a-fA-F0-9]{40})\\n\\n(?:(?<statement>.*)\\n\\n)?/;\n// https://regexr.com/80gf9\nconst suffixRegex = /(?:URI: (?<uri>.+))\\n(?:Version: (?<version>.+))\\n(?:Chain ID: (?<chainId>\\d+))\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\n(?:Issued At: (?<issuedAt>.+))(?:\\nExpiration Time: (?<expirationTime>.+))?(?:\\nNot Before: (?<notBefore>.+))?(?:\\nRequest ID: (?<requestId>.+))?/;\n/**\n * Creates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @log: \"example.com wants you to sign in with your Ethereum account:\n * // @log: 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n * // @log:\n * // @log:\n * // @log: URI: https://example.com/path\n * // @log: Version: 1\n * // @log: Chain ID: 1\n * // @log: Nonce: foobarbaz\n * // @log: Issued At: 2023-02-01T00:00:00.000Z\"\n * ```\n *\n * @param value - Values to use when creating EIP-4361 formatted message.\n * @returns EIP-4361 formatted message.\n */\nfunction createMessage(value) {\n    const { chainId, domain, expirationTime, issuedAt = new Date(), nonce, notBefore, requestId, resources, scheme, uri, version, } = value;\n    // Validate fields\n    {\n        // Required fields\n        if (chainId !== Math.floor(chainId))\n            throw new InvalidMessageFieldError({\n                field: 'chainId',\n                metaMessages: [\n                    '- Chain ID must be a EIP-155 chain ID.',\n                    '- See https://eips.ethereum.org/EIPS/eip-155',\n                    '',\n                    `Provided value: ${chainId}`,\n                ],\n            });\n        if (!(domainRegex.test(domain) ||\n            ipRegex.test(domain) ||\n            localhostRegex.test(domain)))\n            throw new InvalidMessageFieldError({\n                field: 'domain',\n                metaMessages: [\n                    '- Domain must be an RFC 3986 authority.',\n                    '- See https://www.rfc-editor.org/rfc/rfc3986',\n                    '',\n                    `Provided value: ${domain}`,\n                ],\n            });\n        if (!nonceRegex.test(nonce))\n            throw new InvalidMessageFieldError({\n                field: 'nonce',\n                metaMessages: [\n                    '- Nonce must be at least 8 characters.',\n                    '- Nonce must be alphanumeric.',\n                    '',\n                    `Provided value: ${nonce}`,\n                ],\n            });\n        if (!isUri(uri))\n            throw new InvalidMessageFieldError({\n                field: 'uri',\n                metaMessages: [\n                    '- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.',\n                    '- See https://www.rfc-editor.org/rfc/rfc3986',\n                    '',\n                    `Provided value: ${uri}`,\n                ],\n            });\n        if (version !== '1')\n            throw new InvalidMessageFieldError({\n                field: 'version',\n                metaMessages: [\n                    \"- Version must be '1'.\",\n                    '',\n                    `Provided value: ${version}`,\n                ],\n            });\n        // Optional fields\n        if (scheme && !schemeRegex.test(scheme))\n            throw new InvalidMessageFieldError({\n                field: 'scheme',\n                metaMessages: [\n                    '- Scheme must be an RFC 3986 URI scheme.',\n                    '- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1',\n                    '',\n                    `Provided value: ${scheme}`,\n                ],\n            });\n        const statement = value.statement;\n        if (statement?.includes('\\n'))\n            throw new InvalidMessageFieldError({\n                field: 'statement',\n                metaMessages: [\n                    \"- Statement must not include '\\\\n'.\",\n                    '',\n                    `Provided value: ${statement}`,\n                ],\n            });\n    }\n    // Construct message\n    const address = _Address_js__WEBPACK_IMPORTED_MODULE_0__.from(value.address, { checksum: true });\n    const origin = (() => {\n        if (scheme)\n            return `${scheme}://${domain}`;\n        return domain;\n    })();\n    const statement = (() => {\n        if (!value.statement)\n            return '';\n        return `${value.statement}\\n`;\n    })();\n    const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`;\n    let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}\\nNonce: ${nonce}\\nIssued At: ${issuedAt.toISOString()}`;\n    if (expirationTime)\n        suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`;\n    if (notBefore)\n        suffix += `\\nNot Before: ${notBefore.toISOString()}`;\n    if (requestId)\n        suffix += `\\nRequest ID: ${requestId}`;\n    if (resources) {\n        let content = '\\nResources:';\n        for (const resource of resources) {\n            if (!isUri(resource))\n                throw new InvalidMessageFieldError({\n                    field: 'resources',\n                    metaMessages: [\n                        '- Every resource must be a RFC 3986 URI.',\n                        '- See https://www.rfc-editor.org/rfc/rfc3986',\n                        '',\n                        `Provided value: ${resource}`,\n                    ],\n                });\n            content += `\\n- ${resource}`;\n        }\n        suffix += content;\n    }\n    return `${prefix}\\n${suffix}`;\n}\n/**\n * Generates random [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) nonce.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.generateNonce()\n * // @log: '65ed4681d4efe0270b923ff5f4b097b1c95974dc33aeebecd5724c42fd86dfd25dc70b27ef836b2aa22e68f19ebcccc1'\n * ```\n *\n * @returns Random nonce.\n */\nfunction generateNonce() {\n    return (0,_internal_uid_js__WEBPACK_IMPORTED_MODULE_1__.uid)(96);\n}\n/**\n * Check if the given URI is a valid [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) URI.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.isUri('https://example.com/foo')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `false` if invalid, otherwise the valid URI.\n */\n// based on https://github.com/ogt/valid-url\nfunction isUri(value) {\n    // check for illegal characters\n    if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value))\n        return false;\n    // check for hex escapes that aren't complete\n    if (/%[^0-9a-f]/i.test(value))\n        return false;\n    if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))\n        return false;\n    // from RFC 3986\n    const splitted = splitUri(value);\n    const scheme = splitted[1];\n    const authority = splitted[2];\n    const path = splitted[3];\n    const query = splitted[4];\n    const fragment = splitted[5];\n    // scheme and path are required, though the path can be empty\n    if (!(scheme?.length && path && path.length >= 0))\n        return false;\n    // if authority is present, the path must be empty or begin with a /\n    if (authority?.length) {\n        if (!(path.length === 0 || /^\\//.test(path)))\n            return false;\n    }\n    else {\n        // if authority is not present, the path must not start with //\n        if (/^\\/\\//.test(path))\n            return false;\n    }\n    // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n    if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase()))\n        return false;\n    let out = '';\n    // re-assemble the URL per section 5.3 in RFC 3986\n    out += `${scheme}:`;\n    if (authority?.length)\n        out += `//${authority}`;\n    out += path;\n    if (query?.length)\n        out += `?${query}`;\n    if (fragment?.length)\n        out += `#${fragment}`;\n    return out;\n}\nfunction splitUri(value) {\n    return value.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n}\n/**\n * [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message into message fields object.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.parseMessage(`example.com wants you to sign in with your Ethereum account:\n * 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n *\n * I accept the ExampleOrg Terms of Service: https://example.com/tos\n *\n * URI: https://example.com/path\n * Version: 1\n * Chain ID: 1\n * Nonce: foobarbaz\n * Issued At: 2023-02-01T00:00:00.000Z`)\n * // @log: {\n * // @log:   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * // @log:   chainId: 1,\n * // @log:   domain: 'example.com',\n * // @log:   issuedAt: '2023-02-01T00:00:00.000Z',\n * // @log:   nonce: 'foobarbaz',\n * // @log:   statement: 'I accept the ExampleOrg Terms of Service: https://example.com/tos',\n * // @log:   uri: 'https://example.com/path',\n * // @log:   version: '1',\n * // @log: }\n * ```\n *\n * @param message - [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.\n * @returns Message fields object.\n */\nfunction parseMessage(message) {\n    const { scheme, statement, ...prefix } = (message.match(prefixRegex)\n        ?.groups ?? {});\n    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = (message.match(suffixRegex)?.groups ?? {});\n    const resources = message.split('Resources:')[1]?.split('\\n- ').slice(1);\n    return {\n        ...prefix,\n        ...suffix,\n        ...(chainId ? { chainId: Number(chainId) } : {}),\n        ...(expirationTime ? { expirationTime: new Date(expirationTime) } : {}),\n        ...(issuedAt ? { issuedAt: new Date(issuedAt) } : {}),\n        ...(notBefore ? { notBefore: new Date(notBefore) } : {}),\n        ...(requestId ? { requestId } : {}),\n        ...(resources ? { resources } : {}),\n        ...(scheme ? { scheme } : {}),\n        ...(statement ? { statement } : {}),\n    };\n}\n/**\n * Validates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.validateMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: 'example.com',\n *   message: {\n *     address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *     chainId: 1,\n *     domain: 'example.com',\n *     nonce: 'foobarbaz',\n *     uri: 'https://example.com/path',\n *     version: '1',\n *   },\n *   nonce: 'foobarbaz',\n * })\n * // @log: true\n * ```\n *\n * @param value - Values to use when validating EIP-4361 formatted message.\n * @returns Whether the message is valid.\n */\nfunction validateMessage(value) {\n    const { address, domain, message, nonce, scheme, time = new Date() } = value;\n    if (domain && message.domain !== domain)\n        return false;\n    if (nonce && message.nonce !== nonce)\n        return false;\n    if (scheme && message.scheme !== scheme)\n        return false;\n    if (message.expirationTime && time >= message.expirationTime)\n        return false;\n    if (message.notBefore && time < message.notBefore)\n        return false;\n    try {\n        if (!message.address)\n            return false;\n        if (address && !_Address_js__WEBPACK_IMPORTED_MODULE_0__.isEqual(message.address, address))\n            return false;\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\n/**\n * Thrown when a field in a SIWE Message is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1.1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @error: Siwe.InvalidMessageFieldError: Invalid Sign-In with Ethereum message field \"chainId\".\n * // @error: - Chain ID must be a EIP-155 chain ID.\n * // @error: - See https://eips.ethereum.org/EIPS/eip-155\n * // @error: Provided value: 1.1\n * ```\n */\nclass InvalidMessageFieldError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(parameters) {\n        const { field, metaMessages } = parameters;\n        super(`Invalid Sign-In with Ethereum message field \"${field}\".`, {\n            metaMessages,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Siwe.InvalidMessageFieldError'\n        });\n    }\n}\n//# sourceMappingURL=Siwe.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TaXdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDRjtBQUNFO0FBQ2pDLGlEQUFpRCxLQUFLLDBCQUEwQixHQUFHLFFBQVEsSUFBSTtBQUMvRix3TEFBd0wsSUFBSTtBQUM1TCwwQ0FBMEMsSUFBSTtBQUM5QyxpQ0FBaUMsR0FBRztBQUNwQztBQUNQO0FBQ08scUdBQXFHLElBQUksbUZBQW1GLEdBQUc7QUFDdE07QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHdIQUF3SDtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLDZDQUFZLGtCQUFrQixnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBLHNCQUFzQixPQUFPLEtBQUssT0FBTztBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLEtBQUs7QUFDTCxzQkFBc0IsUUFBUSxvREFBb0QsUUFBUSxNQUFNLFVBQVU7QUFDMUcseUJBQXlCLElBQUksYUFBYSxRQUFRLGNBQWMsUUFBUSxXQUFXLE1BQU0sZUFBZSx1QkFBdUI7QUFDL0g7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQSxpQkFBaUI7QUFDakIsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPLElBQUksT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcscURBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksK0JBQStCO0FBQzNDLHNCQUFzQjtBQUN0QixZQUFZLHFFQUFxRSwyQ0FBMkM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCLElBQUk7QUFDdkQsK0JBQStCLDJDQUEyQyxJQUFJO0FBQzlFLHlCQUF5QiwrQkFBK0IsSUFBSTtBQUM1RCwwQkFBMEIsaUNBQWlDLElBQUk7QUFDL0QsMEJBQTBCLFlBQVksSUFBSTtBQUMxQywwQkFBMEIsWUFBWSxJQUFJO0FBQzFDLHVCQUF1QixTQUFTLElBQUk7QUFDcEMsMEJBQTBCLFlBQVksSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSw2REFBNkQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDLGlEQUFnQjtBQUM5RDtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEMsOERBQThELE1BQU07QUFDcEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TaXdlLmpzPzk0OTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4vaW50ZXJuYWwvdWlkLmpzJztcbmV4cG9ydCBjb25zdCBkb21haW5SZWdleCA9IC9eKFthLXpBLVowLTldKFthLXpBLVowLTlcXC1dezAsNjF9W2EtekEtWjAtOV0pP1xcLikrW2EtekEtWl17Mix9KDpbMC05XXsxLDV9KT8kLztcbmV4cG9ydCBjb25zdCBpcFJlZ2V4ID0gL14oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSg6WzAtOV17MSw1fSk/JC87XG5leHBvcnQgY29uc3QgbG9jYWxob3N0UmVnZXggPSAvXmxvY2FsaG9zdCg6WzAtOV17MSw1fSk/JC87XG5leHBvcnQgY29uc3Qgbm9uY2VSZWdleCA9IC9eW2EtekEtWjAtOV17OCx9JC87XG5leHBvcnQgY29uc3Qgc2NoZW1lUmVnZXggPSAvXihbYS16QS1aXVthLXpBLVowLTkrLS5dKikkLztcbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS84MGdkalxuZXhwb3J0IGNvbnN0IHByZWZpeFJlZ2V4ID0gL14oPzooPzxzY2hlbWU+W2EtekEtWl1bYS16QS1aMC05Ky0uXSopOlxcL1xcLyk/KD88ZG9tYWluPlthLXpBLVowLTkrLS5dKig/OjpbMC05XXsxLDV9KT8pICg/OndhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50OlxcbikoPzxhZGRyZXNzPjB4W2EtZkEtRjAtOV17NDB9KVxcblxcbig/Oig/PHN0YXRlbWVudD4uKilcXG5cXG4pPy87XG4vLyBodHRwczovL3JlZ2V4ci5jb20vODBnZjlcbmV4cG9ydCBjb25zdCBzdWZmaXhSZWdleCA9IC8oPzpVUkk6ICg/PHVyaT4uKykpXFxuKD86VmVyc2lvbjogKD88dmVyc2lvbj4uKykpXFxuKD86Q2hhaW4gSUQ6ICg/PGNoYWluSWQ+XFxkKykpXFxuKD86Tm9uY2U6ICg/PG5vbmNlPlthLXpBLVowLTldKykpXFxuKD86SXNzdWVkIEF0OiAoPzxpc3N1ZWRBdD4uKykpKD86XFxuRXhwaXJhdGlvbiBUaW1lOiAoPzxleHBpcmF0aW9uVGltZT4uKykpPyg/Olxcbk5vdCBCZWZvcmU6ICg/PG5vdEJlZm9yZT4uKykpPyg/OlxcblJlcXVlc3QgSUQ6ICg/PHJlcXVlc3RJZD4uKykpPy87XG4vKipcbiAqIENyZWF0ZXMgW0VJUC00MzYxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQzNjEpIGZvcm1hdHRlZCBtZXNzYWdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2l3ZSB9IGZyb20gJ294J1xuICpcbiAqIFNpd2UuY3JlYXRlTWVzc2FnZSh7XG4gKiAgIGFkZHJlc3M6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnLFxuICogICBjaGFpbklkOiAxLFxuICogICBkb21haW46ICdleGFtcGxlLmNvbScsXG4gKiAgIG5vbmNlOiAnZm9vYmFyYmF6JyxcbiAqICAgdXJpOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9wYXRoJyxcbiAqICAgdmVyc2lvbjogJzEnLFxuICogfSlcbiAqIC8vIEBsb2c6IFwiZXhhbXBsZS5jb20gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIEV0aGVyZXVtIGFjY291bnQ6XG4gKiAvLyBAbG9nOiAweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWVcbiAqIC8vIEBsb2c6XG4gKiAvLyBAbG9nOlxuICogLy8gQGxvZzogVVJJOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGhcbiAqIC8vIEBsb2c6IFZlcnNpb246IDFcbiAqIC8vIEBsb2c6IENoYWluIElEOiAxXG4gKiAvLyBAbG9nOiBOb25jZTogZm9vYmFyYmF6XG4gKiAvLyBAbG9nOiBJc3N1ZWQgQXQ6IDIwMjMtMDItMDFUMDA6MDA6MDAuMDAwWlwiXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZXMgdG8gdXNlIHdoZW4gY3JlYXRpbmcgRUlQLTQzNjEgZm9ybWF0dGVkIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBFSVAtNDM2MSBmb3JtYXR0ZWQgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2UodmFsdWUpIHtcbiAgICBjb25zdCB7IGNoYWluSWQsIGRvbWFpbiwgZXhwaXJhdGlvblRpbWUsIGlzc3VlZEF0ID0gbmV3IERhdGUoKSwgbm9uY2UsIG5vdEJlZm9yZSwgcmVxdWVzdElkLCByZXNvdXJjZXMsIHNjaGVtZSwgdXJpLCB2ZXJzaW9uLCB9ID0gdmFsdWU7XG4gICAgLy8gVmFsaWRhdGUgZmllbGRzXG4gICAge1xuICAgICAgICAvLyBSZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgaWYgKGNoYWluSWQgIT09IE1hdGguZmxvb3IoY2hhaW5JZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yKHtcbiAgICAgICAgICAgICAgICBmaWVsZDogJ2NoYWluSWQnLFxuICAgICAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICAgICAnLSBDaGFpbiBJRCBtdXN0IGJlIGEgRUlQLTE1NSBjaGFpbiBJRC4nLFxuICAgICAgICAgICAgICAgICAgICAnLSBTZWUgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xNTUnLFxuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgYFByb3ZpZGVkIHZhbHVlOiAke2NoYWluSWR9YCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghKGRvbWFpblJlZ2V4LnRlc3QoZG9tYWluKSB8fFxuICAgICAgICAgICAgaXBSZWdleC50ZXN0KGRvbWFpbikgfHxcbiAgICAgICAgICAgIGxvY2FsaG9zdFJlZ2V4LnRlc3QoZG9tYWluKSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yKHtcbiAgICAgICAgICAgICAgICBmaWVsZDogJ2RvbWFpbicsXG4gICAgICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICctIERvbWFpbiBtdXN0IGJlIGFuIFJGQyAzOTg2IGF1dGhvcml0eS4nLFxuICAgICAgICAgICAgICAgICAgICAnLSBTZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzM5ODYnLFxuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgYFByb3ZpZGVkIHZhbHVlOiAke2RvbWFpbn1gLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFub25jZVJlZ2V4LnRlc3Qobm9uY2UpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlRmllbGRFcnJvcih7XG4gICAgICAgICAgICAgICAgZmllbGQ6ICdub25jZScsXG4gICAgICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICctIE5vbmNlIG11c3QgYmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzLicsXG4gICAgICAgICAgICAgICAgICAgICctIE5vbmNlIG11c3QgYmUgYWxwaGFudW1lcmljLicsXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBgUHJvdmlkZWQgdmFsdWU6ICR7bm9uY2V9YCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNVcmkodXJpKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGZpZWxkOiAndXJpJyxcbiAgICAgICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJy0gVVJJIG11c3QgYmUgYSBSRkMgMzk4NiBVUkkgcmVmZXJyaW5nIHRvIHRoZSByZXNvdXJjZSB0aGF0IGlzIHRoZSBzdWJqZWN0IG9mIHRoZSBzaWduaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICctIFNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NicsXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBgUHJvdmlkZWQgdmFsdWU6ICR7dXJpfWAsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gJzEnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlRmllbGRFcnJvcih7XG4gICAgICAgICAgICAgICAgZmllbGQ6ICd2ZXJzaW9uJyxcbiAgICAgICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgXCItIFZlcnNpb24gbXVzdCBiZSAnMScuXCIsXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBgUHJvdmlkZWQgdmFsdWU6ICR7dmVyc2lvbn1gLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgLy8gT3B0aW9uYWwgZmllbGRzXG4gICAgICAgIGlmIChzY2hlbWUgJiYgIXNjaGVtZVJlZ2V4LnRlc3Qoc2NoZW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGZpZWxkOiAnc2NoZW1lJyxcbiAgICAgICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJy0gU2NoZW1lIG11c3QgYmUgYW4gUkZDIDM5ODYgVVJJIHNjaGVtZS4nLFxuICAgICAgICAgICAgICAgICAgICAnLSBTZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzM5ODYjc2VjdGlvbi0zLjEnLFxuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgYFByb3ZpZGVkIHZhbHVlOiAke3NjaGVtZX1gLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gdmFsdWUuc3RhdGVtZW50O1xuICAgICAgICBpZiAoc3RhdGVtZW50Py5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yKHtcbiAgICAgICAgICAgICAgICBmaWVsZDogJ3N0YXRlbWVudCcsXG4gICAgICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiLSBTdGF0ZW1lbnQgbXVzdCBub3QgaW5jbHVkZSAnXFxcXG4nLlwiLFxuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgYFByb3ZpZGVkIHZhbHVlOiAke3N0YXRlbWVudH1gLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQ29uc3RydWN0IG1lc3NhZ2VcbiAgICBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tKHZhbHVlLmFkZHJlc3MsIHsgY2hlY2tzdW06IHRydWUgfSk7XG4gICAgY29uc3Qgb3JpZ2luID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHNjaGVtZSlcbiAgICAgICAgICAgIHJldHVybiBgJHtzY2hlbWV9Oi8vJHtkb21haW59YDtcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHN0YXRlbWVudCA9ICgoKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUuc3RhdGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICByZXR1cm4gYCR7dmFsdWUuc3RhdGVtZW50fVxcbmA7XG4gICAgfSkoKTtcbiAgICBjb25zdCBwcmVmaXggPSBgJHtvcmlnaW59IHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50OlxcbiR7YWRkcmVzc31cXG5cXG4ke3N0YXRlbWVudH1gO1xuICAgIGxldCBzdWZmaXggPSBgVVJJOiAke3VyaX1cXG5WZXJzaW9uOiAke3ZlcnNpb259XFxuQ2hhaW4gSUQ6ICR7Y2hhaW5JZH1cXG5Ob25jZTogJHtub25jZX1cXG5Jc3N1ZWQgQXQ6ICR7aXNzdWVkQXQudG9JU09TdHJpbmcoKX1gO1xuICAgIGlmIChleHBpcmF0aW9uVGltZSlcbiAgICAgICAgc3VmZml4ICs9IGBcXG5FeHBpcmF0aW9uIFRpbWU6ICR7ZXhwaXJhdGlvblRpbWUudG9JU09TdHJpbmcoKX1gO1xuICAgIGlmIChub3RCZWZvcmUpXG4gICAgICAgIHN1ZmZpeCArPSBgXFxuTm90IEJlZm9yZTogJHtub3RCZWZvcmUudG9JU09TdHJpbmcoKX1gO1xuICAgIGlmIChyZXF1ZXN0SWQpXG4gICAgICAgIHN1ZmZpeCArPSBgXFxuUmVxdWVzdCBJRDogJHtyZXF1ZXN0SWR9YDtcbiAgICBpZiAocmVzb3VyY2VzKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gJ1xcblJlc291cmNlczonO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHJlc291cmNlcykge1xuICAgICAgICAgICAgaWYgKCFpc1VyaShyZXNvdXJjZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlRmllbGRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiAncmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnLSBFdmVyeSByZXNvdXJjZSBtdXN0IGJlIGEgUkZDIDM5ODYgVVJJLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnLSBTZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzM5ODYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBgUHJvdmlkZWQgdmFsdWU6ICR7cmVzb3VyY2V9YCxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYFxcbi0gJHtyZXNvdXJjZX1gO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZpeCArPSBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJlZml4fVxcbiR7c3VmZml4fWA7XG59XG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb20gW0VJUC00MzYxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQzNjEpIG5vbmNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2l3ZSB9IGZyb20gJ294J1xuICpcbiAqIFNpd2UuZ2VuZXJhdGVOb25jZSgpXG4gKiAvLyBAbG9nOiAnNjVlZDQ2ODFkNGVmZTAyNzBiOTIzZmY1ZjRiMDk3YjFjOTU5NzRkYzMzYWVlYmVjZDU3MjRjNDJmZDg2ZGZkMjVkYzcwYjI3ZWY4MzZiMmFhMjJlNjhmMTllYmNjY2MxJ1xuICogYGBgXG4gKlxuICogQHJldHVybnMgUmFuZG9tIG5vbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVOb25jZSgpIHtcbiAgICByZXR1cm4gdWlkKDk2KTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIFVSSSBpcyBhIHZhbGlkIFtSRkMgMzk4Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzM5ODYpIFVSSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpd2UgfSBmcm9tICdveCdcbiAqXG4gKiBTaXdlLmlzVXJpKCdodHRwczovL2V4YW1wbGUuY29tL2ZvbycpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGBmYWxzZWAgaWYgaW52YWxpZCwgb3RoZXJ3aXNlIHRoZSB2YWxpZCBVUkkuXG4gKi9cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vZ3QvdmFsaWQtdXJsXG5leHBvcnQgZnVuY3Rpb24gaXNVcmkodmFsdWUpIHtcbiAgICAvLyBjaGVjayBmb3IgaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKC9bXmEtejAtOVxcOlxcL1xcP1xcI1xcW1xcXVxcQFxcIVxcJFxcJlxcJ1xcKFxcKVxcKlxcK1xcLFxcO1xcPVxcLlxcLVxcX1xcflxcJV0vaS50ZXN0KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGNoZWNrIGZvciBoZXggZXNjYXBlcyB0aGF0IGFyZW4ndCBjb21wbGV0ZVxuICAgIGlmICgvJVteMC05YS1mXS9pLnRlc3QodmFsdWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKC8lWzAtOWEtZl0oOj9bXjAtOWEtZl18JCkvaS50ZXN0KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGZyb20gUkZDIDM5ODZcbiAgICBjb25zdCBzcGxpdHRlZCA9IHNwbGl0VXJpKHZhbHVlKTtcbiAgICBjb25zdCBzY2hlbWUgPSBzcGxpdHRlZFsxXTtcbiAgICBjb25zdCBhdXRob3JpdHkgPSBzcGxpdHRlZFsyXTtcbiAgICBjb25zdCBwYXRoID0gc3BsaXR0ZWRbM107XG4gICAgY29uc3QgcXVlcnkgPSBzcGxpdHRlZFs0XTtcbiAgICBjb25zdCBmcmFnbWVudCA9IHNwbGl0dGVkWzVdO1xuICAgIC8vIHNjaGVtZSBhbmQgcGF0aCBhcmUgcmVxdWlyZWQsIHRob3VnaCB0aGUgcGF0aCBjYW4gYmUgZW1wdHlcbiAgICBpZiAoIShzY2hlbWU/Lmxlbmd0aCAmJiBwYXRoICYmIHBhdGgubGVuZ3RoID49IDApKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gaWYgYXV0aG9yaXR5IGlzIHByZXNlbnQsIHRoZSBwYXRoIG11c3QgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIC9cbiAgICBpZiAoYXV0aG9yaXR5Py5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCEocGF0aC5sZW5ndGggPT09IDAgfHwgL15cXC8vLnRlc3QocGF0aCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaWYgYXV0aG9yaXR5IGlzIG5vdCBwcmVzZW50LCB0aGUgcGF0aCBtdXN0IG5vdCBzdGFydCB3aXRoIC8vXG4gICAgICAgIGlmICgvXlxcL1xcLy8udGVzdChwYXRoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gc2NoZW1lIG11c3QgYmVnaW4gd2l0aCBhIGxldHRlciwgdGhlbiBjb25zaXN0IG9mIGxldHRlcnMsIGRpZ2l0cywgKywgLiwgb3IgLVxuICAgIGlmICghL15bYS16XVthLXowLTlcXCtcXC1cXC5dKiQvLnRlc3Qoc2NoZW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIC8vIHJlLWFzc2VtYmxlIHRoZSBVUkwgcGVyIHNlY3Rpb24gNS4zIGluIFJGQyAzOTg2XG4gICAgb3V0ICs9IGAke3NjaGVtZX06YDtcbiAgICBpZiAoYXV0aG9yaXR5Py5sZW5ndGgpXG4gICAgICAgIG91dCArPSBgLy8ke2F1dGhvcml0eX1gO1xuICAgIG91dCArPSBwYXRoO1xuICAgIGlmIChxdWVyeT8ubGVuZ3RoKVxuICAgICAgICBvdXQgKz0gYD8ke3F1ZXJ5fWA7XG4gICAgaWYgKGZyYWdtZW50Py5sZW5ndGgpXG4gICAgICAgIG91dCArPSBgIyR7ZnJhZ21lbnR9YDtcbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gc3BsaXRVcmkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubWF0Y2goLyg/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLyhbXlxcLz8jXSopKT8oW14/I10qKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8vKTtcbn1cbi8qKlxuICogW0VJUC00MzYxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQzNjEpIGZvcm1hdHRlZCBtZXNzYWdlIGludG8gbWVzc2FnZSBmaWVsZHMgb2JqZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2l3ZSB9IGZyb20gJ294J1xuICpcbiAqIFNpd2UucGFyc2VNZXNzYWdlKGBleGFtcGxlLmNvbSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpcbiAqIDB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZVxuICpcbiAqIEkgYWNjZXB0IHRoZSBFeGFtcGxlT3JnIFRlcm1zIG9mIFNlcnZpY2U6IGh0dHBzOi8vZXhhbXBsZS5jb20vdG9zXG4gKlxuICogVVJJOiBodHRwczovL2V4YW1wbGUuY29tL3BhdGhcbiAqIFZlcnNpb246IDFcbiAqIENoYWluIElEOiAxXG4gKiBOb25jZTogZm9vYmFyYmF6XG4gKiBJc3N1ZWQgQXQ6IDIwMjMtMDItMDFUMDA6MDA6MDAuMDAwWmApXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBkb21haW46ICdleGFtcGxlLmNvbScsXG4gKiAvLyBAbG9nOiAgIGlzc3VlZEF0OiAnMjAyMy0wMi0wMVQwMDowMDowMC4wMDBaJyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6ICdmb29iYXJiYXonLFxuICogLy8gQGxvZzogICBzdGF0ZW1lbnQ6ICdJIGFjY2VwdCB0aGUgRXhhbXBsZU9yZyBUZXJtcyBvZiBTZXJ2aWNlOiBodHRwczovL2V4YW1wbGUuY29tL3RvcycsXG4gKiAvLyBAbG9nOiAgIHVyaTogJ2h0dHBzOi8vZXhhbXBsZS5jb20vcGF0aCcsXG4gKiAvLyBAbG9nOiAgIHZlcnNpb246ICcxJyxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIC0gW0VJUC00MzYxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQzNjEpIGZvcm1hdHRlZCBtZXNzYWdlLlxuICogQHJldHVybnMgTWVzc2FnZSBmaWVsZHMgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB7IHNjaGVtZSwgc3RhdGVtZW50LCAuLi5wcmVmaXggfSA9IChtZXNzYWdlLm1hdGNoKHByZWZpeFJlZ2V4KVxuICAgICAgICA/Lmdyb3VwcyA/PyB7fSk7XG4gICAgY29uc3QgeyBjaGFpbklkLCBleHBpcmF0aW9uVGltZSwgaXNzdWVkQXQsIG5vdEJlZm9yZSwgcmVxdWVzdElkLCAuLi5zdWZmaXggfSA9IChtZXNzYWdlLm1hdGNoKHN1ZmZpeFJlZ2V4KT8uZ3JvdXBzID8/IHt9KTtcbiAgICBjb25zdCByZXNvdXJjZXMgPSBtZXNzYWdlLnNwbGl0KCdSZXNvdXJjZXM6JylbMV0/LnNwbGl0KCdcXG4tICcpLnNsaWNlKDEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByZWZpeCxcbiAgICAgICAgLi4uc3VmZml4LFxuICAgICAgICAuLi4oY2hhaW5JZCA/IHsgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpIH0gOiB7fSksXG4gICAgICAgIC4uLihleHBpcmF0aW9uVGltZSA/IHsgZXhwaXJhdGlvblRpbWU6IG5ldyBEYXRlKGV4cGlyYXRpb25UaW1lKSB9IDoge30pLFxuICAgICAgICAuLi4oaXNzdWVkQXQgPyB7IGlzc3VlZEF0OiBuZXcgRGF0ZShpc3N1ZWRBdCkgfSA6IHt9KSxcbiAgICAgICAgLi4uKG5vdEJlZm9yZSA/IHsgbm90QmVmb3JlOiBuZXcgRGF0ZShub3RCZWZvcmUpIH0gOiB7fSksXG4gICAgICAgIC4uLihyZXF1ZXN0SWQgPyB7IHJlcXVlc3RJZCB9IDoge30pLFxuICAgICAgICAuLi4ocmVzb3VyY2VzID8geyByZXNvdXJjZXMgfSA6IHt9KSxcbiAgICAgICAgLi4uKHNjaGVtZSA/IHsgc2NoZW1lIH0gOiB7fSksXG4gICAgICAgIC4uLihzdGF0ZW1lbnQgPyB7IHN0YXRlbWVudCB9IDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBbRUlQLTQzNjFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM2MSkgbWVzc2FnZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpd2UgfSBmcm9tICdveCdcbiAqXG4gKiBTaXdlLnZhbGlkYXRlTWVzc2FnZSh7XG4gKiAgIGFkZHJlc3M6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnLFxuICogICBkb21haW46ICdleGFtcGxlLmNvbScsXG4gKiAgIG1lc3NhZ2U6IHtcbiAqICAgICBhZGRyZXNzOiAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJyxcbiAqICAgICBjaGFpbklkOiAxLFxuICogICAgIGRvbWFpbjogJ2V4YW1wbGUuY29tJyxcbiAqICAgICBub25jZTogJ2Zvb2JhcmJheicsXG4gKiAgICAgdXJpOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9wYXRoJyxcbiAqICAgICB2ZXJzaW9uOiAnMScsXG4gKiAgIH0sXG4gKiAgIG5vbmNlOiAnZm9vYmFyYmF6JyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZXMgdG8gdXNlIHdoZW4gdmFsaWRhdGluZyBFSVAtNDM2MSBmb3JtYXR0ZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgdmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2UodmFsdWUpIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGRvbWFpbiwgbWVzc2FnZSwgbm9uY2UsIHNjaGVtZSwgdGltZSA9IG5ldyBEYXRlKCkgfSA9IHZhbHVlO1xuICAgIGlmIChkb21haW4gJiYgbWVzc2FnZS5kb21haW4gIT09IGRvbWFpbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChub25jZSAmJiBtZXNzYWdlLm5vbmNlICE9PSBub25jZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzY2hlbWUgJiYgbWVzc2FnZS5zY2hlbWUgIT09IHNjaGVtZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtZXNzYWdlLmV4cGlyYXRpb25UaW1lICYmIHRpbWUgPj0gbWVzc2FnZS5leHBpcmF0aW9uVGltZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtZXNzYWdlLm5vdEJlZm9yZSAmJiB0aW1lIDwgbWVzc2FnZS5ub3RCZWZvcmUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UuYWRkcmVzcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFkZHJlc3MgJiYgIUFkZHJlc3MuaXNFcXVhbChtZXNzYWdlLmFkZHJlc3MsIGFkZHJlc3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgZmllbGQgaW4gYSBTSVdFIE1lc3NhZ2UgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpd2UgfSBmcm9tICdveCdcbiAqXG4gKiBTaXdlLmNyZWF0ZU1lc3NhZ2Uoe1xuICogICBhZGRyZXNzOiAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJyxcbiAqICAgY2hhaW5JZDogMS4xLFxuICogICBkb21haW46ICdleGFtcGxlLmNvbScsXG4gKiAgIG5vbmNlOiAnZm9vYmFyYmF6JyxcbiAqICAgdXJpOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9wYXRoJyxcbiAqICAgdmVyc2lvbjogJzEnLFxuICogfSlcbiAqIC8vIEBlcnJvcjogU2l3ZS5JbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3I6IEludmFsaWQgU2lnbi1JbiB3aXRoIEV0aGVyZXVtIG1lc3NhZ2UgZmllbGQgXCJjaGFpbklkXCIuXG4gKiAvLyBAZXJyb3I6IC0gQ2hhaW4gSUQgbXVzdCBiZSBhIEVJUC0xNTUgY2hhaW4gSUQuXG4gKiAvLyBAZXJyb3I6IC0gU2VlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTU1XG4gKiAvLyBAZXJyb3I6IFByb3ZpZGVkIHZhbHVlOiAxLjFcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCB7IGZpZWxkLCBtZXRhTWVzc2FnZXMgfSA9IHBhcmFtZXRlcnM7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIFNpZ24tSW4gd2l0aCBFdGhlcmV1bSBtZXNzYWdlIGZpZWxkIFwiJHtmaWVsZH1cIi5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2l3ZS5JbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpd2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Siwe.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Solidity.js":
/*!************************************************!*\
  !*** ../node_modules/ox/_esm/core/Solidity.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayRegex: () => (/* binding */ arrayRegex),\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   maxInt104: () => (/* binding */ maxInt104),\n/* harmony export */   maxInt112: () => (/* binding */ maxInt112),\n/* harmony export */   maxInt120: () => (/* binding */ maxInt120),\n/* harmony export */   maxInt128: () => (/* binding */ maxInt128),\n/* harmony export */   maxInt136: () => (/* binding */ maxInt136),\n/* harmony export */   maxInt144: () => (/* binding */ maxInt144),\n/* harmony export */   maxInt152: () => (/* binding */ maxInt152),\n/* harmony export */   maxInt16: () => (/* binding */ maxInt16),\n/* harmony export */   maxInt160: () => (/* binding */ maxInt160),\n/* harmony export */   maxInt168: () => (/* binding */ maxInt168),\n/* harmony export */   maxInt176: () => (/* binding */ maxInt176),\n/* harmony export */   maxInt184: () => (/* binding */ maxInt184),\n/* harmony export */   maxInt192: () => (/* binding */ maxInt192),\n/* harmony export */   maxInt200: () => (/* binding */ maxInt200),\n/* harmony export */   maxInt208: () => (/* binding */ maxInt208),\n/* harmony export */   maxInt216: () => (/* binding */ maxInt216),\n/* harmony export */   maxInt224: () => (/* binding */ maxInt224),\n/* harmony export */   maxInt232: () => (/* binding */ maxInt232),\n/* harmony export */   maxInt24: () => (/* binding */ maxInt24),\n/* harmony export */   maxInt240: () => (/* binding */ maxInt240),\n/* harmony export */   maxInt248: () => (/* binding */ maxInt248),\n/* harmony export */   maxInt256: () => (/* binding */ maxInt256),\n/* harmony export */   maxInt32: () => (/* binding */ maxInt32),\n/* harmony export */   maxInt40: () => (/* binding */ maxInt40),\n/* harmony export */   maxInt48: () => (/* binding */ maxInt48),\n/* harmony export */   maxInt56: () => (/* binding */ maxInt56),\n/* harmony export */   maxInt64: () => (/* binding */ maxInt64),\n/* harmony export */   maxInt72: () => (/* binding */ maxInt72),\n/* harmony export */   maxInt8: () => (/* binding */ maxInt8),\n/* harmony export */   maxInt80: () => (/* binding */ maxInt80),\n/* harmony export */   maxInt88: () => (/* binding */ maxInt88),\n/* harmony export */   maxInt96: () => (/* binding */ maxInt96),\n/* harmony export */   maxUint104: () => (/* binding */ maxUint104),\n/* harmony export */   maxUint112: () => (/* binding */ maxUint112),\n/* harmony export */   maxUint120: () => (/* binding */ maxUint120),\n/* harmony export */   maxUint128: () => (/* binding */ maxUint128),\n/* harmony export */   maxUint136: () => (/* binding */ maxUint136),\n/* harmony export */   maxUint144: () => (/* binding */ maxUint144),\n/* harmony export */   maxUint152: () => (/* binding */ maxUint152),\n/* harmony export */   maxUint16: () => (/* binding */ maxUint16),\n/* harmony export */   maxUint160: () => (/* binding */ maxUint160),\n/* harmony export */   maxUint168: () => (/* binding */ maxUint168),\n/* harmony export */   maxUint176: () => (/* binding */ maxUint176),\n/* harmony export */   maxUint184: () => (/* binding */ maxUint184),\n/* harmony export */   maxUint192: () => (/* binding */ maxUint192),\n/* harmony export */   maxUint200: () => (/* binding */ maxUint200),\n/* harmony export */   maxUint208: () => (/* binding */ maxUint208),\n/* harmony export */   maxUint216: () => (/* binding */ maxUint216),\n/* harmony export */   maxUint224: () => (/* binding */ maxUint224),\n/* harmony export */   maxUint232: () => (/* binding */ maxUint232),\n/* harmony export */   maxUint24: () => (/* binding */ maxUint24),\n/* harmony export */   maxUint240: () => (/* binding */ maxUint240),\n/* harmony export */   maxUint248: () => (/* binding */ maxUint248),\n/* harmony export */   maxUint256: () => (/* binding */ maxUint256),\n/* harmony export */   maxUint32: () => (/* binding */ maxUint32),\n/* harmony export */   maxUint40: () => (/* binding */ maxUint40),\n/* harmony export */   maxUint48: () => (/* binding */ maxUint48),\n/* harmony export */   maxUint56: () => (/* binding */ maxUint56),\n/* harmony export */   maxUint64: () => (/* binding */ maxUint64),\n/* harmony export */   maxUint72: () => (/* binding */ maxUint72),\n/* harmony export */   maxUint8: () => (/* binding */ maxUint8),\n/* harmony export */   maxUint80: () => (/* binding */ maxUint80),\n/* harmony export */   maxUint88: () => (/* binding */ maxUint88),\n/* harmony export */   maxUint96: () => (/* binding */ maxUint96),\n/* harmony export */   minInt104: () => (/* binding */ minInt104),\n/* harmony export */   minInt112: () => (/* binding */ minInt112),\n/* harmony export */   minInt120: () => (/* binding */ minInt120),\n/* harmony export */   minInt128: () => (/* binding */ minInt128),\n/* harmony export */   minInt136: () => (/* binding */ minInt136),\n/* harmony export */   minInt144: () => (/* binding */ minInt144),\n/* harmony export */   minInt152: () => (/* binding */ minInt152),\n/* harmony export */   minInt16: () => (/* binding */ minInt16),\n/* harmony export */   minInt160: () => (/* binding */ minInt160),\n/* harmony export */   minInt168: () => (/* binding */ minInt168),\n/* harmony export */   minInt176: () => (/* binding */ minInt176),\n/* harmony export */   minInt184: () => (/* binding */ minInt184),\n/* harmony export */   minInt192: () => (/* binding */ minInt192),\n/* harmony export */   minInt200: () => (/* binding */ minInt200),\n/* harmony export */   minInt208: () => (/* binding */ minInt208),\n/* harmony export */   minInt216: () => (/* binding */ minInt216),\n/* harmony export */   minInt224: () => (/* binding */ minInt224),\n/* harmony export */   minInt232: () => (/* binding */ minInt232),\n/* harmony export */   minInt24: () => (/* binding */ minInt24),\n/* harmony export */   minInt240: () => (/* binding */ minInt240),\n/* harmony export */   minInt248: () => (/* binding */ minInt248),\n/* harmony export */   minInt256: () => (/* binding */ minInt256),\n/* harmony export */   minInt32: () => (/* binding */ minInt32),\n/* harmony export */   minInt40: () => (/* binding */ minInt40),\n/* harmony export */   minInt48: () => (/* binding */ minInt48),\n/* harmony export */   minInt56: () => (/* binding */ minInt56),\n/* harmony export */   minInt64: () => (/* binding */ minInt64),\n/* harmony export */   minInt72: () => (/* binding */ minInt72),\n/* harmony export */   minInt8: () => (/* binding */ minInt8),\n/* harmony export */   minInt80: () => (/* binding */ minInt80),\n/* harmony export */   minInt88: () => (/* binding */ minInt88),\n/* harmony export */   minInt96: () => (/* binding */ minInt96)\n/* harmony export */ });\nconst arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst maxInt8 = 2n ** (8n - 1n) - 1n;\nconst maxInt16 = 2n ** (16n - 1n) - 1n;\nconst maxInt24 = 2n ** (24n - 1n) - 1n;\nconst maxInt32 = 2n ** (32n - 1n) - 1n;\nconst maxInt40 = 2n ** (40n - 1n) - 1n;\nconst maxInt48 = 2n ** (48n - 1n) - 1n;\nconst maxInt56 = 2n ** (56n - 1n) - 1n;\nconst maxInt64 = 2n ** (64n - 1n) - 1n;\nconst maxInt72 = 2n ** (72n - 1n) - 1n;\nconst maxInt80 = 2n ** (80n - 1n) - 1n;\nconst maxInt88 = 2n ** (88n - 1n) - 1n;\nconst maxInt96 = 2n ** (96n - 1n) - 1n;\nconst maxInt104 = 2n ** (104n - 1n) - 1n;\nconst maxInt112 = 2n ** (112n - 1n) - 1n;\nconst maxInt120 = 2n ** (120n - 1n) - 1n;\nconst maxInt128 = 2n ** (128n - 1n) - 1n;\nconst maxInt136 = 2n ** (136n - 1n) - 1n;\nconst maxInt144 = 2n ** (144n - 1n) - 1n;\nconst maxInt152 = 2n ** (152n - 1n) - 1n;\nconst maxInt160 = 2n ** (160n - 1n) - 1n;\nconst maxInt168 = 2n ** (168n - 1n) - 1n;\nconst maxInt176 = 2n ** (176n - 1n) - 1n;\nconst maxInt184 = 2n ** (184n - 1n) - 1n;\nconst maxInt192 = 2n ** (192n - 1n) - 1n;\nconst maxInt200 = 2n ** (200n - 1n) - 1n;\nconst maxInt208 = 2n ** (208n - 1n) - 1n;\nconst maxInt216 = 2n ** (216n - 1n) - 1n;\nconst maxInt224 = 2n ** (224n - 1n) - 1n;\nconst maxInt232 = 2n ** (232n - 1n) - 1n;\nconst maxInt240 = 2n ** (240n - 1n) - 1n;\nconst maxInt248 = 2n ** (248n - 1n) - 1n;\nconst maxInt256 = 2n ** (256n - 1n) - 1n;\nconst minInt8 = -(2n ** (8n - 1n));\nconst minInt16 = -(2n ** (16n - 1n));\nconst minInt24 = -(2n ** (24n - 1n));\nconst minInt32 = -(2n ** (32n - 1n));\nconst minInt40 = -(2n ** (40n - 1n));\nconst minInt48 = -(2n ** (48n - 1n));\nconst minInt56 = -(2n ** (56n - 1n));\nconst minInt64 = -(2n ** (64n - 1n));\nconst minInt72 = -(2n ** (72n - 1n));\nconst minInt80 = -(2n ** (80n - 1n));\nconst minInt88 = -(2n ** (88n - 1n));\nconst minInt96 = -(2n ** (96n - 1n));\nconst minInt104 = -(2n ** (104n - 1n));\nconst minInt112 = -(2n ** (112n - 1n));\nconst minInt120 = -(2n ** (120n - 1n));\nconst minInt128 = -(2n ** (128n - 1n));\nconst minInt136 = -(2n ** (136n - 1n));\nconst minInt144 = -(2n ** (144n - 1n));\nconst minInt152 = -(2n ** (152n - 1n));\nconst minInt160 = -(2n ** (160n - 1n));\nconst minInt168 = -(2n ** (168n - 1n));\nconst minInt176 = -(2n ** (176n - 1n));\nconst minInt184 = -(2n ** (184n - 1n));\nconst minInt192 = -(2n ** (192n - 1n));\nconst minInt200 = -(2n ** (200n - 1n));\nconst minInt208 = -(2n ** (208n - 1n));\nconst minInt216 = -(2n ** (216n - 1n));\nconst minInt224 = -(2n ** (224n - 1n));\nconst minInt232 = -(2n ** (232n - 1n));\nconst minInt240 = -(2n ** (240n - 1n));\nconst minInt248 = -(2n ** (248n - 1n));\nconst minInt256 = -(2n ** (256n - 1n));\nconst maxUint8 = 2n ** 8n - 1n;\nconst maxUint16 = 2n ** 16n - 1n;\nconst maxUint24 = 2n ** 24n - 1n;\nconst maxUint32 = 2n ** 32n - 1n;\nconst maxUint40 = 2n ** 40n - 1n;\nconst maxUint48 = 2n ** 48n - 1n;\nconst maxUint56 = 2n ** 56n - 1n;\nconst maxUint64 = 2n ** 64n - 1n;\nconst maxUint72 = 2n ** 72n - 1n;\nconst maxUint80 = 2n ** 80n - 1n;\nconst maxUint88 = 2n ** 88n - 1n;\nconst maxUint96 = 2n ** 96n - 1n;\nconst maxUint104 = 2n ** 104n - 1n;\nconst maxUint112 = 2n ** 112n - 1n;\nconst maxUint120 = 2n ** 120n - 1n;\nconst maxUint128 = 2n ** 128n - 1n;\nconst maxUint136 = 2n ** 136n - 1n;\nconst maxUint144 = 2n ** 144n - 1n;\nconst maxUint152 = 2n ** 152n - 1n;\nconst maxUint160 = 2n ** 160n - 1n;\nconst maxUint168 = 2n ** 168n - 1n;\nconst maxUint176 = 2n ** 176n - 1n;\nconst maxUint184 = 2n ** 184n - 1n;\nconst maxUint192 = 2n ** 192n - 1n;\nconst maxUint200 = 2n ** 200n - 1n;\nconst maxUint208 = 2n ** 208n - 1n;\nconst maxUint216 = 2n ** 216n - 1n;\nconst maxUint224 = 2n ** 224n - 1n;\nconst maxUint232 = 2n ** 232n - 1n;\nconst maxUint240 = 2n ** 240n - 1n;\nconst maxUint248 = 2n ** 248n - 1n;\nconst maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Tb2xpZGl0eS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU29saWRpdHkuanM/ZWQ5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgYXJyYXlSZWdleCA9IC9eKC4qKVxcWyhbMC05XSopXFxdJC87XG4vLyBgYnl0ZXM8TT5gOiBiaW5hcnkgdHlwZSBvZiBgTWAgYnl0ZXMsIGAwIDwgTSA8PSAzMmBcbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS82dmE1NVxuZXhwb3J0IGNvbnN0IGJ5dGVzUmVnZXggPSAvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLztcbi8vIGAodSlpbnQ8TT5gOiAodW4pc2lnbmVkIGludGVnZXIgdHlwZSBvZiBgTWAgYml0cywgYDAgPCBNIDw9IDI1NmAsIGBNICUgOCA9PSAwYFxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2OGhwXG5leHBvcnQgY29uc3QgaW50ZWdlclJlZ2V4ID0gL14odT9pbnQpKDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC87XG5leHBvcnQgY29uc3QgbWF4SW50OCA9IDJuICoqICg4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE2ID0gMm4gKiogKDE2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0ID0gMm4gKiogKDI0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDMyID0gMm4gKiogKDMybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDQwID0gMm4gKiogKDQwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDQ4ID0gMm4gKiogKDQ4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDU2ID0gMm4gKiogKDU2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDY0ID0gMm4gKiogKDY0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDcyID0gMm4gKiogKDcybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDgwID0gMm4gKiogKDgwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDg4ID0gMm4gKiogKDg4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDk2ID0gMm4gKiogKDk2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEwNCA9IDJuICoqICgxMDRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTEyID0gMm4gKiogKDExMm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMjAgPSAybiAqKiAoMTIwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEyOCA9IDJuICoqICgxMjhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTM2ID0gMm4gKiogKDEzNm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNDQgPSAybiAqKiAoMTQ0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE1MiA9IDJuICoqICgxNTJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTYwID0gMm4gKiogKDE2MG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNjggPSAybiAqKiAoMTY4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE3NiA9IDJuICoqICgxNzZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTg0ID0gMm4gKiogKDE4NG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxOTIgPSAybiAqKiAoMTkybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIwMCA9IDJuICoqICgyMDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjA4ID0gMm4gKiogKDIwOG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMTYgPSAybiAqKiAoMjE2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIyNCA9IDJuICoqICgyMjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjMyID0gMm4gKiogKDIzMm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyNDAgPSAybiAqKiAoMjQwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0OCA9IDJuICoqICgyNDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjU2ID0gMm4gKiogKDI1Nm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtaW5JbnQ4ID0gLSgybiAqKiAoOG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE2ID0gLSgybiAqKiAoMTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNCA9IC0oMm4gKiogKDI0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MzIgPSAtKDJuICoqICgzMm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDQwID0gLSgybiAqKiAoNDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ0OCA9IC0oMm4gKiogKDQ4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NTYgPSAtKDJuICoqICg1Nm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDY0ID0gLSgybiAqKiAoNjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ3MiA9IC0oMm4gKiogKDcybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50ODAgPSAtKDJuICoqICg4MG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDg4ID0gLSgybiAqKiAoODhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ5NiA9IC0oMm4gKiogKDk2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTA0ID0gLSgybiAqKiAoMTA0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTEyID0gLSgybiAqKiAoMTEybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTIwID0gLSgybiAqKiAoMTIwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTI4ID0gLSgybiAqKiAoMTI4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTM2ID0gLSgybiAqKiAoMTM2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTQ0ID0gLSgybiAqKiAoMTQ0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTUyID0gLSgybiAqKiAoMTUybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTYwID0gLSgybiAqKiAoMTYwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTY4ID0gLSgybiAqKiAoMTY4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTc2ID0gLSgybiAqKiAoMTc2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTg0ID0gLSgybiAqKiAoMTg0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTkyID0gLSgybiAqKiAoMTkybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjAwID0gLSgybiAqKiAoMjAwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjA4ID0gLSgybiAqKiAoMjA4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjE2ID0gLSgybiAqKiAoMjE2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjI0ID0gLSgybiAqKiAoMjI0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjMyID0gLSgybiAqKiAoMjMybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjQwID0gLSgybiAqKiAoMjQwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjQ4ID0gLSgybiAqKiAoMjQ4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjU2ID0gLSgybiAqKiAoMjU2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWF4VWludDggPSAybiAqKiA4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNiA9IDJuICoqIDE2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNCA9IDJuICoqIDI0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQzMiA9IDJuICoqIDMybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ0MCA9IDJuICoqIDQwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ0OCA9IDJuICoqIDQ4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ1NiA9IDJuICoqIDU2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ2NCA9IDJuICoqIDY0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ3MiA9IDJuICoqIDcybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ4MCA9IDJuICoqIDgwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ4OCA9IDJuICoqIDg4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ5NiA9IDJuICoqIDk2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMDQgPSAybiAqKiAxMDRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDExMiA9IDJuICoqIDExMm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTIwID0gMm4gKiogMTIwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMjggPSAybiAqKiAxMjhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEzNiA9IDJuICoqIDEzNm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTQ0ID0gMm4gKiogMTQ0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNTIgPSAybiAqKiAxNTJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE2MCA9IDJuICoqIDE2MG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTY4ID0gMm4gKiogMTY4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNzYgPSAybiAqKiAxNzZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE4NCA9IDJuICoqIDE4NG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTkyID0gMm4gKiogMTkybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMDAgPSAybiAqKiAyMDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIwOCA9IDJuICoqIDIwOG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjE2ID0gMm4gKiogMjE2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMjQgPSAybiAqKiAyMjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIzMiA9IDJuICoqIDIzMm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjQwID0gMm4gKiogMjQwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNDggPSAybiAqKiAyNDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI1NiA9IDJuICoqIDI1Nm4gLSAxbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvbGlkaXR5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Solidity.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/StateOverrides.js":
/*!******************************************************!*\
  !*** ../node_modules/ox/_esm/core/StateOverrides.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts an {@link ox#StateOverrides.Rpc} to an {@link ox#StateOverrides.StateOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { StateOverrides } from 'ox'\n *\n * const stateOverrides = StateOverrides.fromRpc({\n *   '0x0000000000000000000000000000000000000000': {\n *     balance: '0x1',\n *   },\n * })\n * ```\n *\n * @param rpcStateOverrides - The RPC state overrides to convert.\n * @returns An instantiated {@link ox#StateOverrides.StateOverrides}.\n */\nfunction fromRpc(rpcStateOverrides) {\n    const stateOverrides = {};\n    for (const [address, accountOverridesRpc] of Object.entries(rpcStateOverrides)) {\n        const accountOverrides = {};\n        if (accountOverridesRpc.balance)\n            accountOverrides.balance = BigInt(accountOverridesRpc.balance);\n        if (accountOverridesRpc.code)\n            accountOverrides.code = accountOverridesRpc.code;\n        if (accountOverridesRpc.movePrecompileToAddress)\n            accountOverrides.movePrecompileToAddress =\n                accountOverridesRpc.movePrecompileToAddress;\n        if (accountOverridesRpc.nonce)\n            accountOverrides.nonce = BigInt(accountOverridesRpc.nonce);\n        if (accountOverridesRpc.state)\n            accountOverrides.state = accountOverridesRpc.state;\n        if (accountOverridesRpc.stateDiff)\n            accountOverrides.stateDiff = accountOverridesRpc.stateDiff;\n        stateOverrides[address] = accountOverrides;\n    }\n    return stateOverrides;\n}\n/**\n * Converts an {@link ox#StateOverrides.StateOverrides} to an {@link ox#StateOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { StateOverrides } from 'ox'\n *\n * const stateOverrides = StateOverrides.toRpc({\n *   '0x0000000000000000000000000000000000000000': {\n *     balance: 1n,\n *   },\n * })\n * ```\n *\n * @param stateOverrides - The state overrides to convert.\n * @returns An instantiated {@link ox#StateOverrides.Rpc}.\n */\nfunction toRpc(stateOverrides) {\n    const rpcStateOverrides = {};\n    for (const [address, accountOverrides] of Object.entries(stateOverrides)) {\n        const accountOverridesRpc = {};\n        if (typeof accountOverrides.balance === 'bigint')\n            accountOverridesRpc.balance = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(accountOverrides.balance);\n        if (accountOverrides.code)\n            accountOverridesRpc.code = accountOverrides.code;\n        if (accountOverrides.movePrecompileToAddress)\n            accountOverridesRpc.movePrecompileToAddress =\n                accountOverrides.movePrecompileToAddress;\n        if (typeof accountOverrides.nonce === 'bigint')\n            accountOverridesRpc.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(accountOverrides.nonce);\n        if (accountOverrides.state)\n            accountOverridesRpc.state = accountOverrides.state;\n        if (accountOverrides.stateDiff)\n            accountOverridesRpc.stateDiff = accountOverrides.stateDiff;\n        rpcStateOverrides[address] = accountOverridesRpc;\n    }\n    return rpcStateOverrides;\n}\n//# sourceMappingURL=StateOverrides.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TdGF0ZU92ZXJyaWRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0M7QUFDaEM7QUFDQSxnQkFBZ0IsNkJBQTZCLE9BQU8sdUNBQXVDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDLE9BQU8sNEJBQTRCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywrQ0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0NBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU3RhdGVPdmVycmlkZXMuanM/ZTU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjU3RhdGVPdmVycmlkZXMuUnBjfSB0byBhbiB7QGxpbmsgb3gjU3RhdGVPdmVycmlkZXMuU3RhdGVPdmVycmlkZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU3RhdGVPdmVycmlkZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzdGF0ZU92ZXJyaWRlcyA9IFN0YXRlT3ZlcnJpZGVzLmZyb21ScGMoe1xuICogICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJzoge1xuICogICAgIGJhbGFuY2U6ICcweDEnLFxuICogICB9LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBycGNTdGF0ZU92ZXJyaWRlcyAtIFRoZSBSUEMgc3RhdGUgb3ZlcnJpZGVzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1N0YXRlT3ZlcnJpZGVzLlN0YXRlT3ZlcnJpZGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMocnBjU3RhdGVPdmVycmlkZXMpIHtcbiAgICBjb25zdCBzdGF0ZU92ZXJyaWRlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIGFjY291bnRPdmVycmlkZXNScGNdIG9mIE9iamVjdC5lbnRyaWVzKHJwY1N0YXRlT3ZlcnJpZGVzKSkge1xuICAgICAgICBjb25zdCBhY2NvdW50T3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChhY2NvdW50T3ZlcnJpZGVzUnBjLmJhbGFuY2UpXG4gICAgICAgICAgICBhY2NvdW50T3ZlcnJpZGVzLmJhbGFuY2UgPSBCaWdJbnQoYWNjb3VudE92ZXJyaWRlc1JwYy5iYWxhbmNlKTtcbiAgICAgICAgaWYgKGFjY291bnRPdmVycmlkZXNScGMuY29kZSlcbiAgICAgICAgICAgIGFjY291bnRPdmVycmlkZXMuY29kZSA9IGFjY291bnRPdmVycmlkZXNScGMuY29kZTtcbiAgICAgICAgaWYgKGFjY291bnRPdmVycmlkZXNScGMubW92ZVByZWNvbXBpbGVUb0FkZHJlc3MpXG4gICAgICAgICAgICBhY2NvdW50T3ZlcnJpZGVzLm1vdmVQcmVjb21waWxlVG9BZGRyZXNzID1cbiAgICAgICAgICAgICAgICBhY2NvdW50T3ZlcnJpZGVzUnBjLm1vdmVQcmVjb21waWxlVG9BZGRyZXNzO1xuICAgICAgICBpZiAoYWNjb3VudE92ZXJyaWRlc1JwYy5ub25jZSlcbiAgICAgICAgICAgIGFjY291bnRPdmVycmlkZXMubm9uY2UgPSBCaWdJbnQoYWNjb3VudE92ZXJyaWRlc1JwYy5ub25jZSk7XG4gICAgICAgIGlmIChhY2NvdW50T3ZlcnJpZGVzUnBjLnN0YXRlKVxuICAgICAgICAgICAgYWNjb3VudE92ZXJyaWRlcy5zdGF0ZSA9IGFjY291bnRPdmVycmlkZXNScGMuc3RhdGU7XG4gICAgICAgIGlmIChhY2NvdW50T3ZlcnJpZGVzUnBjLnN0YXRlRGlmZilcbiAgICAgICAgICAgIGFjY291bnRPdmVycmlkZXMuc3RhdGVEaWZmID0gYWNjb3VudE92ZXJyaWRlc1JwYy5zdGF0ZURpZmY7XG4gICAgICAgIHN0YXRlT3ZlcnJpZGVzW2FkZHJlc3NdID0gYWNjb3VudE92ZXJyaWRlcztcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlT3ZlcnJpZGVzO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjU3RhdGVPdmVycmlkZXMuU3RhdGVPdmVycmlkZXN9IHRvIGFuIHtAbGluayBveCNTdGF0ZU92ZXJyaWRlcy5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU3RhdGVPdmVycmlkZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzdGF0ZU92ZXJyaWRlcyA9IFN0YXRlT3ZlcnJpZGVzLnRvUnBjKHtcbiAqICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCc6IHtcbiAqICAgICBiYWxhbmNlOiAxbixcbiAqICAgfSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RhdGVPdmVycmlkZXMgLSBUaGUgc3RhdGUgb3ZlcnJpZGVzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1N0YXRlT3ZlcnJpZGVzLlJwY30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhzdGF0ZU92ZXJyaWRlcykge1xuICAgIGNvbnN0IHJwY1N0YXRlT3ZlcnJpZGVzID0ge307XG4gICAgZm9yIChjb25zdCBbYWRkcmVzcywgYWNjb3VudE92ZXJyaWRlc10gb2YgT2JqZWN0LmVudHJpZXMoc3RhdGVPdmVycmlkZXMpKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRPdmVycmlkZXNScGMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBhY2NvdW50T3ZlcnJpZGVzLmJhbGFuY2UgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgYWNjb3VudE92ZXJyaWRlc1JwYy5iYWxhbmNlID0gSGV4LmZyb21OdW1iZXIoYWNjb3VudE92ZXJyaWRlcy5iYWxhbmNlKTtcbiAgICAgICAgaWYgKGFjY291bnRPdmVycmlkZXMuY29kZSlcbiAgICAgICAgICAgIGFjY291bnRPdmVycmlkZXNScGMuY29kZSA9IGFjY291bnRPdmVycmlkZXMuY29kZTtcbiAgICAgICAgaWYgKGFjY291bnRPdmVycmlkZXMubW92ZVByZWNvbXBpbGVUb0FkZHJlc3MpXG4gICAgICAgICAgICBhY2NvdW50T3ZlcnJpZGVzUnBjLm1vdmVQcmVjb21waWxlVG9BZGRyZXNzID1cbiAgICAgICAgICAgICAgICBhY2NvdW50T3ZlcnJpZGVzLm1vdmVQcmVjb21waWxlVG9BZGRyZXNzO1xuICAgICAgICBpZiAodHlwZW9mIGFjY291bnRPdmVycmlkZXMubm9uY2UgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgYWNjb3VudE92ZXJyaWRlc1JwYy5ub25jZSA9IEhleC5mcm9tTnVtYmVyKGFjY291bnRPdmVycmlkZXMubm9uY2UpO1xuICAgICAgICBpZiAoYWNjb3VudE92ZXJyaWRlcy5zdGF0ZSlcbiAgICAgICAgICAgIGFjY291bnRPdmVycmlkZXNScGMuc3RhdGUgPSBhY2NvdW50T3ZlcnJpZGVzLnN0YXRlO1xuICAgICAgICBpZiAoYWNjb3VudE92ZXJyaWRlcy5zdGF0ZURpZmYpXG4gICAgICAgICAgICBhY2NvdW50T3ZlcnJpZGVzUnBjLnN0YXRlRGlmZiA9IGFjY291bnRPdmVycmlkZXMuc3RhdGVEaWZmO1xuICAgICAgICBycGNTdGF0ZU92ZXJyaWRlc1thZGRyZXNzXSA9IGFjY291bnRPdmVycmlkZXNScGM7XG4gICAgfVxuICAgIHJldHVybiBycGNTdGF0ZU92ZXJyaWRlcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRlT3ZlcnJpZGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/StateOverrides.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Transaction.js":
/*!***************************************************!*\
  !*** ../node_modules/ox/_esm/core/Transaction.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcType: () => (/* binding */ fromRpcType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcType: () => (/* binding */ toRpcType)\n/* harmony export */ });\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Authorization.js */ \"../node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"../node_modules/ox/_esm/core/Signature.js\");\n\n\n\n/** Type to RPC Type mapping. */\nconst toRpcType = {\n    legacy: '0x0',\n    eip2930: '0x1',\n    eip1559: '0x2',\n    eip4844: '0x3',\n    eip7702: '0x4',\n};\n/** RPC Type to Type mapping. */\nconst fromRpcType = {\n    '0x0': 'legacy',\n    '0x1': 'eip2930',\n    '0x2': 'eip1559',\n    '0x3': 'eip4844',\n    '0x4': 'eip7702',\n};\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x2',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */\nfunction fromRpc(transaction, _options = {}) {\n    if (!transaction)\n        return null;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(transaction);\n    const transaction_ = {\n        ...transaction,\n        ...signature,\n    };\n    transaction_.blockNumber = transaction.blockNumber\n        ? BigInt(transaction.blockNumber)\n        : null;\n    transaction_.data = transaction.input;\n    transaction_.gas = BigInt(transaction.gas ?? 0n);\n    transaction_.nonce = BigInt(transaction.nonce ?? 0n);\n    transaction_.transactionIndex = transaction.transactionIndex\n        ? Number(transaction.transactionIndex)\n        : null;\n    transaction_.value = BigInt(transaction.value ?? 0n);\n    if (transaction.authorizationList)\n        transaction_.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_1__.fromRpcList(transaction.authorizationList);\n    if (transaction.chainId)\n        transaction_.chainId = Number(transaction.chainId);\n    if (transaction.gasPrice)\n        transaction_.gasPrice = BigInt(transaction.gasPrice);\n    if (transaction.maxFeePerBlobGas)\n        transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);\n    if (transaction.maxFeePerGas)\n        transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);\n    if (transaction.maxPriorityFeePerGas)\n        transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);\n    if (transaction.type)\n        transaction_.type =\n            fromRpcType[transaction.type] ?? transaction.type;\n    if (signature)\n        transaction_.v = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.yParityToV(signature.yParity);\n    return transaction_;\n}\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   chainId: 1,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n *   v: 27,\n *   value: 700000000000000000n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */\nfunction toRpc(transaction, _options) {\n    const rpc = {};\n    rpc.blockHash = transaction.blockHash;\n    rpc.blockNumber =\n        typeof transaction.blockNumber === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.blockNumber)\n            : null;\n    rpc.from = transaction.from;\n    rpc.gas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.gas ?? 0n);\n    rpc.hash = transaction.hash;\n    rpc.input = transaction.input;\n    rpc.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.nonce ?? 0n);\n    rpc.to = transaction.to;\n    rpc.transactionIndex = transaction.transactionIndex\n        ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.transactionIndex)\n        : null;\n    rpc.type = toRpcType[transaction.type] ?? transaction.type;\n    rpc.value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.value ?? 0n);\n    if (transaction.accessList)\n        rpc.accessList = transaction.accessList;\n    if (transaction.authorizationList)\n        rpc.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_1__.toRpcList(transaction.authorizationList);\n    if (transaction.blobVersionedHashes)\n        rpc.blobVersionedHashes = transaction.blobVersionedHashes;\n    if (transaction.chainId)\n        rpc.chainId = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.chainId);\n    if (typeof transaction.gasPrice === 'bigint')\n        rpc.gasPrice = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.gasPrice);\n    if (typeof transaction.maxFeePerBlobGas === 'bigint')\n        rpc.maxFeePerBlobGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxFeePerBlobGas);\n    if (typeof transaction.maxFeePerGas === 'bigint')\n        rpc.maxFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxFeePerGas);\n    if (typeof transaction.maxPriorityFeePerGas === 'bigint')\n        rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxPriorityFeePerGas);\n    if (typeof transaction.r === 'bigint')\n        rpc.r = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.r, { size: 32 });\n    if (typeof transaction.s === 'bigint')\n        rpc.s = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.s, { size: 32 });\n    if (typeof transaction.v === 'number')\n        rpc.v = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.v, { size: 1 });\n    if (typeof transaction.yParity === 'number')\n        rpc.yParity = transaction.yParity === 0 ? '0x0' : '0x1';\n    return rpc;\n}\n//# sourceMappingURL=Transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW9EO0FBQ3BCO0FBQ1k7QUFDNUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEIsT0FBTyxpQ0FBaUM7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDTywyQ0FBMkM7QUFDbEQ7QUFDQTtBQUNBLHNCQUFzQixrREFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBEQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLE9BQU8seUJBQXlCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQ0FBYztBQUM1QjtBQUNBO0FBQ0EsY0FBYywrQ0FBYztBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVLCtDQUFjO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQWM7QUFDcEM7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQSwrQkFBK0IsK0NBQWM7QUFDN0M7QUFDQSwyQkFBMkIsK0NBQWM7QUFDekM7QUFDQSxtQ0FBbUMsK0NBQWM7QUFDakQ7QUFDQSxnQkFBZ0IsK0NBQWMsa0JBQWtCLFVBQVU7QUFDMUQ7QUFDQSxnQkFBZ0IsK0NBQWMsa0JBQWtCLFVBQVU7QUFDMUQ7QUFDQSxnQkFBZ0IsK0NBQWMsa0JBQWtCLFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uLmpzPzg2NDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvbiBmcm9tICcuL0F1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG4vKiogVHlwZSB0byBSUEMgVHlwZSBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IHRvUnBjVHlwZSA9IHtcbiAgICBsZWdhY3k6ICcweDAnLFxuICAgIGVpcDI5MzA6ICcweDEnLFxuICAgIGVpcDE1NTk6ICcweDInLFxuICAgIGVpcDQ4NDQ6ICcweDMnLFxuICAgIGVpcDc3MDI6ICcweDQnLFxufTtcbi8qKiBSUEMgVHlwZSB0byBUeXBlIG1hcHBpbmcuICovXG5leHBvcnQgY29uc3QgZnJvbVJwY1R5cGUgPSB7XG4gICAgJzB4MCc6ICdsZWdhY3knLFxuICAgICcweDEnOiAnZWlwMjkzMCcsXG4gICAgJzB4Mic6ICdlaXAxNTU5JyxcbiAgICAnMHgzJzogJ2VpcDQ4NDQnLFxuICAgICcweDQnOiAnZWlwNzcwMicsXG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uUnBjfSB0byBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uVHJhbnNhY3Rpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLmZyb21ScGMoe1xuICogICBoYXNoOiAnMHgzNTNmZGZjMzhhMmYyNjExNWRhYWRlZTlmNWI4MzkyY2U2MmI4NGY0MTA5NTc5NjdlMmVkNTZiMzUzMzhjZGQwJyxcbiAqICAgbm9uY2U6ICcweDM1NycsXG4gKiAgIGJsb2NrSGFzaDpcbiAqICAgICAnMHhjMzUwZDgwNzUwNWZiODM1NjUwZjAwMTM2MzJjNTUxNTU5Mjk4N2JhMTY5YmJjNjYyNmQ5ZmM1NGQ5MWYwZjBiJyxcbiAqICAgYmxvY2tOdW1iZXI6ICcweDEyZjI5NmYnLFxuICogICB0cmFuc2FjdGlvbkluZGV4OiAnMHgyJyxcbiAqICAgZnJvbTogJzB4ODE0ZTVlMGUzMTAxNmI5YTdmMTM4Yzc2YjdlN2IyYmI1YzFhYjZhNicsXG4gKiAgIHRvOiAnMHgzZmM5MWEzYWZkNzAzOTVjZDQ5NmM2NDdkNWE2Y2M5ZDRiMmI3ZmFkJyxcbiAqICAgdmFsdWU6ICcweDliNmU2NGE4ZWM2MDAwMCcsXG4gKiAgIGdhczogJzB4NDNmNWQnLFxuICogICBtYXhGZWVQZXJHYXM6ICcweDJjYTZhZTQ5NCcsXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAnMHg0MWNjM2MwJyxcbiAqICAgaW5wdXQ6XG4gKiAgICAgJzB4MzU5MzU2NGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjY0MzUwNDcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MGIwODA2MDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBlMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOWI2ZTY0YThlYzYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOWI2ZTY0YThlYzYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MTI0YmI1YWU5NzhjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGMwMmFhYTM5YjIyM2ZlOGQwYTBlNWM0ZjI3ZWFkOTA4M2M3NTZjYzIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjNTZjN2EwZWFhODA0Zjg1NGI1MzZhNWYzZDVmNDlkMmVjNGIxMmI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZWUxM2ExMDNhMTBkNTkzYjlhZTA2YjNlMDVmMmU3ZTFjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxOTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjNTZjN2EwZWFhODA0Zjg1NGI1MzZhNWYzZDVmNDlkMmVjNGIxMmI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxOTAyNDAwMDFiOTg3MmInLFxuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgYWNjZXNzTGlzdDogW10sXG4gKiAgIHR5cGU6ICcweDInLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSBSUEMgdHJhbnNhY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uVHJhbnNhY3Rpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyh0cmFuc2FjdGlvbiwgX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdHJhbnNhY3Rpb24pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl8gPSB7XG4gICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfTtcbiAgICB0cmFuc2FjdGlvbl8uYmxvY2tOdW1iZXIgPSB0cmFuc2FjdGlvbi5ibG9ja051bWJlclxuICAgICAgICA/IEJpZ0ludCh0cmFuc2FjdGlvbi5ibG9ja051bWJlcilcbiAgICAgICAgOiBudWxsO1xuICAgIHRyYW5zYWN0aW9uXy5kYXRhID0gdHJhbnNhY3Rpb24uaW5wdXQ7XG4gICAgdHJhbnNhY3Rpb25fLmdhcyA9IEJpZ0ludCh0cmFuc2FjdGlvbi5nYXMgPz8gMG4pO1xuICAgIHRyYW5zYWN0aW9uXy5ub25jZSA9IEJpZ0ludCh0cmFuc2FjdGlvbi5ub25jZSA/PyAwbik7XG4gICAgdHJhbnNhY3Rpb25fLnRyYW5zYWN0aW9uSW5kZXggPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkluZGV4XG4gICAgICAgID8gTnVtYmVyKHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uSW5kZXgpXG4gICAgICAgIDogbnVsbDtcbiAgICB0cmFuc2FjdGlvbl8udmFsdWUgPSBCaWdJbnQodHJhbnNhY3Rpb24udmFsdWUgPz8gMG4pO1xuICAgIGlmICh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdClcbiAgICAgICAgdHJhbnNhY3Rpb25fLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjTGlzdCh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdCk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5jaGFpbklkID0gTnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5nYXNQcmljZSlcbiAgICAgICAgdHJhbnNhY3Rpb25fLmdhc1ByaWNlID0gQmlnSW50KHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcylcbiAgICAgICAgdHJhbnNhY3Rpb25fLm1heEZlZVBlckJsb2JHYXMgPSBCaWdJbnQodHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcyk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcylcbiAgICAgICAgdHJhbnNhY3Rpb25fLm1heEZlZVBlckdhcyA9IEJpZ0ludCh0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgdHJhbnNhY3Rpb25fLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAodHJhbnNhY3Rpb24udHlwZSlcbiAgICAgICAgdHJhbnNhY3Rpb25fLnR5cGUgPVxuICAgICAgICAgICAgZnJvbVJwY1R5cGVbdHJhbnNhY3Rpb24udHlwZV0gPz8gdHJhbnNhY3Rpb24udHlwZTtcbiAgICBpZiAoc2lnbmF0dXJlKVxuICAgICAgICB0cmFuc2FjdGlvbl8udiA9IFNpZ25hdHVyZS55UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25fO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uVHJhbnNhY3Rpb259IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbi5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLnRvUnBjKHtcbiAqICAgYWNjZXNzTGlzdDogW10sXG4gKiAgIGJsb2NrSGFzaDpcbiAqICAgICAnMHhjMzUwZDgwNzUwNWZiODM1NjUwZjAwMTM2MzJjNTUxNTU5Mjk4N2JhMTY5YmJjNjYyNmQ5ZmM1NGQ5MWYwZjBiJyxcbiAqICAgYmxvY2tOdW1iZXI6IDE5ODY4MDE1bixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZnJvbTogJzB4ODE0ZTVlMGUzMTAxNmI5YTdmMTM4Yzc2YjdlN2IyYmI1YzFhYjZhNicsXG4gKiAgIGdhczogMjc4MzY1bixcbiAqICAgaGFzaDogJzB4MzUzZmRmYzM4YTJmMjYxMTVkYWFkZWU5ZjViODM5MmNlNjJiODRmNDEwOTU3OTY3ZTJlZDU2YjM1MzM4Y2RkMCcsXG4gKiAgIGlucHV0OlxuICogICAgICcweDM1OTM1NjRjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDY2NDM1MDQ3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDBiMDgwNjA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDliNmU2NGE4ZWM2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDliNmU2NGE4ZWM2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxOTEyNGJiNWFlOTc4YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjMDJhYWEzOWIyMjNmZThkMGEwZTVjNGYyN2VhZDkwODNjNzU2Y2MyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjNTZjN2EwZWFhODA0Zjg1NGI1MzZhNWYzZDVmNDlkMmVjNGIxMmI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmVlMTNhMTAzYTEwZDU5M2I5YWUwNmIzZTA1ZjJlN2UxYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkwMjQwMDAxYjk4NzJiJyxcbiAqICAgbWF4RmVlUGVyR2FzOiAxMTk4NTkzNzU1Nm4sXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiA2ODk5Mzk4NG4sXG4gKiAgIG5vbmNlOiA4NTVuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgdG86ICcweDNmYzkxYTNhZmQ3MDM5NWNkNDk2YzY0N2Q1YTZjYzlkNGIyYjdmYWQnLFxuICogICB0cmFuc2FjdGlvbkluZGV4OiAyLFxuICogICB0eXBlOiAnZWlwMTU1OScsXG4gKiAgIHY6IDI3LFxuICogICB2YWx1ZTogNzAwMDAwMDAwMDAwMDAwMDAwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyh0cmFuc2FjdGlvbiwgX29wdGlvbnMpIHtcbiAgICBjb25zdCBycGMgPSB7fTtcbiAgICBycGMuYmxvY2tIYXNoID0gdHJhbnNhY3Rpb24uYmxvY2tIYXNoO1xuICAgIHJwYy5ibG9ja051bWJlciA9XG4gICAgICAgIHR5cGVvZiB0cmFuc2FjdGlvbi5ibG9ja051bWJlciA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24uYmxvY2tOdW1iZXIpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgcnBjLmZyb20gPSB0cmFuc2FjdGlvbi5mcm9tO1xuICAgIHJwYy5nYXMgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi5nYXMgPz8gMG4pO1xuICAgIHJwYy5oYXNoID0gdHJhbnNhY3Rpb24uaGFzaDtcbiAgICBycGMuaW5wdXQgPSB0cmFuc2FjdGlvbi5pbnB1dDtcbiAgICBycGMubm9uY2UgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi5ub25jZSA/PyAwbik7XG4gICAgcnBjLnRvID0gdHJhbnNhY3Rpb24udG87XG4gICAgcnBjLnRyYW5zYWN0aW9uSW5kZXggPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkluZGV4XG4gICAgICAgID8gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24udHJhbnNhY3Rpb25JbmRleClcbiAgICAgICAgOiBudWxsO1xuICAgIHJwYy50eXBlID0gdG9ScGNUeXBlW3RyYW5zYWN0aW9uLnR5cGVdID8/IHRyYW5zYWN0aW9uLnR5cGU7XG4gICAgcnBjLnZhbHVlID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24udmFsdWUgPz8gMG4pO1xuICAgIGlmICh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KVxuICAgICAgICBycGMuYWNjZXNzTGlzdCA9IHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3Q7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmF1dGhvcml6YXRpb25MaXN0KVxuICAgICAgICBycGMuYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLnRvUnBjTGlzdCh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdCk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmJsb2JWZXJzaW9uZWRIYXNoZXMpXG4gICAgICAgIHJwYy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gdHJhbnNhY3Rpb24uYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZClcbiAgICAgICAgcnBjLmNoYWluSWQgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi5jaGFpbklkKTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmdhc1ByaWNlID09PSAnYmlnaW50JylcbiAgICAgICAgcnBjLmdhc1ByaWNlID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24uZ2FzUHJpY2UpO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcyA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJwYy5tYXhGZWVQZXJCbG9iR2FzID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcyk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMgPT09ICdiaWdpbnQnKVxuICAgICAgICBycGMubWF4RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID09PSAnYmlnaW50JylcbiAgICAgICAgcnBjLm1heFByaW9yaXR5RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24uciA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJwYy5yID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24uciwgeyBzaXplOiAzMiB9KTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLnMgPT09ICdiaWdpbnQnKVxuICAgICAgICBycGMucyA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLnMsIHsgc2l6ZTogMzIgfSk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi52ID09PSAnbnVtYmVyJylcbiAgICAgICAgcnBjLnYgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi52LCB7IHNpemU6IDEgfSk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi55UGFyaXR5ID09PSAnbnVtYmVyJylcbiAgICAgICAgcnBjLnlQYXJpdHkgPSB0cmFuc2FjdGlvbi55UGFyaXR5ID09PSAwID8gJzB4MCcgOiAnMHgxJztcbiAgICByZXR1cm4gcnBjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Transaction.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TransactionEnvelope.js":
/*!***********************************************************!*\
  !*** ../node_modules/ox/_esm/core/TransactionEnvelope.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeeCapTooHighError: () => (/* binding */ FeeCapTooHighError),\n/* harmony export */   GasPriceTooHighError: () => (/* binding */ GasPriceTooHighError),\n/* harmony export */   InvalidChainIdError: () => (/* binding */ InvalidChainIdError),\n/* harmony export */   InvalidSerializedError: () => (/* binding */ InvalidSerializedError),\n/* harmony export */   TipAboveFeeCapError: () => (/* binding */ TipAboveFeeCapError)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Value.js */ \"../node_modules/ox/_esm/core/Value.js\");\n\n\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nclass FeeCapTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ feeCap, } = {}) {\n        super(`The fee cap (\\`maxFeePerGas\\`/\\`maxPriorityFeePerGas\\`${feeCap ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(feeCap)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.FeeCapTooHighError'\n        });\n    }\n}\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nclass GasPriceTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ gasPrice, } = {}) {\n        super(`The gas price (\\`gasPrice\\`${gasPrice ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(gasPrice)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.GasPriceTooHighError'\n        });\n    }\n}\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */\nclass InvalidChainIdError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ chainId }) {\n        super(typeof chainId !== 'undefined'\n            ? `Chain ID \"${chainId}\" is invalid.`\n            : 'Chain ID is invalid.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.InvalidChainIdError'\n        });\n    }\n}\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */\nclass InvalidSerializedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ attributes, serialized, type, }) {\n        const missing = Object.entries(attributes)\n            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n            .filter(Boolean);\n        super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n            metaMessages: [\n                `Serialized Transaction: \"${serialized}\"`,\n                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n            ].filter(Boolean),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.InvalidSerializedError'\n        });\n    }\n}\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */\nclass TipAboveFeeCapError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ maxPriorityFeePerGas, maxFeePerGas, } = {}) {\n        super([\n            `The provided tip (\\`maxPriorityFeePerGas\\`${maxPriorityFeePerGas\n                ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxPriorityFeePerGas)} gwei`\n                : ''}) cannot be higher than the fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxFeePerGas)} gwei` : ''}).`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.TipAboveFeeCapError'\n        });\n    }\n}\n//# sourceMappingURL=TransactionEnvelope.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0M7QUFDRjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ08saUNBQWlDLGlEQUFnQjtBQUN4RCxrQkFBa0IsVUFBVSxJQUFJO0FBQ2hDLHVFQUF1RSxlQUFlLGlEQUFnQixVQUFVLFdBQVc7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyxpREFBZ0I7QUFDMUQsa0JBQWtCLFlBQVksSUFBSTtBQUNsQyw0Q0FBNEMsaUJBQWlCLGlEQUFnQixZQUFZLFdBQVc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RCxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUNBQXFDLGlEQUFnQjtBQUM1RCxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQsNERBQTRELG1CQUFtQjtBQUMvRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsaURBQWdCO0FBQ3pELGtCQUFrQixzQ0FBc0MsSUFBSTtBQUM1RDtBQUNBLHlEQUF5RDtBQUN6RCx3QkFBd0IsaURBQWdCLHdCQUF3QjtBQUNoRSxxQkFBcUIsdURBQXVELHFCQUFxQixpREFBZ0IsZ0JBQWdCLFdBQVc7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGUuanM/OTA4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgVmFsdWUgZnJvbSAnLi9WYWx1ZS5qcyc7XG4vKipcbiAqIFRocm93biB3aGVuIGEgZmVlIGNhcCBpcyB0b28gaGlnaC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHtcbiAqICAgbWF4RmVlUGVyR2FzOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuRmVlQ2FwVG9vSGlnaEVycm9yOiBUaGUgZmVlIGNhcCAoYG1heEZlZVBlckdhc2AvYG1heFByaW9yaXR5RmVlUGVyR2FzYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMy4xMjk2Mzk5MzYgZ3dlaSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVDYXBUb29IaWdoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGZlZUNhcCwgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGBUaGUgZmVlIGNhcCAoXFxgbWF4RmVlUGVyR2FzXFxgL1xcYG1heFByaW9yaXR5RmVlUGVyR2FzXFxgJHtmZWVDYXAgPyBgID0gJHtWYWx1ZS5mb3JtYXRHd2VpKGZlZUNhcCl9IGd3ZWlgIDogJyd9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkZlZUNhcFRvb0hpZ2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGdhcyBwcmljZSBpcyB0b28gaGlnaC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmFzc2VydCh7XG4gKiAgIGdhc1ByaWNlOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuR2FzUHJpY2VUb29IaWdoRXJyb3I6IFRoZSBnYXMgcHJpY2UgKGBnYXNQcmljZWAgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMuMTI5NjM5OTM2IGd3ZWkpIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgR2FzUHJpY2VUb29IaWdoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdhc1ByaWNlLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoYFRoZSBnYXMgcHJpY2UgKFxcYGdhc1ByaWNlXFxgJHtnYXNQcmljZSA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkoZ2FzUHJpY2UpfSBnd2VpYCA6ICcnfSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNhY3Rpb25FbnZlbG9wZS5HYXNQcmljZVRvb0hpZ2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNoYWluIElEIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydCh7IGNoYWluSWQ6IDAgfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkQ2hhaW5JZEVycm9yOiBDaGFpbiBJRCBcIjBcIiBpcyBpbnZhbGlkLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQ2hhaW5JZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjaGFpbklkIH0pIHtcbiAgICAgICAgc3VwZXIodHlwZW9mIGNoYWluSWQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IGBDaGFpbiBJRCBcIiR7Y2hhaW5JZH1cIiBpcyBpbnZhbGlkLmBcbiAgICAgICAgICAgIDogJ0NoYWluIElEIGlzIGludmFsaWQuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmRlc2VyaWFsaXplKCcweDAyYzAnKVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3I6IEludmFsaWQgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvZiB0eXBlIFwiZWlwMTU1OVwiIHdhcyBwcm92aWRlZC5cbiAqIC8vIEBlcnJvcjogU2VyaWFsaXplZCBUcmFuc2FjdGlvbjogXCIweDAyYzBcIlxuICogLy8gQGVycm9yOiBNaXNzaW5nIEF0dHJpYnV0ZXM6IGNoYWluSWQsIG5vbmNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBnYXMsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdFxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VyaWFsaXplZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhdHRyaWJ1dGVzLCBzZXJpYWxpemVkLCB0eXBlLCB9KSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKVxuICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGtleSA6IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBzdXBlcihgSW52YWxpZCBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9mIHR5cGUgXCIke3R5cGV9XCIgd2FzIHByb3ZpZGVkLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBTZXJpYWxpemVkIFRyYW5zYWN0aW9uOiBcIiR7c2VyaWFsaXplZH1cImAsXG4gICAgICAgICAgICAgICAgbWlzc2luZy5sZW5ndGggPiAwID8gYE1pc3NpbmcgQXR0cmlidXRlczogJHttaXNzaW5nLmpvaW4oJywgJyl9YCA6ICcnLFxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdGlwIGlzIGhpZ2hlciB0aGFuIGEgZmVlIGNhcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiAxMG4sXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAxMW4sXG4gKiB9KVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLlRpcEFib3ZlRmVlQ2FwRXJyb3I6IFRoZSBwcm92aWRlZCB0aXAgKGBtYXhQcmlvcml0eUZlZVBlckdhc2AgPSAxMSBnd2VpKSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIGZlZSBjYXAgKGBtYXhGZWVQZXJHYXNgID0gMTAgZ3dlaSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFRpcEFib3ZlRmVlQ2FwRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihbXG4gICAgICAgICAgICBgVGhlIHByb3ZpZGVkIHRpcCAoXFxgbWF4UHJpb3JpdHlGZWVQZXJHYXNcXGAke21heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICAgICAgICAgPyBgID0gJHtWYWx1ZS5mb3JtYXRHd2VpKG1heFByaW9yaXR5RmVlUGVyR2FzKX0gZ3dlaWBcbiAgICAgICAgICAgICAgICA6ICcnfSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBmZWUgY2FwIChcXGBtYXhGZWVQZXJHYXNcXGAke21heEZlZVBlckdhcyA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkobWF4RmVlUGVyR2FzKX0gZ3dlaWAgOiAnJ30pLmAsXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNhY3Rpb25FbnZlbG9wZS5UaXBBYm92ZUZlZUNhcEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkVudmVsb3BlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TransactionEnvelope.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js":
/*!******************************************************************!*\
  !*** ../node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AccessList.js */ \"../node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"../node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"../node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"../node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\n\nconst serializedType = '0x02';\nconst type = 'eip1559';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = envelope;\n    if (chainId <= 0)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidChainIdError({ chainId });\n    if (to)\n        _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(to, { strict: false });\n    if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.FeeCapTooHighError({ feeCap: maxFeePerGas });\n    if (maxPriorityFeePerGas &&\n        maxFeePerGas &&\n        maxPriorityFeePerGas > maxFeePerGas)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.TipAboveFeeCapError({\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n        });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.deserialize('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip1559',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 9 || transactionArray.length === 12))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 9\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-1559 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-1559 Transaction Envelope from a {@link ox#TransactionEnvelopeEip1559.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from('0x02f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-1559 Transaction Envelope.\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.from(signature) : {}),\n        type: 'eip1559',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip1559.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-1559 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_6__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input, } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(options.signature || envelope);\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : '0x',\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxPriorityFeePerGas) : '0x',\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxFeePerGas) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toTuple(signature) : []),\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(serializedType, _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} to an {@link ox#TransactionEnvelopeEip1559.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip1559.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-1559 transaction envelope to convert.\n * @returns An RPC-formatted EIP-1559 transaction envelope.\n */\nfunction toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(envelope);\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId),\n        data: envelope.data ?? envelope.input,\n        type: '0x2',\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.maxFeePerGas === 'bigint'\n            ? { maxFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.maxFeePerGas) }\n            : {}),\n        ...(typeof envelope.maxPriorityFeePerGas === 'bigint'\n            ? {\n                maxPriorityFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.maxPriorityFeePerGas),\n            }\n            : {}),\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toRpc(signature) : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip1559.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNOO0FBQ047QUFDRjtBQUNBO0FBQ1k7QUFDb0I7QUFDekQ7QUFDQTtBQUNQO0FBQ0EsY0FBYyxnRUFBZ0U7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGtEQUFrRDtBQUM5RDtBQUNBLGtCQUFrQix3RUFBdUMsR0FBRyxTQUFTO0FBQ3JFO0FBQ0EsUUFBUSwrQ0FBYyxPQUFPLGVBQWU7QUFDNUM7QUFDQSxrQkFBa0IsdUVBQXNDLEdBQUcsc0JBQXNCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3RUFBdUM7QUFDekQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFnRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QiwwQ0FBUyxDQUFDLDBDQUFTO0FBQ2hEO0FBQ0E7QUFDQSxrQkFBa0IsMkVBQTBDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FB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QUN6QztBQUNBLFdBQVcsMkNBQVUsaUJBQWlCLDRDQUFXO0FBQ2pEO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWdFLE9BQU8sd0NBQXdDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHNCQUFzQixrREFBaUI7QUFDdkM7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSywrQ0FBYztBQUNuQyxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IsT0FBTywrQ0FBYztBQUNyQyxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IsT0FBTywrQ0FBYztBQUNyQyxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IsY0FBYywrQ0FBYztBQUM1QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHNDQUFzQywrQ0FBYztBQUNwRDtBQUNBLGdCQUFnQjtBQUNoQix3QkFBd0IsZ0RBQWUsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBK0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmpzP2ZlNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWNjZXNzTGlzdCBmcm9tICcuL0FjY2Vzc0xpc3QuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZWRUeXBlID0gJzB4MDInO1xuZXhwb3J0IGNvbnN0IHR5cGUgPSAnZWlwMTU1OSc7XG4vKipcbiAqIEFzc2VydHMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHtcbiAqICAgbWF4RmVlUGVyR2FzOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogLy8gQGVycm9yOiBGZWVDYXBUb29IaWdoRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFRoZSBmZWUgY2FwIChgbWFzRmVlUGVyR2FzYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMyBnd2VpKSBjYW5ub3QgYmVcbiAqIC8vIEBlcnJvcjogaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGVudmVsb3BlKSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCB0byB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKGNoYWluSWQgPD0gMClcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gICAgaWYgKHRvKVxuICAgICAgICBBZGRyZXNzLmFzc2VydCh0bywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGlmIChtYXhGZWVQZXJHYXMgJiYgQmlnSW50KG1heEZlZVBlckdhcykgPiAybiAqKiAyNTZuIC0gMW4pXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkZlZUNhcFRvb0hpZ2hFcnJvcih7IGZlZUNhcDogbWF4RmVlUGVyR2FzIH0pO1xuICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhcyAmJlxuICAgICAgICBtYXhGZWVQZXJHYXMgJiZcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPiBtYXhGZWVQZXJHYXMpXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLlRpcEFib3ZlRmVlQ2FwRXJyb3Ioe1xuICAgICAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9IGZyb20gaXRzIHNlcmlhbGl6ZWQgZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5kZXNlcmlhbGl6ZSgnMHgwMmVmMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAxNTU5JyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMjAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIGdhczogMTAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbi5cbiAqIEByZXR1cm5zIERlc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkFycmF5ID0gUmxwLnRvSGV4KEhleC5zbGljZShzZXJpYWxpemVkLCAxKSk7XG4gICAgY29uc3QgW2NoYWluSWQsIG5vbmNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBnYXMsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdCwgeVBhcml0eSwgciwgcyxdID0gdHJhbnNhY3Rpb25BcnJheTtcbiAgICBpZiAoISh0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gOSB8fCB0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTIpKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBnYXMsXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBhY2Nlc3NMaXN0LFxuICAgICAgICAgICAgICAgIC4uLih0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA+IDlcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5UGFyaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0pO1xuICAgIGxldCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICB0eXBlLFxuICAgIH07XG4gICAgaWYgKEhleC52YWxpZGF0ZSh0bykgJiYgdG8gIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnRvID0gdG87XG4gICAgaWYgKEhleC52YWxpZGF0ZShnYXMpICYmIGdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gQmlnSW50KGdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShkYXRhKSAmJiBkYXRhICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gZGF0YTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG5vbmNlKSAmJiBub25jZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubm9uY2UgPSBCaWdJbnQobm9uY2UpO1xuICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpICYmIHZhbHVlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi52YWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhGZWVQZXJHYXMpICYmIG1heEZlZVBlckdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID0gQmlnSW50KG1heEZlZVBlckdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhQcmlvcml0eUZlZVBlckdhcykgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KG1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAoYWNjZXNzTGlzdC5sZW5ndGggIT09IDAgJiYgYWNjZXNzTGlzdCAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IEFjY2Vzc0xpc3QuZnJvbVR1cGxlTGlzdChhY2Nlc3NMaXN0KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSByICYmIHMgJiYgeVBhcml0eSA/IFNpZ25hdHVyZS5mcm9tVHVwbGUoW3lQYXJpdHksIHIsIHNdKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc2lnbmF0dXJlKVxuICAgICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgLi4uc2lnbmF0dXJlLFxuICAgICAgICB9O1xuICAgIGFzc2VydCh0cmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24gb2JqZWN0IGludG8gYW4gRUlQLTE1NTkgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDE1NTknLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHI6IDEyNS4uLm4sXG4gKiAvLyBAbG9nOiAgIHM6IDY0Mi4uLm4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGluc3RhbnRpYXRlIGFuIEVJUC0xNTU5IFRyYW5zYWN0aW9uIEVudmVsb3BlIGZyb20gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuU2VyaWFsaXplZH0gdmFsdWUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKCcweDAyZjg1ODAxODIwMzExODUwMjU0MGJlNDAwODUwNGE4MTdjODAwODA5NDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5Yzg4ODBkZTBiNmIzYTc2NDAwMDA4MGMwODQ3NzM1OTQwMGUxYTAwMTYyN2M2ODcyNjFiMGU3Zjg2MzhhZjExMTJlZmE4YTc3ZTIzNjU2ZjZlNzk0NTI3NWIxOWU5ZGVlZDgwMjYxJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwMTU1OScsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEFuIEVJUC0xNTU5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZW52ZWxvcGVfLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKSA6IHt9KSxcbiAgICAgICAgdHlwZTogJ2VpcDE1NTknLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIGNvbXB1dGUgdGhlIHNpZ24gcGF5bG9hZCB3aGljaCBjYW4gYmUgdXNlZFxuICogd2l0aCBFQ0RTQSBzaWduaW5nIHV0aWxpdGllcyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIHtcbiAgICByZXR1cm4gaGFzaChlbnZlbG9wZSwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBIYXNoZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLidcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbShlbnZlbG9wZSwgeyBzaWduYXR1cmUgfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBFSVAtMTU1OSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBoYXNoLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVzaWduIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihzZXJpYWxpemUoe1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgLi4uKHByZXNpZ25cbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgeVBhcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHY6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH0pKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gLi4uIHNlbmQgYHNlcmlhbGl6ZWRgIHRyYW5zYWN0aW9uIHRvIEpTT04tUlBDIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYFxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoYWluSWQsIGdhcywgbm9uY2UsIHRvLCB2YWx1ZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywgYWNjZXNzTGlzdCwgZGF0YSwgaW5wdXQsIH0gPSBlbnZlbG9wZTtcbiAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgIGNvbnN0IGFjY2Vzc1R1cGxlTGlzdCA9IEFjY2Vzc0xpc3QudG9UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3Qob3B0aW9ucy5zaWduYXR1cmUgfHwgZW52ZWxvcGUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbXG4gICAgICAgIEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4UHJpb3JpdHlGZWVQZXJHYXMpIDogJzB4JyxcbiAgICAgICAgbWF4RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gaW5wdXQgPz8gJzB4JyxcbiAgICAgICAgYWNjZXNzVHVwbGVMaXN0LFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvVHVwbGUoc2lnbmF0dXJlKSA6IFtdKSxcbiAgICBdO1xuICAgIHJldHVybiBIZXguY29uY2F0KHNlcmlhbGl6ZWRUeXBlLCBSbHAuZnJvbUhleChzZXJpYWxpemVkKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OX0gdG8gYW4ge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBScGNSZXF1ZXN0LCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfcnBjID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkudG9ScGMoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gUnBjUmVxdWVzdC5mcm9tKHtcbiAqICAgaWQ6IDAsXG4gKiAgIG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICogICBwYXJhbXM6IFtlbnZlbG9wZV9ycGNdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBFSVAtMTU1OSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gUlBDLWZvcm1hdHRlZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGVudmVsb3BlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoZW52ZWxvcGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICBjaGFpbklkOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5jaGFpbklkKSxcbiAgICAgICAgZGF0YTogZW52ZWxvcGUuZGF0YSA/PyBlbnZlbG9wZS5pbnB1dCxcbiAgICAgICAgdHlwZTogJzB4MicsXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUuZ2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IGdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5ub25jZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBub25jZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubm9uY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLnZhbHVlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IHZhbHVlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS52YWx1ZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubWF4RmVlUGVyR2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IG1heEZlZVBlckdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubWF4RmVlUGVyR2FzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1JwYyhzaWduYXR1cmUpIDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OX0uIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnZlbG9wZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydCh7XG4gKiAgIG1heEZlZVBlckdhczogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js":
/*!******************************************************************!*\
  !*** ../node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AccessList.js */ \"../node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"../node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"../node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"../node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\n\nconst serializedType = '0x01';\nconst type = 'eip2930';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (chainId <= 0)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidChainIdError({ chainId });\n    if (to)\n        _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(to, { strict: false });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.GasPriceTooHighError({ gasPrice });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip2930',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 8 || transactionArray.length === 11))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                gasPrice,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 8\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gasPrice) && gasPrice !== '0x')\n        transaction.gasPrice = BigInt(gasPrice);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-2930 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-2930 Transaction Envelope from a {@link ox#TransactionEnvelopeEip2930.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from('0x01f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.from(signature) : {}),\n        type: 'eip2930',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, {\n *   signature,\n * })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-2930 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_6__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { chainId, gas, data, input, nonce, to, value, accessList, gasPrice } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(options.signature || envelope);\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : '0x',\n        gasPrice ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gasPrice) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toTuple(signature) : []),\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat('0x01', _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} to an {@link ox#TransactionEnvelopeEip2930.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-2930 transaction envelope to convert.\n * @returns An RPC-formatted EIP-2930 transaction envelope.\n */\nfunction toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(envelope);\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId),\n        data: envelope.data ?? envelope.input,\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.gasPrice === 'bigint'\n            ? { gasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gasPrice) }\n            : {}),\n        type: '0x1',\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toRpc(signature) : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip2930.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNOO0FBQ047QUFDRjtBQUNBO0FBQ1k7QUFDb0I7QUFDekQ7QUFDQTtBQUNQO0FBQ0EsY0FBYyxnRUFBZ0U7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHdCQUF3QjtBQUNwQztBQUNBLGtCQUFrQix3RUFBdUMsR0FBRyxTQUFTO0FBQ3JFO0FBQ0EsUUFBUSwrQ0FBYyxPQUFPLGVBQWU7QUFDNUM7QUFDQSxrQkFBa0IseUVBQXdDLEdBQUcsVUFBVTtBQUN2RTtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFnRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QiwwQ0FBUyxDQUFDLDBDQUFTO0FBQ2hEO0FBQ0E7QUFDQSxrQkFBa0IsMkVBQTBDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxzQkFBc0Isa0RBQWlCO0FBQ3ZDO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQWM7QUFDL0I7QUFDQTtBQUNBLGdCQUFnQixLQUFLLCtDQUFjO0FBQ25DLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQixPQUFPLCtDQUFjO0FBQ3JDLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQixPQUFPLCtDQUFjO0FBQ3JDLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQixVQUFVLCtDQUFjO0FBQ3hDLGdCQUFnQjtBQUNoQjtBQUNBLHdCQUF3QixnREFBZSxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUErRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuanM/MTNjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBY2Nlc3NMaXN0IGZyb20gJy4vQWNjZXNzTGlzdC5qcyc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4vUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG5pbXBvcnQgKiBhcyBUcmFuc2FjdGlvbkVudmVsb3BlIGZyb20gJy4vVHJhbnNhY3Rpb25FbnZlbG9wZS5qcyc7XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplZFR5cGUgPSAnMHgwMSc7XG5leHBvcnQgY29uc3QgdHlwZSA9ICdlaXAyOTMwJztcbi8qKlxuICogQXNzZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMH0gaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5hc3NlcnQoe1xuICogICBnYXNQcmljZTogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBlcnJvcjogR2FzUHJpY2VUb29IaWdoRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFRoZSBnYXMgcHJpY2UgKGBnYXNQcmljZWAgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMgZ3dlaSkgY2Fubm90IGJlXG4gKiAvLyBAZXJyb3I6IGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChlbnZlbG9wZSkge1xuICAgIGNvbnN0IHsgY2hhaW5JZCwgZ2FzUHJpY2UsIHRvIH0gPSBlbnZlbG9wZTtcbiAgICBpZiAoY2hhaW5JZCA8PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkQ2hhaW5JZEVycm9yKHsgY2hhaW5JZCB9KTtcbiAgICBpZiAodG8pXG4gICAgICAgIEFkZHJlc3MuYXNzZXJ0KHRvLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgaWYgKGdhc1ByaWNlICYmIEJpZ0ludChnYXNQcmljZSkgPiAybiAqKiAyNTZuIC0gMW4pXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkdhc1ByaWNlVG9vSGlnaEVycm9yKHsgZ2FzUHJpY2UgfSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMH0gZnJvbSBpdHMgc2VyaWFsaXplZCBmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmRlc2VyaWFsaXplKCcweDAxZWYwMTgyMDMxMTg0NzczNTk0MDA4NDc3MzU5NDAwODA5NDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5Yzg4ODBkZTBiNmIzYTc2NDAwMDA4MGMwJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDI5MzAnLFxuICogLy8gQGxvZzogICBub25jZTogNzg1bixcbiAqIC8vIEBsb2c6ICAgZ2FzUHJpY2U6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25BcnJheSA9IFJscC50b0hleChIZXguc2xpY2Uoc2VyaWFsaXplZCwgMSkpO1xuICAgIGNvbnN0IFtjaGFpbklkLCBub25jZSwgZ2FzUHJpY2UsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0LCB5UGFyaXR5LCByLCBzLF0gPSB0cmFuc2FjdGlvbkFycmF5O1xuICAgIGlmICghKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID09PSA4IHx8IHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID09PSAxMSkpXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3Ioe1xuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYWNjZXNzTGlzdCxcbiAgICAgICAgICAgICAgICAuLi4odHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPiA4XG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeVBhcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICBsZXQgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgdHlwZSxcbiAgICB9O1xuICAgIGlmIChIZXgudmFsaWRhdGUodG8pICYmIHRvICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHRvO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzKSAmJiBnYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhcyA9IEJpZ0ludChnYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZGF0YSkgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkgJiYgbm9uY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzUHJpY2UpICYmIGdhc1ByaWNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXNQcmljZSA9IEJpZ0ludChnYXNQcmljZSk7XG4gICAgaWYgKGFjY2Vzc0xpc3QubGVuZ3RoICE9PSAwICYmIGFjY2Vzc0xpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gciAmJiBzICYmIHlQYXJpdHkgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNpZ25hdHVyZSlcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGFuIEVJUC0yOTMwIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBhY2Nlc3NMaXN0OiBbLi4uXSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDI5MzAnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHI6IDEyNS4uLm4sXG4gKiAvLyBAbG9nOiAgIHM6IDY0Mi4uLm4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGluc3RhbnRpYXRlIGFuIEVJUC0yOTMwIFRyYW5zYWN0aW9uIEVudmVsb3BlIGZyb20gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuU2VyaWFsaXplZH0gdmFsdWUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKCcweDAxZjg1ODAxODIwMzExODUwMjU0MGJlNDAwODUwNGE4MTdjODAwODA5NDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5Yzg4ODBkZTBiNmIzYTc2NDAwMDA4MGMwODQ3NzM1OTQwMGUxYTAwMTYyN2M2ODcyNjFiMGU3Zjg2MzhhZjExMTJlZmE4YTc3ZTIzNjU2ZjZlNzk0NTI3NWIxOWU5ZGVlZDgwMjYxJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwMjkzMCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZW52ZWxvcGVfLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKSA6IHt9KSxcbiAgICAgICAgdHlwZTogJ2VpcDI5MzAnLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIGNvbXB1dGUgdGhlIHNpZ24gcGF5bG9hZCB3aGljaCBjYW4gYmUgdXNlZFxuICogd2l0aCBFQ0RTQSBzaWduaW5nIHV0aWxpdGllcyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGdldCB0aGUgc2lnbiBwYXlsb2FkIGZvci5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChlbnZlbG9wZSkge1xuICAgIHJldHVybiBoYXNoKGVudmVsb3BlLCB7IHByZXNpZ246IHRydWUgfSk7XG59XG4vKipcbiAqIEhhc2hlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMH0uIFRoaXMgaXMgdGhlIFwidHJhbnNhY3Rpb24gaGFzaFwiLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKGVudmVsb3BlLCB7XG4gKiAgIHNpZ25hdHVyZSxcbiAqIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmhhc2goZW52ZWxvcGVfc2lnbmVkKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTI5MzAgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnNlcmlhbGl6ZShlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gLi4uIHNlbmQgYHNlcmlhbGl6ZWRgIHRyYW5zYWN0aW9uIHRvIEpTT04tUlBDIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYFxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoYWluSWQsIGdhcywgZGF0YSwgaW5wdXQsIG5vbmNlLCB0bywgdmFsdWUsIGFjY2Vzc0xpc3QsIGdhc1ByaWNlIH0gPSBlbnZlbG9wZTtcbiAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgIGNvbnN0IGFjY2Vzc1R1cGxlTGlzdCA9IEFjY2Vzc0xpc3QudG9UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3Qob3B0aW9ucy5zaWduYXR1cmUgfHwgZW52ZWxvcGUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbXG4gICAgICAgIEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIGdhc1ByaWNlID8gSGV4LmZyb21OdW1iZXIoZ2FzUHJpY2UpIDogJzB4JyxcbiAgICAgICAgZ2FzID8gSGV4LmZyb21OdW1iZXIoZ2FzKSA6ICcweCcsXG4gICAgICAgIHRvID8/ICcweCcsXG4gICAgICAgIHZhbHVlID8gSGV4LmZyb21OdW1iZXIodmFsdWUpIDogJzB4JyxcbiAgICAgICAgZGF0YSA/PyBpbnB1dCA/PyAnMHgnLFxuICAgICAgICBhY2Nlc3NUdXBsZUxpc3QsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9UdXBsZShzaWduYXR1cmUpIDogW10pLFxuICAgIF07XG4gICAgcmV0dXJuIEhleC5jb25jYXQoJzB4MDEnLCBSbHAuZnJvbUhleChzZXJpYWxpemVkKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMH0gdG8gYW4ge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBScGNSZXF1ZXN0LCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcyMCcpLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfcnBjID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAudG9ScGMoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gUnBjUmVxdWVzdC5mcm9tKHtcbiAqICAgaWQ6IDAsXG4gKiAgIG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICogICBwYXJhbXM6IFtlbnZlbG9wZV9ycGNdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBFSVAtMjkzMCB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gUlBDLWZvcm1hdHRlZCBFSVAtMjkzMCB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGVudmVsb3BlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoZW52ZWxvcGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICBjaGFpbklkOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5jaGFpbklkKSxcbiAgICAgICAgZGF0YTogZW52ZWxvcGUuZGF0YSA/PyBlbnZlbG9wZS5pbnB1dCxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5nYXMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgZ2FzOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5nYXMpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLm5vbmNlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IG5vbmNlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5ub25jZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUudmFsdWUgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgdmFsdWU6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLnZhbHVlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5nYXNQcmljZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBnYXNQcmljZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzUHJpY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICB0eXBlOiAnMHgxJyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1JwYyhzaWduYXR1cmUpIDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMH0uIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnZlbG9wZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmFzc2VydCh7XG4gKiAgIGdhc1ByaWNlOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byB2YWxpZGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKGVudmVsb3BlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js":
/*!******************************************************************!*\
  !*** ../node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AccessList.js */ \"../node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Blobs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Blobs.js */ \"../node_modules/ox/_esm/core/Blobs.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Kzg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Kzg.js */ \"../node_modules/ox/_esm/core/Kzg.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Rlp.js */ \"../node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Signature.js */ \"../node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"../node_modules/ox/_esm/core/TransactionEnvelope.js\");\n/* harmony import */ var _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TransactionEnvelopeEip1559.js */ \"../node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n\n\n\n\n\n\n\n\n\nconst serializedType = '0x03';\nconst type = 'eip4844';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844, Value } from 'ox'\n *\n * TransactionEnvelopeEip4844.assert({\n *   blobVersionedHashes: [],\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: EmptyBlobVersionedHashesError: Blob versioned hashes must not be empty.\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { blobVersionedHashes } = envelope;\n    if (blobVersionedHashes) {\n        if (blobVersionedHashes.length === 0)\n            throw new _Blobs_js__WEBPACK_IMPORTED_MODULE_0__.EmptyBlobVersionedHashesError();\n        for (const hash of blobVersionedHashes) {\n            const size = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(hash);\n            const version = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(hash, 0, 1));\n            if (size !== 32)\n                throw new _Blobs_js__WEBPACK_IMPORTED_MODULE_0__.InvalidVersionedHashSizeError({ hash, size });\n            if (version !== _Kzg_js__WEBPACK_IMPORTED_MODULE_2__.versionedHashVersion)\n                throw new _Blobs_js__WEBPACK_IMPORTED_MODULE_0__.InvalidVersionedHashVersionError({\n                    hash,\n                    version,\n                });\n        }\n    }\n    _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_3__.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip4844.deserialize('0x03ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   type: 'eip4844',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const transactionOrWrapperArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_4__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(serialized, 1));\n    const hasNetworkWrapper = transactionOrWrapperArray.length === 4;\n    const transactionArray = hasNetworkWrapper\n        ? transactionOrWrapperArray[0]\n        : transactionOrWrapperArray;\n    const wrapperArray = hasNetworkWrapper\n        ? transactionOrWrapperArray.slice(1)\n        : [];\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, yParity, r, s,] = transactionArray;\n    const [blobs, commitments, proofs] = wrapperArray;\n    if (!(transactionArray.length === 11 || transactionArray.length === 14))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_5__.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 9\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        blobVersionedHashes: blobVersionedHashes,\n        chainId: Number(chainId),\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x')\n        transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_1__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList?.length !== 0 && accessList !== '0x')\n        transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_6__.fromTupleList(accessList);\n    if (blobs && commitments && proofs)\n        transaction.sidecars = _Blobs_js__WEBPACK_IMPORTED_MODULE_0__.toSidecars(blobs, {\n            commitments: commitments,\n            proofs: proofs,\n        });\n    const signature = r && s && yParity\n        ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.fromTuple([yParity, r, s])\n        : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-4844 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const blobVersionedHashes = Blobs.sidecarsToVersionedHashes(sidecars)\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerBlobGas: 3000000000n,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip4844',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-4844 Transaction Envelope from a {@link ox#TransactionEnvelopeEip4844.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip4844.from('0x03f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip4844',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-4844 Transaction Envelope.\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.from(signature) : {}),\n        type: 'eip4844',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip4844.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const hash = TransactionEnvelopeEip4844.hash(envelope) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-4844 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_8__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                sidecars: undefined,\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const blobVersionedHashes = Blobs.sidecarsToVersionedHashes(blobs)\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { blobVersionedHashes, chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data, } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_6__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_7__.extract(options.signature || envelope);\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(nonce) : '0x',\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(maxPriorityFeePerGas) : '0x',\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(maxFeePerGas) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(value) : '0x',\n        data ?? '0x',\n        accessTupleList,\n        maxFeePerBlobGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(maxFeePerBlobGas) : '0x',\n        blobVersionedHashes ?? [],\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.toTuple(signature) : []),\n    ];\n    const sidecars = options.sidecars || envelope.sidecars;\n    const blobs = [];\n    const commitments = [];\n    const proofs = [];\n    if (sidecars)\n        for (let i = 0; i < sidecars.length; i++) {\n            const { blob, commitment, proof } = sidecars[i];\n            blobs.push(blob);\n            commitments.push(commitment);\n            proofs.push(proof);\n        }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat('0x03', sidecars\n        ? // If sidecars are provided, envelope turns into a \"network wrapper\":\n            _Rlp_js__WEBPACK_IMPORTED_MODULE_4__.fromHex([serialized, blobs, commitments, proofs])\n        : // Otherwise, standard envelope is used:\n            _Rlp_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} to an {@link ox#TransactionEnvelopeEip4844.Rpc}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, RpcRequest, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerBlobGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip4844.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-4844 transaction envelope to convert.\n * @returns An RPC-formatted EIP-4844 transaction envelope.\n */\nfunction toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_7__.extract(envelope);\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(envelope.chainId),\n        data: envelope.data ?? envelope.input,\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.maxFeePerBlobGas === 'bigint'\n            ? { maxFeePerBlobGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(envelope.maxFeePerBlobGas) }\n            : {}),\n        ...(typeof envelope.maxFeePerGas === 'bigint'\n            ? { maxFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(envelope.maxFeePerGas) }\n            : {}),\n        ...(typeof envelope.maxPriorityFeePerGas === 'bigint'\n            ? { maxPriorityFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(envelope.maxPriorityFeePerGas) }\n            : {}),\n        type: '0x3',\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.toRpc(signature) : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip4844.assert({\n *   blobVersionedHashes: [],\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip4844.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ1Y7QUFDRjtBQUNGO0FBQ0E7QUFDQTtBQUNZO0FBQ29CO0FBQ2M7QUFDdkU7QUFDQTtBQUNQO0FBQ0EsY0FBYyxnRUFBZ0U7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQSxzQkFBc0Isb0VBQW1DO0FBQ3pEO0FBQ0EseUJBQXlCLHlDQUFRO0FBQ2pDLDRCQUE0Qiw2Q0FBWSxDQUFDLDBDQUFTO0FBQ2xEO0FBQ0EsMEJBQTBCLG9FQUFtQyxHQUFHLFlBQVk7QUFDNUUsNEJBQTRCLHlEQUF3QjtBQUNwRCwwQkFBMEIsdUVBQXNDO0FBQ2hFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLElBQUksa0VBQWlDO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWdFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxzQ0FBc0MsMENBQVMsQ0FBQywwQ0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyRUFBMEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHNCQUFzQixrREFBaUI7QUFDdkM7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBYztBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssK0NBQWM7QUFDbkMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLE9BQU8sK0NBQWM7QUFDckMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLE9BQU8sK0NBQWM7QUFDckMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLGtCQUFrQiwrQ0FBYztBQUNoRCxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IsY0FBYywrQ0FBYztBQUM1QyxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0Isc0JBQXNCLCtDQUFjO0FBQ3BELGdCQUFnQjtBQUNoQjtBQUNBLHdCQUF3QixnREFBZSxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUErRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuanM/MDY5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBY2Nlc3NMaXN0IGZyb20gJy4vQWNjZXNzTGlzdC5qcyc7XG5pbXBvcnQgKiBhcyBCbG9icyBmcm9tICcuL0Jsb2JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBLemcgZnJvbSAnLi9LemcuanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4vUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG5pbXBvcnQgKiBhcyBUcmFuc2FjdGlvbkVudmVsb3BlIGZyb20gJy4vVHJhbnNhY3Rpb25FbnZlbG9wZS5qcyc7XG5pbXBvcnQgKiBhcyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmpzJztcbmV4cG9ydCBjb25zdCBzZXJpYWxpemVkVHlwZSA9ICcweDAzJztcbmV4cG9ydCBjb25zdCB0eXBlID0gJ2VpcDQ4NDQnO1xuLyoqXG4gKiBBc3NlcnRzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0fSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmFzc2VydCh7XG4gKiAgIGJsb2JWZXJzaW9uZWRIYXNoZXM6IFtdLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEVtcHR5QmxvYlZlcnNpb25lZEhhc2hlc0Vycm9yOiBCbG9iIHZlcnNpb25lZCBoYXNoZXMgbXVzdCBub3QgYmUgZW1wdHkuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGVudmVsb3BlKSB7XG4gICAgY29uc3QgeyBibG9iVmVyc2lvbmVkSGFzaGVzIH0gPSBlbnZlbG9wZTtcbiAgICBpZiAoYmxvYlZlcnNpb25lZEhhc2hlcykge1xuICAgICAgICBpZiAoYmxvYlZlcnNpb25lZEhhc2hlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvYnMuRW1wdHlCbG9iVmVyc2lvbmVkSGFzaGVzRXJyb3IoKTtcbiAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBIZXguc2l6ZShoYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBIZXgudG9OdW1iZXIoSGV4LnNsaWNlKGhhc2gsIDAsIDEpKTtcbiAgICAgICAgICAgIGlmIChzaXplICE9PSAzMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQmxvYnMuSW52YWxpZFZlcnNpb25lZEhhc2hTaXplRXJyb3IoeyBoYXNoLCBzaXplIH0pO1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IEt6Zy52ZXJzaW9uZWRIYXNoVmVyc2lvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQmxvYnMuSW52YWxpZFZlcnNpb25lZEhhc2hWZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydChlbnZlbG9wZSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NH0gZnJvbSBpdHMgc2VyaWFsaXplZCBmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmRlc2VyaWFsaXplKCcweDAzZWYwMTgyMDMxMTg0NzczNTk0MDA4NDc3MzU5NDAwODA5NDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5Yzg4ODBkZTBiNmIzYTc2NDAwMDA4MGMwJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYmxvYlZlcnNpb25lZEhhc2hlczogWy4uLl0sXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXA0ODQ0JyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMjAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIGdhczogMTAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbi5cbiAqIEByZXR1cm5zIERlc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbk9yV3JhcHBlckFycmF5ID0gUmxwLnRvSGV4KEhleC5zbGljZShzZXJpYWxpemVkLCAxKSk7XG4gICAgY29uc3QgaGFzTmV0d29ya1dyYXBwZXIgPSB0cmFuc2FjdGlvbk9yV3JhcHBlckFycmF5Lmxlbmd0aCA9PT0gNDtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkFycmF5ID0gaGFzTmV0d29ya1dyYXBwZXJcbiAgICAgICAgPyB0cmFuc2FjdGlvbk9yV3JhcHBlckFycmF5WzBdXG4gICAgICAgIDogdHJhbnNhY3Rpb25PcldyYXBwZXJBcnJheTtcbiAgICBjb25zdCB3cmFwcGVyQXJyYXkgPSBoYXNOZXR3b3JrV3JhcHBlclxuICAgICAgICA/IHRyYW5zYWN0aW9uT3JXcmFwcGVyQXJyYXkuc2xpY2UoMSlcbiAgICAgICAgOiBbXTtcbiAgICBjb25zdCBbY2hhaW5JZCwgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0LCBtYXhGZWVQZXJCbG9iR2FzLCBibG9iVmVyc2lvbmVkSGFzaGVzLCB5UGFyaXR5LCByLCBzLF0gPSB0cmFuc2FjdGlvbkFycmF5O1xuICAgIGNvbnN0IFtibG9icywgY29tbWl0bWVudHMsIHByb29mc10gPSB3cmFwcGVyQXJyYXk7XG4gICAgaWYgKCEodHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDExIHx8IHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID09PSAxNCkpXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3Ioe1xuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3QsXG4gICAgICAgICAgICAgICAgLi4uKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID4gOVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlQYXJpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgfSk7XG4gICAgbGV0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIHR5cGUsXG4gICAgfTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHRvKSAmJiB0byAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udG8gPSB0bztcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGdhcykgJiYgZ2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXMgPSBCaWdJbnQoZ2FzKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGRhdGEpICYmIGRhdGEgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSBkYXRhO1xuICAgIGlmIChIZXgudmFsaWRhdGUobm9uY2UpICYmIG5vbmNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5ub25jZSA9IEJpZ0ludChub25jZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZSh2YWx1ZSkgJiYgdmFsdWUgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG1heEZlZVBlckJsb2JHYXMpICYmIG1heEZlZVBlckJsb2JHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heEZlZVBlckJsb2JHYXMgPSBCaWdJbnQobWF4RmVlUGVyQmxvYkdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhGZWVQZXJHYXMpICYmIG1heEZlZVBlckdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID0gQmlnSW50KG1heEZlZVBlckdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhQcmlvcml0eUZlZVBlckdhcykgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KG1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAoYWNjZXNzTGlzdD8ubGVuZ3RoICE9PSAwICYmIGFjY2Vzc0xpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgaWYgKGJsb2JzICYmIGNvbW1pdG1lbnRzICYmIHByb29mcylcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lkZWNhcnMgPSBCbG9icy50b1NpZGVjYXJzKGJsb2JzLCB7XG4gICAgICAgICAgICBjb21taXRtZW50czogY29tbWl0bWVudHMsXG4gICAgICAgICAgICBwcm9vZnM6IHByb29mcyxcbiAgICAgICAgfSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gciAmJiBzICYmIHlQYXJpdHlcbiAgICAgICAgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNpZ25hdHVyZSlcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGFuIEVJUC00ODQ0IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9icywgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBremcgfSBmcm9tICcuL2t6ZydcbiAqXG4gKiBjb25zdCBibG9icyA9IEJsb2JzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogY29uc3QgYmxvYlZlcnNpb25lZEhhc2hlcyA9IEJsb2JzLnRvVmVyc2lvbmVkSGFzaGVzKGJsb2JzLCB7IGt6ZyB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGJsb2JWZXJzaW9uZWRIYXNoZXMsXG4gKiAgIG1heEZlZVBlckJsb2JHYXM6IFZhbHVlLmZyb21Hd2VpKCczJyksXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMScpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzLCBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IHNpZGVjYXJzID0gQmxvYnMudG9TaWRlY2FycyhibG9icywgeyBremcgfSlcbiAqIGNvbnN0IGJsb2JWZXJzaW9uZWRIYXNoZXMgPSBCbG9icy5zaWRlY2Fyc1RvVmVyc2lvbmVkSGFzaGVzKHNpZGVjYXJzKVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuZnJvbSh7XG4gKiAgIGJsb2JWZXJzaW9uZWRIYXNoZXMsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG1heEZlZVBlckJsb2JHYXM6IFZhbHVlLmZyb21Hd2VpKCczJyksXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMScpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmZyb20oZW52ZWxvcGUsIHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWRlY2FycywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYmxvYlZlcnNpb25lZEhhc2hlczogWy4uLl0sXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckJsb2JHYXM6IDMwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXA0ODQ0JyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtNDg0NCBUcmFuc2FjdGlvbiBFbnZlbG9wZSBmcm9tIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuZnJvbSgnMHgwM2Y4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGJsb2JWZXJzaW9uZWRIYXNoZXM6IFsuLi5dLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNDg0NCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEFuIEVJUC00ODQ0IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZW52ZWxvcGVfLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKSA6IHt9KSxcbiAgICAgICAgdHlwZTogJ2VpcDQ4NDQnLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDR9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIGNvbXB1dGUgdGhlIHNpZ24gcGF5bG9hZCB3aGljaCBjYW4gYmUgdXNlZFxuICogd2l0aCBFQ0RTQSBzaWduaW5nIHV0aWxpdGllcyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9icywgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NCB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGJsb2JWZXJzaW9uZWRIYXNoZXMgPSBCbG9icy50b1ZlcnNpb25lZEhhc2hlcyhibG9icywgeyBremcgfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmZyb20oe1xuICogICBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gZ2V0IHRoZSBzaWduIHBheWxvYWQgZm9yLlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSB7XG4gICAgcmV0dXJuIGhhc2goZW52ZWxvcGUsIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbi8qKlxuICogSGFzaGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0fS4gVGhpcyBpcyB0aGUgXCJ0cmFuc2FjdGlvbiBoYXNoXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NCB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGJsb2JWZXJzaW9uZWRIYXNoZXMgPSBCbG9icy50b1ZlcnNpb25lZEhhc2hlcyhibG9icywgeyBremcgfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmZyb20oe1xuICogICBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0Lmhhc2goZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBFSVAtNDg0NCBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBoYXNoLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVzaWduIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihzZXJpYWxpemUoe1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgLi4uKHByZXNpZ25cbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHNpZGVjYXJzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB5UGFyaXR5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgfSkpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBremcgfSBmcm9tICcuL2t6ZydcbiAqXG4gKiBjb25zdCBibG9icyA9IEJsb2JzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogY29uc3QgYmxvYlZlcnNpb25lZEhhc2hlcyA9IEJsb2JzLnRvVmVyc2lvbmVkSGFzaGVzKGJsb2JzLCB7IGt6ZyB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuZnJvbSh7XG4gKiAgIGJsb2JWZXJzaW9uZWRIYXNoZXMsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMsIFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBremcgfSBmcm9tICcuL2t6ZydcbiAqXG4gKiBjb25zdCBibG9icyA9IEJsb2JzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogY29uc3Qgc2lkZWNhcnMgPSBCbG9icy50b1NpZGVjYXJzKGJsb2JzLCB7IGt6ZyB9KVxuICogY29uc3QgYmxvYlZlcnNpb25lZEhhc2hlcyA9IEJsb2JzLnNpZGVjYXJzVG9WZXJzaW9uZWRIYXNoZXMoYmxvYnMpXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5mcm9tKHtcbiAqICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyQmxvYkdhczogVmFsdWUuZnJvbUd3ZWkoJzMnKSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZGVjYXJzLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIC4uLiBzZW5kIGBzZXJpYWxpemVkYCB0cmFuc2FjdGlvbiB0byBKU09OLVJQQyBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBibG9iVmVyc2lvbmVkSGFzaGVzLCBjaGFpbklkLCBnYXMsIG5vbmNlLCB0bywgdmFsdWUsIG1heEZlZVBlckJsb2JHYXMsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGFjY2Vzc0xpc3QsIGRhdGEsIH0gPSBlbnZlbG9wZTtcbiAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgIGNvbnN0IGFjY2Vzc1R1cGxlTGlzdCA9IEFjY2Vzc0xpc3QudG9UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3Qob3B0aW9ucy5zaWduYXR1cmUgfHwgZW52ZWxvcGUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbXG4gICAgICAgIEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4UHJpb3JpdHlGZWVQZXJHYXMpIDogJzB4JyxcbiAgICAgICAgbWF4RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gJzB4JyxcbiAgICAgICAgYWNjZXNzVHVwbGVMaXN0LFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzID8gSGV4LmZyb21OdW1iZXIobWF4RmVlUGVyQmxvYkdhcykgOiAnMHgnLFxuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzID8/IFtdLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvVHVwbGUoc2lnbmF0dXJlKSA6IFtdKSxcbiAgICBdO1xuICAgIGNvbnN0IHNpZGVjYXJzID0gb3B0aW9ucy5zaWRlY2FycyB8fCBlbnZlbG9wZS5zaWRlY2FycztcbiAgICBjb25zdCBibG9icyA9IFtdO1xuICAgIGNvbnN0IGNvbW1pdG1lbnRzID0gW107XG4gICAgY29uc3QgcHJvb2ZzID0gW107XG4gICAgaWYgKHNpZGVjYXJzKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVjYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGJsb2IsIGNvbW1pdG1lbnQsIHByb29mIH0gPSBzaWRlY2Fyc1tpXTtcbiAgICAgICAgICAgIGJsb2JzLnB1c2goYmxvYik7XG4gICAgICAgICAgICBjb21taXRtZW50cy5wdXNoKGNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgcHJvb2ZzLnB1c2gocHJvb2YpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIEhleC5jb25jYXQoJzB4MDMnLCBzaWRlY2Fyc1xuICAgICAgICA/IC8vIElmIHNpZGVjYXJzIGFyZSBwcm92aWRlZCwgZW52ZWxvcGUgdHVybnMgaW50byBhIFwibmV0d29yayB3cmFwcGVyXCI6XG4gICAgICAgICAgICBSbHAuZnJvbUhleChbc2VyaWFsaXplZCwgYmxvYnMsIGNvbW1pdG1lbnRzLCBwcm9vZnNdKVxuICAgICAgICA6IC8vIE90aGVyd2lzZSwgc3RhbmRhcmQgZW52ZWxvcGUgaXMgdXNlZDpcbiAgICAgICAgICAgIFJscC5mcm9tSGV4KHNlcmlhbGl6ZWQpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0fSB0byBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMsIFJwY1JlcXVlc3QsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGJsb2JWZXJzaW9uZWRIYXNoZXMgPSBCbG9icy50b1ZlcnNpb25lZEhhc2hlcyhibG9icywgeyBremcgfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmZyb20oe1xuICogICBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICBtYXhGZWVQZXJCbG9iR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMjAnKSxcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTQ4NDQgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgRUlQLTQ4NDQgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhlbnZlbG9wZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGVudmVsb3BlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZCksXG4gICAgICAgIGRhdGE6IGVudmVsb3BlLmRhdGEgPz8gZW52ZWxvcGUuaW5wdXQsXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUuZ2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IGdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5ub25jZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBub25jZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubm9uY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLnZhbHVlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IHZhbHVlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS52YWx1ZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubWF4RmVlUGVyQmxvYkdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBtYXhGZWVQZXJCbG9iR2FzOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5tYXhGZWVQZXJCbG9iR2FzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5tYXhGZWVQZXJHYXMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgbWF4RmVlUGVyR2FzOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5tYXhGZWVQZXJHYXMpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLm1heFByaW9yaXR5RmVlUGVyR2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IG1heFByaW9yaXR5RmVlUGVyR2FzOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5tYXhQcmlvcml0eUZlZVBlckdhcykgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIHR5cGU6ICcweDMnLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvUnBjKHNpZ25hdHVyZSkgOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0fS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudmVsb3BlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuYXNzZXJ0KHtcbiAqICAgYmxvYlZlcnNpb25lZEhhc2hlczogW10sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js":
/*!******************************************************************!*\
  !*** ../node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AccessList.js */ \"../node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Authorization.js */ \"../node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"../node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Signature.js */ \"../node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"../node_modules/ox/_esm/core/TransactionEnvelope.js\");\n/* harmony import */ var _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TransactionEnvelopeEip1559.js */ \"../node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n\n\n\n\n\n\n\n\n\nconst serializedType = '0x04';\nconst type = 'eip7702';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * TransactionEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { authorizationList } = envelope;\n    if (authorizationList) {\n        for (const authorization of authorizationList) {\n            const { address, chainId } = authorization;\n            if (address)\n                _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, { strict: false });\n            if (Number(chainId) < 0)\n                throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({ chainId });\n        }\n    }\n    _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_2__.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_4__.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 10 || transactionArray.length === 13))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                authorizationList,\n                ...(transactionArray.length > 9\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_5__.fromTupleList(accessList);\n    if (authorizationList !== '0x')\n        transaction.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_6__.fromTupleList(authorizationList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TransactionEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.from(signature) : {}),\n        type: 'eip7702',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_8__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input, } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_5__.toTupleList(accessList);\n    const authorizationTupleList = _Authorization_js__WEBPACK_IMPORTED_MODULE_6__.toTupleList(authorizationList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_7__.extract(options.signature || envelope);\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(nonce) : '0x',\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(maxPriorityFeePerGas) : '0x',\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(maxFeePerGas) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        authorizationTupleList,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.toTuple(signature) : []),\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_4__.concat(serializedType, _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(serialized));\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip7702.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDTjtBQUNZO0FBQ2xCO0FBQ0Y7QUFDQTtBQUNZO0FBQ29CO0FBQ2M7QUFDdkU7QUFDQTtBQUNQO0FBQ0EsY0FBYyxnRUFBZ0U7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0EsZ0JBQWdCLCtDQUFjLFlBQVksZUFBZTtBQUN6RDtBQUNBLDBCQUEwQix3RUFBdUMsR0FBRyxTQUFTO0FBQzdFO0FBQ0E7QUFDQSxJQUFJLGtFQUFpQztBQUNyQztBQUNBO0FBQ0EsbUJBQW1CLGdFQUFnRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLDBDQUFTLENBQUMsMENBQVM7QUFDaEQ7QUFDQTtBQUNBLGtCQUFrQiwyRUFBMEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQTtBQUNBLGlDQUFpQyx5REFBd0I7QUFDekQ7QUFDQSx3Q0FBd0MsNERBQTJCO0FBQ25FLDBDQUEwQyxvREFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUE4RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0VBQWtFLFdBQVc7QUFDN0U7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnREFBZ0Q7QUFDMUg7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0NBQW9DO0FBQzNDLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBYyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0RBQStEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhCQUE4QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0EsYUFBYSwrREFBK0Q7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx1RUFBdUUsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0NBQW9DO0FBQzNDLFlBQVksVUFBVTtBQUN0QixXQUFXLCtDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLCtEQUErRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrRUFBa0UsV0FBVztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBK0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QztBQUNoRCxZQUFZLGtIQUFrSDtBQUM5SDtBQUNBLDRCQUE0Qix1REFBc0I7QUFDbEQsbUNBQW1DLDBEQUF5QjtBQUM1RCxzQkFBc0Isa0RBQWlCO0FBQ3ZDO0FBQ0EsUUFBUSwrQ0FBYztBQUN0QixnQkFBZ0IsK0NBQWM7QUFDOUIsK0JBQStCLCtDQUFjO0FBQzdDLHVCQUF1QiwrQ0FBYztBQUNyQyxjQUFjLCtDQUFjO0FBQzVCO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrREFBaUI7QUFDekM7QUFDQSxXQUFXLDJDQUFVLGlCQUFpQiw0Q0FBVztBQUNqRDtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUErRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5qcz80ZjRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFjY2Vzc0xpc3QgZnJvbSAnLi9BY2Nlc3NMaXN0LmpzJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEF1dGhvcml6YXRpb24gZnJvbSAnLi9BdXRob3JpemF0aW9uLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBSbHAgZnJvbSAnLi9SbHAuanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4vU2lnbmF0dXJlLmpzJztcbmltcG9ydCAqIGFzIFRyYW5zYWN0aW9uRW52ZWxvcGUgZnJvbSAnLi9UcmFuc2FjdGlvbkVudmVsb3BlLmpzJztcbmltcG9ydCAqIGFzIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IGZyb20gJy4vVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuanMnO1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZWRUeXBlID0gJzB4MDQnO1xuZXhwb3J0IGNvbnN0IHR5cGUgPSAnZWlwNzcwMic7XG4vKipcbiAqIEFzc2VydHMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDJ9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuYXNzZXJ0KHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3Q6IFtdLFxuICogICBtYXhGZWVQZXJHYXM6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEZlZUNhcFRvb0hpZ2hFcnJvcjpcbiAqIC8vIEBlcnJvcjogVGhlIGZlZSBjYXAgKGBtYXNGZWVQZXJHYXNgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzIGd3ZWkpIGNhbm5vdCBiZVxuICogLy8gQGVycm9yOiBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB7IGF1dGhvcml6YXRpb25MaXN0IH0gPSBlbnZlbG9wZTtcbiAgICBpZiAoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCBhdXRob3JpemF0aW9uIG9mIGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQgfSA9IGF1dGhvcml6YXRpb247XG4gICAgICAgICAgICBpZiAoYWRkcmVzcylcbiAgICAgICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAoTnVtYmVyKGNoYWluSWQpIDwgMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkQ2hhaW5JZEVycm9yKHsgY2hhaW5JZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoZW52ZWxvcGUpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDJ9IGZyb20gaXRzIHNlcmlhbGl6ZWQgZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5kZXNlcmlhbGl6ZSgnMHgwNGVmMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDc3MDInLFxuICogLy8gQGxvZzogICBub25jZTogNzg1bixcbiAqIC8vIEBsb2c6ICAgbWF4RmVlUGVyR2FzOiAyMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgZ2FzOiAxMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQXJyYXkgPSBSbHAudG9IZXgoSGV4LnNsaWNlKHNlcmlhbGl6ZWQsIDEpKTtcbiAgICBjb25zdCBbY2hhaW5JZCwgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0LCBhdXRob3JpemF0aW9uTGlzdCwgeVBhcml0eSwgciwgcyxdID0gdHJhbnNhY3Rpb25BcnJheTtcbiAgICBpZiAoISh0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTAgfHwgdHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDEzKSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYWNjZXNzTGlzdCxcbiAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uTGlzdCxcbiAgICAgICAgICAgICAgICAuLi4odHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPiA5XG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeVBhcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICBsZXQgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgdHlwZSxcbiAgICB9O1xuICAgIGlmIChIZXgudmFsaWRhdGUodG8pICYmIHRvICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHRvO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzKSAmJiBnYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhcyA9IEJpZ0ludChnYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZGF0YSkgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkgJiYgbm9uY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUobWF4RmVlUGVyR2FzKSAmJiBtYXhGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyA9IEJpZ0ludChtYXhGZWVQZXJHYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUobWF4UHJpb3JpdHlGZWVQZXJHYXMpICYmIG1heFByaW9yaXR5RmVlUGVyR2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ0ludChtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKGFjY2Vzc0xpc3QubGVuZ3RoICE9PSAwICYmIGFjY2Vzc0xpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgaWYgKGF1dGhvcml6YXRpb25MaXN0ICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChhdXRob3JpemF0aW9uTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gciAmJiBzICYmIHlQYXJpdHkgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNpZ25hdHVyZSlcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGFuIEVJUC03NzAyIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IFtBdXRob3JpemF0aW9uLmZyb20oYXV0aG9yaXphdGlvbiwgeyBzaWduYXR1cmUgfSldXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBhdXRob3JpemF0aW9uTGlzdCwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjaGFpbklkOiAxLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksIC8vIFshY29kZSBmb2N1c11cbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksIC8vIFshY29kZSBmb2N1c11cbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDc3MDInLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHI6IDEyNS4uLm4sXG4gKiAvLyBAbG9nOiAgIHM6IDY0Mi4uLm4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGluc3RhbnRpYXRlIGFuIEVJUC03NzAyIFRyYW5zYWN0aW9uIEVudmVsb3BlIGZyb20gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuU2VyaWFsaXplZH0gdmFsdWUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKCcweDA0Zjg1ODAxODIwMzExODUwMjU0MGJlNDAwODUwNGE4MTdjODAwODA5NDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5Yzg4ODBkZTBiNmIzYTc2NDAwMDA4MGMwODQ3NzM1OTQwMGUxYTAwMTYyN2M2ODcyNjFiMGU3Zjg2MzhhZjExMTJlZmE4YTc3ZTIzNjU2ZjZlNzk0NTI3NWIxOWU5ZGVlZDgwMjYxJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNzcwMicsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEFuIEVJUC03NzAyIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZW52ZWxvcGVfLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKSA6IHt9KSxcbiAgICAgICAgdHlwZTogJ2VpcDc3MDInLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIGNvbXB1dGUgdGhlIHNpZ24gcGF5bG9hZCB3aGljaCBjYW4gYmUgdXNlZFxuICogd2l0aCBFQ0RTQSBzaWduaW5nIHV0aWxpdGllcyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gZ2V0IHRoZSBzaWduIHBheWxvYWQgZm9yLlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSB7XG4gICAgcmV0dXJuIGhhc2goZW52ZWxvcGUsIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbi8qKlxuICogSGFzaGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyfS4gVGhpcyBpcyB0aGUgXCJ0cmFuc2FjdGlvbiBoYXNoXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJ1xuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKGVudmVsb3BlLCB7IHNpZ25hdHVyZSB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5oYXNoKGVudmVsb3BlX3NpZ25lZCkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIEVJUC03NzAyIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIGhhc2guXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHByZXNpZ24gfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KHNlcmlhbGl6ZSh7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICAuLi4ocHJlc2lnblxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB5UGFyaXR5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25MaXN0ID0gW0F1dGhvcml6YXRpb24uZnJvbShhdXRob3JpemF0aW9uLCB7IHNpZ25hdHVyZSB9KV1cbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oe1xuICogICBhdXRob3JpemF0aW9uTGlzdCxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gLi4uIHNlbmQgYHNlcmlhbGl6ZWRgIHRyYW5zYWN0aW9uIHRvIEpTT04tUlBDIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYFxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGF1dGhvcml6YXRpb25MaXN0LCBjaGFpbklkLCBnYXMsIG5vbmNlLCB0bywgdmFsdWUsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGFjY2Vzc0xpc3QsIGRhdGEsIGlucHV0LCB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBjb25zdCBhY2Nlc3NUdXBsZUxpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IGF1dGhvcml6YXRpb25UdXBsZUxpc3QgPSBBdXRob3JpemF0aW9uLnRvVHVwbGVMaXN0KGF1dGhvcml6YXRpb25MaXN0KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChvcHRpb25zLnNpZ25hdHVyZSB8fCBlbnZlbG9wZSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgSGV4LmZyb21OdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlID8gSGV4LmZyb21OdW1iZXIobm9uY2UpIDogJzB4JyxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPyBIZXguZnJvbU51bWJlcihtYXhQcmlvcml0eUZlZVBlckdhcykgOiAnMHgnLFxuICAgICAgICBtYXhGZWVQZXJHYXMgPyBIZXguZnJvbU51bWJlcihtYXhGZWVQZXJHYXMpIDogJzB4JyxcbiAgICAgICAgZ2FzID8gSGV4LmZyb21OdW1iZXIoZ2FzKSA6ICcweCcsXG4gICAgICAgIHRvID8/ICcweCcsXG4gICAgICAgIHZhbHVlID8gSGV4LmZyb21OdW1iZXIodmFsdWUpIDogJzB4JyxcbiAgICAgICAgZGF0YSA/PyBpbnB1dCA/PyAnMHgnLFxuICAgICAgICBhY2Nlc3NUdXBsZUxpc3QsXG4gICAgICAgIGF1dGhvcml6YXRpb25UdXBsZUxpc3QsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9UdXBsZShzaWduYXR1cmUpIDogW10pLFxuICAgIF07XG4gICAgcmV0dXJuIEhleC5jb25jYXQoc2VyaWFsaXplZFR5cGUsIFJscC5mcm9tSGV4KHNlcmlhbGl6ZWQpKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyfS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudmVsb3BlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIudmFsaWRhdGUoe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogW10sXG4gKiAgIG1heEZlZVBlckdhczogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"../node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signature.js */ \"../node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"../node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\nconst type = 'legacy';\n/**\n * Asserts a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (to)\n        _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(to, { strict: false });\n    if (typeof chainId !== 'undefined' && chainId <= 0)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({ chainId });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.GasPriceTooHighError({ gasPrice });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const tuple = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(serialized);\n    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = tuple;\n    if (!(tuple.length === 6 || tuple.length === 9))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n            attributes: {\n                nonce,\n                gasPrice,\n                gas,\n                to,\n                value,\n                data,\n                ...(tuple.length > 6\n                    ? {\n                        v: chainIdOrV_,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    const transaction = {\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gasPrice) && gasPrice !== '0x')\n        transaction.gasPrice = BigInt(gasPrice);\n    if (tuple.length === 6)\n        return transaction;\n    const chainIdOrV = _Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(chainIdOrV_) && chainIdOrV_ !== '0x'\n        ? Number(chainIdOrV_)\n        : 0;\n    if (s === '0x' && r === '0x') {\n        if (chainIdOrV > 0)\n            transaction.chainId = Number(chainIdOrV);\n        return transaction;\n    }\n    const v = chainIdOrV;\n    const chainId = Math.floor((v - 35) / 2);\n    if (chainId > 0)\n        transaction.chainId = chainId;\n    else if (v !== 27 && v !== 28)\n        throw new _Signature_js__WEBPACK_IMPORTED_MODULE_4__.InvalidVError({ value: v });\n    transaction.yParity = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.vToYParity(v);\n    transaction.v = v;\n    transaction.s = s === '0x' ? 0n : BigInt(s);\n    transaction.r = r === '0x' ? 0n : BigInt(r);\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TransactionEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    const signature_ = (() => {\n        if (!signature)\n            return {};\n        const s = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.from(signature);\n        s.v = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(s.yParity);\n        return s;\n    })();\n    return {\n        ...envelope_,\n        ...signature_,\n        type: 'legacy',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_5__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { chainId = 0, gas, data, input, nonce, to, value, gasPrice } = envelope;\n    assert(envelope);\n    let serialized = [\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : '0x',\n        gasPrice ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gasPrice) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n    ];\n    const signature = (() => {\n        if (options.signature)\n            return {\n                r: options.signature.r,\n                s: options.signature.s,\n                v: _Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(options.signature.yParity),\n            };\n        if (typeof envelope.r === 'undefined' || typeof envelope.s === 'undefined')\n            return undefined;\n        return {\n            r: envelope.r,\n            s: envelope.s,\n            v: envelope.v,\n        };\n    })();\n    if (signature) {\n        const v = (() => {\n            // EIP-155 (inferred chainId)\n            if (signature.v >= 35) {\n                const inferredChainId = Math.floor((signature.v - 35) / 2);\n                if (inferredChainId > 0)\n                    return signature.v;\n                return 27 + (signature.v === 35 ? 0 : 1);\n            }\n            // EIP-155 (explicit chainId)\n            if (chainId > 0)\n                return chainId * 2 + 35 + signature.v - 27;\n            // Pre-EIP-155 (no chainId)\n            const v = 27 + (signature.v === 27 ? 0 : 1);\n            if (signature.v !== v)\n                throw new _Signature_js__WEBPACK_IMPORTED_MODULE_4__.InvalidVError({ value: signature.v });\n            return v;\n        })();\n        serialized = [\n            ...serialized,\n            _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(v),\n            signature.r === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(signature.r)),\n            signature.s === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(signature.s)),\n        ];\n    }\n    else if (chainId > 0)\n        serialized = [...serialized, _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId), '0x', '0x'];\n    return _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized);\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} to an {@link ox#TransactionEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */\nfunction toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.extract(envelope);\n    return {\n        ...envelope,\n        chainId: typeof envelope.chainId === 'number'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId)\n            : undefined,\n        data: envelope.data ?? envelope.input,\n        type: '0x0',\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.gasPrice === 'bigint'\n            ? { gasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gasPrice) }\n            : {}),\n        ...(signature\n            ? {\n                ..._Signature_js__WEBPACK_IMPORTED_MODULE_4__.toRpc(signature),\n                v: signature.yParity === 0 ? '0x1b' : '0x1c',\n            }\n            : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeLegacy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNOO0FBQ0Y7QUFDQTtBQUNZO0FBQ29CO0FBQ3pEO0FBQ1A7QUFDQSxjQUFjLDhEQUE4RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0EsUUFBUSwrQ0FBYyxPQUFPLGVBQWU7QUFDNUM7QUFDQSxrQkFBa0Isd0VBQXVDLEdBQUcsU0FBUztBQUNyRTtBQUNBLGtCQUFrQix5RUFBd0MsR0FBRyxVQUFVO0FBQ3ZFO0FBQ0E7QUFDQSxtQkFBbUIsOERBQThEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLDBDQUFTO0FBQzNCO0FBQ0E7QUFDQSxrQkFBa0IsMkVBQTBDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuanM/MjU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4vUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG5pbXBvcnQgKiBhcyBUcmFuc2FjdGlvbkVudmVsb3BlIGZyb20gJy4vVHJhbnNhY3Rpb25FbnZlbG9wZS5qcyc7XG5leHBvcnQgY29uc3QgdHlwZSA9ICdsZWdhY3knO1xuLyoqXG4gKiBBc3NlcnRzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeX0gaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEdhc1ByaWNlVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZ2FzIHByaWNlIChgZ2FzUHJpY2VgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzIGd3ZWkpIGNhbm5vdCBiZVxuICogLy8gQGVycm9yOiBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB7IGNoYWluSWQsIGdhc1ByaWNlLCB0byB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKHRvKVxuICAgICAgICBBZGRyZXNzLmFzc2VydCh0bywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGlmICh0eXBlb2YgY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2hhaW5JZCA8PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkQ2hhaW5JZEVycm9yKHsgY2hhaW5JZCB9KTtcbiAgICBpZiAoZ2FzUHJpY2UgJiYgQmlnSW50KGdhc1ByaWNlKSA+IDJuICoqIDI1Nm4gLSAxbilcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuR2FzUHJpY2VUb29IaWdoRXJyb3IoeyBnYXNQcmljZSB9KTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeX0gZnJvbSBpdHMgc2VyaWFsaXplZCBmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5kZXNlcmlhbGl6ZSgnMHgwMWVmMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdsZWdhY3knLFxuICogLy8gQGxvZzogICBub25jZTogNzg1bixcbiAqIC8vIEBsb2c6ICAgZ2FzUHJpY2U6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgY29uc3QgdHVwbGUgPSBSbHAudG9IZXgoc2VyaWFsaXplZCk7XG4gICAgY29uc3QgW25vbmNlLCBnYXNQcmljZSwgZ2FzLCB0bywgdmFsdWUsIGRhdGEsIGNoYWluSWRPclZfLCByLCBzXSA9IHR1cGxlO1xuICAgIGlmICghKHR1cGxlLmxlbmd0aCA9PT0gNiB8fCB0dXBsZS5sZW5ndGggPT09IDkpKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgICAgICAgICBnYXMsXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAuLi4odHVwbGUubGVuZ3RoID4gNlxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHY6IGNoYWluSWRPclZfLFxuICAgICAgICAgICAgICAgICAgICAgICAgcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICB0eXBlLFxuICAgIH07XG4gICAgaWYgKEhleC52YWxpZGF0ZSh0bykgJiYgdG8gIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnRvID0gdG87XG4gICAgaWYgKEhleC52YWxpZGF0ZShnYXMpICYmIGdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gQmlnSW50KGdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShkYXRhKSAmJiBkYXRhICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gZGF0YTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG5vbmNlKSAmJiBub25jZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubm9uY2UgPSBCaWdJbnQobm9uY2UpO1xuICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpICYmIHZhbHVlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi52YWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShnYXNQcmljZSkgJiYgZ2FzUHJpY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhc1ByaWNlID0gQmlnSW50KGdhc1ByaWNlKTtcbiAgICBpZiAodHVwbGUubGVuZ3RoID09PSA2KVxuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgY29uc3QgY2hhaW5JZE9yViA9IEhleC52YWxpZGF0ZShjaGFpbklkT3JWXykgJiYgY2hhaW5JZE9yVl8gIT09ICcweCdcbiAgICAgICAgPyBOdW1iZXIoY2hhaW5JZE9yVl8pXG4gICAgICAgIDogMDtcbiAgICBpZiAocyA9PT0gJzB4JyAmJiByID09PSAnMHgnKSB7XG4gICAgICAgIGlmIChjaGFpbklkT3JWID4gMClcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNoYWluSWQgPSBOdW1iZXIoY2hhaW5JZE9yVik7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgY29uc3QgdiA9IGNoYWluSWRPclY7XG4gICAgY29uc3QgY2hhaW5JZCA9IE1hdGguZmxvb3IoKHYgLSAzNSkgLyAyKTtcbiAgICBpZiAoY2hhaW5JZCA+IDApXG4gICAgICAgIHRyYW5zYWN0aW9uLmNoYWluSWQgPSBjaGFpbklkO1xuICAgIGVsc2UgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KVxuICAgICAgICB0aHJvdyBuZXcgU2lnbmF0dXJlLkludmFsaWRWRXJyb3IoeyB2YWx1ZTogdiB9KTtcbiAgICB0cmFuc2FjdGlvbi55UGFyaXR5ID0gU2lnbmF0dXJlLnZUb1lQYXJpdHkodik7XG4gICAgdHJhbnNhY3Rpb24udiA9IHY7XG4gICAgdHJhbnNhY3Rpb24ucyA9IHMgPT09ICcweCcgPyAwbiA6IEJpZ0ludChzKTtcbiAgICB0cmFuc2FjdGlvbi5yID0gciA9PT0gJzB4JyA/IDBuIDogQmlnSW50KHIpO1xuICAgIGFzc2VydCh0cmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24gb2JqZWN0IGludG8gYSBsZWdhY3kgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3ksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oZW52ZWxvcGUsIHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBnYXNQcmljZTogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXA3NzAyJyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBsZWdhY3kgVHJhbnNhY3Rpb24gRW52ZWxvcGUgZnJvbSBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oJzB4Zjg1ODAxODIwMzExODUwMjU0MGJlNDAwODUwNGE4MTdjODAwODA5NDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5Yzg4ODBkZTBiNmIzYTc2NDAwMDA4MGMwODQ3NzM1OTQwMGUxYTAwMTYyN2M2ODcyNjFiMGU3Zjg2MzhhZjExMTJlZmE4YTc3ZTIzNjU2ZjZlNzk0NTI3NWIxOWU5ZGVlZDgwMjYxJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnbGVnYWN5JyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgQSBsZWdhY3kgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbnZlbG9wZV8gPSAodHlwZW9mIGVudmVsb3BlID09PSAnc3RyaW5nJyA/IGRlc2VyaWFsaXplKGVudmVsb3BlKSA6IGVudmVsb3BlKTtcbiAgICBhc3NlcnQoZW52ZWxvcGVfKTtcbiAgICBjb25zdCBzaWduYXR1cmVfID0gKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaWduYXR1cmUpXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIGNvbnN0IHMgPSBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpO1xuICAgICAgICBzLnYgPSBTaWduYXR1cmUueVBhcml0eVRvVihzLnlQYXJpdHkpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlXyxcbiAgICAgICAgLi4uc2lnbmF0dXJlXyxcbiAgICAgICAgdHlwZTogJ2xlZ2FjeScsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGF5bG9hZCB0byBzaWduIGZvciBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIGNvbXB1dGUgdGhlIHNpZ24gcGF5bG9hZCB3aGljaCBjYW4gYmUgdXNlZFxuICogd2l0aCBFQ0RTQSBzaWduaW5nIHV0aWxpdGllcyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gZ2V0IHRoZSBzaWduIHBheWxvYWQgZm9yLlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSB7XG4gICAgcmV0dXJuIGhhc2goZW52ZWxvcGUsIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbi8qKlxuICogSGFzaGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeX0uIFRoaXMgaXMgdGhlIFwidHJhbnNhY3Rpb24gaGFzaFwiLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbShlbnZlbG9wZSwgeyBzaWduYXR1cmUgfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5oYXNoKGVudmVsb3BlX3NpZ25lZCkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIExlZ2FjeSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBoYXNoLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVzaWduIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihzZXJpYWxpemUoe1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgLi4uKHByZXNpZ25cbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgeVBhcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHY6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH0pKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3ksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5zZXJpYWxpemUoZW52ZWxvcGUsIHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiAvLyAuLi4gc2VuZCBgc2VyaWFsaXplZGAgdHJhbnNhY3Rpb24gdG8gSlNPTi1SUEMgYGV0aF9zZW5kUmF3VHJhbnNhY3Rpb25gXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gc2VyaWFsaXplLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hhaW5JZCA9IDAsIGdhcywgZGF0YSwgaW5wdXQsIG5vbmNlLCB0bywgdmFsdWUsIGdhc1ByaWNlIH0gPSBlbnZlbG9wZTtcbiAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgIGxldCBzZXJpYWxpemVkID0gW1xuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIGdhc1ByaWNlID8gSGV4LmZyb21OdW1iZXIoZ2FzUHJpY2UpIDogJzB4JyxcbiAgICAgICAgZ2FzID8gSGV4LmZyb21OdW1iZXIoZ2FzKSA6ICcweCcsXG4gICAgICAgIHRvID8/ICcweCcsXG4gICAgICAgIHZhbHVlID8gSGV4LmZyb21OdW1iZXIodmFsdWUpIDogJzB4JyxcbiAgICAgICAgZGF0YSA/PyBpbnB1dCA/PyAnMHgnLFxuICAgIF07XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmF0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiBvcHRpb25zLnNpZ25hdHVyZS5yLFxuICAgICAgICAgICAgICAgIHM6IG9wdGlvbnMuc2lnbmF0dXJlLnMsXG4gICAgICAgICAgICAgICAgdjogU2lnbmF0dXJlLnlQYXJpdHlUb1Yob3B0aW9ucy5zaWduYXR1cmUueVBhcml0eSksXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGVudmVsb3BlLnIgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlbnZlbG9wZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBlbnZlbG9wZS5yLFxuICAgICAgICAgICAgczogZW52ZWxvcGUucyxcbiAgICAgICAgICAgIHY6IGVudmVsb3BlLnYsXG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHYgPSAoKCkgPT4ge1xuICAgICAgICAgICAgLy8gRUlQLTE1NSAoaW5mZXJyZWQgY2hhaW5JZClcbiAgICAgICAgICAgIGlmIChzaWduYXR1cmUudiA+PSAzNSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZmVycmVkQ2hhaW5JZCA9IE1hdGguZmxvb3IoKHNpZ25hdHVyZS52IC0gMzUpIC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKGluZmVycmVkQ2hhaW5JZCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmUudjtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjcgKyAoc2lnbmF0dXJlLnYgPT09IDM1ID8gMCA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRUlQLTE1NSAoZXhwbGljaXQgY2hhaW5JZClcbiAgICAgICAgICAgIGlmIChjaGFpbklkID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW5JZCAqIDIgKyAzNSArIHNpZ25hdHVyZS52IC0gMjc7XG4gICAgICAgICAgICAvLyBQcmUtRUlQLTE1NSAobm8gY2hhaW5JZClcbiAgICAgICAgICAgIGNvbnN0IHYgPSAyNyArIChzaWduYXR1cmUudiA9PT0gMjcgPyAwIDogMSk7XG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlLnYgIT09IHYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZS5JbnZhbGlkVkVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS52IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHNlcmlhbGl6ZWQgPSBbXG4gICAgICAgICAgICAuLi5zZXJpYWxpemVkLFxuICAgICAgICAgICAgSGV4LmZyb21OdW1iZXIodiksXG4gICAgICAgICAgICBzaWduYXR1cmUuciA9PT0gMG4gPyAnMHgnIDogSGV4LnRyaW1MZWZ0KEhleC5mcm9tTnVtYmVyKHNpZ25hdHVyZS5yKSksXG4gICAgICAgICAgICBzaWduYXR1cmUucyA9PT0gMG4gPyAnMHgnIDogSGV4LnRyaW1MZWZ0KEhleC5mcm9tTnVtYmVyKHNpZ25hdHVyZS5zKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYWluSWQgPiAwKVxuICAgICAgICBzZXJpYWxpemVkID0gWy4uLnNlcmlhbGl6ZWQsIEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLCAnMHgnLCAnMHgnXTtcbiAgICByZXR1cm4gUmxwLmZyb21IZXgoc2VyaWFsaXplZCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBScGNSZXF1ZXN0LCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kudG9ScGMoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gUnBjUmVxdWVzdC5mcm9tKHtcbiAqICAgaWQ6IDAsXG4gKiAgIG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICogICBwYXJhbXM6IFtlbnZlbG9wZV9ycGNdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBsZWdhY3kgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgbGVnYWN5IHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoZW52ZWxvcGUpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChlbnZlbG9wZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIGNoYWluSWQ6IHR5cGVvZiBlbnZlbG9wZS5jaGFpbklkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5jaGFpbklkKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGRhdGE6IGVudmVsb3BlLmRhdGEgPz8gZW52ZWxvcGUuaW5wdXQsXG4gICAgICAgIHR5cGU6ICcweDAnLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLmdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBnYXM6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLmdhcykgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubm9uY2UgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgbm9uY2U6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLm5vbmNlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS52YWx1ZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyB2YWx1ZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUudmFsdWUpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLmdhc1ByaWNlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IGdhc1ByaWNlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5nYXNQcmljZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihzaWduYXR1cmVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIC4uLlNpZ25hdHVyZS50b1JwYyhzaWduYXR1cmUpLFxuICAgICAgICAgICAgICAgIHY6IHNpZ25hdHVyZS55UGFyaXR5ID09PSAwID8gJzB4MWInIDogJzB4MWMnLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeX0uIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnZlbG9wZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5hc3NlcnQoe1xuICogICBnYXNQcmljZTogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TransactionReceipt.js":
/*!**********************************************************!*\
  !*** ../node_modules/ox/_esm/core/TransactionReceipt.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcStatus: () => (/* binding */ fromRpcStatus),\n/* harmony export */   fromRpcType: () => (/* binding */ fromRpcType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcStatus: () => (/* binding */ toRpcStatus),\n/* harmony export */   toRpcType: () => (/* binding */ toRpcType)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Log.js */ \"../node_modules/ox/_esm/core/Log.js\");\n\n\n/** RPC status to status mapping. */\nconst fromRpcStatus = {\n    '0x0': 'reverted',\n    '0x1': 'success',\n};\n/** Status to RPC status mapping. */\nconst toRpcStatus = {\n    reverted: '0x0',\n    success: '0x1',\n};\n/** RPC type to type mapping. */\nconst fromRpcType = {\n    '0x0': 'legacy',\n    '0x1': 'eip2930',\n    '0x2': 'eip1559',\n    '0x3': 'eip4844',\n    '0x4': 'eip7702',\n};\n/** Type to RPC type mapping. */\nconst toRpcType = {\n    legacy: '0x0',\n    eip2930: '0x1',\n    eip1559: '0x2',\n    eip4844: '0x3',\n    eip7702: '0x4',\n};\n/**\n * Converts a {@link ox#TransactionReceipt.Rpc} to an {@link ox#TransactionReceipt.TransactionReceipt}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = TransactionReceipt.fromRpc({\n *   blobGasPrice: '0x42069',\n *   blobGasUsed: '0x1337',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   contractAddress: null,\n *   cumulativeGasUsed: '0x82515',\n *   effectiveGasPrice: '0x21c2f6c09',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: '0x2abba',\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   status: '0x1',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: '0x2',\n *   type: '0x2',\n * })\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an example of how to use the `TransactionReceipt.fromRpc` method to convert an RPC transaction receipt to a {@link ox#TransactionReceipt.TransactionReceipt} object.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = await window.ethereum!\n *   .request({\n *     method: 'eth_getTransactionReceipt',\n *     params: [\n *       '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *     ],\n *   })\n *   .then(TransactionReceipt.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param receipt - The RPC receipt to convert.\n * @returns An instantiated {@link ox#TransactionReceipt.TransactionReceipt}.\n */\nfunction fromRpc(receipt) {\n    if (!receipt)\n        return null;\n    return {\n        ...receipt,\n        blobGasPrice: receipt.blobGasPrice\n            ? BigInt(receipt.blobGasPrice)\n            : undefined,\n        blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : undefined,\n        blockNumber: BigInt(receipt.blockNumber ?? 0n),\n        cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),\n        effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),\n        gasUsed: BigInt(receipt.gasUsed ?? 0n),\n        logs: receipt.logs.map((log) => _Log_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(log, { pending: false })),\n        status: fromRpcStatus[receipt.status],\n        transactionIndex: Number(receipt.transactionIndex ?? 0),\n        type: fromRpcType[receipt.type] || receipt.type,\n    };\n}\n/**\n * Converts a {@link ox#TransactionReceipt.TransactionReceipt} to a {@link ox#TransactionReceipt.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = TransactionReceipt.toRpc({\n *   blobGasPrice: 270441n,\n *   blobGasUsed: 4919n,\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   contractAddress: null,\n *   cumulativeGasUsed: 533781n,\n *   effectiveGasPrice: 9062804489n,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: 175034n,\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   root: undefined,\n *   status: 'success',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n * })\n * // @log: {\n * // @log:   blobGasPrice: \"0x042069\",\n * // @log:   blobGasUsed: \"0x1337\",\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: \"0x012f296f\",\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: \"0x082515\",\n * // @log:   effectiveGasPrice: \"0x021c2f6c09\",\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: \"0x02abba\",\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"0x1\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: \"0x02\",\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @param receipt - The receipt to convert.\n * @returns An RPC receipt.\n */\nfunction toRpc(receipt) {\n    return {\n        blobGasPrice: receipt.blobGasPrice\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(receipt.blobGasPrice)\n            : undefined,\n        blobGasUsed: receipt.blobGasUsed\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(receipt.blobGasUsed)\n            : undefined,\n        blockHash: receipt.blockHash,\n        blockNumber: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(receipt.blockNumber),\n        contractAddress: receipt.contractAddress,\n        cumulativeGasUsed: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(receipt.cumulativeGasUsed),\n        effectiveGasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(receipt.effectiveGasPrice),\n        from: receipt.from,\n        gasUsed: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(receipt.gasUsed),\n        logs: receipt.logs.map(_Log_js__WEBPACK_IMPORTED_MODULE_0__.toRpc),\n        logsBloom: receipt.logsBloom,\n        root: receipt.root,\n        status: toRpcStatus[receipt.status],\n        to: receipt.to,\n        transactionHash: receipt.transactionHash,\n        transactionIndex: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(receipt.transactionIndex),\n        type: toRpcType[receipt.type] ?? receipt.type,\n    };\n}\n//# sourceMappingURL=TransactionReceipt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvblJlY2VpcHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDQTtBQUNoQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQyxPQUFPLCtDQUErQztBQUN0RztBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILGdEQUFnRDtBQUN6SztBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0NBQStDO0FBQzVFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNENBQVcsUUFBUSxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnREFBZ0QsTUFBTSxnQ0FBZ0M7QUFDckc7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsY0FBYywrQ0FBYztBQUM1QjtBQUNBO0FBQ0EsY0FBYywrQ0FBYztBQUM1QjtBQUNBO0FBQ0EscUJBQXFCLCtDQUFjO0FBQ25DO0FBQ0EsMkJBQTJCLCtDQUFjO0FBQ3pDLDJCQUEyQiwrQ0FBYztBQUN6QztBQUNBLGlCQUFpQiwrQ0FBYztBQUMvQiwrQkFBK0IsMENBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uUmVjZWlwdC5qcz83ZTZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBMb2cgZnJvbSAnLi9Mb2cuanMnO1xuLyoqIFJQQyBzdGF0dXMgdG8gc3RhdHVzIG1hcHBpbmcuICovXG5leHBvcnQgY29uc3QgZnJvbVJwY1N0YXR1cyA9IHtcbiAgICAnMHgwJzogJ3JldmVydGVkJyxcbiAgICAnMHgxJzogJ3N1Y2Nlc3MnLFxufTtcbi8qKiBTdGF0dXMgdG8gUlBDIHN0YXR1cyBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IHRvUnBjU3RhdHVzID0ge1xuICAgIHJldmVydGVkOiAnMHgwJyxcbiAgICBzdWNjZXNzOiAnMHgxJyxcbn07XG4vKiogUlBDIHR5cGUgdG8gdHlwZSBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IGZyb21ScGNUeXBlID0ge1xuICAgICcweDAnOiAnbGVnYWN5JyxcbiAgICAnMHgxJzogJ2VpcDI5MzAnLFxuICAgICcweDInOiAnZWlwMTU1OScsXG4gICAgJzB4Myc6ICdlaXA0ODQ0JyxcbiAgICAnMHg0JzogJ2VpcDc3MDInLFxufTtcbi8qKiBUeXBlIHRvIFJQQyB0eXBlIG1hcHBpbmcuICovXG5leHBvcnQgY29uc3QgdG9ScGNUeXBlID0ge1xuICAgIGxlZ2FjeTogJzB4MCcsXG4gICAgZWlwMjkzMDogJzB4MScsXG4gICAgZWlwMTU1OTogJzB4MicsXG4gICAgZWlwNDg0NDogJzB4MycsXG4gICAgZWlwNzcwMjogJzB4NCcsXG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlY2VpcHQuUnBjfSB0byBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25SZWNlaXB0LlRyYW5zYWN0aW9uUmVjZWlwdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvblJlY2VpcHQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCByZWNlaXB0ID0gVHJhbnNhY3Rpb25SZWNlaXB0LmZyb21ScGMoe1xuICogICBibG9iR2FzUHJpY2U6ICcweDQyMDY5JyxcbiAqICAgYmxvYkdhc1VzZWQ6ICcweDEzMzcnLFxuICogICBibG9ja0hhc2g6XG4gKiAgICAgJzB4YzM1MGQ4MDc1MDVmYjgzNTY1MGYwMDEzNjMyYzU1MTU1OTI5ODdiYTE2OWJiYzY2MjZkOWZjNTRkOTFmMGYwYicsXG4gKiAgIGJsb2NrTnVtYmVyOiAnMHgxMmYyOTZmJyxcbiAqICAgY29udHJhY3RBZGRyZXNzOiBudWxsLFxuICogICBjdW11bGF0aXZlR2FzVXNlZDogJzB4ODI1MTUnLFxuICogICBlZmZlY3RpdmVHYXNQcmljZTogJzB4MjFjMmY2YzA5JyxcbiAqICAgZnJvbTogJzB4ODE0ZTVlMGUzMTAxNmI5YTdmMTM4Yzc2YjdlN2IyYmI1YzFhYjZhNicsXG4gKiAgIGdhc1VzZWQ6ICcweDJhYmJhJyxcbiAqICAgbG9nczogW10sXG4gKiAgIGxvZ3NCbG9vbTpcbiAqICAgICAnMHgwMDIwMDAwMDAwMDAwMDAwMDAwMDAwODA4MDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMjAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwODAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwODAyMDQwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMTAwMDAwMDA4MDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHN0YXR1czogJzB4MScsXG4gKiAgIHRvOiAnMHgzZmM5MWEzYWZkNzAzOTVjZDQ5NmM2NDdkNWE2Y2M5ZDRiMmI3ZmFkJyxcbiAqICAgdHJhbnNhY3Rpb25IYXNoOlxuICogICAgICcweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDAnLFxuICogICB0cmFuc2FjdGlvbkluZGV4OiAnMHgyJyxcbiAqICAgdHlwZTogJzB4MicsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBibG9iR2FzUHJpY2U6IDI3MDQ0MW4sXG4gKiAvLyBAbG9nOiAgIGJsb2JHYXNVc2VkOiA0OTE5bixcbiAqIC8vIEBsb2c6ICAgYmxvY2tIYXNoOiBcIjB4YzM1MGQ4MDc1MDVmYjgzNTY1MGYwMDEzNjMyYzU1MTU1OTI5ODdiYTE2OWJiYzY2MjZkOWZjNTRkOTFmMGYwYlwiLFxuICogLy8gQGxvZzogICBibG9ja051bWJlcjogMTk4NjgwMTVuLFxuICogLy8gQGxvZzogICBjb250cmFjdEFkZHJlc3M6IG51bGwsXG4gKiAvLyBAbG9nOiAgIGN1bXVsYXRpdmVHYXNVc2VkOiA1MzM3ODFuLFxuICogLy8gQGxvZzogICBlZmZlY3RpdmVHYXNQcmljZTogOTA2MjgwNDQ4OW4sXG4gKiAvLyBAbG9nOiAgIGZyb206IFwiMHg4MTRlNWUwZTMxMDE2YjlhN2YxMzhjNzZiN2U3YjJiYjVjMWFiNmE2XCIsXG4gKiAvLyBAbG9nOiAgIGdhc1VzZWQ6IDE3NTAzNG4sXG4gKiAvLyBAbG9nOiAgIGxvZ3M6IFtdLFxuICogLy8gQGxvZzogICBsb2dzQmxvb206IFwiMHgwMDIwMDAwMDAwMDAwMDAwMDAwMDAwODA4MDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMjAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwODAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwODAyMDQwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMTAwMDAwMDA4MDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICogLy8gQGxvZzogICByb290OiB1bmRlZmluZWQsXG4gKiAvLyBAbG9nOiAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gKiAvLyBAbG9nOiAgIHRvOiBcIjB4M2ZjOTFhM2FmZDcwMzk1Y2Q0OTZjNjQ3ZDVhNmNjOWQ0YjJiN2ZhZFwiLFxuICogLy8gQGxvZzogICB0cmFuc2FjdGlvbkhhc2g6IFwiMHgzNTNmZGZjMzhhMmYyNjExNWRhYWRlZTlmNWI4MzkyY2U2MmI4NGY0MTA5NTc5NjdlMmVkNTZiMzUzMzhjZGQwXCIsXG4gKiAvLyBAbG9nOiAgIHRyYW5zYWN0aW9uSW5kZXg6IDIsXG4gKiAvLyBAbG9nOiAgIHR5cGU6IFwiZWlwMTU1OVwiLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmQtdG8tZW5kXG4gKlxuICogQmVsb3cgaXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gdXNlIHRoZSBgVHJhbnNhY3Rpb25SZWNlaXB0LmZyb21ScGNgIG1ldGhvZCB0byBjb252ZXJ0IGFuIFJQQyB0cmFuc2FjdGlvbiByZWNlaXB0IHRvIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uUmVjZWlwdC5UcmFuc2FjdGlvblJlY2VpcHR9IG9iamVjdC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvblJlY2VpcHQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2luZG93LmV0aGVyZXVtIVxuICogICAucmVxdWVzdCh7XG4gKiAgICAgbWV0aG9kOiAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG4gKiAgICAgcGFyYW1zOiBbXG4gKiAgICAgICAnMHgzNTNmZGZjMzhhMmYyNjExNWRhYWRlZTlmNWI4MzkyY2U2MmI4NGY0MTA5NTc5NjdlMmVkNTZiMzUzMzhjZGQwJyxcbiAqICAgICBdLFxuICogICB9KVxuICogICAudGhlbihUcmFuc2FjdGlvblJlY2VpcHQuZnJvbVJwYykgLy8gWyFjb2RlIGhsXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBibG9iR2FzUHJpY2U6IDI3MDQ0MW4sXG4gKiAvLyBAbG9nOiAgIGJsb2JHYXNVc2VkOiA0OTE5bixcbiAqIC8vIEBsb2c6ICAgYmxvY2tIYXNoOiBcIjB4YzM1MGQ4MDc1MDVmYjgzNTY1MGYwMDEzNjMyYzU1MTU1OTI5ODdiYTE2OWJiYzY2MjZkOWZjNTRkOTFmMGYwYlwiLFxuICogLy8gQGxvZzogICBibG9ja051bWJlcjogMTk4NjgwMTVuLFxuICogLy8gQGxvZzogICBjb250cmFjdEFkZHJlc3M6IG51bGwsXG4gKiAvLyBAbG9nOiAgIGN1bXVsYXRpdmVHYXNVc2VkOiA1MzM3ODFuLFxuICogLy8gQGxvZzogICBlZmZlY3RpdmVHYXNQcmljZTogOTA2MjgwNDQ4OW4sXG4gKiAvLyBAbG9nOiAgIGZyb206IFwiMHg4MTRlNWUwZTMxMDE2YjlhN2YxMzhjNzZiN2U3YjJiYjVjMWFiNmE2XCIsXG4gKiAvLyBAbG9nOiAgIGdhc1VzZWQ6IDE3NTAzNG4sXG4gKiAvLyBAbG9nOiAgIGxvZ3M6IFtdLFxuICogLy8gQGxvZzogICBsb2dzQmxvb206IFwiMHgwMDIwMDAwMDAwMDAwMDAwMDAwMDAwODA4MDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMjAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwODAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwODAyMDQwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMTAwMDAwMDA4MDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICogLy8gQGxvZzogICByb290OiB1bmRlZmluZWQsXG4gKiAvLyBAbG9nOiAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gKiAvLyBAbG9nOiAgIHRvOiBcIjB4M2ZjOTFhM2FmZDcwMzk1Y2Q0OTZjNjQ3ZDVhNmNjOWQ0YjJiN2ZhZFwiLFxuICogLy8gQGxvZzogICB0cmFuc2FjdGlvbkhhc2g6IFwiMHgzNTNmZGZjMzhhMmYyNjExNWRhYWRlZTlmNWI4MzkyY2U2MmI4NGY0MTA5NTc5NjdlMmVkNTZiMzUzMzhjZGQwXCIsXG4gKiAvLyBAbG9nOiAgIHRyYW5zYWN0aW9uSW5kZXg6IDIsXG4gKiAvLyBAbG9nOiAgIHR5cGU6IFwiZWlwMTU1OVwiLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogOjo6bm90ZVxuICpcbiAqIEZvciBzaW1wbGljaXR5LCB0aGUgYWJvdmUgZXhhbXBsZSB1c2VzIGB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdGAsIGJ1dCB5b3UgY2FuIHVzZSBhbnlcbiAqIHR5cGUgb2YgSlNPTi1SUEMgaW50ZXJmYWNlLlxuICpcbiAqIDo6OlxuICpcbiAqIEBwYXJhbSByZWNlaXB0IC0gVGhlIFJQQyByZWNlaXB0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1RyYW5zYWN0aW9uUmVjZWlwdC5UcmFuc2FjdGlvblJlY2VpcHR9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhyZWNlaXB0KSB7XG4gICAgaWYgKCFyZWNlaXB0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZWNlaXB0LFxuICAgICAgICBibG9iR2FzUHJpY2U6IHJlY2VpcHQuYmxvYkdhc1ByaWNlXG4gICAgICAgICAgICA/IEJpZ0ludChyZWNlaXB0LmJsb2JHYXNQcmljZSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBibG9iR2FzVXNlZDogcmVjZWlwdC5ibG9iR2FzVXNlZCA/IEJpZ0ludChyZWNlaXB0LmJsb2JHYXNVc2VkKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgYmxvY2tOdW1iZXI6IEJpZ0ludChyZWNlaXB0LmJsb2NrTnVtYmVyID8/IDBuKSxcbiAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IEJpZ0ludChyZWNlaXB0LmN1bXVsYXRpdmVHYXNVc2VkID8/IDBuKSxcbiAgICAgICAgZWZmZWN0aXZlR2FzUHJpY2U6IEJpZ0ludChyZWNlaXB0LmVmZmVjdGl2ZUdhc1ByaWNlID8/IDBuKSxcbiAgICAgICAgZ2FzVXNlZDogQmlnSW50KHJlY2VpcHQuZ2FzVXNlZCA/PyAwbiksXG4gICAgICAgIGxvZ3M6IHJlY2VpcHQubG9ncy5tYXAoKGxvZykgPT4gTG9nLmZyb21ScGMobG9nLCB7IHBlbmRpbmc6IGZhbHNlIH0pKSxcbiAgICAgICAgc3RhdHVzOiBmcm9tUnBjU3RhdHVzW3JlY2VpcHQuc3RhdHVzXSxcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogTnVtYmVyKHJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCA/PyAwKSxcbiAgICAgICAgdHlwZTogZnJvbVJwY1R5cGVbcmVjZWlwdC50eXBlXSB8fCByZWNlaXB0LnR5cGUsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25SZWNlaXB0LlRyYW5zYWN0aW9uUmVjZWlwdH0gdG8gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25SZWNlaXB0LlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvblJlY2VpcHQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCByZWNlaXB0ID0gVHJhbnNhY3Rpb25SZWNlaXB0LnRvUnBjKHtcbiAqICAgYmxvYkdhc1ByaWNlOiAyNzA0NDFuLFxuICogICBibG9iR2FzVXNlZDogNDkxOW4sXG4gKiAgIGJsb2NrSGFzaDpcbiAqICAgICAnMHhjMzUwZDgwNzUwNWZiODM1NjUwZjAwMTM2MzJjNTUxNTU5Mjk4N2JhMTY5YmJjNjYyNmQ5ZmM1NGQ5MWYwZjBiJyxcbiAqICAgYmxvY2tOdW1iZXI6IDE5ODY4MDE1bixcbiAqICAgY29udHJhY3RBZGRyZXNzOiBudWxsLFxuICogICBjdW11bGF0aXZlR2FzVXNlZDogNTMzNzgxbixcbiAqICAgZWZmZWN0aXZlR2FzUHJpY2U6IDkwNjI4MDQ0ODluLFxuICogICBmcm9tOiAnMHg4MTRlNWUwZTMxMDE2YjlhN2YxMzhjNzZiN2U3YjJiYjVjMWFiNmE2JyxcbiAqICAgZ2FzVXNlZDogMTc1MDM0bixcbiAqICAgbG9nczogW10sXG4gKiAgIGxvZ3NCbG9vbTpcbiAqICAgICAnMHgwMDIwMDAwMDAwMDAwMDAwMDAwMDAwODA4MDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMjAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwODAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwODAyMDQwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMTAwMDAwMDA4MDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHJvb3Q6IHVuZGVmaW5lZCxcbiAqICAgc3RhdHVzOiAnc3VjY2VzcycsXG4gKiAgIHRvOiAnMHgzZmM5MWEzYWZkNzAzOTVjZDQ5NmM2NDdkNWE2Y2M5ZDRiMmI3ZmFkJyxcbiAqICAgdHJhbnNhY3Rpb25IYXNoOlxuICogICAgICcweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDAnLFxuICogICB0cmFuc2FjdGlvbkluZGV4OiAyLFxuICogICB0eXBlOiAnZWlwMTU1OScsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBibG9iR2FzUHJpY2U6IFwiMHgwNDIwNjlcIixcbiAqIC8vIEBsb2c6ICAgYmxvYkdhc1VzZWQ6IFwiMHgxMzM3XCIsXG4gKiAvLyBAbG9nOiAgIGJsb2NrSGFzaDogXCIweGMzNTBkODA3NTA1ZmI4MzU2NTBmMDAxMzYzMmM1NTE1NTkyOTg3YmExNjliYmM2NjI2ZDlmYzU0ZDkxZjBmMGJcIixcbiAqIC8vIEBsb2c6ICAgYmxvY2tOdW1iZXI6IFwiMHgwMTJmMjk2ZlwiLFxuICogLy8gQGxvZzogICBjb250cmFjdEFkZHJlc3M6IG51bGwsXG4gKiAvLyBAbG9nOiAgIGN1bXVsYXRpdmVHYXNVc2VkOiBcIjB4MDgyNTE1XCIsXG4gKiAvLyBAbG9nOiAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBcIjB4MDIxYzJmNmMwOVwiLFxuICogLy8gQGxvZzogICBmcm9tOiBcIjB4ODE0ZTVlMGUzMTAxNmI5YTdmMTM4Yzc2YjdlN2IyYmI1YzFhYjZhNlwiLFxuICogLy8gQGxvZzogICBnYXNVc2VkOiBcIjB4MDJhYmJhXCIsXG4gKiAvLyBAbG9nOiAgIGxvZ3M6IFtdLFxuICogLy8gQGxvZzogICBsb2dzQmxvb206IFwiMHgwMDIwMDAwMDAwMDAwMDAwMDAwMDAwODA4MDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMjAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwODAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwODAyMDQwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMTAwMDAwMDA4MDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICogLy8gQGxvZzogICByb290OiB1bmRlZmluZWQsXG4gKiAvLyBAbG9nOiAgIHN0YXR1czogXCIweDFcIixcbiAqIC8vIEBsb2c6ICAgdG86IFwiMHgzZmM5MWEzYWZkNzAzOTVjZDQ5NmM2NDdkNWE2Y2M5ZDRiMmI3ZmFkXCIsXG4gKiAvLyBAbG9nOiAgIHRyYW5zYWN0aW9uSGFzaDogXCIweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDBcIixcbiAqIC8vIEBsb2c6ICAgdHJhbnNhY3Rpb25JbmRleDogXCIweDAyXCIsXG4gKiAvLyBAbG9nOiAgIHR5cGU6IFwiZWlwMTU1OVwiLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHJlY2VpcHQgLSBUaGUgcmVjZWlwdCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gUlBDIHJlY2VpcHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhyZWNlaXB0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmxvYkdhc1ByaWNlOiByZWNlaXB0LmJsb2JHYXNQcmljZVxuICAgICAgICAgICAgPyBIZXguZnJvbU51bWJlcihyZWNlaXB0LmJsb2JHYXNQcmljZSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBibG9iR2FzVXNlZDogcmVjZWlwdC5ibG9iR2FzVXNlZFxuICAgICAgICAgICAgPyBIZXguZnJvbU51bWJlcihyZWNlaXB0LmJsb2JHYXNVc2VkKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGJsb2NrSGFzaDogcmVjZWlwdC5ibG9ja0hhc2gsXG4gICAgICAgIGJsb2NrTnVtYmVyOiBIZXguZnJvbU51bWJlcihyZWNlaXB0LmJsb2NrTnVtYmVyKSxcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiByZWNlaXB0LmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IEhleC5mcm9tTnVtYmVyKHJlY2VpcHQuY3VtdWxhdGl2ZUdhc1VzZWQpLFxuICAgICAgICBlZmZlY3RpdmVHYXNQcmljZTogSGV4LmZyb21OdW1iZXIocmVjZWlwdC5lZmZlY3RpdmVHYXNQcmljZSksXG4gICAgICAgIGZyb206IHJlY2VpcHQuZnJvbSxcbiAgICAgICAgZ2FzVXNlZDogSGV4LmZyb21OdW1iZXIocmVjZWlwdC5nYXNVc2VkKSxcbiAgICAgICAgbG9nczogcmVjZWlwdC5sb2dzLm1hcChMb2cudG9ScGMpLFxuICAgICAgICBsb2dzQmxvb206IHJlY2VpcHQubG9nc0Jsb29tLFxuICAgICAgICByb290OiByZWNlaXB0LnJvb3QsXG4gICAgICAgIHN0YXR1czogdG9ScGNTdGF0dXNbcmVjZWlwdC5zdGF0dXNdLFxuICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiByZWNlaXB0LnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogSGV4LmZyb21OdW1iZXIocmVjZWlwdC50cmFuc2FjdGlvbkluZGV4KSxcbiAgICAgICAgdHlwZTogdG9ScGNUeXBlW3JlY2VpcHQudHlwZV0gPz8gcmVjZWlwdC50eXBlLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvblJlY2VpcHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TransactionReceipt.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TransactionRequest.js":
/*!**********************************************************!*\
  !*** ../node_modules/ox/_esm/core/TransactionRequest.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Authorization.js */ \"../node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n/**\n * Converts a {@link ox#TransactionRequest.TransactionRequest} to a {@link ox#TransactionRequest.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionRequest, Value } from 'ox'\n *\n * const request = TransactionRequest.toRpc({\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('0.01'),\n * })\n * ```\n *\n * @example\n * ### Using with a Provider\n *\n * You can use {@link ox#Provider.(from:function)} to instantiate an EIP-1193 Provider and\n * send a transaction to the Wallet using the `eth_sendTransaction` method.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionRequest, Value } from 'ox'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('0.01'),\n * })\n *\n * const hash = await provider.request({ // [!code focus]\n *   method: 'eth_sendTransaction', // [!code focus]\n *   params: [request], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param request - The request to convert.\n * @returns An RPC request.\n */\nfunction toRpc(request) {\n    const request_rpc = {};\n    if (typeof request.accessList !== 'undefined')\n        request_rpc.accessList = request.accessList;\n    if (typeof request.authorizationList !== 'undefined')\n        request_rpc.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_0__.toRpcList(request.authorizationList);\n    if (typeof request.blobVersionedHashes !== 'undefined')\n        request_rpc.blobVersionedHashes = request.blobVersionedHashes;\n    if (typeof request.blobs !== 'undefined')\n        request_rpc.blobs = request.blobs;\n    if (typeof request.chainId !== 'undefined')\n        request_rpc.chainId = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.chainId);\n    if (typeof request.data !== 'undefined') {\n        request_rpc.data = request.data;\n        request_rpc.input = request.data;\n    }\n    else if (typeof request.input !== 'undefined') {\n        request_rpc.data = request.input;\n        request_rpc.input = request.input;\n    }\n    if (typeof request.from !== 'undefined')\n        request_rpc.from = request.from;\n    if (typeof request.gas !== 'undefined')\n        request_rpc.gas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.gas);\n    if (typeof request.gasPrice !== 'undefined')\n        request_rpc.gasPrice = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.gasPrice);\n    if (typeof request.maxFeePerBlobGas !== 'undefined')\n        request_rpc.maxFeePerBlobGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxFeePerBlobGas);\n    if (typeof request.maxFeePerGas !== 'undefined')\n        request_rpc.maxFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== 'undefined')\n        request_rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxPriorityFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== 'undefined')\n        request_rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxPriorityFeePerGas);\n    if (typeof request.nonce !== 'undefined')\n        request_rpc.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.nonce);\n    if (typeof request.to !== 'undefined')\n        request_rpc.to = request.to;\n    if (typeof request.type !== 'undefined')\n        request_rpc.type = request.type;\n    if (typeof request.value !== 'undefined')\n        request_rpc.value = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.value);\n    return request_rpc;\n}\n//# sourceMappingURL=TransactionRequest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvblJlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9EO0FBQ3BCO0FBQ2hDO0FBQ0EsZUFBZSxnREFBZ0QsTUFBTSxnQ0FBZ0M7QUFDckc7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3REFBdUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFjO0FBQ3hDO0FBQ0EsK0JBQStCLCtDQUFjO0FBQzdDO0FBQ0EsdUNBQXVDLCtDQUFjO0FBQ3JEO0FBQ0EsbUNBQW1DLCtDQUFjO0FBQ2pEO0FBQ0EsMkNBQTJDLCtDQUFjO0FBQ3pEO0FBQ0EsMkNBQTJDLCtDQUFjO0FBQ3pEO0FBQ0EsNEJBQTRCLCtDQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQWM7QUFDMUM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25SZXF1ZXN0LmpzP2M2OTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvbiBmcm9tICcuL0F1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25SZXF1ZXN0LlRyYW5zYWN0aW9uUmVxdWVzdH0gdG8gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25SZXF1ZXN0LlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvblJlcXVlc3QsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFRyYW5zYWN0aW9uUmVxdWVzdC50b1JwYyh7XG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMC4wMScpLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVXNpbmcgd2l0aCBhIFByb3ZpZGVyXG4gKlxuICogWW91IGNhbiB1c2Uge0BsaW5rIG94I1Byb3ZpZGVyLihmcm9tOmZ1bmN0aW9uKX0gdG8gaW5zdGFudGlhdGUgYW4gRUlQLTExOTMgUHJvdmlkZXIgYW5kXG4gKiBzZW5kIGEgdHJhbnNhY3Rpb24gdG8gdGhlIFdhbGxldCB1c2luZyB0aGUgYGV0aF9zZW5kVHJhbnNhY3Rpb25gIG1ldGhvZC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBQcm92aWRlciwgVHJhbnNhY3Rpb25SZXF1ZXN0LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByb3ZpZGVyID0gUHJvdmlkZXIuZnJvbSh3aW5kb3cuZXRoZXJldW0hKVxuICpcbiAqIGNvbnN0IHJlcXVlc3QgPSBUcmFuc2FjdGlvblJlcXVlc3QudG9ScGMoe1xuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzAuMDEnKSxcbiAqIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBhcmFtczogW3JlcXVlc3RdLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXF1ZXN0X3JwYyA9IHt9O1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5hY2Nlc3NMaXN0ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMuYWNjZXNzTGlzdCA9IHJlcXVlc3QuYWNjZXNzTGlzdDtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuYXV0aG9yaXphdGlvbkxpc3QgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5hdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24udG9ScGNMaXN0KHJlcXVlc3QuYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5ibG9iVmVyc2lvbmVkSGFzaGVzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHJlcXVlc3QuYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuYmxvYnMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5ibG9icyA9IHJlcXVlc3QuYmxvYnM7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmNoYWluSWQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5jaGFpbklkID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5jaGFpbklkKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVxdWVzdF9ycGMuZGF0YSA9IHJlcXVlc3QuZGF0YTtcbiAgICAgICAgcmVxdWVzdF9ycGMuaW5wdXQgPSByZXF1ZXN0LmRhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0LmlucHV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXF1ZXN0X3JwYy5kYXRhID0gcmVxdWVzdC5pbnB1dDtcbiAgICAgICAgcmVxdWVzdF9ycGMuaW5wdXQgPSByZXF1ZXN0LmlucHV0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZnJvbSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmZyb20gPSByZXF1ZXN0LmZyb207XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmdhcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmdhcyA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3QuZ2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZ2FzUHJpY2UgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5nYXNQcmljZSA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3QuZ2FzUHJpY2UpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5tYXhGZWVQZXJCbG9iR2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMubWF4RmVlUGVyQmxvYkdhcyA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3QubWF4RmVlUGVyQmxvYkdhcyk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0Lm1heEZlZVBlckdhcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLm1heEZlZVBlckdhcyA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3QubWF4RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3QubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLm1heFByaW9yaXR5RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0Lm5vbmNlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMubm9uY2UgPSBIZXguZnJvbU51bWJlcihyZXF1ZXN0Lm5vbmNlKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QudG8gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy50byA9IHJlcXVlc3QudG87XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LnR5cGUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy50eXBlID0gcmVxdWVzdC50eXBlO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLnZhbHVlID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC52YWx1ZSk7XG4gICAgcmV0dXJuIHJlcXVlc3RfcnBjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25SZXF1ZXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TransactionRequest.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/TypedData.js":
/*!*************************************************!*\
  !*** ../node_modules/ox/_esm/core/TypedData.js ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesSizeMismatchError: () => (/* binding */ BytesSizeMismatchError),\n/* harmony export */   InvalidDomainError: () => (/* binding */ InvalidDomainError),\n/* harmony export */   InvalidPrimaryTypeError: () => (/* binding */ InvalidPrimaryTypeError),\n/* harmony export */   InvalidStructTypeError: () => (/* binding */ InvalidStructTypeError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   domainSeparator: () => (/* binding */ domainSeparator),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeData: () => (/* binding */ encodeData),\n/* harmony export */   encodeField: () => (/* binding */ encodeField),\n/* harmony export */   encodeType: () => (/* binding */ encodeType),\n/* harmony export */   extractEip712DomainTypes: () => (/* binding */ extractEip712DomainTypes),\n/* harmony export */   findTypeDependencies: () => (/* binding */ findTypeDependencies),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hashDomain: () => (/* binding */ hashDomain),\n/* harmony export */   hashStruct: () => (/* binding */ hashStruct),\n/* harmony export */   hashType: () => (/* binding */ hashType),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AbiParameters.js */ \"../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Json.js */ \"../node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"../node_modules/ox/_esm/core/Solidity.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__]);\n_AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n\n/**\n * Asserts that [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.assert({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nfunction assert(value) {\n    const { domain, message, primaryType, types } = value;\n    const validateData = (struct, data) => {\n        for (const param of struct) {\n            const { name, type } = param;\n            const value = data[name];\n            const integerMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_0__.integerRegex);\n            if (integerMatch &&\n                (typeof value === 'number' || typeof value === 'bigint')) {\n                const [, base, size_] = integerMatch;\n                // If number cannot be cast to a sized hex value, it is out of range\n                // and will throw.\n                _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(value, {\n                    signed: base === 'int',\n                    size: Number.parseInt(size_ ?? '') / 8,\n                });\n            }\n            if (type === 'address' &&\n                typeof value === 'string' &&\n                !_Address_js__WEBPACK_IMPORTED_MODULE_2__.validate(value))\n                throw new _Address_js__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError({\n                    address: value,\n                    cause: new _Address_js__WEBPACK_IMPORTED_MODULE_2__.InvalidInputError(),\n                });\n            const bytesMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_0__.bytesRegex);\n            if (bytesMatch) {\n                const [, size] = bytesMatch;\n                if (size && _Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(value) !== Number.parseInt(size))\n                    throw new BytesSizeMismatchError({\n                        expectedSize: Number.parseInt(size),\n                        givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(value),\n                    });\n            }\n            const struct = types[type];\n            if (struct) {\n                validateReference(type);\n                validateData(struct, value);\n            }\n        }\n    };\n    // Validate domain types.\n    if (types.EIP712Domain && domain) {\n        if (typeof domain !== 'object')\n            throw new InvalidDomainError({ domain });\n        validateData(types.EIP712Domain, domain);\n    }\n    // Validate message types.\n    if (primaryType !== 'EIP712Domain') {\n        if (types[primaryType])\n            validateData(types[primaryType], message);\n        else\n            throw new InvalidPrimaryTypeError({ primaryType, types });\n    }\n}\n/**\n * Creates [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator) for the provided domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.domainSeparator({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: '0x9911ee4f58a7059a8f5385248040e6984d80e2c849500fe6a4d11c4fa98c2af3'\n * ```\n *\n * @param domain - The domain for which to create the domain separator.\n * @returns The domain separator.\n */\nfunction domainSeparator(domain) {\n    return hashDomain({\n        domain,\n    });\n}\n/**\n * Encodes typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `0x19  0x01  domainSeparator  hashStruct(message)`.\n *\n * @example\n * ```ts twoslash\n * import { TypedData, Hash } from 'ox'\n *\n * const data = TypedData.encode({ // [!code focus:33]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n * // @log: '0x19012fdf3441fcaf4f30c7e16292b258a5d7054a4e2e00dbd7b7d2f467f2b8fb9413c52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e'\n * // @log: (0x19  0x01  domainSeparator  hashStruct(message))\n *\n * const hash = Hash.keccak256(data)\n * ```\n *\n * @param value - The Typed Data to encode.\n * @returns The encoded Typed Data.\n */\nfunction encode(value) {\n    const { domain = {}, message, primaryType } = value;\n    const types = {\n        EIP712Domain: extractEip712DomainTypes(domain),\n        ...value.types,\n    };\n    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n    // as we can't statically check this with TypeScript.\n    assert({\n        domain,\n        message,\n        primaryType,\n        types,\n    });\n    // Typed Data Format: `0x19  0x01  domainSeparator  hashStruct(message)`\n    const parts = ['0x19', '0x01'];\n    if (domain)\n        parts.push(hashDomain({\n            domain,\n            types,\n        }));\n    if (primaryType !== 'EIP712Domain')\n        parts.push(hashStruct({\n            data: message,\n            primaryType,\n            types,\n        }));\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(...parts);\n}\n/**\n * Encodes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for the provided primaryType.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.encodeType({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n * })\n * // @log: 'Foo(address address,string name,string foo)'\n * ```\n *\n * @param value - The Typed Data schema.\n * @returns The encoded type.\n */\nfunction encodeType(value) {\n    const { primaryType, types } = value;\n    let result = '';\n    const unsortedDeps = findTypeDependencies({ primaryType, types });\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        result += `${type}(${(types[type] ?? [])\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(',')})`;\n    }\n    return result;\n}\n/**\n * Gets [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for EIP-721 domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.extractEip712DomainTypes({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: [\n * // @log:   { 'name': 'name', 'type': 'string' },\n * // @log:   { 'name': 'version', 'type': 'string' },\n * // @log:   { 'name': 'chainId', 'type': 'uint256' },\n * // @log:   { 'name': 'verifyingContract', 'type': 'address' },\n * // @log: ]\n * ```\n *\n * @param domain - The EIP-712 domain.\n * @returns The EIP-712 domain schema.\n */\nfunction extractEip712DomainTypes(domain) {\n    return [\n        typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n        domain?.version && { name: 'version', type: 'string' },\n        typeof domain?.chainId === 'number' && {\n            name: 'chainId',\n            type: 'uint256',\n        },\n        domain?.verifyingContract && {\n            name: 'verifyingContract',\n            type: 'address',\n        },\n        domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean);\n}\n/**\n * Gets the payload to use for signing typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The typed data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nfunction getSignPayload(value) {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(encode(value));\n}\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashDomain({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n * })\n * // @log: '0x6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1'\n * ```\n *\n * @param value - The Typed Data domain and types.\n * @returns The hashed domain.\n */\nfunction hashDomain(value) {\n    const { domain, types } = value;\n    return hashStruct({\n        data: domain,\n        primaryType: 'EIP712Domain',\n        types: {\n            ...types,\n            EIP712Domain: types?.EIP712Domain || extractEip712DomainTypes(domain),\n        },\n    });\n}\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) struct.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashStruct({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n *   data: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: '0x996fb3b6d48c50312d69abdd4c1b6fb02057c85aa86bb8d04c6f023326a168ce'\n * ```\n *\n * @param value - The Typed Data struct to hash.\n * @returns The hashed Typed Data struct.\n */\nfunction hashStruct(value) {\n    const { data, primaryType, types } = value;\n    const encoded = encodeData({\n        data,\n        primaryType,\n        types,\n    });\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(encoded);\n}\n/**\n * Serializes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema into string.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.serialize({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: \"{\"domain\":{},\"message\":{\"address\":\"0xb9cab4f0e46f7f6b1024b5a7463734fa68e633f9\",\"name\":\"jxom\",\"foo\":\"0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9\"},\"primaryType\":\"Foo\",\"types\":{\"Foo\":[{\"name\":\"address\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"foo\",\"type\":\"string\"}]}}\"\n * ```\n *\n * @param value - The Typed Data schema to serialize.\n * @returns The serialized Typed Data schema. w\n */\nfunction serialize(value) {\n    const { domain: domain_, message: message_, primaryType, types, } = value;\n    const normalizeData = (struct, value) => {\n        const data = { ...value };\n        for (const param of struct) {\n            const { name, type } = param;\n            if (type === 'address')\n                data[name] = data[name].toLowerCase();\n        }\n        return data;\n    };\n    const domain = (() => {\n        if (!domain_)\n            return {};\n        const type = types.EIP712Domain ?? extractEip712DomainTypes(domain_);\n        return normalizeData(type, domain_);\n    })();\n    const message = (() => {\n        if (primaryType === 'EIP712Domain')\n            return undefined;\n        if (!types[primaryType])\n            return {};\n        return normalizeData(types[primaryType], message_);\n    })();\n    return _Json_js__WEBPACK_IMPORTED_MODULE_4__.stringify({ domain, message, primaryType, types }, (_, value) => {\n        if (typeof value === 'bigint')\n            return value.toString();\n        return value;\n    });\n}\n/**\n * Checks if [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * const valid = TypedData.validate({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: true\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the bytes size of a typed data value does not match the expected size. */\nclass BytesSizeMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ expectedSize, givenSize, }) {\n        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TypedData.BytesSizeMismatchError'\n        });\n    }\n}\n/** Thrown when the domain is invalid. */\nclass InvalidDomainError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ domain }) {\n        super(`Invalid domain \"${_Json_js__WEBPACK_IMPORTED_MODULE_4__.stringify(domain)}\".`, {\n            metaMessages: ['Must be a valid EIP-712 domain.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TypedData.InvalidDomainError'\n        });\n    }\n}\n/** Thrown when the primary type of a typed data value is invalid. */\nclass InvalidPrimaryTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ primaryType, types, }) {\n        super(`Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`, {\n            metaMessages: ['Check that the primary type is a key in `types`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TypedData.InvalidPrimaryTypeError'\n        });\n    }\n}\n/** Thrown when the struct type is not a valid type. */\nclass InvalidStructTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ type }) {\n        super(`Struct type \"${type}\" is invalid.`, {\n            metaMessages: ['Struct type must not be a Solidity type.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TypedData.InvalidStructTypeError'\n        });\n    }\n}\n/** @internal */\nfunction encodeData(value) {\n    const { data, primaryType, types } = value;\n    const encodedTypes = [{ type: 'bytes32' }];\n    const encodedValues = [hashType({ primaryType, types })];\n    for (const field of types[primaryType] ?? []) {\n        const [type, value] = encodeField({\n            types,\n            name: field.name,\n            type: field.type,\n            value: data[field.name],\n        });\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__.encode(encodedTypes, encodedValues);\n}\n/** @internal */\nfunction hashType(value) {\n    const { primaryType, types } = value;\n    const encodedHashType = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(encodeType({ primaryType, types }));\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(encodedHashType);\n}\n/** @internal */\nfunction encodeField(properties) {\n    let { types, name, type, value } = properties;\n    if (types[type] !== undefined)\n        return [\n            { type: 'bytes32' },\n            _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(encodeData({ data: value, primaryType: type, types })),\n        ];\n    if (type === 'bytes') {\n        const prepend = value.length % 2 ? '0' : '';\n        value = `0x${prepend + value.slice(2)}`;\n        return [{ type: 'bytes32' }, _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(value, { as: 'Hex' })];\n    }\n    if (type === 'string')\n        return [\n            { type: 'bytes32' },\n            _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_7__.fromString(value), { as: 'Hex' }),\n        ];\n    if (type.lastIndexOf(']') === type.length - 1) {\n        const parsedType = type.slice(0, type.lastIndexOf('['));\n        const typeValuePairs = value.map((item) => encodeField({\n            name,\n            type: parsedType,\n            types,\n            value: item,\n        }));\n        return [\n            { type: 'bytes32' },\n            _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__.encode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),\n        ];\n    }\n    return [{ type }, value];\n}\n/** @internal */\nfunction findTypeDependencies(value, results = new Set()) {\n    const { primaryType: primaryType_, types } = value;\n    const match = primaryType_.match(/^\\w*/u);\n    const primaryType = match?.[0];\n    if (results.has(primaryType) || types[primaryType] === undefined)\n        return results;\n    results.add(primaryType);\n    for (const field of types[primaryType])\n        findTypeDependencies({ primaryType: field.type, types }, results);\n    return results;\n}\n/** @internal */\nfunction validateReference(type) {\n    // Struct type must not be a Solidity type.\n    if (type === 'address' ||\n        type === 'bool' ||\n        type === 'string' ||\n        type.startsWith('bytes') ||\n        type.startsWith('uint') ||\n        type.startsWith('int'))\n        throw new InvalidStructTypeError({ type });\n}\n//# sourceMappingURL=TypedData.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UeXBlZERhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWjtBQUNKO0FBQ0U7QUFDSjtBQUNGO0FBQ0U7QUFDUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDLFdBQVcsOEJBQThCO0FBQ3pDLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EsNENBQTRDLHNEQUFxQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlEQUFnQjtBQUNqQywwQkFBMEIsNERBQTJCO0FBQ3JEO0FBQ0EsK0JBQStCLDBEQUF5QjtBQUN4RCxpQkFBaUI7QUFDakIsMENBQTBDLG9EQUFtQjtBQUM3RDtBQUNBO0FBQ0EsNEJBQTRCLHlDQUFRO0FBQ3BDO0FBQ0E7QUFDQSxtQ0FBbUMseUNBQVE7QUFDM0MscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNB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QW9CO0FBQy9CO0FBQ0E7QUFDTztBQUNQLFlBQVkscUJBQXFCO0FBQ2pDLDRCQUE0QiwrQ0FBYyxjQUFjLG9CQUFvQjtBQUM1RSxXQUFXLCtDQUFjO0FBQ3pCO0FBQ0E7QUFDTztBQUNQLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixZQUFZLCtDQUFjLGNBQWMsdUNBQXVDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUMsa0JBQWtCLGlCQUFpQixFQUFFLCtDQUFjLFVBQVUsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixZQUFZLCtDQUFjLENBQUMsaURBQWdCLFdBQVcsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsWUFBWSwrQ0FBYyxDQUFDLHFEQUFvQjtBQUMvQztBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDTztBQUNQLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0EscUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UeXBlZERhdGEuanM/NmM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4vQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBbRUlQLTcxMiBUeXBlZCBEYXRhXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMikgaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeXBlZERhdGEgfSBmcm9tICdveCdcbiAqXG4gKiBUeXBlZERhdGEuYXNzZXJ0KHtcbiAqICAgZG9tYWluOiB7XG4gKiAgICAgbmFtZTogJ0V0aGVyIScsXG4gKiAgICAgdmVyc2lvbjogJzEnLFxuICogICAgIGNoYWluSWQ6IDEsXG4gKiAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6ICcweENjQ0NjY2NjQ0NDQ2NDQ0NDQ0NjQ2NDY2NDY0NDQ2NDY2NjY2NjY0MnLFxuICogICB9LFxuICogICBwcmltYXJ5VHlwZTogJ0ZvbycsXG4gKiAgIHR5cGVzOiB7XG4gKiAgICAgRm9vOiBbXG4gKiAgICAgICB7IG5hbWU6ICdhZGRyZXNzJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gKiAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ3N0cmluZycgfSxcbiAqICAgICAgIHsgbmFtZTogJ2ZvbycsIHR5cGU6ICdzdHJpbmcnIH0sXG4gKiAgICAgXSxcbiAqICAgfSxcbiAqICAgbWVzc2FnZToge1xuICogICAgIGFkZHJlc3M6ICcweGI5Q0FCNEYwRTQ2RjdGNmIxMDI0YjVBNzQ2MzczNGZhNjhFNjMzZjknLFxuICogICAgIG5hbWU6ICdqeG9tJyxcbiAqICAgICBmb286ICcweGI5Q0FCNEYwRTQ2RjdGNmIxMDI0YjVBNzQ2MzczNGZhNjhFNjMzZjknLFxuICogICB9LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBUeXBlZCBEYXRhIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgY29uc3QgeyBkb21haW4sIG1lc3NhZ2UsIHByaW1hcnlUeXBlLCB0eXBlcyB9ID0gdmFsdWU7XG4gICAgY29uc3QgdmFsaWRhdGVEYXRhID0gKHN0cnVjdCwgZGF0YSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHN0cnVjdCkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtuYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IGludGVnZXJNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuaW50ZWdlclJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChpbnRlZ2VyTWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFssIGJhc2UsIHNpemVfXSA9IGludGVnZXJNYXRjaDtcbiAgICAgICAgICAgICAgICAvLyBJZiBudW1iZXIgY2Fubm90IGJlIGNhc3QgdG8gYSBzaXplZCBoZXggdmFsdWUsIGl0IGlzIG91dCBvZiByYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aWxsIHRocm93LlxuICAgICAgICAgICAgICAgIEhleC5mcm9tTnVtYmVyKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZDogYmFzZSA9PT0gJ2ludCcsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IE51bWJlci5wYXJzZUludChzaXplXyA/PyAnJykgLyA4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAhQWRkcmVzcy52YWxpZGF0ZSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFkZHJlc3MuSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBjYXVzZTogbmV3IEFkZHJlc3MuSW52YWxpZElucHV0RXJyb3IoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzTWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmJ5dGVzUmVnZXgpO1xuICAgICAgICAgICAgaWYgKGJ5dGVzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbLCBzaXplXSA9IGJ5dGVzTWF0Y2g7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgJiYgSGV4LnNpemUodmFsdWUpICE9PSBOdW1iZXIucGFyc2VJbnQoc2l6ZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZW5TaXplOiBIZXguc2l6ZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gdHlwZXNbdHlwZV07XG4gICAgICAgICAgICBpZiAoc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVSZWZlcmVuY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVEYXRhKHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBWYWxpZGF0ZSBkb21haW4gdHlwZXMuXG4gICAgaWYgKHR5cGVzLkVJUDcxMkRvbWFpbiAmJiBkb21haW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb21haW4gIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWREb21haW5FcnJvcih7IGRvbWFpbiB9KTtcbiAgICAgICAgdmFsaWRhdGVEYXRhKHR5cGVzLkVJUDcxMkRvbWFpbiwgZG9tYWluKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgbWVzc2FnZSB0eXBlcy5cbiAgICBpZiAocHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICAgIGlmICh0eXBlc1twcmltYXJ5VHlwZV0pXG4gICAgICAgICAgICB2YWxpZGF0ZURhdGEodHlwZXNbcHJpbWFyeVR5cGVdLCBtZXNzYWdlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmltYXJ5VHlwZUVycm9yKHsgcHJpbWFyeVR5cGUsIHR5cGVzIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBbRUlQLTcxMiBUeXBlZCBEYXRhXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMikgW2Bkb21haW5TZXBhcmF0b3JgXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMiNkZWZpbml0aW9uLW9mLWRvbWFpbnNlcGFyYXRvcikgZm9yIHRoZSBwcm92aWRlZCBkb21haW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeXBlZERhdGEgfSBmcm9tICdveCdcbiAqXG4gKiBUeXBlZERhdGEuZG9tYWluU2VwYXJhdG9yKHtcbiAqICAgbmFtZTogJ0V0aGVyIScsXG4gKiAgIHZlcnNpb246ICcxJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdmVyaWZ5aW5nQ29udHJhY3Q6ICcweENjQ0NjY2NjQ0NDQ2NDQ0NDQ0NjQ2NDY2NDY0NDQ2NDY2NjY2NjY0MnLFxuICogfSlcbiAqIC8vIEBsb2c6ICcweDk5MTFlZTRmNThhNzA1OWE4ZjUzODUyNDgwNDBlNjk4NGQ4MGUyYzg0OTUwMGZlNmE0ZDExYzRmYTk4YzJhZjMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZG9tYWluIC0gVGhlIGRvbWFpbiBmb3Igd2hpY2ggdG8gY3JlYXRlIHRoZSBkb21haW4gc2VwYXJhdG9yLlxuICogQHJldHVybnMgVGhlIGRvbWFpbiBzZXBhcmF0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb21haW5TZXBhcmF0b3IoZG9tYWluKSB7XG4gICAgcmV0dXJuIGhhc2hEb21haW4oe1xuICAgICAgICBkb21haW4sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuY29kZXMgdHlwZWQgZGF0YSBpbiBbRUlQLTcxMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKTogYDB4MTkg4oCWIDB4MDEg4oCWIGRvbWFpblNlcGFyYXRvciDigJYgaGFzaFN0cnVjdChtZXNzYWdlKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeXBlZERhdGEsIEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gVHlwZWREYXRhLmVuY29kZSh7IC8vIFshY29kZSBmb2N1czozM11cbiAqICAgZG9tYWluOiB7XG4gKiAgICAgbmFtZTogJ0V0aGVyIE1haWwnLFxuICogICAgIHZlcnNpb246ICcxJyxcbiAqICAgICBjaGFpbklkOiAxLFxuICogICAgIHZlcmlmeWluZ0NvbnRyYWN0OiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgfSxcbiAqICAgdHlwZXM6IHtcbiAqICAgICBQZXJzb246IFtcbiAqICAgICAgIHsgbmFtZTogJ25hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICogICAgICAgeyBuYW1lOiAnd2FsbGV0JywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gKiAgICAgXSxcbiAqICAgICBNYWlsOiBbXG4gKiAgICAgICB7IG5hbWU6ICdmcm9tJywgdHlwZTogJ1BlcnNvbicgfSxcbiAqICAgICAgIHsgbmFtZTogJ3RvJywgdHlwZTogJ1BlcnNvbicgfSxcbiAqICAgICAgIHsgbmFtZTogJ2NvbnRlbnRzJywgdHlwZTogJ3N0cmluZycgfSxcbiAqICAgICBdLFxuICogICB9LFxuICogICBwcmltYXJ5VHlwZTogJ01haWwnLFxuICogICBtZXNzYWdlOiB7XG4gKiAgICAgZnJvbToge1xuICogICAgICAgbmFtZTogJ0NvdycsXG4gKiAgICAgICB3YWxsZXQ6ICcweENEMmEzZDlGOTM4RTEzQ0Q5NDdFYzA1QWJDN0ZFNzM0RGY4REQ4MjYnLFxuICogICAgIH0sXG4gKiAgICAgdG86IHtcbiAqICAgICAgIG5hbWU6ICdCb2InLFxuICogICAgICAgd2FsbGV0OiAnMHhiQmJCQkJCYmJCQkJiYmJCYmJCYmJiYkJCYkJiYmJiQmJCYmJCQmJCJyxcbiAqICAgICB9LFxuICogICAgIGNvbnRlbnRzOiAnSGVsbG8sIEJvYiEnLFxuICogICB9LFxuICogfSlcbiAqIC8vIEBsb2c6ICcweDE5MDEyZmRmMzQ0MWZjYWY0ZjMwYzdlMTYyOTJiMjU4YTVkNzA1NGE0ZTJlMDBkYmQ3YjdkMmY0NjdmMmI4ZmI5NDEzYzUyYzBlZTVkODQyNjQ0NzE4MDYyOTBhM2YyYzRjZWNmYzU0OTA2MjZiZjkxMmQwMWYyNDBkN2EyNzRiMzcxZSdcbiAqIC8vIEBsb2c6ICgweDE5IOKAliAweDAxIOKAliBkb21haW5TZXBhcmF0b3Ig4oCWIGhhc2hTdHJ1Y3QobWVzc2FnZSkpXG4gKlxuICogY29uc3QgaGFzaCA9IEhhc2gua2VjY2FrMjU2KGRhdGEpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgVHlwZWQgRGF0YSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBUeXBlZCBEYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gICAgY29uc3QgeyBkb21haW4gPSB7fSwgbWVzc2FnZSwgcHJpbWFyeVR5cGUgfSA9IHZhbHVlO1xuICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICBFSVA3MTJEb21haW46IGV4dHJhY3RFaXA3MTJEb21haW5UeXBlcyhkb21haW4pLFxuICAgICAgICAuLi52YWx1ZS50eXBlcyxcbiAgICB9O1xuICAgIC8vIE5lZWQgdG8gZG8gYSBydW50aW1lIHZhbGlkYXRpb24gY2hlY2sgb24gYWRkcmVzc2VzLCBieXRlIHJhbmdlcywgaW50ZWdlciByYW5nZXMsIGV0Y1xuICAgIC8vIGFzIHdlIGNhbid0IHN0YXRpY2FsbHkgY2hlY2sgdGhpcyB3aXRoIFR5cGVTY3JpcHQuXG4gICAgYXNzZXJ0KHtcbiAgICAgICAgZG9tYWluLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBwcmltYXJ5VHlwZSxcbiAgICAgICAgdHlwZXMsXG4gICAgfSk7XG4gICAgLy8gVHlwZWQgRGF0YSBGb3JtYXQ6IGAweDE5IOKAliAweDAxIOKAliBkb21haW5TZXBhcmF0b3Ig4oCWIGhhc2hTdHJ1Y3QobWVzc2FnZSlgXG4gICAgY29uc3QgcGFydHMgPSBbJzB4MTknLCAnMHgwMSddO1xuICAgIGlmIChkb21haW4pXG4gICAgICAgIHBhcnRzLnB1c2goaGFzaERvbWFpbih7XG4gICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgfSkpO1xuICAgIGlmIChwcmltYXJ5VHlwZSAhPT0gJ0VJUDcxMkRvbWFpbicpXG4gICAgICAgIHBhcnRzLnB1c2goaGFzaFN0cnVjdCh7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgfSkpO1xuICAgIHJldHVybiBIZXguY29uY2F0KC4uLnBhcnRzKTtcbn1cbi8qKlxuICogRW5jb2RlcyBbRUlQLTcxMiBUeXBlZCBEYXRhXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMikgc2NoZW1hIGZvciB0aGUgcHJvdmlkZWQgcHJpbWFyeVR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeXBlZERhdGEgfSBmcm9tICdveCdcbiAqXG4gKiBUeXBlZERhdGEuZW5jb2RlVHlwZSh7XG4gKiAgIHR5cGVzOiB7XG4gKiAgICAgRm9vOiBbXG4gKiAgICAgICB7IG5hbWU6ICdhZGRyZXNzJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gKiAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ3N0cmluZycgfSxcbiAqICAgICAgIHsgbmFtZTogJ2ZvbycsIHR5cGU6ICdzdHJpbmcnIH0sXG4gKiAgICAgXSxcbiAqICAgfSxcbiAqICAgcHJpbWFyeVR5cGU6ICdGb28nLFxuICogfSlcbiAqIC8vIEBsb2c6ICdGb28oYWRkcmVzcyBhZGRyZXNzLHN0cmluZyBuYW1lLHN0cmluZyBmb28pJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIFR5cGVkIERhdGEgc2NoZW1hLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVR5cGUodmFsdWUpIHtcbiAgICBjb25zdCB7IHByaW1hcnlUeXBlLCB0eXBlcyB9ID0gdmFsdWU7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IHVuc29ydGVkRGVwcyA9IGZpbmRUeXBlRGVwZW5kZW5jaWVzKHsgcHJpbWFyeVR5cGUsIHR5cGVzIH0pO1xuICAgIHVuc29ydGVkRGVwcy5kZWxldGUocHJpbWFyeVR5cGUpO1xuICAgIGNvbnN0IGRlcHMgPSBbcHJpbWFyeVR5cGUsIC4uLkFycmF5LmZyb20odW5zb3J0ZWREZXBzKS5zb3J0KCldO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBkZXBzKSB7XG4gICAgICAgIHJlc3VsdCArPSBgJHt0eXBlfSgkeyh0eXBlc1t0eXBlXSA/PyBbXSlcbiAgICAgICAgICAgIC5tYXAoKHsgbmFtZSwgdHlwZTogdCB9KSA9PiBgJHt0fSAke25hbWV9YClcbiAgICAgICAgICAgIC5qb2luKCcsJyl9KWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEdldHMgW0VJUC03MTIgVHlwZWQgRGF0YV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MTIpIHNjaGVtYSBmb3IgRUlQLTcyMSBkb21haW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeXBlZERhdGEgfSBmcm9tICdveCdcbiAqXG4gKiBUeXBlZERhdGEuZXh0cmFjdEVpcDcxMkRvbWFpblR5cGVzKHtcbiAqICAgbmFtZTogJ0V0aGVyIScsXG4gKiAgIHZlcnNpb246ICcxJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdmVyaWZ5aW5nQ29udHJhY3Q6ICcweENjQ0NjY2NjQ0NDQ2NDQ0NDQ0NjQ2NDY2NDY0NDQ2NDY2NjY2NjY0MnLFxuICogfSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgeyAnbmFtZSc6ICduYW1lJywgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICogLy8gQGxvZzogICB7ICduYW1lJzogJ3ZlcnNpb24nLCAndHlwZSc6ICdzdHJpbmcnIH0sXG4gKiAvLyBAbG9nOiAgIHsgJ25hbWUnOiAnY2hhaW5JZCcsICd0eXBlJzogJ3VpbnQyNTYnIH0sXG4gKiAvLyBAbG9nOiAgIHsgJ25hbWUnOiAndmVyaWZ5aW5nQ29udHJhY3QnLCAndHlwZSc6ICdhZGRyZXNzJyB9LFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGRvbWFpbiAtIFRoZSBFSVAtNzEyIGRvbWFpbi5cbiAqIEByZXR1cm5zIFRoZSBFSVAtNzEyIGRvbWFpbiBzY2hlbWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RWlwNzEyRG9tYWluVHlwZXMoZG9tYWluKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdHlwZW9mIGRvbWFpbj8ubmFtZSA9PT0gJ3N0cmluZycgJiYgeyBuYW1lOiAnbmFtZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIGRvbWFpbj8udmVyc2lvbiAmJiB7IG5hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgdHlwZW9mIGRvbWFpbj8uY2hhaW5JZCA9PT0gJ251bWJlcicgJiYge1xuICAgICAgICAgICAgbmFtZTogJ2NoYWluSWQnLFxuICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICB9LFxuICAgICAgICBkb21haW4/LnZlcmlmeWluZ0NvbnRyYWN0ICYmIHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJpZnlpbmdDb250cmFjdCcsXG4gICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgIH0sXG4gICAgICAgIGRvbWFpbj8uc2FsdCAmJiB7IG5hbWU6ICdzYWx0JywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG59XG4vKipcbiAqIEdldHMgdGhlIHBheWxvYWQgdG8gdXNlIGZvciBzaWduaW5nIHR5cGVkIGRhdGEgaW4gW0VJUC03MTIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFR5cGVkRGF0YSwgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBUeXBlZERhdGEuZ2V0U2lnblBheWxvYWQoeyAvLyBbIWNvZGUgZm9jdXM6OTldXG4gKiAgIGRvbWFpbjoge1xuICogICAgIG5hbWU6ICdFdGhlciBNYWlsJyxcbiAqICAgICB2ZXJzaW9uOiAnMScsXG4gKiAgICAgY2hhaW5JZDogMSxcbiAqICAgICB2ZXJpZnlpbmdDb250cmFjdDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIH0sXG4gKiAgIHR5cGVzOiB7XG4gKiAgICAgUGVyc29uOiBbXG4gKiAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ3N0cmluZycgfSxcbiAqICAgICAgIHsgbmFtZTogJ3dhbGxldCcsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICogICAgIF0sXG4gKiAgICAgTWFpbDogW1xuICogICAgICAgeyBuYW1lOiAnZnJvbScsIHR5cGU6ICdQZXJzb24nIH0sXG4gKiAgICAgICB7IG5hbWU6ICd0bycsIHR5cGU6ICdQZXJzb24nIH0sXG4gKiAgICAgICB7IG5hbWU6ICdjb250ZW50cycsIHR5cGU6ICdzdHJpbmcnIH0sXG4gKiAgICAgXSxcbiAqICAgfSxcbiAqICAgcHJpbWFyeVR5cGU6ICdNYWlsJyxcbiAqICAgbWVzc2FnZToge1xuICogICAgIGZyb206IHtcbiAqICAgICAgIG5hbWU6ICdDb3cnLFxuICogICAgICAgd2FsbGV0OiAnMHhDRDJhM2Q5RjkzOEUxM0NEOTQ3RWMwNUFiQzdGRTczNERmOEREODI2JyxcbiAqICAgICB9LFxuICogICAgIHRvOiB7XG4gKiAgICAgICBuYW1lOiAnQm9iJyxcbiAqICAgICAgIHdhbGxldDogJzB4YkJiQkJCQmJiQkJCYmJiQmJiQmJiYmJCQmJCYmJiYkJiQmJiQkJiQicsXG4gKiAgICAgfSxcbiAqICAgICBjb250ZW50czogJ0hlbGxvLCBCb2IhJyxcbiAqICAgfSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdHlwZWQgZGF0YSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgcGF5bG9hZCB0byB1c2UgZm9yIHNpZ25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZCh2YWx1ZSkge1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihlbmNvZGUodmFsdWUpKTtcbn1cbi8qKlxuICogSGFzaGVzIFtFSVAtNzEyIFR5cGVkIERhdGFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSBkb21haW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeXBlZERhdGEgfSBmcm9tICdveCdcbiAqXG4gKiBUeXBlZERhdGEuaGFzaERvbWFpbih7XG4gKiAgIGRvbWFpbjoge1xuICogICAgIG5hbWU6ICdFdGhlciBNYWlsJyxcbiAqICAgICB2ZXJzaW9uOiAnMScsXG4gKiAgICAgY2hhaW5JZDogMSxcbiAqICAgICB2ZXJpZnlpbmdDb250cmFjdDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIH0sXG4gKiB9KVxuICogLy8gQGxvZzogJzB4NjE5MjEwNmYxMjljZTA1YzkwNzVkMzE5YzFmYTZlYTliM2FlMzdjYmQwYzFlZjkyZTJiZTcxMzdiYjA3YmFhMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBUeXBlZCBEYXRhIGRvbWFpbiBhbmQgdHlwZXMuXG4gKiBAcmV0dXJucyBUaGUgaGFzaGVkIGRvbWFpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hEb21haW4odmFsdWUpIHtcbiAgICBjb25zdCB7IGRvbWFpbiwgdHlwZXMgfSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoU3RydWN0KHtcbiAgICAgICAgZGF0YTogZG9tYWluLFxuICAgICAgICBwcmltYXJ5VHlwZTogJ0VJUDcxMkRvbWFpbicsXG4gICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAuLi50eXBlcyxcbiAgICAgICAgICAgIEVJUDcxMkRvbWFpbjogdHlwZXM/LkVJUDcxMkRvbWFpbiB8fCBleHRyYWN0RWlwNzEyRG9tYWluVHlwZXMoZG9tYWluKSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogSGFzaGVzIFtFSVAtNzEyIFR5cGVkIERhdGFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSBzdHJ1Y3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeXBlZERhdGEgfSBmcm9tICdveCdcbiAqXG4gKiBUeXBlZERhdGEuaGFzaFN0cnVjdCh7XG4gKiAgIHR5cGVzOiB7XG4gKiAgICAgRm9vOiBbXG4gKiAgICAgICB7IG5hbWU6ICdhZGRyZXNzJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gKiAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ3N0cmluZycgfSxcbiAqICAgICAgIHsgbmFtZTogJ2ZvbycsIHR5cGU6ICdzdHJpbmcnIH0sXG4gKiAgICAgXSxcbiAqICAgfSxcbiAqICAgcHJpbWFyeVR5cGU6ICdGb28nLFxuICogICBkYXRhOiB7XG4gKiAgICAgYWRkcmVzczogJzB4YjlDQUI0RjBFNDZGN0Y2YjEwMjRiNUE3NDYzNzM0ZmE2OEU2MzNmOScsXG4gKiAgICAgbmFtZTogJ2p4b20nLFxuICogICAgIGZvbzogJzB4YjlDQUI0RjBFNDZGN0Y2YjEwMjRiNUE3NDYzNzM0ZmE2OEU2MzNmOScsXG4gKiAgIH0sXG4gKiB9KVxuICogLy8gQGxvZzogJzB4OTk2ZmIzYjZkNDhjNTAzMTJkNjlhYmRkNGMxYjZmYjAyMDU3Yzg1YWE4NmJiOGQwNGM2ZjAyMzMyNmExNjhjZSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBUeXBlZCBEYXRhIHN0cnVjdCB0byBoYXNoLlxuICogQHJldHVybnMgVGhlIGhhc2hlZCBUeXBlZCBEYXRhIHN0cnVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hTdHJ1Y3QodmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHByaW1hcnlUeXBlLCB0eXBlcyB9ID0gdmFsdWU7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZURhdGEoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBwcmltYXJ5VHlwZSxcbiAgICAgICAgdHlwZXMsXG4gICAgfSk7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KGVuY29kZWQpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIFtFSVAtNzEyIFR5cGVkIERhdGFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSBzY2hlbWEgaW50byBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeXBlZERhdGEgfSBmcm9tICdveCdcbiAqXG4gKiBUeXBlZERhdGEuc2VyaWFsaXplKHtcbiAqICAgZG9tYWluOiB7XG4gKiAgICAgbmFtZTogJ0V0aGVyIScsXG4gKiAgICAgdmVyc2lvbjogJzEnLFxuICogICAgIGNoYWluSWQ6IDEsXG4gKiAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6ICcweENjQ0NjY2NjQ0NDQ2NDQ0NDQ0NjQ2NDY2NDY0NDQ2NDY2NjY2NjY0MnLFxuICogICB9LFxuICogICBwcmltYXJ5VHlwZTogJ0ZvbycsXG4gKiAgIHR5cGVzOiB7XG4gKiAgICAgRm9vOiBbXG4gKiAgICAgICB7IG5hbWU6ICdhZGRyZXNzJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gKiAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ3N0cmluZycgfSxcbiAqICAgICAgIHsgbmFtZTogJ2ZvbycsIHR5cGU6ICdzdHJpbmcnIH0sXG4gKiAgICAgXSxcbiAqICAgfSxcbiAqICAgbWVzc2FnZToge1xuICogICAgIGFkZHJlc3M6ICcweGI5Q0FCNEYwRTQ2RjdGNmIxMDI0YjVBNzQ2MzczNGZhNjhFNjMzZjknLFxuICogICAgIG5hbWU6ICdqeG9tJyxcbiAqICAgICBmb286ICcweGI5Q0FCNEYwRTQ2RjdGNmIxMDI0YjVBNzQ2MzczNGZhNjhFNjMzZjknLFxuICogICB9LFxuICogfSlcbiAqIC8vIEBsb2c6IFwie1wiZG9tYWluXCI6e30sXCJtZXNzYWdlXCI6e1wiYWRkcmVzc1wiOlwiMHhiOWNhYjRmMGU0NmY3ZjZiMTAyNGI1YTc0NjM3MzRmYTY4ZTYzM2Y5XCIsXCJuYW1lXCI6XCJqeG9tXCIsXCJmb29cIjpcIjB4YjlDQUI0RjBFNDZGN0Y2YjEwMjRiNUE3NDYzNzM0ZmE2OEU2MzNmOVwifSxcInByaW1hcnlUeXBlXCI6XCJGb29cIixcInR5cGVzXCI6e1wiRm9vXCI6W3tcIm5hbWVcIjpcImFkZHJlc3NcIixcInR5cGVcIjpcImFkZHJlc3NcIn0se1wibmFtZVwiOlwibmFtZVwiLFwidHlwZVwiOlwic3RyaW5nXCJ9LHtcIm5hbWVcIjpcImZvb1wiLFwidHlwZVwiOlwic3RyaW5nXCJ9XX19XCJcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBUeXBlZCBEYXRhIHNjaGVtYSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUeXBlZCBEYXRhIHNjaGVtYS4gd1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgY29uc3QgeyBkb21haW46IGRvbWFpbl8sIG1lc3NhZ2U6IG1lc3NhZ2VfLCBwcmltYXJ5VHlwZSwgdHlwZXMsIH0gPSB2YWx1ZTtcbiAgICBjb25zdCBub3JtYWxpemVEYXRhID0gKHN0cnVjdCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgLi4udmFsdWUgfTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBzdHJ1Y3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gcGFyYW07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKVxuICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0gPSBkYXRhW25hbWVdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBjb25zdCBkb21haW4gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoIWRvbWFpbl8pXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlcy5FSVA3MTJEb21haW4gPz8gZXh0cmFjdEVpcDcxMkRvbWFpblR5cGVzKGRvbWFpbl8pO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplRGF0YSh0eXBlLCBkb21haW5fKTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKCkgPT4ge1xuICAgICAgICBpZiAocHJpbWFyeVR5cGUgPT09ICdFSVA3MTJEb21haW4nKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCF0eXBlc1twcmltYXJ5VHlwZV0pXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIHJldHVybiBub3JtYWxpemVEYXRhKHR5cGVzW3ByaW1hcnlUeXBlXSwgbWVzc2FnZV8pO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEpzb24uc3RyaW5naWZ5KHsgZG9tYWluLCBtZXNzYWdlLCBwcmltYXJ5VHlwZSwgdHlwZXMgfSwgKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIFtFSVAtNzEyIFR5cGVkIERhdGFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFR5cGVkRGF0YSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gVHlwZWREYXRhLnZhbGlkYXRlKHtcbiAqICAgZG9tYWluOiB7XG4gKiAgICAgbmFtZTogJ0V0aGVyIScsXG4gKiAgICAgdmVyc2lvbjogJzEnLFxuICogICAgIGNoYWluSWQ6IDEsXG4gKiAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6ICcweENjQ0NjY2NjQ0NDQ2NDQ0NDQ0NjQ2NDY2NDY0NDQ2NDY2NjY2NjY0MnLFxuICogICB9LFxuICogICBwcmltYXJ5VHlwZTogJ0ZvbycsXG4gKiAgIHR5cGVzOiB7XG4gKiAgICAgRm9vOiBbXG4gKiAgICAgICB7IG5hbWU6ICdhZGRyZXNzJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gKiAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ3N0cmluZycgfSxcbiAqICAgICAgIHsgbmFtZTogJ2ZvbycsIHR5cGU6ICdzdHJpbmcnIH0sXG4gKiAgICAgXSxcbiAqICAgfSxcbiAqICAgbWVzc2FnZToge1xuICogICAgIGFkZHJlc3M6ICcweGI5Q0FCNEYwRTQ2RjdGNmIxMDI0YjVBNzQ2MzczNGZhNjhFNjMzZjknLFxuICogICAgIG5hbWU6ICdqeG9tJyxcbiAqICAgICBmb286ICcweGI5Q0FCNEYwRTQ2RjdGNmIxMDI0YjVBNzQ2MzczNGZhNjhFNjMzZjknLFxuICogICB9LFxuICogfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBUeXBlZCBEYXRhIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBieXRlcyBzaXplIG9mIGEgdHlwZWQgZGF0YSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgc2l6ZS4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc1NpemVNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZFNpemUsIGdpdmVuU2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgRXhwZWN0ZWQgYnl0ZXMke2V4cGVjdGVkU2l6ZX0sIGdvdCBieXRlcyR7Z2l2ZW5TaXplfS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1R5cGVkRGF0YS5CeXRlc1NpemVNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIGRvbWFpbiBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREb21haW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZG9tYWluIH0pIHtcbiAgICAgICAgc3VwZXIoYEludmFsaWQgZG9tYWluIFwiJHtKc29uLnN0cmluZ2lmeShkb21haW4pfVwiLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydNdXN0IGJlIGEgdmFsaWQgRUlQLTcxMiBkb21haW4uJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHlwZWREYXRhLkludmFsaWREb21haW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBwcmltYXJ5IHR5cGUgb2YgYSB0eXBlZCBkYXRhIHZhbHVlIGlzIGludmFsaWQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFByaW1hcnlUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHByaW1hcnlUeXBlLCB0eXBlcywgfSkge1xuICAgICAgICBzdXBlcihgSW52YWxpZCBwcmltYXJ5IHR5cGUgXFxgJHtwcmltYXJ5VHlwZX1cXGAgbXVzdCBiZSBvbmUgb2YgXFxgJHtKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyh0eXBlcykpfVxcYC5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnQ2hlY2sgdGhhdCB0aGUgcHJpbWFyeSB0eXBlIGlzIGEga2V5IGluIGB0eXBlc2AuJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHlwZWREYXRhLkludmFsaWRQcmltYXJ5VHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHN0cnVjdCB0eXBlIGlzIG5vdCBhIHZhbGlkIHR5cGUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0cnVjdFR5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdHlwZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTdHJ1Y3QgdHlwZSBcIiR7dHlwZX1cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydTdHJ1Y3QgdHlwZSBtdXN0IG5vdCBiZSBhIFNvbGlkaXR5IHR5cGUuJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHlwZWREYXRhLkludmFsaWRTdHJ1Y3RUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVEYXRhKHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBwcmltYXJ5VHlwZSwgdHlwZXMgfSA9IHZhbHVlO1xuICAgIGNvbnN0IGVuY29kZWRUeXBlcyA9IFt7IHR5cGU6ICdieXRlczMyJyB9XTtcbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW2hhc2hUeXBlKHsgcHJpbWFyeVR5cGUsIHR5cGVzIH0pXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSA/PyBbXSkge1xuICAgICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gZW5jb2RlRmllbGQoe1xuICAgICAgICAgICAgdHlwZXMsXG4gICAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgdHlwZTogZmllbGQudHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhW2ZpZWxkLm5hbWVdLFxuICAgICAgICB9KTtcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmVuY29kZShlbmNvZGVkVHlwZXMsIGVuY29kZWRWYWx1ZXMpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUeXBlKHZhbHVlKSB7XG4gICAgY29uc3QgeyBwcmltYXJ5VHlwZSwgdHlwZXMgfSA9IHZhbHVlO1xuICAgIGNvbnN0IGVuY29kZWRIYXNoVHlwZSA9IEhleC5mcm9tU3RyaW5nKGVuY29kZVR5cGUoeyBwcmltYXJ5VHlwZSwgdHlwZXMgfSkpO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihlbmNvZGVkSGFzaFR5cGUpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUZpZWxkKHByb3BlcnRpZXMpIHtcbiAgICBsZXQgeyB0eXBlcywgbmFtZSwgdHlwZSwgdmFsdWUgfSA9IHByb3BlcnRpZXM7XG4gICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgICAgICAgSGFzaC5rZWNjYWsyNTYoZW5jb2RlRGF0YSh7IGRhdGE6IHZhbHVlLCBwcmltYXJ5VHlwZTogdHlwZSwgdHlwZXMgfSkpLFxuICAgICAgICBdO1xuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgIGNvbnN0IHByZXBlbmQgPSB2YWx1ZS5sZW5ndGggJSAyID8gJzAnIDogJyc7XG4gICAgICAgIHZhbHVlID0gYDB4JHtwcmVwZW5kICsgdmFsdWUuc2xpY2UoMil9YDtcbiAgICAgICAgcmV0dXJuIFt7IHR5cGU6ICdieXRlczMyJyB9LCBIYXNoLmtlY2NhazI1Nih2YWx1ZSwgeyBhczogJ0hleCcgfSldO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgICAgICAgSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyh2YWx1ZSksIHsgYXM6ICdIZXgnIH0pLFxuICAgICAgICBdO1xuICAgIGlmICh0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpO1xuICAgICAgICBjb25zdCB0eXBlVmFsdWVQYWlycyA9IHZhbHVlLm1hcCgoaXRlbSkgPT4gZW5jb2RlRmllbGQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgICAgICAgSGFzaC5rZWNjYWsyNTYoQWJpUGFyYW1ldGVycy5lbmNvZGUodHlwZVZhbHVlUGFpcnMubWFwKChbdF0pID0+IHQpLCB0eXBlVmFsdWVQYWlycy5tYXAoKFssIHZdKSA9PiB2KSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW3sgdHlwZSB9LCB2YWx1ZV07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFR5cGVEZXBlbmRlbmNpZXModmFsdWUsIHJlc3VsdHMgPSBuZXcgU2V0KCkpIHtcbiAgICBjb25zdCB7IHByaW1hcnlUeXBlOiBwcmltYXJ5VHlwZV8sIHR5cGVzIH0gPSB2YWx1ZTtcbiAgICBjb25zdCBtYXRjaCA9IHByaW1hcnlUeXBlXy5tYXRjaCgvXlxcdyovdSk7XG4gICAgY29uc3QgcHJpbWFyeVR5cGUgPSBtYXRjaD8uWzBdO1xuICAgIGlmIChyZXN1bHRzLmhhcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIHJlc3VsdHMuYWRkKHByaW1hcnlUeXBlKTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSlcbiAgICAgICAgZmluZFR5cGVEZXBlbmRlbmNpZXMoeyBwcmltYXJ5VHlwZTogZmllbGQudHlwZSwgdHlwZXMgfSwgcmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlZmVyZW5jZSh0eXBlKSB7XG4gICAgLy8gU3RydWN0IHR5cGUgbXVzdCBub3QgYmUgYSBTb2xpZGl0eSB0eXBlLlxuICAgIGlmICh0eXBlID09PSAnYWRkcmVzcycgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2Jvb2wnIHx8XG4gICAgICAgIHR5cGUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSB8fFxuICAgICAgICB0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fFxuICAgICAgICB0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0cnVjdFR5cGVFcnJvcih7IHR5cGUgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeXBlZERhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/TypedData.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/ValidatorData.js":
/*!*****************************************************!*\
  !*** ../node_modules/ox/_esm/core/ValidatorData.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n/**\n * Encodes data with a validator in [ERC-191 format](https://eips.ethereum.org/EIPS/eip-191#version-0x00): `0x19  0x00  <intended validator address>  <data to sign>`.\n *\n * @example\n * ```ts twoslash\n * import { Hex, ValidatorData } from 'ox'\n *\n * const encoded = ValidatorData.encode({\n *   data: Hex.fromString('hello world'),\n *   validator: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n * })\n * // @log: '0x1900d8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * // @log: '0x19  0x00  0xd8da6bf26964af9d7eed9e03e53415d37aa96045  \"hello world\"'\n * ```\n *\n * @param value - The data to encode.\n * @returns The encoded personal sign message.\n */\nfunction encode(value) {\n    const { data, validator } = value;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(\n    // Validator Data Format: `0x19  0x00  <intended validator address>  <data to sign>`\n    '0x19', '0x00', validator, _Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(data));\n}\n/**\n * Gets the payload to use for signing [ERC-191 formatted](https://eips.ethereum.org/EIPS/eip-191#0x00) data with an intended validator.\n *\n * @example\n * ```ts twoslash\n * import { Hex, Secp256k1, ValidatorData } from 'ox'\n *\n * const payload = ValidatorData.getSignPayload({ // [!code focus]\n *   data: Hex.fromString('hello world'), // [!code focus]\n *   validator: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', // [!code focus]\n * }) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nfunction getSignPayload(value) {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(encode(value));\n}\n//# sourceMappingURL=ValidatorData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9WYWxpZGF0b3JEYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDRjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksa0JBQWtCO0FBQzlCLFdBQVcsMkNBQVU7QUFDckI7QUFDQSwrQkFBK0IseUNBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVywrQ0FBYztBQUN6QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVmFsaWRhdG9yRGF0YS5qcz9jZDZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIEVuY29kZXMgZGF0YSB3aXRoIGEgdmFsaWRhdG9yIGluIFtFUkMtMTkxIGZvcm1hdF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xOTEjdmVyc2lvbi0weDAwKTogYDB4MTkg4oCWIDB4MDAg4oCWIDxpbnRlbmRlZCB2YWxpZGF0b3IgYWRkcmVzcz4g4oCWIDxkYXRhIHRvIHNpZ24+YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCwgVmFsaWRhdG9yRGF0YSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVuY29kZWQgPSBWYWxpZGF0b3JEYXRhLmVuY29kZSh7XG4gKiAgIGRhdGE6IEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpLFxuICogICB2YWxpZGF0b3I6ICcweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUnLFxuICogfSlcbiAqIC8vIEBsb2c6ICcweDE5MDBkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCdcbiAqIC8vIEBsb2c6ICcweDE5IOKAliAweDAwIOKAliAweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUg4oCWIFwiaGVsbG8gd29ybGRcIidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRhIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHBlcnNvbmFsIHNpZ24gbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgdmFsaWRhdG9yIH0gPSB2YWx1ZTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChcbiAgICAvLyBWYWxpZGF0b3IgRGF0YSBGb3JtYXQ6IGAweDE5IOKAliAweDAwIOKAliA8aW50ZW5kZWQgdmFsaWRhdG9yIGFkZHJlc3M+IOKAliA8ZGF0YSB0byBzaWduPmBcbiAgICAnMHgxOScsICcweDAwJywgdmFsaWRhdG9yLCBIZXguZnJvbShkYXRhKSk7XG59XG4vKipcbiAqIEdldHMgdGhlIHBheWxvYWQgdG8gdXNlIGZvciBzaWduaW5nIFtFUkMtMTkxIGZvcm1hdHRlZF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xOTEjMHgwMCkgZGF0YSB3aXRoIGFuIGludGVuZGVkIHZhbGlkYXRvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCwgU2VjcDI1NmsxLCBWYWxpZGF0b3JEYXRhIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IFZhbGlkYXRvckRhdGEuZ2V0U2lnblBheWxvYWQoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6IEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHZhbGlkYXRvcjogJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRhIHRvIGdldCB0aGUgc2lnbiBwYXlsb2FkIGZvci5cbiAqIEByZXR1cm5zIFRoZSBwYXlsb2FkIHRvIHVzZSBmb3Igc2lnbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKHZhbHVlKSB7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KGVuY29kZSh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsaWRhdG9yRGF0YS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/ValidatorData.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Value.js":
/*!*********************************************!*\
  !*** ../node_modules/ox/_esm/core/Value.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidDecimalNumberError: () => (/* binding */ InvalidDecimalNumberError),\n/* harmony export */   exponents: () => (/* binding */ exponents),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatGwei: () => (/* binding */ formatGwei),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromEther: () => (/* binding */ fromEther),\n/* harmony export */   fromGwei: () => (/* binding */ fromGwei)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */\nconst exponents = {\n    wei: 0,\n    gwei: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18,\n};\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */\nfunction format(value, decimals = 0) {\n    let display = value.toString();\n    const negative = display.startsWith('-');\n    if (negative)\n        display = display.slice(1);\n    display = display.padStart(decimals, '0');\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals),\n    ];\n    fraction = fraction.replace(/(0+)$/, '');\n    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */\nfunction formatEther(wei, unit = 'wei') {\n    return format(wei, exponents.ether - exponents[unit]);\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */\nfunction formatGwei(wei, unit = 'wei') {\n    return format(wei, exponents.gwei - exponents[unit]);\n}\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */\nfunction from(value, decimals = 0) {\n    if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n        throw new InvalidDecimalNumberError({ value });\n    let [integer = '', fraction = '0'] = value.split('.');\n    const negative = integer.startsWith('-');\n    if (negative)\n        integer = integer.slice(1);\n    // trim trailing zeros.\n    fraction = fraction.replace(/(0+)$/, '');\n    // round off if the fraction is larger than the number of decimals.\n    if (decimals === 0) {\n        if (Math.round(Number(`.${fraction}`)) === 1)\n            integer = `${BigInt(integer) + 1n}`;\n        fraction = '';\n    }\n    else if (fraction.length > decimals) {\n        const [left, unit, right] = [\n            fraction.slice(0, decimals - 1),\n            fraction.slice(decimals - 1, decimals),\n            fraction.slice(decimals),\n        ];\n        const rounded = Math.round(Number(`${unit}.${right}`));\n        if (rounded > 9)\n            fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');\n        else\n            fraction = `${left}${rounded}`;\n        if (fraction.length > decimals) {\n            fraction = fraction.slice(1);\n            integer = `${BigInt(integer) + 1n}`;\n        }\n        fraction = fraction.slice(0, decimals);\n    }\n    else {\n        fraction = fraction.padEnd(decimals, '0');\n    }\n    return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);\n}\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nfunction fromEther(ether, unit = 'wei') {\n    return from(ether, exponents.ether - exponents[unit]);\n}\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nfunction fromGwei(gwei, unit = 'wei') {\n    return from(gwei, exponents.gwei - exponents[unit]);\n}\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */\nclass InvalidDecimalNumberError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is not a valid decimal number.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Value.InvalidDecimalNumberError'\n        });\n    }\n}\n//# sourceMappingURL=Value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9WYWx1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBc0M7QUFDdEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CLEVBQUUsZUFBZSxFQUFFLGVBQWUsU0FBUyxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQyx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSyxHQUFHLE1BQU07QUFDM0Q7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0EsMEJBQTBCLEtBQUssRUFBRSxRQUFRO0FBQ3pDO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0IsRUFBRSxRQUFRLEVBQUUsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3Q0FBd0MsaURBQWdCO0FBQy9ELGtCQUFrQixPQUFPO0FBQ3pCLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVmFsdWUuanM/ODkzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuLyoqIEBzZWUgaHR0cHM6Ly9ldGhlcmV1bS5naXRodWIuaW8veWVsbG93cGFwZXIvcGFwZXIucGRmICovXG5leHBvcnQgY29uc3QgZXhwb25lbnRzID0ge1xuICAgIHdlaTogMCxcbiAgICBnd2VpOiA5LFxuICAgIHN6YWJvOiAxMixcbiAgICBmaW5uZXk6IDE1LFxuICAgIGV0aGVyOiAxOCxcbn07XG4vKipcbiAqIEZvcm1hdHMgYSBgYmlnaW50YCBWYWx1ZSB0byBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIChkaXZpZGVkIGJ5IHRoZSBnaXZlbiBleHBvbmVudCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZvcm1hdCg0MjBfMDAwXzAwMF8wMDBuLCA5KVxuICogLy8gQGxvZzogJzQyMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCBWYWx1ZSB0byBmb3JtYXQuXG4gKiBAcGFyYW0gZGVjaW1hbHMgLSBUaGUgZXhwb25lbnQgdG8gZGl2aWRlIHRoZSBgYmlnaW50YCBWYWx1ZSBieS5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCBkZWNpbWFscyA9IDApIHtcbiAgICBsZXQgZGlzcGxheSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbmVnYXRpdmUgPSBkaXNwbGF5LnN0YXJ0c1dpdGgoJy0nKTtcbiAgICBpZiAobmVnYXRpdmUpXG4gICAgICAgIGRpc3BsYXkgPSBkaXNwbGF5LnNsaWNlKDEpO1xuICAgIGRpc3BsYXkgPSBkaXNwbGF5LnBhZFN0YXJ0KGRlY2ltYWxzLCAnMCcpO1xuICAgIGxldCBbaW50ZWdlciwgZnJhY3Rpb25dID0gW1xuICAgICAgICBkaXNwbGF5LnNsaWNlKDAsIGRpc3BsYXkubGVuZ3RoIC0gZGVjaW1hbHMpLFxuICAgICAgICBkaXNwbGF5LnNsaWNlKGRpc3BsYXkubGVuZ3RoIC0gZGVjaW1hbHMpLFxuICAgIF07XG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5yZXBsYWNlKC8oMCspJC8sICcnKTtcbiAgICByZXR1cm4gYCR7bmVnYXRpdmUgPyAnLScgOiAnJ30ke2ludGVnZXIgfHwgJzAnfSR7ZnJhY3Rpb24gPyBgLiR7ZnJhY3Rpb259YCA6ICcnfWA7XG59XG4vKipcbiAqIEZvcm1hdHMgYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKSB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBFdGhlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZm9ybWF0RXRoZXIoMV8wMDBfMDAwXzAwMF8wMDBfMDAwXzAwMG4pXG4gKiAvLyBAbG9nOiAnMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3ZWkgLSBUaGUgVmFsdWUgdG8gZm9ybWF0LlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBmb3JtYXQgdGhlIFZhbHVlIGluLiBAZGVmYXVsdCAnd2VpJy5cbiAqIEByZXR1cm5zIFRoZSBFdGhlciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpLCB1bml0ID0gJ3dlaScpIHtcbiAgICByZXR1cm4gZm9ybWF0KHdlaSwgZXhwb25lbnRzLmV0aGVyIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogRm9ybWF0cyBhIGBiaWdpbnRgIFZhbHVlIChkZWZhdWx0OiB3ZWkpIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEd3ZWkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZvcm1hdEd3ZWkoMV8wMDBfMDAwXzAwMG4pXG4gKiAvLyBAbG9nOiAnMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3ZWkgLSBUaGUgVmFsdWUgdG8gZm9ybWF0LlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBmb3JtYXQgdGhlIFZhbHVlIGluLiBAZGVmYXVsdCAnd2VpJy5cbiAqIEByZXR1cm5zIFRoZSBHd2VpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRHd2VpKHdlaSwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh3ZWksIGV4cG9uZW50cy5nd2VpIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgYHN0cmluZ2AgcmVwcmVzZW50YXRpb24gb2YgYSBWYWx1ZSB0byBgYmlnaW50YCAobXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gZXhwb25lbnQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mcm9tKCc0MjAnLCA5KVxuICogLy8gQGxvZzogNDIwMDAwMDAwMDAwblxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKiBAcGFyYW0gZGVjaW1hbHMgLSBUaGUgZXhwb25lbnQgdG8gbXVsdGlwbHkgdGhlIFZhbHVlIGJ5LlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUsIGRlY2ltYWxzID0gMCkge1xuICAgIGlmICghL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWREZWNpbWFsTnVtYmVyRXJyb3IoeyB2YWx1ZSB9KTtcbiAgICBsZXQgW2ludGVnZXIgPSAnJywgZnJhY3Rpb24gPSAnMCddID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IGludGVnZXIuc3RhcnRzV2l0aCgnLScpO1xuICAgIGlmIChuZWdhdGl2ZSlcbiAgICAgICAgaW50ZWdlciA9IGludGVnZXIuc2xpY2UoMSk7XG4gICAgLy8gdHJpbSB0cmFpbGluZyB6ZXJvcy5cbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnJlcGxhY2UoLygwKykkLywgJycpO1xuICAgIC8vIHJvdW5kIG9mZiBpZiB0aGUgZnJhY3Rpb24gaXMgbGFyZ2VyIHRoYW4gdGhlIG51bWJlciBvZiBkZWNpbWFscy5cbiAgICBpZiAoZGVjaW1hbHMgPT09IDApIHtcbiAgICAgICAgaWYgKE1hdGgucm91bmQoTnVtYmVyKGAuJHtmcmFjdGlvbn1gKSkgPT09IDEpXG4gICAgICAgICAgICBpbnRlZ2VyID0gYCR7QmlnSW50KGludGVnZXIpICsgMW59YDtcbiAgICAgICAgZnJhY3Rpb24gPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAoZnJhY3Rpb24ubGVuZ3RoID4gZGVjaW1hbHMpIHtcbiAgICAgICAgY29uc3QgW2xlZnQsIHVuaXQsIHJpZ2h0XSA9IFtcbiAgICAgICAgICAgIGZyYWN0aW9uLnNsaWNlKDAsIGRlY2ltYWxzIC0gMSksXG4gICAgICAgICAgICBmcmFjdGlvbi5zbGljZShkZWNpbWFscyAtIDEsIGRlY2ltYWxzKSxcbiAgICAgICAgICAgIGZyYWN0aW9uLnNsaWNlKGRlY2ltYWxzKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoTnVtYmVyKGAke3VuaXR9LiR7cmlnaHR9YCkpO1xuICAgICAgICBpZiAocm91bmRlZCA+IDkpXG4gICAgICAgICAgICBmcmFjdGlvbiA9IGAke0JpZ0ludChsZWZ0KSArIEJpZ0ludCgxKX0wYC5wYWRTdGFydChsZWZ0Lmxlbmd0aCArIDEsICcwJyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZyYWN0aW9uID0gYCR7bGVmdH0ke3JvdW5kZWR9YDtcbiAgICAgICAgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IGRlY2ltYWxzKSB7XG4gICAgICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnNsaWNlKDEpO1xuICAgICAgICAgICAgaW50ZWdlciA9IGAke0JpZ0ludChpbnRlZ2VyKSArIDFufWA7XG4gICAgICAgIH1cbiAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zbGljZSgwLCBkZWNpbWFscyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnBhZEVuZChkZWNpbWFscywgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChgJHtuZWdhdGl2ZSA/ICctJyA6ICcnfSR7aW50ZWdlcn0ke2ZyYWN0aW9ufWApO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgRXRoZXIgdG8gYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbUV0aGVyKCc0MjAnKVxuICogLy8gQGxvZzogNDIwMDAwMDAwMDAwMDAwMDAwMDAwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGV0aGVyIC0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEV0aGVyLlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBwYXJzZSB0by4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBBIGBiaWdpbnRgIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV0aGVyKGV0aGVyLCB1bml0ID0gJ3dlaScpIHtcbiAgICByZXR1cm4gZnJvbShldGhlciwgZXhwb25lbnRzLmV0aGVyIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEd3ZWkgdG8gYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbUd3ZWkoJzQyMCcpXG4gKiAvLyBAbG9nOiA0MjAwMDAwMDAwMDBuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZ3dlaSAtIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBHd2VpLlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBwYXJzZSB0by4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBBIGBiaWdpbnRgIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUd3ZWkoZ3dlaSwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZyb20oZ3dlaSwgZXhwb25lbnRzLmd3ZWkgLSBleHBvbmVudHNbdW5pdF0pO1xufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRlY2ltYWwgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mcm9tRXRoZXIoJzEyMy40NTYuNzg5JylcbiAqIC8vIEBlcnJvcjogVmFsdWUuSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvcjogVmFsdWUgYDEyMy40NTYuNzg5YCBpcyBub3QgYSB2YWxpZCBkZWNpbWFsIG51bWJlci5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGEgdmFsaWQgZGVjaW1hbCBudW1iZXIuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdWYWx1ZS5JbnZhbGlkRGVjaW1hbE51bWJlckVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYWx1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Value.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/WebAuthnP256.js":
/*!****************************************************!*\
  !*** ../node_modules/ox/_esm/core/WebAuthnP256.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CredentialCreationFailedError: () => (/* binding */ CredentialCreationFailedError),\n/* harmony export */   CredentialRequestFailedError: () => (/* binding */ CredentialRequestFailedError),\n/* harmony export */   createChallenge: () => (/* binding */ createChallenge),\n/* harmony export */   createCredential: () => (/* binding */ createCredential),\n/* harmony export */   getAuthenticatorData: () => (/* binding */ getAuthenticatorData),\n/* harmony export */   getClientDataJSON: () => (/* binding */ getClientDataJSON),\n/* harmony export */   getCredentialCreationOptions: () => (/* binding */ getCredentialCreationOptions),\n/* harmony export */   getCredentialRequestOptions: () => (/* binding */ getCredentialRequestOptions),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _Base64_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Base64.js */ \"../node_modules/ox/_esm/core/Base64.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _P256_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./P256.js */ \"../node_modules/ox/_esm/core/P256.js\");\n/* harmony import */ var _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/webauthn.js */ \"../node_modules/ox/_esm/core/internal/webauthn.js\");\n\n\n\n\n\n\n\nconst createChallenge = Uint8Array.from([\n    105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n]);\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nasync function createCredential(options) {\n    const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options;\n    const creationOptions = getCredentialCreationOptions(rest);\n    try {\n        const credential = (await createFn(creationOptions));\n        if (!credential)\n            throw new CredentialCreationFailedError();\n        const response = credential.response;\n        const publicKey = await _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__.parseCredentialPublicKey(response);\n        return {\n            id: credential.id,\n            publicKey,\n            raw: credential,\n        };\n    }\n    catch (error) {\n        throw new CredentialCreationFailedError({\n            cause: error,\n        });\n    }\n}\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nfunction getAuthenticatorData(options = {}) {\n    const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options;\n    const rpIdHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(rpId));\n    const flag_bytes = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(flag, { size: 1 });\n    const signCount_bytes = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(signCount, { size: 4 });\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(rpIdHash, flag_bytes, signCount_bytes);\n}\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nfunction getClientDataJSON(options) {\n    const { challenge, crossOrigin = false, extraClientData, origin = window.location.origin, } = options;\n    return JSON.stringify({\n        type: 'webauthn.get',\n        challenge: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(challenge, { url: true, pad: false }),\n        origin,\n        crossOrigin,\n        ...extraClientData,\n    });\n}\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nfunction getCredentialCreationOptions(options) {\n    const { attestation = 'none', authenticatorSelection = {\n        residentKey: 'preferred',\n        requireResidentKey: false,\n        userVerification: 'required',\n    }, challenge = createChallenge, excludeCredentialIds, name: name_, rp = {\n        id: window.location.hostname,\n        name: window.document.title,\n    }, user, extensions, } = options;\n    const name = (user?.name ?? name_);\n    return {\n        publicKey: {\n            attestation,\n            authenticatorSelection,\n            challenge,\n            ...(excludeCredentialIds\n                ? {\n                    excludeCredentials: excludeCredentialIds?.map((id) => ({\n                        id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(id),\n                        type: 'public-key',\n                    })),\n                }\n                : {}),\n            pubKeyCredParams: [\n                {\n                    type: 'public-key',\n                    alg: -7, // p256\n                },\n            ],\n            rp,\n            user: {\n                id: user?.id ?? _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(name), { as: 'Bytes' }),\n                name,\n                displayName: user?.displayName ?? name,\n            },\n            extensions,\n        },\n    };\n}\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nfunction getCredentialRequestOptions(options) {\n    const { credentialId, challenge, rpId = window.location.hostname, userVerification = 'required', } = options;\n    return {\n        publicKey: {\n            ...(credentialId\n                ? {\n                    allowCredentials: Array.isArray(credentialId)\n                        ? credentialId.map((id) => ({\n                            id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(id),\n                            type: 'public-key',\n                        }))\n                        : [\n                            {\n                                id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(credentialId),\n                                type: 'public-key',\n                            },\n                        ],\n                }\n                : {}),\n            challenge: _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(challenge),\n            rpId,\n            userVerification,\n        },\n    };\n}\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nfunction getSignPayload(options) {\n    const { challenge, crossOrigin, extraClientData, flag, origin, rpId, signCount, userVerification = 'required', } = options;\n    const authenticatorData = getAuthenticatorData({\n        flag,\n        rpId,\n        signCount,\n    });\n    const clientDataJSON = getClientDataJSON({\n        challenge,\n        crossOrigin,\n        extraClientData,\n        origin,\n    });\n    const clientDataJSONHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(clientDataJSON));\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n    const typeIndex = clientDataJSON.indexOf('\"type\"');\n    const metadata = {\n        authenticatorData,\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired: userVerification === 'required',\n    };\n    const payload = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(authenticatorData, clientDataJSONHash);\n    return { metadata, payload };\n}\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nasync function sign(options) {\n    const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options;\n    const requestOptions = getCredentialRequestOptions(rest);\n    try {\n        const credential = (await getFn(requestOptions));\n        if (!credential)\n            throw new CredentialRequestFailedError();\n        const response = credential.response;\n        const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));\n        const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n        const typeIndex = clientDataJSON.indexOf('\"type\"');\n        const signature = _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__.parseAsn1Signature(new Uint8Array(response.signature));\n        return {\n            metadata: {\n                authenticatorData: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(new Uint8Array(response.authenticatorData)),\n                clientDataJSON,\n                challengeIndex,\n                typeIndex,\n                userVerificationRequired: requestOptions.publicKey.userVerification === 'required',\n            },\n            signature,\n            raw: credential,\n        };\n    }\n    catch (error) {\n        throw new CredentialRequestFailedError({\n            cause: error,\n        });\n    }\n}\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nfunction verify(options) {\n    const { challenge, hash = true, metadata, publicKey, signature } = options;\n    const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired, } = metadata;\n    const authenticatorDataBytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(authenticatorData);\n    // Check length of `authenticatorData`.\n    if (authenticatorDataBytes.length < 37)\n        return false;\n    const flag = authenticatorDataBytes[32];\n    // Verify that the UP bit of the flags in authData is set.\n    if ((flag & 0x01) !== 0x01)\n        return false;\n    // If user verification was determined to be required, verify that\n    // the UV bit of the flags in authData is set. Otherwise, ignore the\n    // value of the UV flag.\n    if (userVerificationRequired && (flag & 0x04) !== 0x04)\n        return false;\n    // If the BE bit of the flags in authData is not set, verify that\n    // the BS bit is not set.\n    if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10)\n        return false;\n    // Check that response is for an authentication assertion\n    const type = '\"type\":\"webauthn.get\"';\n    if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1))\n        return false;\n    // Check that hash is in the clientDataJSON.\n    const match = clientDataJSON\n        .slice(Number(challengeIndex))\n        .match(/^\"challenge\":\"(.*?)\"/);\n    if (!match)\n        return false;\n    // Validate the challenge in the clientDataJSON.\n    const [_, challenge_extracted] = match;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(challenge_extracted)) !== challenge)\n        return false;\n    const clientDataJSONHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(clientDataJSON), {\n        as: 'Bytes',\n    });\n    const payload = _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.concat(authenticatorDataBytes, clientDataJSONHash);\n    return _P256_js__WEBPACK_IMPORTED_MODULE_5__.verify({\n        hash,\n        payload,\n        publicKey,\n        signature,\n    });\n}\n/** Thrown when a WebAuthn P256 credential creation fails. */\nclass CredentialCreationFailedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ cause } = {}) {\n        super('Failed to create credential.', {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WebAuthnP256.CredentialCreationFailedError'\n        });\n    }\n}\n/** Thrown when a WebAuthn P256 credential request fails. */\nclass CredentialRequestFailedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ cause } = {}) {\n        super('Failed to request credential.', {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WebAuthnP256.CredentialRequestFailedError'\n        });\n    }\n}\n//# sourceMappingURL=WebAuthnP256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XZWJBdXRoblAyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ0Y7QUFDRTtBQUNKO0FBQ0Y7QUFDRTtBQUNpQjtBQUM1QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSw2RkFBNkY7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJFQUFpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUNBQXVDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDO0FBQ2pELFlBQVksMkRBQTJEO0FBQ3ZFLHFCQUFxQiw0Q0FBVyxDQUFDLCtDQUFjO0FBQy9DLHVCQUF1QiwrQ0FBYyxTQUFTLFNBQVM7QUFDdkQsNEJBQTRCLCtDQUFjLGNBQWMsU0FBUztBQUNqRSxXQUFXLDJDQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQ0FBc0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1Q0FBdUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDhGQUE4RjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLG9GQUFvRjtBQUNoRztBQUNBO0FBQ0EsbUJBQW1CLCtDQUFjLGNBQWMsdUJBQXVCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBYztBQUMxQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQWMsQ0FBQyxpREFBZ0IsVUFBVSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDJGQUEyRjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQWM7QUFDOUM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9DQUFvQywrQ0FBYztBQUNsRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHVCQUF1Qiw4Q0FBYTtBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsaUNBQWlDO0FBQ3JHLElBQUkseUNBQXlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBLFdBQVcsb0JBQW9CLGdDQUFnQztBQUMvRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxSUFBcUk7QUFDdks7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHlHQUF5RztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQiw0Q0FBVyxDQUFDLCtDQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBVTtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLHNCQUFzQiw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUlBQXFJO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSx1RkFBdUY7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFFQUEyQjtBQUNyRDtBQUNBO0FBQ0EsbUNBQW1DLDhDQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHlEQUF5RDtBQUNyRSxZQUFZLDBGQUEwRjtBQUN0RyxtQ0FBbUMsOENBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFhLENBQUMsK0NBQWM7QUFDcEM7QUFDQSwrQkFBK0IsNENBQVcsQ0FBQyxpREFBZ0I7QUFDM0Q7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDZDQUFZO0FBQ2hDLFdBQVcsNENBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPLDRDQUE0QyxpREFBZ0I7QUFDbkUsa0JBQWtCLFFBQVEsSUFBSTtBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLGlEQUFnQjtBQUNsRSxrQkFBa0IsUUFBUSxJQUFJO0FBQzlCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XZWJBdXRoblAyNTYuanM/OWYwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCYXNlNjQgZnJvbSAnLi9CYXNlNjQuanMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFAyNTYgZnJvbSAnLi9QMjU2LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvd2ViYXV0aG4uanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNoYWxsZW5nZSA9IFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgMTA1LCAxNzEsIDE4MCwgMTgxLCAxNjAsIDIyMiwgNzUsIDE5OCwgNDIsIDQyLCAzMiwgMzEsIDE0MSwgMzcsIDE4NiwgMjMzLFxuXSk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgV2ViQXV0aG4gUDI1NiBDcmVkZW50aWFsLCB3aGljaCBjYW4gYmUgc3RvcmVkIGFuZCBsYXRlciB1c2VkIGZvciBzaWduaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5jcmVhdGVDcmVkZW50aWFsKHsgbmFtZTogJ0V4YW1wbGUnIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgaWQ6ICdvWjQ4Li4uJyxcbiAqIC8vIEBsb2c6ICAgcHVibGljS2V5OiB7IHg6IDUxNDIxLi4uNTEyM24sIHk6IDEyMzQ1Li4uNjc4OW4gfSxcbiAqIC8vIEBsb2c6ICAgcmF3OiBQdWJsaWNLZXlDcmVkZW50aWFsIHt9LFxuICogLy8gQGxvZzogfVxuICpcbiAqIGNvbnN0IHsgbWV0YWRhdGEsIHNpZ25hdHVyZSB9ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnNpZ24oe1xuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsXG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gQ3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgQSBXZWJBdXRobiBQMjU2IGNyZWRlbnRpYWwuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDcmVkZW50aWFsKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNyZWF0ZUZuID0gd2luZG93Lm5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUuYmluZCh3aW5kb3cubmF2aWdhdG9yLmNyZWRlbnRpYWxzKSwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjcmVhdGlvbk9wdGlvbnMgPSBnZXRDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKHJlc3QpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWwgPSAoYXdhaXQgY3JlYXRlRm4oY3JlYXRpb25PcHRpb25zKSk7XG4gICAgICAgIGlmICghY3JlZGVudGlhbClcbiAgICAgICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsQ3JlYXRpb25GYWlsZWRFcnJvcigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGNyZWRlbnRpYWwucmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGludGVybmFsLnBhcnNlQ3JlZGVudGlhbFB1YmxpY0tleShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICAgIHJhdzogY3JlZGVudGlhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsQ3JlYXRpb25GYWlsZWRFcnJvcih7XG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgYXV0aGVudGljYXRvciBkYXRhIHdoaWNoIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogcHJvY2Vzc2luZyBvZiBhbiBhdXRoZW50aWNhdG9yIHJlcXVlc3QgKGllLiBmcm9tIGBXZWJBdXRoblAyNTYuc2lnbmApLlxuICpcbiAqIDo6Ondhcm5pbmdcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG1haW5seSBmb3IgdGVzdGluZyBwdXJwb3NlcyBvciBmb3IgbWFudWFsbHkgY29uc3RydWN0aW5nXG4gKiBhdXRlbnRpY2F0b3IgZGF0YS4gSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCBub3QgbmVlZCB0aGlzIGZ1bmN0aW9uLlxuICogYGF1dGhlbnRpY2F0b3JEYXRhYCBpcyB0eXBpY2FsbHkgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGVcbiAqIHtAbGluayBveCNXZWJBdXRoblAyNTYuKHNpZ246ZnVuY3Rpb24pfSByZXNwb25zZSAoaWUuIGFuIGF1dGhlbnRpY2F0b3IgcmVzcG9uc2UpLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aGVudGljYXRvckRhdGEgPSBXZWJBdXRoblAyNTYuZ2V0QXV0aGVudGljYXRvckRhdGEoe1xuICogICBycElkOiAnZXhhbXBsZS5jb20nLFxuICogICBzaWduQ291bnQ6IDQyMCxcbiAqIH0pXG4gKiAvLyBAbG9nOiBcIjB4YTM3OWE2ZjZlZWFmYjlhNTVlMzc4YzExODAzNGUyNzUxZTY4MmZhYjlmMmQzMGFiMTNkMjEyNTU4NmNlMTk0NzA1MDAwMDAxYTRcIlxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbnN0cnVjdCB0aGUgYXV0aGVudGljYXRvciBkYXRhLlxuICogQHJldHVybnMgVGhlIGF1dGhlbnRpY2F0b3IgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhlbnRpY2F0b3JEYXRhKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZmxhZyA9IDUsIHJwSWQgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIHNpZ25Db3VudCA9IDAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcnBJZEhhc2ggPSBIYXNoLnNoYTI1NihIZXguZnJvbVN0cmluZyhycElkKSk7XG4gICAgY29uc3QgZmxhZ19ieXRlcyA9IEhleC5mcm9tTnVtYmVyKGZsYWcsIHsgc2l6ZTogMSB9KTtcbiAgICBjb25zdCBzaWduQ291bnRfYnl0ZXMgPSBIZXguZnJvbU51bWJlcihzaWduQ291bnQsIHsgc2l6ZTogNCB9KTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChycElkSGFzaCwgZmxhZ19ieXRlcywgc2lnbkNvdW50X2J5dGVzKTtcbn1cbi8qKlxuICogQ29uc3RydWN0cyB0aGUgQ2xpZW50IERhdGEgaW4gc3RyaW5naWZpZWQgSlNPTiBmb3JtYXQgd2hpY2ggcmVwcmVzZW50cyBjbGllbnQgZGF0YSB0aGF0XG4gKiB3YXMgcGFzc2VkIHRvIGBjcmVkZW50aWFscy5nZXQoKWAgaW4ge0BsaW5rIG94I1dlYkF1dGhuUDI1Ni4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIDo6Ondhcm5pbmdcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG1haW5seSBmb3IgdGVzdGluZyBwdXJwb3NlcyBvciBmb3IgbWFudWFsbHkgY29uc3RydWN0aW5nXG4gKiBjbGllbnQgZGF0YS4gSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCBub3QgbmVlZCB0aGlzIGZ1bmN0aW9uLlxuICogYGNsaWVudERhdGFKU09OYCBpcyB0eXBpY2FsbHkgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGVcbiAqIHtAbGluayBveCNXZWJBdXRoblAyNTYuKHNpZ246ZnVuY3Rpb24pfSByZXNwb25zZSAoaWUuIGFuIGF1dGhlbnRpY2F0b3IgcmVzcG9uc2UpLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgY2xpZW50RGF0YUpTT04gPSBXZWJBdXRoblAyNTYuZ2V0Q2xpZW50RGF0YUpTT04oe1xuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJyxcbiAqICAgb3JpZ2luOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScsXG4gKiB9KVxuICogLy8gQGxvZzogXCJ7XCJ0eXBlXCI6XCJ3ZWJhdXRobi5nZXRcIixcImNoYWxsZW5nZVwiOlwiM3EyLTd3XCIsXCJvcmlnaW5cIjpcImh0dHBzOi8vZXhhbXBsZS5jb21cIixcImNyb3NzT3JpZ2luXCI6ZmFsc2V9XCJcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25zdHJ1Y3QgdGhlIGNsaWVudCBkYXRhLlxuICogQHJldHVybnMgVGhlIGNsaWVudCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50RGF0YUpTT04ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hhbGxlbmdlLCBjcm9zc09yaWdpbiA9IGZhbHNlLCBleHRyYUNsaWVudERhdGEsIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6ICd3ZWJhdXRobi5nZXQnLFxuICAgICAgICBjaGFsbGVuZ2U6IEJhc2U2NC5mcm9tSGV4KGNoYWxsZW5nZSwgeyB1cmw6IHRydWUsIHBhZDogZmFsc2UgfSksXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgY3Jvc3NPcmlnaW4sXG4gICAgICAgIC4uLmV4dHJhQ2xpZW50RGF0YSxcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3JlYXRpb24gb3B0aW9ucyBmb3IgYSBQMjU2IFdlYkF1dGhuIENyZWRlbnRpYWwgdG8gYmUgdXNlZCB3aXRoXG4gKiB0aGUgV2ViIEF1dGhlbnRpY2F0aW9uIEFQSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IG9wdGlvbnMgPSBXZWJBdXRoblAyNTYuZ2V0Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyh7IG5hbWU6ICdFeGFtcGxlJyB9KVxuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCB3aW5kb3cubmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZShvcHRpb25zKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXR0ZXN0YXRpb24gPSAnbm9uZScsIGF1dGhlbnRpY2F0b3JTZWxlY3Rpb24gPSB7XG4gICAgICAgIHJlc2lkZW50S2V5OiAncHJlZmVycmVkJyxcbiAgICAgICAgcmVxdWlyZVJlc2lkZW50S2V5OiBmYWxzZSxcbiAgICAgICAgdXNlclZlcmlmaWNhdGlvbjogJ3JlcXVpcmVkJyxcbiAgICB9LCBjaGFsbGVuZ2UgPSBjcmVhdGVDaGFsbGVuZ2UsIGV4Y2x1ZGVDcmVkZW50aWFsSWRzLCBuYW1lOiBuYW1lXywgcnAgPSB7XG4gICAgICAgIGlkOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICAgIG5hbWU6IHdpbmRvdy5kb2N1bWVudC50aXRsZSxcbiAgICB9LCB1c2VyLCBleHRlbnNpb25zLCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBuYW1lID0gKHVzZXI/Lm5hbWUgPz8gbmFtZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgICAgYXR0ZXN0YXRpb24sXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yU2VsZWN0aW9uLFxuICAgICAgICAgICAgY2hhbGxlbmdlLFxuICAgICAgICAgICAgLi4uKGV4Y2x1ZGVDcmVkZW50aWFsSWRzXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDcmVkZW50aWFsczogZXhjbHVkZUNyZWRlbnRpYWxJZHM/Lm1hcCgoaWQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogQmFzZTY0LnRvQnl0ZXMoaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgcHViS2V5Q3JlZFBhcmFtczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgICAgICAgICBhbGc6IC03LCAvLyBwMjU2XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBycCxcbiAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogdXNlcj8uaWQgPz8gSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyhuYW1lKSwgeyBhczogJ0J5dGVzJyB9KSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiB1c2VyPy5kaXNwbGF5TmFtZSA/PyBuYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWVzdCBvcHRpb25zIHRvIHNpZ24gYSBjaGFsbGVuZ2Ugd2l0aCB0aGUgV2ViIEF1dGhlbnRpY2F0aW9uIEFQSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IG9wdGlvbnMgPSBXZWJBdXRoblAyNTYuZ2V0Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKHtcbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCB3aW5kb3cubmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldChvcHRpb25zKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNyZWRlbnRpYWxJZCwgY2hhbGxlbmdlLCBycElkID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLCB1c2VyVmVyaWZpY2F0aW9uID0gJ3JlcXVpcmVkJywgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVibGljS2V5OiB7XG4gICAgICAgICAgICAuLi4oY3JlZGVudGlhbElkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q3JlZGVudGlhbHM6IEFycmF5LmlzQXJyYXkoY3JlZGVudGlhbElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVkZW50aWFsSWQubWFwKChpZCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogQmFzZTY0LnRvQnl0ZXMoaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogQmFzZTY0LnRvQnl0ZXMoY3JlZGVudGlhbElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIGNoYWxsZW5nZTogQnl0ZXMuZnJvbUhleChjaGFsbGVuZ2UpLFxuICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgIHVzZXJWZXJpZmljYXRpb24sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ29uc3RydWN0cyB0aGUgZmluYWwgZGlnZXN0IHRoYXQgd2FzIHNpZ25lZCBhbmQgY29tcHV0ZWQgYnkgdGhlIGF1dGhlbnRpY2F0b3IuIFRoaXMgcGF5bG9hZCBpbmNsdWRlc1xuICogdGhlIGNyeXB0b2dyYXBoaWMgYGNoYWxsZW5nZWAsIGFzIHdlbGwgYXMgYXV0aGVudGljYXRvciBtZXRhZGF0YSAoYGF1dGhlbnRpY2F0b3JEYXRhYCArIGBjbGllbnREYXRhSlNPTmApLlxuICogVGhpcyB2YWx1ZSBjYW4gYmUgYWxzbyB1c2VkIHdpdGggcmF3IFAyNTYgdmVyaWZpY2F0aW9uIChzdWNoIGFzIHtAbGluayBveCNQMjU2Lih2ZXJpZnk6ZnVuY3Rpb24pfSBvclxuICoge0BsaW5rIG94I1dlYkNyeXB0b1AyNTYuKHZlcmlmeTpmdW5jdGlvbil9KS5cbiAqXG4gKiA6Ojp3YXJuaW5nXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBtYWlubHkgZm9yIHRlc3RpbmcgcHVycG9zZXMgb3IgZm9yIG1hbnVhbGx5IGNvbnN0cnVjdGluZ1xuICogc2lnbmluZyBwYXlsb2Fkcy4gSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCBub3QgbmVlZCB0aGlzIGZ1bmN0aW9uIGFuZFxuICogaW5zdGVhZCB1c2Uge0BsaW5rIG94I1dlYkF1dGhuUDI1Ni4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2LCBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgcGF5bG9hZCB9ID0gV2ViQXV0aG5QMjU2LmdldFNpZ25QYXlsb2FkKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBtZXRhZGF0YToge1xuICogLy8gQGxvZzogICAgIGF1dGhlbnRpY2F0b3JEYXRhOiBcIjB4NDk5NjBkZTU4ODBlOGM2ODc0MzQxNzBmNjQ3NjYwNWI4ZmU0YWViOWEyODYzMmM3OTk1Y2YzYmE4MzFkOTc2MzA1MDAwMDAwMDBcIixcbiAqIC8vIEBsb2c6ICAgICBjaGFsbGVuZ2VJbmRleDogMjMsXG4gKiAvLyBAbG9nOiAgICAgY2xpZW50RGF0YUpTT046IFwie1widHlwZVwiOlwid2ViYXV0aG4uZ2V0XCIsXCJjaGFsbGVuZ2VcIjpcIjlqRUZpanVoRVdyTTRTT1ctdENoSmJVRUhFUDQ0VmNqY0otQnFvMWZUTThcIixcIm9yaWdpblwiOlwiaHR0cDovL2xvY2FsaG9zdDo1MTczXCIsXCJjcm9zc09yaWdpblwiOmZhbHNlfVwiLFxuICogLy8gQGxvZzogICAgIHR5cGVJbmRleDogMSxcbiAqIC8vIEBsb2c6ICAgICB1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQ6IHRydWUsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHBheWxvYWQ6IFwiMHg0OTk2MGRlNTg4MGU4YzY4NzQzNDE3MGY2NDc2NjA1YjhmZTRhZWI5YTI4NjMyYzc5OTVjZjNiYTgzMWQ5NzYzMDUwMDAwMDAwMDQ1MDg2ZGNiMDZhNWYyMzRkYjYyNWJjZGM5NGU2NTdmODZiNzZiNmZkM2ViOWMzMDU0M2VhYmMxZTU3N2E0YjBcIixcbiAqIC8vIEBsb2c6IH1cbiAqXG4gKiBjb25zdCB7IHB1YmxpY0tleSwgcHJpdmF0ZUtleSB9ID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oe1xuICogICBwYXlsb2FkLFxuICogICBwcml2YXRlS2V5LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25zdHJ1Y3QgdGhlIHNpZ25pbmcgcGF5bG9hZC5cbiAqIEByZXR1cm5zIFRoZSBzaWduaW5nIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGFsbGVuZ2UsIGNyb3NzT3JpZ2luLCBleHRyYUNsaWVudERhdGEsIGZsYWcsIG9yaWdpbiwgcnBJZCwgc2lnbkNvdW50LCB1c2VyVmVyaWZpY2F0aW9uID0gJ3JlcXVpcmVkJywgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXV0aGVudGljYXRvckRhdGEgPSBnZXRBdXRoZW50aWNhdG9yRGF0YSh7XG4gICAgICAgIGZsYWcsXG4gICAgICAgIHJwSWQsXG4gICAgICAgIHNpZ25Db3VudCxcbiAgICB9KTtcbiAgICBjb25zdCBjbGllbnREYXRhSlNPTiA9IGdldENsaWVudERhdGFKU09OKHtcbiAgICAgICAgY2hhbGxlbmdlLFxuICAgICAgICBjcm9zc09yaWdpbixcbiAgICAgICAgZXh0cmFDbGllbnREYXRhLFxuICAgICAgICBvcmlnaW4sXG4gICAgfSk7XG4gICAgY29uc3QgY2xpZW50RGF0YUpTT05IYXNoID0gSGFzaC5zaGEyNTYoSGV4LmZyb21TdHJpbmcoY2xpZW50RGF0YUpTT04pKTtcbiAgICBjb25zdCBjaGFsbGVuZ2VJbmRleCA9IGNsaWVudERhdGFKU09OLmluZGV4T2YoJ1wiY2hhbGxlbmdlXCInKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBjbGllbnREYXRhSlNPTi5pbmRleE9mKCdcInR5cGVcIicpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICBhdXRoZW50aWNhdG9yRGF0YSxcbiAgICAgICAgY2xpZW50RGF0YUpTT04sXG4gICAgICAgIGNoYWxsZW5nZUluZGV4LFxuICAgICAgICB0eXBlSW5kZXgsXG4gICAgICAgIHVzZXJWZXJpZmljYXRpb25SZXF1aXJlZDogdXNlclZlcmlmaWNhdGlvbiA9PT0gJ3JlcXVpcmVkJyxcbiAgICB9O1xuICAgIGNvbnN0IHBheWxvYWQgPSBIZXguY29uY2F0KGF1dGhlbnRpY2F0b3JEYXRhLCBjbGllbnREYXRhSlNPTkhhc2gpO1xuICAgIHJldHVybiB7IG1ldGFkYXRhLCBwYXlsb2FkIH07XG59XG4vKipcbiAqIFNpZ25zIGEgY2hhbGxlbmdlIHVzaW5nIGEgc3RvcmVkIFdlYkF1dGhuIFAyNTYgQ3JlZGVudGlhbC4gSWYgbm8gQ3JlZGVudGlhbCBpcyBwcm92aWRlZCxcbiAqIGEgcHJvbXB0IHdpbGwgYmUgZGlzcGxheWVkIGZvciB0aGUgdXNlciB0byBzZWxlY3QgYW4gZXhpc3RpbmcgQ3JlZGVudGlhbFxuICogdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5jcmVhdGVDcmVkZW50aWFsKHtcbiAqICAgbmFtZTogJ0V4YW1wbGUnLFxuICogfSlcbiAqXG4gKiBjb25zdCB7IG1ldGFkYXRhLCBzaWduYXR1cmUgfSA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5zaWduKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsIC8vIFshY29kZSBmb2N1c11cbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgbWV0YWRhdGE6IHtcbiAqIC8vIEBsb2c6ICAgICBhdXRoZW50aWNhdG9yRGF0YTogJzB4NDk5NjBkZTU4ODBlOGM2ODc0MzQxNzBmNjQ3NjYwNWI4ZmU0YWViOWEyODYzMmM3OTk1Y2YzYmE4MzFkOTc2MzA1MDAwMDAwMDAnLFxuICogLy8gQGxvZzogICAgIGNsaWVudERhdGFKU09OOiAne1widHlwZVwiOlwid2ViYXV0aG4uZ2V0XCIsXCJjaGFsbGVuZ2VcIjpcIjlqRUZpanVoRVdyTTRTT1ctdENoSmJVRUhFUDQ0VmNqY0otQnFvMWZUTThcIixcIm9yaWdpblwiOlwiaHR0cDovL2xvY2FsaG9zdDo1MTczXCIsXCJjcm9zc09yaWdpblwiOmZhbHNlfScsXG4gKiAvLyBAbG9nOiAgICAgY2hhbGxlbmdlSW5kZXg6IDIzLFxuICogLy8gQGxvZzogICAgIHR5cGVJbmRleDogMSxcbiAqIC8vIEBsb2c6ICAgICB1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQ6IHRydWUsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHNpZ25hdHVyZTogeyByOiA1MTIzMS4uLjQyMTVuLCBzOiAxMjM0NS4uLjY3ODluIH0sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBnZXRGbiA9IHdpbmRvdy5uYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0LmJpbmQod2luZG93Lm5hdmlnYXRvci5jcmVkZW50aWFscyksIC4uLnJlc3QgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBnZXRDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMocmVzdCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IChhd2FpdCBnZXRGbihyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbFJlcXVlc3RGYWlsZWRFcnJvcigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGNyZWRlbnRpYWwucmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IGNsaWVudERhdGFKU09OID0gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShyZXNwb25zZS5jbGllbnREYXRhSlNPTikpO1xuICAgICAgICBjb25zdCBjaGFsbGVuZ2VJbmRleCA9IGNsaWVudERhdGFKU09OLmluZGV4T2YoJ1wiY2hhbGxlbmdlXCInKTtcbiAgICAgICAgY29uc3QgdHlwZUluZGV4ID0gY2xpZW50RGF0YUpTT04uaW5kZXhPZignXCJ0eXBlXCInKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gaW50ZXJuYWwucGFyc2VBc24xU2lnbmF0dXJlKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLnNpZ25hdHVyZSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogSGV4LmZyb21CeXRlcyhuZXcgVWludDhBcnJheShyZXNwb25zZS5hdXRoZW50aWNhdG9yRGF0YSkpLFxuICAgICAgICAgICAgICAgIGNsaWVudERhdGFKU09OLFxuICAgICAgICAgICAgICAgIGNoYWxsZW5nZUluZGV4LFxuICAgICAgICAgICAgICAgIHR5cGVJbmRleCxcbiAgICAgICAgICAgICAgICB1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQ6IHJlcXVlc3RPcHRpb25zLnB1YmxpY0tleS51c2VyVmVyaWZpY2F0aW9uID09PSAncmVxdWlyZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgIHJhdzogY3JlZGVudGlhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsUmVxdWVzdEZhaWxlZEVycm9yKHtcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBWZXJpZmllcyBhIHNpZ25hdHVyZSB1c2luZyB0aGUgQ3JlZGVudGlhbCdzIHB1YmxpYyBrZXkgYW5kIHRoZSBjaGFsbGVuZ2Ugd2hpY2ggd2FzIHNpZ25lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCBXZWJBdXRoblAyNTYuY3JlYXRlQ3JlZGVudGlhbCh7XG4gKiAgIG5hbWU6ICdFeGFtcGxlJyxcbiAqIH0pXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7XG4gKiAgIGNyZWRlbnRpYWxJZDogY3JlZGVudGlhbC5pZCxcbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1ldGFkYXRhLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleTogY3JlZGVudGlhbC5wdWJsaWNLZXksIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hhbGxlbmdlLCBoYXNoID0gdHJ1ZSwgbWV0YWRhdGEsIHB1YmxpY0tleSwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgYXV0aGVudGljYXRvckRhdGEsIGNoYWxsZW5nZUluZGV4LCBjbGllbnREYXRhSlNPTiwgdHlwZUluZGV4LCB1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQsIH0gPSBtZXRhZGF0YTtcbiAgICBjb25zdCBhdXRoZW50aWNhdG9yRGF0YUJ5dGVzID0gQnl0ZXMuZnJvbUhleChhdXRoZW50aWNhdG9yRGF0YSk7XG4gICAgLy8gQ2hlY2sgbGVuZ3RoIG9mIGBhdXRoZW50aWNhdG9yRGF0YWAuXG4gICAgaWYgKGF1dGhlbnRpY2F0b3JEYXRhQnl0ZXMubGVuZ3RoIDwgMzcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBmbGFnID0gYXV0aGVudGljYXRvckRhdGFCeXRlc1szMl07XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIFVQIGJpdCBvZiB0aGUgZmxhZ3MgaW4gYXV0aERhdGEgaXMgc2V0LlxuICAgIGlmICgoZmxhZyAmIDB4MDEpICE9PSAweDAxKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gSWYgdXNlciB2ZXJpZmljYXRpb24gd2FzIGRldGVybWluZWQgdG8gYmUgcmVxdWlyZWQsIHZlcmlmeSB0aGF0XG4gICAgLy8gdGhlIFVWIGJpdCBvZiB0aGUgZmxhZ3MgaW4gYXV0aERhdGEgaXMgc2V0LiBPdGhlcndpc2UsIGlnbm9yZSB0aGVcbiAgICAvLyB2YWx1ZSBvZiB0aGUgVVYgZmxhZy5cbiAgICBpZiAodXNlclZlcmlmaWNhdGlvblJlcXVpcmVkICYmIChmbGFnICYgMHgwNCkgIT09IDB4MDQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBJZiB0aGUgQkUgYml0IG9mIHRoZSBmbGFncyBpbiBhdXRoRGF0YSBpcyBub3Qgc2V0LCB2ZXJpZnkgdGhhdFxuICAgIC8vIHRoZSBCUyBiaXQgaXMgbm90IHNldC5cbiAgICBpZiAoKGZsYWcgJiAweDA4KSAhPT0gMHgwOCAmJiAoZmxhZyAmIDB4MTApID09PSAweDEwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSBpcyBmb3IgYW4gYXV0aGVudGljYXRpb24gYXNzZXJ0aW9uXG4gICAgY29uc3QgdHlwZSA9ICdcInR5cGVcIjpcIndlYmF1dGhuLmdldFwiJztcbiAgICBpZiAodHlwZSAhPT0gY2xpZW50RGF0YUpTT04uc2xpY2UoTnVtYmVyKHR5cGVJbmRleCksIHR5cGUubGVuZ3RoICsgMSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayB0aGF0IGhhc2ggaXMgaW4gdGhlIGNsaWVudERhdGFKU09OLlxuICAgIGNvbnN0IG1hdGNoID0gY2xpZW50RGF0YUpTT05cbiAgICAgICAgLnNsaWNlKE51bWJlcihjaGFsbGVuZ2VJbmRleCkpXG4gICAgICAgIC5tYXRjaCgvXlwiY2hhbGxlbmdlXCI6XCIoLio/KVwiLyk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFZhbGlkYXRlIHRoZSBjaGFsbGVuZ2UgaW4gdGhlIGNsaWVudERhdGFKU09OLlxuICAgIGNvbnN0IFtfLCBjaGFsbGVuZ2VfZXh0cmFjdGVkXSA9IG1hdGNoO1xuICAgIGlmIChIZXguZnJvbUJ5dGVzKEJhc2U2NC50b0J5dGVzKGNoYWxsZW5nZV9leHRyYWN0ZWQpKSAhPT0gY2hhbGxlbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY2xpZW50RGF0YUpTT05IYXNoID0gSGFzaC5zaGEyNTYoQnl0ZXMuZnJvbVN0cmluZyhjbGllbnREYXRhSlNPTiksIHtcbiAgICAgICAgYXM6ICdCeXRlcycsXG4gICAgfSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IEJ5dGVzLmNvbmNhdChhdXRoZW50aWNhdG9yRGF0YUJ5dGVzLCBjbGllbnREYXRhSlNPTkhhc2gpO1xuICAgIHJldHVybiBQMjU2LnZlcmlmeSh7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgIH0pO1xufVxuLyoqIFRocm93biB3aGVuIGEgV2ViQXV0aG4gUDI1NiBjcmVkZW50aWFsIGNyZWF0aW9uIGZhaWxzLiAqL1xuZXhwb3J0IGNsYXNzIENyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjYXVzZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoJ0ZhaWxlZCB0byBjcmVhdGUgY3JlZGVudGlhbC4nLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdXZWJBdXRoblAyNTYuQ3JlZGVudGlhbENyZWF0aW9uRmFpbGVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiBhIFdlYkF1dGhuIFAyNTYgY3JlZGVudGlhbCByZXF1ZXN0IGZhaWxzLiAqL1xuZXhwb3J0IGNsYXNzIENyZWRlbnRpYWxSZXF1ZXN0RmFpbGVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlIH0gPSB7fSkge1xuICAgICAgICBzdXBlcignRmFpbGVkIHRvIHJlcXVlc3QgY3JlZGVudGlhbC4nLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdXZWJBdXRoblAyNTYuQ3JlZGVudGlhbFJlcXVlc3RGYWlsZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViQXV0aG5QMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/WebAuthnP256.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/WebCryptoP256.js":
/*!*****************************************************!*\
  !*** ../node_modules/ox/_esm/core/WebCryptoP256.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPair: () => (/* binding */ createKeyPair),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/p256 */ \"../node_modules/ox/node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PublicKey.js */ \"../node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nasync function createKeyPair(options = {}) {\n    const { extractable = false } = options;\n    const keypair = await globalThis.crypto.subtle.generateKey({\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n    }, extractable, ['sign', 'verify']);\n    const publicKey_raw = await globalThis.crypto.subtle.exportKey('raw', keypair.publicKey);\n    const publicKey = _PublicKey_js__WEBPACK_IMPORTED_MODULE_0__.from(new Uint8Array(publicKey_raw));\n    return {\n        privateKey: keypair.privateKey,\n        publicKey,\n    };\n}\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nasync function sign(options) {\n    const { payload, privateKey } = options;\n    const signature = await globalThis.crypto.subtle.sign({\n        name: 'ECDSA',\n        hash: 'SHA-256',\n    }, privateKey, _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(payload));\n    const signature_bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromArray(new Uint8Array(signature));\n    const r = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature_bytes, 0, 32));\n    let s = _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature_bytes, 32, 64));\n    if (s > _noble_curves_p256__WEBPACK_IMPORTED_MODULE_2__.p256.CURVE.n / 2n)\n        s = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_2__.p256.CURVE.n - s;\n    return { r, s };\n}\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nasync function verify(options) {\n    const { payload, signature } = options;\n    const publicKey = await globalThis.crypto.subtle.importKey('raw', _PublicKey_js__WEBPACK_IMPORTED_MODULE_0__.toBytes(options.publicKey), { name: 'ECDSA', namedCurve: 'P-256' }, true, ['verify']);\n    return await globalThis.crypto.subtle.verify({\n        name: 'ECDSA',\n        hash: 'SHA-256',\n    }, publicKey, _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(signature.r), _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(signature.s)), _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(payload));\n}\n//# sourceMappingURL=WebCryptoP256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XZWJDcnlwdG9QMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwQztBQUNOO0FBQ1E7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0IsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QztBQUNoRCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsK0NBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNPO0FBQ1AsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsS0FBSyxjQUFjLDJDQUFVO0FBQzdCLDRCQUE0QixnREFBZTtBQUMzQyxjQUFjLCtDQUFjLENBQUMsNENBQVc7QUFDeEMsWUFBWSwrQ0FBYyxDQUFDLDRDQUFXO0FBQ3RDLFlBQVksb0RBQUk7QUFDaEIsWUFBWSxvREFBSTtBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLGdEQUFnRCxtQ0FBbUM7QUFDbkY7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxxQkFBcUI7QUFDakMsc0VBQXNFLGtEQUFpQix1QkFBdUIsb0NBQW9DO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBLEtBQUssYUFBYSw2Q0FBWSxDQUFDLGlEQUFnQixlQUFlLGlEQUFnQixnQkFBZ0IsMkNBQVU7QUFDeEc7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dlYkNyeXB0b1AyNTYuanM/NTgzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwMjU2IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9wMjU2JztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgUHVibGljS2V5IGZyb20gJy4vUHVibGljS2V5LmpzJztcbi8qKlxuICogR2VuZXJhdGVzIGFuIEVDRFNBIFAyNTYga2V5IHBhaXIgdGhhdCBpbmNsdWRlczpcbiAqXG4gKiAtIGEgYHByaXZhdGVLZXlgIG9mIHR5cGUgW2BDcnlwdG9LZXlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvS2V5KVxuICpcbiAqIC0gYSBgcHVibGljS2V5YCBvZiB0eXBlIHtAbGluayBveCNIZXguSGV4fSBvciB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwdWJsaWNLZXksIHByaXZhdGVLZXkgfSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByaXZhdGVLZXk6IENyeXB0b0tleSB7fSxcbiAqIC8vIEBsb2c6ICAgcHVibGljS2V5OiB7XG4gKiAvLyBAbG9nOiAgICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6ICAgICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBrZXkgcGFpci5cbiAqIEByZXR1cm5zIFRoZSBrZXkgcGFpci5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUtleVBhaXIob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleHRyYWN0YWJsZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGtleXBhaXIgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoe1xuICAgICAgICBuYW1lOiAnRUNEU0EnLFxuICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgIH0sIGV4dHJhY3RhYmxlLCBbJ3NpZ24nLCAndmVyaWZ5J10pO1xuICAgIGNvbnN0IHB1YmxpY0tleV9yYXcgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBrZXlwYWlyLnB1YmxpY0tleSk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20obmV3IFVpbnQ4QXJyYXkocHVibGljS2V5X3JhdykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByaXZhdGVLZXk6IGtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgcHVibGljS2V5LFxuICAgIH07XG59XG4vKipcbiAqIFNpZ25zIGEgcGF5bG9hZCB3aXRoIHRoZSBwcm92aWRlZCBgQ3J5cHRvS2V5YCBwcml2YXRlIGtleSBhbmQgcmV0dXJucyBhIFAyNTYgc2lnbmF0dXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQ3J5cHRvUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSB9ID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwcml2YXRlS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDE1MTIzMS4uLjQ0MjNuLFxuICogLy8gQGxvZzogICBzOiA1MTYxMjMuLi41NTEybixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3Igc2lnbmluZyB0aGUgcGF5bG9hZC5cbiAqIEByZXR1cm5zIFRoZSBQMjU2IEVDRFNBIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ24ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGF5bG9hZCwgcHJpdmF0ZUtleSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuc2lnbih7XG4gICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICB9LCBwcml2YXRlS2V5LCBCeXRlcy5mcm9tKHBheWxvYWQpKTtcbiAgICBjb25zdCBzaWduYXR1cmVfYnl0ZXMgPSBCeXRlcy5mcm9tQXJyYXkobmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSk7XG4gICAgY29uc3QgciA9IEJ5dGVzLnRvQmlnSW50KEJ5dGVzLnNsaWNlKHNpZ25hdHVyZV9ieXRlcywgMCwgMzIpKTtcbiAgICBsZXQgcyA9IEJ5dGVzLnRvQmlnSW50KEJ5dGVzLnNsaWNlKHNpZ25hdHVyZV9ieXRlcywgMzIsIDY0KSk7XG4gICAgaWYgKHMgPiBwMjU2LkNVUlZFLm4gLyAybilcbiAgICAgICAgcyA9IHAyNTYuQ1VSVkUubiAtIHM7XG4gICAgcmV0dXJuIHsgciwgcyB9O1xufVxuLyoqXG4gKiBWZXJpZmllcyBhIHBheWxvYWQgd2FzIHNpZ25lZCBieSB0aGUgcHJvdmlkZWQgcHVibGljIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IFdlYkNyeXB0b1AyNTYudmVyaWZ5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHVibGljS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgdmVyaWZpY2F0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwYXlsb2FkIHdhcyBzaWduZWQgYnkgdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGF5bG9hZCwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIFB1YmxpY0tleS50b0J5dGVzKG9wdGlvbnMucHVibGljS2V5KSwgeyBuYW1lOiAnRUNEU0EnLCBuYW1lZEN1cnZlOiAnUC0yNTYnIH0sIHRydWUsIFsndmVyaWZ5J10pO1xuICAgIHJldHVybiBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUudmVyaWZ5KHtcbiAgICAgICAgbmFtZTogJ0VDRFNBJyxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgIH0sIHB1YmxpY0tleSwgQnl0ZXMuY29uY2F0KEJ5dGVzLmZyb21OdW1iZXIoc2lnbmF0dXJlLnIpLCBCeXRlcy5mcm9tTnVtYmVyKHNpZ25hdHVyZS5zKSksIEJ5dGVzLmZyb20ocGF5bG9hZCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViQ3J5cHRvUDI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/WebCryptoP256.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/Withdrawal.js":
/*!**************************************************!*\
  !*** ../node_modules/ox/_esm/core/Withdrawal.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */\nfunction fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */\nfunction toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.amount),\n        index: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.index),\n        validatorIndex: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XaXRoZHJhd2FsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnQztBQUNoQztBQUNBLGVBQWUseUJBQXlCLE9BQU8sK0JBQStCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtCQUErQjtBQUM1RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDLE9BQU8sd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBYztBQUM5QixlQUFlLCtDQUFjO0FBQzdCLHdCQUF3QiwrQ0FBYztBQUN0QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XaXRoZHJhd2FsLmpzPzg0MjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9IHRvIGFuIHtAbGluayBveCNXaXRoZHJhd2FsLldpdGhkcmF3YWx9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJyxcbiAqICAgYW1vdW50OiAnMHg2MjAzMjMnLFxuICogICBpbmRleDogJzB4MCcsXG4gKiAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6IDY0MjMzMzFuLFxuICogLy8gQGxvZzogICBpbmRleDogMCxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3aXRoZHJhd2FsIC0gVGhlIFJQQyB3aXRoZHJhd2FsIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1dpdGhkcmF3YWwuV2l0aGRyYXdhbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHdpdGhkcmF3YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi53aXRoZHJhd2FsLFxuICAgICAgICBhbW91bnQ6IEJpZ0ludCh3aXRoZHJhd2FsLmFtb3VudCksXG4gICAgICAgIGluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXG4gICAgICAgIHZhbGlkYXRvckluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5XaXRoZHJhd2FsfSB0byBhbiB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLnRvUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsXG4gKiAgIGFtb3VudDogNjQyMzMzMW4sXG4gKiAgIGluZGV4OiAwLFxuICogICB2YWxpZGF0b3JJbmRleDogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6ICcweDYyMDMyMycsXG4gKiAvLyBAbG9nOiAgIGluZGV4OiAnMHgwJyxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6ICcweDEnLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdpdGhkcmF3YWwgLSBUaGUgV2l0aGRyYXdhbCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gUlBDIFdpdGhkcmF3YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogd2l0aGRyYXdhbC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuYW1vdW50KSxcbiAgICAgICAgaW5kZXg6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhkcmF3YWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/Withdrawal.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/abi.js":
/*!****************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/abi.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSignatures: () => (/* binding */ isSignatures)\n/* harmony export */ });\n/** @internal */\nfunction isSignatures(value) {\n    for (const item of value) {\n        if (typeof item !== 'string')\n            return false;\n    }\n    return true;\n}\n//# sourceMappingURL=abi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaS5qcz9kZWNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NpZ25hdHVyZXModmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/abi.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/abiItem.js":
/*!********************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/abiItem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAmbiguousTypes: () => (/* binding */ getAmbiguousTypes),\n/* harmony export */   isArgOfType: () => (/* binding */ isArgOfType),\n/* harmony export */   normalizeSignature: () => (/* binding */ normalizeSignature)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n\n\n/** @internal */\nfunction normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError('Unable to normalize signature.');\n    return result;\n}\n/** @internal */\nfunction isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmlJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlDO0FBQ0Y7QUFDdkM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBZ0IsUUFBUSxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUksU0FBUyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWdCO0FBQ3ZDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsdUJBQXVCLGlEQUFnQjtBQUN2QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmlJdGVtLmpzP2JhYTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9FcnJvcnMuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBsZXQgYWN0aXZlID0gdHJ1ZTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgIGxldCBsZXZlbCA9IDA7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGxldCB2YWxpZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzaWduYXR1cmVbaV07XG4gICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3IsIHdlIHdhbnQgdG8gcmVhY3RpdmF0ZS5cbiAgICAgICAgaWYgKFsnKCcsICcpJywgJywnXS5pbmNsdWRlcyhjaGFyKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBcImxldmVsXCIgdG9rZW4sIHdlIHdhbnQgdG8gaW5jcmVtZW50L2RlY3JlbWVudC5cbiAgICAgICAgaWYgKGNoYXIgPT09ICcoJylcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIGlmIChjaGFyID09PSAnKScpXG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgYWN0aXZlLCB3ZSBkb24ndCB3YW50IHRvIG11dGF0ZSB0aGUgcmVzdWx0LlxuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBJZiBsZXZlbCA9PT0gMCwgd2UgYXJlIGF0IHRoZSBkZWZpbml0aW9uIGxldmVsLlxuICAgICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnICcgJiYgWydldmVudCcsICdmdW5jdGlvbicsICdlcnJvcicsICcnXS5pbmNsdWRlcyhyZXN1bHQpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGRlZmluaXRpb24sIHdlIG11c3QgYmUgZmluaXNoZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBzcGFjZXNcbiAgICAgICAgaWYgKGNoYXIgPT09ICcgJykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIHNlcGFyYXRvciwgYW5kIHRoZSBjdXJyZW50IHNlY3Rpb24gaXNuJ3QgZW1wdHksIHdlIHdhbnQgdG8gZGVhY3RpdmF0ZS5cbiAgICAgICAgICAgIGlmIChzaWduYXR1cmVbaSAtIDFdICE9PSAnLCcgJiYgY3VycmVudCAhPT0gJywnICYmIGN1cnJlbnQgIT09ICcsKCcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gY2hhcjtcbiAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignVW5hYmxlIHRvIG5vcm1hbGl6ZSBzaWduYXR1cmUuJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FyZ09mVHlwZShhcmcsIGFiaVBhcmFtZXRlcikge1xuICAgIGNvbnN0IGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlclR5cGUgPSBhYmlQYXJhbWV0ZXIudHlwZTtcbiAgICBzd2l0Y2ggKGFiaVBhcmFtZXRlclR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmcsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGlmIChhYmlQYXJhbWV0ZXJUeXBlID09PSAndHVwbGUnICYmICdjb21wb25lbnRzJyBpbiBhYmlQYXJhbWV0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYWJpUGFyYW1ldGVyLmNvbXBvbmVudHMpLmV2ZXJ5KChjb21wb25lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FyZ09mVHlwZShPYmplY3QudmFsdWVzKGFyZylbaW5kZXhdLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYCh1KWludDxNPmA6ICh1bilzaWduZWQgaW50ZWdlciB0eXBlIG9mIGBNYCBiaXRzLCBgMCA8IE0gPD0gMjU2YCwgYE0gJSA4ID09IDBgXG4gICAgICAgICAgICAvLyBodHRwczovL3JlZ2V4ci5jb20vNnY4aHBcbiAgICAgICAgICAgIGlmICgvXnU/aW50KDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ251bWJlcicgfHwgYXJnVHlwZSA9PT0gJ2JpZ2ludCc7XG4gICAgICAgICAgICAvLyBgYnl0ZXM8TT5gOiBiaW5hcnkgdHlwZSBvZiBgTWAgYnl0ZXMsIGAwIDwgTSA8PSAzMmBcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcmVnZXhyLmNvbS82dmE1NVxuICAgICAgICAgICAgaWYgKC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgICAgICAvLyBmaXhlZC1sZW5ndGggKGA8dHlwZT5bTV1gKSBhbmQgZHluYW1pYyAoYDx0eXBlPltdYCkgYXJyYXlzXG4gICAgICAgICAgICAvLyBodHRwczovL3JlZ2V4ci5jb20vNnZhNmlcbiAgICAgICAgICAgIGlmICgvW2Etel0rWzEtOV17MCwzfShcXFtbMC05XXswLH1cXF0pKyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoYXJnKSAmJlxuICAgICAgICAgICAgICAgICAgICBhcmcuZXZlcnkoKHgpID0+IGlzQXJnT2ZUeXBlKHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFiaVBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcCBvZmYgYFtdYCBvciBgW01dYCBmcm9tIGVuZCBvZiB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhYmlQYXJhbWV0ZXJUeXBlLnJlcGxhY2UoLyhcXFtbMC05XXswLH1cXF0pJC8sICcnKSxcbiAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbWJpZ3VvdXNUeXBlcyhzb3VyY2VQYXJhbWV0ZXJzLCB0YXJnZXRQYXJhbWV0ZXJzLCBhcmdzKSB7XG4gICAgZm9yIChjb25zdCBwYXJhbWV0ZXJJbmRleCBpbiBzb3VyY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVBhcmFtZXRlciA9IHNvdXJjZVBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdO1xuICAgICAgICBjb25zdCB0YXJnZXRQYXJhbWV0ZXIgPSB0YXJnZXRQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcbiAgICAgICAgaWYgKHNvdXJjZVBhcmFtZXRlci50eXBlID09PSAndHVwbGUnICYmXG4gICAgICAgICAgICB0YXJnZXRQYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJyAmJlxuICAgICAgICAgICAgJ2NvbXBvbmVudHMnIGluIHNvdXJjZVBhcmFtZXRlciAmJlxuICAgICAgICAgICAgJ2NvbXBvbmVudHMnIGluIHRhcmdldFBhcmFtZXRlcilcbiAgICAgICAgICAgIHJldHVybiBnZXRBbWJpZ3VvdXNUeXBlcyhzb3VyY2VQYXJhbWV0ZXIuY29tcG9uZW50cywgdGFyZ2V0UGFyYW1ldGVyLmNvbXBvbmVudHMsIGFyZ3NbcGFyYW1ldGVySW5kZXhdKTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbc291cmNlUGFyYW1ldGVyLnR5cGUsIHRhcmdldFBhcmFtZXRlci50eXBlXTtcbiAgICAgICAgY29uc3QgYW1iaWd1b3VzID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcygnYWRkcmVzcycpICYmIHR5cGVzLmluY2x1ZGVzKCdieXRlczIwJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnc1twYXJhbWV0ZXJJbmRleF0sIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcygnYWRkcmVzcycpICYmIHR5cGVzLmluY2x1ZGVzKCdieXRlcycpKVxuICAgICAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGlmIChhbWJpZ3VvdXMpXG4gICAgICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIHJldHVybjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/abiItem.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/abiParameters.js":
/*!**************************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/abiParameters.js ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeAddress: () => (/* binding */ decodeAddress),\n/* harmony export */   decodeArray: () => (/* binding */ decodeArray),\n/* harmony export */   decodeBool: () => (/* binding */ decodeBool),\n/* harmony export */   decodeBytes: () => (/* binding */ decodeBytes),\n/* harmony export */   decodeNumber: () => (/* binding */ decodeNumber),\n/* harmony export */   decodeParameter: () => (/* binding */ decodeParameter),\n/* harmony export */   decodeString: () => (/* binding */ decodeString),\n/* harmony export */   decodeTuple: () => (/* binding */ decodeTuple),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeAddress: () => (/* binding */ encodeAddress),\n/* harmony export */   encodeArray: () => (/* binding */ encodeArray),\n/* harmony export */   encodeBoolean: () => (/* binding */ encodeBoolean),\n/* harmony export */   encodeBytes: () => (/* binding */ encodeBytes),\n/* harmony export */   encodeNumber: () => (/* binding */ encodeNumber),\n/* harmony export */   encodeString: () => (/* binding */ encodeString),\n/* harmony export */   encodeTuple: () => (/* binding */ encodeTuple),\n/* harmony export */   getArrayComponents: () => (/* binding */ getArrayComponents),\n/* harmony export */   hasDynamicChild: () => (/* binding */ hasDynamicChild),\n/* harmony export */   prepareParameter: () => (/* binding */ prepareParameter),\n/* harmony export */   prepareParameters: () => (/* binding */ prepareParameters)\n/* harmony export */ });\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbiParameters.js */ \"../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Solidity.js */ \"../node_modules/ox/_esm/core/Solidity.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__]);\n_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n/** @internal */\nfunction decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nfunction decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? _Address_js__WEBPACK_IMPORTED_MODULE_1__.checksum(address) : address;\n    return [wrap(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.slice(value, -20))), 32];\n}\n/** @internal */\nfunction decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeBool(cursor) {\n    return [_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\n/** @internal */\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data), 32];\n    }\n    const value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(cursor.readBytes(Number.parseInt(size), 32));\n    return [value, 32];\n}\n/** @internal */\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256');\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBigInt(value, { signed })\n            : _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(value, { signed }),\n        32,\n    ];\n}\n/** @internal */\nfunction decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toString(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\n/** @internal */\nfunction prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */\nfunction prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = _Solidity_js__WEBPACK_IMPORTED_MODULE_4__.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(parameter.type);\n}\n/** @internal */\nfunction encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nfunction encodeAddress(value, options) {\n    const { checksum = false } = options;\n    _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(value.toLowerCase()),\n    };\n}\n/** @internal */\nfunction encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize),\n            value,\n        });\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value) };\n}\n/** @internal */\nfunction encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value)) };\n}\n/** @internal */\nfunction encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new _Hex_js__WEBPACK_IMPORTED_MODULE_2__.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\n/** @internal */\nfunction encodeString(value) {\n    const hexValue = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n    const partsLength = Math.ceil(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue), { size: 32 })), ...parts),\n    };\n}\n/** @internal */\nfunction encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n/** @internal */\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmlQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ1o7QUFDSjtBQUNFO0FBQ047QUFDYTtBQUM5QztBQUNPO0FBQ1AsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQixJQUFJLHlDQUF5QztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQsY0FBYywrREFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQ0FBMkM7QUFDbEQsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSx5Q0FBeUMsaURBQWdCO0FBQ3pELGlCQUFpQiw4Q0FBYSxDQUFDLDRDQUFXO0FBQzFDO0FBQ0E7QUFDTztBQUNQLFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNB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QUN6QztBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQVUsOEJBQThCLFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qcz80YzRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi4vQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4uL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vSGV4LmpzJztcbmltcG9ydCB7IGludGVnZXJSZWdleCB9IGZyb20gJy4uL1NvbGlkaXR5LmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBzdGF0aWNQb3NpdGlvbiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW0udHlwZSk7XG4gICAgaWYgKGFycmF5Q29tcG9uZW50cykge1xuICAgICAgICBjb25zdCBbbGVuZ3RoLCB0eXBlXSA9IGFycmF5Q29tcG9uZW50cztcbiAgICAgICAgcmV0dXJuIGRlY29kZUFycmF5KGN1cnNvciwgeyAuLi5wYXJhbSwgdHlwZSB9LCB7IGNoZWNrc3VtQWRkcmVzcywgbGVuZ3RoLCBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICd0dXBsZScpXG4gICAgICAgIHJldHVybiBkZWNvZGVUdXBsZShjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdhZGRyZXNzJylcbiAgICAgICAgcmV0dXJuIGRlY29kZUFkZHJlc3MoY3Vyc29yLCB7IGNoZWNrc3VtOiBjaGVja3N1bUFkZHJlc3MgfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdib29sJylcbiAgICAgICAgcmV0dXJuIGRlY29kZUJvb2woY3Vyc29yKTtcbiAgICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKCdieXRlcycpKVxuICAgICAgICByZXR1cm4gZGVjb2RlQnl0ZXMoY3Vyc29yLCBwYXJhbSwgeyBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKSlcbiAgICAgICAgcmV0dXJuIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBkZWNvZGVTdHJpbmcoY3Vyc29yLCB7IHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3IocGFyYW0udHlwZSk7XG59XG5jb25zdCBzaXplT2ZMZW5ndGggPSAzMjtcbmNvbnN0IHNpemVPZk9mZnNldCA9IDMyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFkZHJlc3MoY3Vyc29yLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcbiAgICBjb25zdCB3cmFwID0gKGFkZHJlc3MpID0+IGNoZWNrc3VtID8gQWRkcmVzcy5jaGVja3N1bShhZGRyZXNzKSA6IGFkZHJlc3M7XG4gICAgcmV0dXJuIFt3cmFwKEhleC5mcm9tQnl0ZXMoQnl0ZXMuc2xpY2UodmFsdWUsIC0yMCkpKSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5KGN1cnNvciwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgbGVuZ3RoLCBzdGF0aWNQb3NpdGlvbiB9ID0gb3B0aW9ucztcbiAgICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBpcyBub3Qga25vd24gaW4gYWR2YW5jZSAoZHluYW1pYyBhcnJheSksXG4gICAgLy8gdGhpcyBtZWFucyB3ZSB3aWxsIG5lZWQgdG8gd29uZGVyIG9mZiB0byB0aGUgcG9pbnRlciBhbmQgZGVjb2RlLlxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBhIGR5bmFtaWMgdHlwZSwgc28gZ2V0IHRoZSBvZmZzZXQgb2YgdGhlIGFycmF5IGRhdGEuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XG4gICAgICAgIC8vIFN0YXJ0IGlzIHRoZSBzdGF0aWMgcG9zaXRpb24gb2YgY3VycmVudCBzbG90ICsgb2Zmc2V0LlxuICAgICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICBjb25zdCBzdGFydE9mRGF0YSA9IHN0YXJ0ICsgc2l6ZU9mTGVuZ3RoO1xuICAgICAgICAvLyBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgZnJvbSB0aGUgb2Zmc2V0LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZkxlbmd0aCkpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXJyYXkgaGFzIGFueSBkeW5hbWljIGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBkeW5hbWljQ2hpbGQgPSBoYXNEeW5hbWljQ2hpbGQocGFyYW0pO1xuICAgICAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGNoaWxkcmVuIGlzIGR5bmFtaWMsIHRoZW4gYWxsIGVsZW1lbnRzIHdpbGwgYmUgb2Zmc2V0IHBvaW50ZXIsIHRodXMgc2l6ZSBvZiBvbmUgc2xvdCAoMzIgYnl0ZXMpLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBlbGVtZW50cyB3aWxsIGJlIHRoZSBzaXplIG9mIHRoZWlyIGVuY29kaW5nIChjb25zdW1lZCBieXRlcykuXG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnRPZkRhdGEgKyAoZHluYW1pY0NoaWxkID8gaSAqIDMyIDogY29uc3VtZWQpKTtcbiAgICAgICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXJ0T2ZEYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXMga25vd24gaW4gYWR2YW5jZSxcbiAgICAvLyBhbmQgdGhlIGxlbmd0aCBvZiBhbiBlbGVtZW50IGRlZXBseSBuZXN0ZWQgaW4gdGhlIGFycmF5IGlzIG5vdCBrbm93bixcbiAgICAvLyB3ZSBuZWVkIHRvIGRlY29kZSB0aGUgb2Zmc2V0IG9mIHRoZSBhcnJheSBkYXRhLlxuICAgIGlmIChoYXNEeW5hbWljQ2hpbGQocGFyYW0pKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgYXJyYXkgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiBjdXJyZW50IHNsb3QgKyBvZmZzZXQuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFsb25nIHRvIHRoZSBuZXh0IHNsb3QgKG5leHQgb2Zmc2V0IHBvaW50ZXIpLlxuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0ICsgaSAqIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IFtkYXRhXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzIGtub3duIGluIGFkdmFuY2UgYW5kIHRoZSBhcnJheSBpcyBkZWVwbHkgc3RhdGljLFxuICAgIC8vIHRoZW4gd2UgY2FuIGp1c3QgZGVjb2RlIGVhY2ggZWxlbWVudCBpbiBzZXF1ZW5jZS5cbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhdGljUG9zaXRpb24gKyBjb25zdW1lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgdmFsdWUucHVzaChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIFt2YWx1ZSwgY29uc3VtZWRdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJvb2woY3Vyc29yKSB7XG4gICAgcmV0dXJuIFtCeXRlcy50b0Jvb2xlYW4oY3Vyc29yLnJlYWRCeXRlcygzMiksIHsgc2l6ZTogMzIgfSksIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlcyhjdXJzb3IsIHBhcmFtLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcbiAgICBjb25zdCBbXywgc2l6ZV0gPSBwYXJhbS50eXBlLnNwbGl0KCdieXRlcycpO1xuICAgIGlmICghc2l6ZSkge1xuICAgICAgICAvLyBEZWFsaW5nIHdpdGggZHluYW1pYyB0eXBlcywgc28gZ2V0IHRoZSBvZmZzZXQgb2YgdGhlIGJ5dGVzIGRhdGEuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAgICAgLy8gU2V0IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgdG8gc3RhcnQgb2YgYnl0ZXMgZGF0YS5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBsZW5ndGgsIHdlIGhhdmUgemVybyBkYXRhLlxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgICAgIHJldHVybiBbJzB4JywgMzJdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdXJzb3IucmVhZEJ5dGVzKGxlbmd0aCk7XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbSGV4LmZyb21CeXRlcyhkYXRhKSwgMzJdO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IEhleC5mcm9tQnl0ZXMoY3Vyc29yLnJlYWRCeXRlcyhOdW1iZXIucGFyc2VJbnQoc2l6ZSksIDMyKSk7XG4gICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKSB7XG4gICAgY29uc3Qgc2lnbmVkID0gcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KHBhcmFtLnR5cGUuc3BsaXQoJ2ludCcpWzFdIHx8ICcyNTYnKTtcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci5yZWFkQnl0ZXMoMzIpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNpemUgPiA0OFxuICAgICAgICAgICAgPyBCeXRlcy50b0JpZ0ludCh2YWx1ZSwgeyBzaWduZWQgfSlcbiAgICAgICAgICAgIDogQnl0ZXMudG9OdW1iZXIodmFsdWUsIHsgc2lnbmVkIH0pLFxuICAgICAgICAzMixcbiAgICBdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVR1cGxlKGN1cnNvciwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgLy8gVHVwbGVzIGNhbiBoYXZlIHVubmFtZWQgY29tcG9uZW50cyAoaS5lLiB0aGV5IGFyZSBhcnJheXMpLCBzbyB3ZSBtdXN0XG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHR1cGxlIGlzIG5hbWVkIG9yIHVubmFtZWQuIEluIHRoZSBjYXNlIG9mIGEgbmFtZWRcbiAgICAvLyB0dXBsZSwgdGhlIHZhbHVlIHdpbGwgYmUgYW4gb2JqZWN0IHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgdGhlIG5hbWUgb2YgdGhlXG4gICAgLy8gY29tcG9uZW50LiBJbiB0aGUgY2FzZSBvZiBhbiB1bm5hbWVkIHR1cGxlLCB0aGUgdmFsdWUgd2lsbCBiZSBhbiBhcnJheS5cbiAgICBjb25zdCBoYXNVbm5hbWVkQ2hpbGQgPSBwYXJhbS5jb21wb25lbnRzLmxlbmd0aCA9PT0gMCB8fCBwYXJhbS5jb21wb25lbnRzLnNvbWUoKHsgbmFtZSB9KSA9PiAhbmFtZSk7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdmFsdWUgdG8gYW4gb2JqZWN0IG9yIGFuIGFycmF5LCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGVcbiAgICAvLyB0dXBsZSBpcyBuYW1lZCBvciB1bm5hbWVkLlxuICAgIGNvbnN0IHZhbHVlID0gaGFzVW5uYW1lZENoaWxkID8gW10gOiB7fTtcbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIC8vIElmIHRoZSB0dXBsZSBoYXMgYSBkeW5hbWljIGNoaWxkLCB3ZSBtdXN0IGZpcnN0IGRlY29kZSB0aGUgb2Zmc2V0IHRvIHRoZVxuICAgIC8vIHR1cGxlIGRhdGEuXG4gICAgaWYgKGhhc0R5bmFtaWNDaGlsZChwYXJhbSkpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGR5bmFtaWMgdHlwZXMsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSB0dXBsZSBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZk9mZnNldCkpO1xuICAgICAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIHJlZmVyZW5jaW5nIHNsb3QgKyBvZmZzZXQuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0uY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcGFyYW0uY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCArIGNvbnN1bWVkKTtcbiAgICAgICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgY29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHR1cGxlIGhhcyBzdGF0aWMgY2hpbGRyZW4sIHdlIGNhbiBqdXN0IGRlY29kZSBlYWNoIGNvbXBvbmVudFxuICAgIC8vIGluIHNlcXVlbmNlLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0uY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBwYXJhbS5jb21wb25lbnRzW2ldO1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIGNvbXBvbmVudCwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZVtoYXNVbm5hbWVkQ2hpbGQgPyBpIDogY29tcG9uZW50Py5uYW1lXSA9IGRhdGE7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICB9XG4gICAgcmV0dXJuIFt2YWx1ZSwgY29uc3VtZWRdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmluZyhjdXJzb3IsIHsgc3RhdGljUG9zaXRpb24gfSkge1xuICAgIC8vIEdldCBvZmZzZXQgdG8gc3RhcnQgb2Ygc3RyaW5nIGRhdGEuXG4gICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgIC8vIFN0YXJ0IGlzIHRoZSBzdGF0aWMgcG9zaXRpb24gb2YgY3VycmVudCBzbG90ICsgb2Zmc2V0LlxuICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICBjb25zdCBsZW5ndGggPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbGVuZ3RoLCB3ZSBoYXZlIHplcm8gZGF0YSAoZW1wdHkgc3RyaW5nKS5cbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFsnJywgMzJdO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgsIDMyKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJ5dGVzLnRvU3RyaW5nKEJ5dGVzLnRyaW1MZWZ0KGRhdGEpKTtcbiAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQYXJhbWV0ZXJzKHsgY2hlY2tzdW1BZGRyZXNzLCBwYXJhbWV0ZXJzLCB2YWx1ZXMsIH0pIHtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlcGFyZWRQYXJhbWV0ZXJzLnB1c2gocHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtZXRlcnNbaV0sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJlZFBhcmFtZXRlcnM7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVBhcmFtZXRlcih7IGNoZWNrc3VtQWRkcmVzcyA9IGZhbHNlLCBwYXJhbWV0ZXI6IHBhcmFtZXRlcl8sIHZhbHVlLCB9KSB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gcGFyYW1ldGVyXztcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW1ldGVyLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3QgW2xlbmd0aCwgdHlwZV0gPSBhcnJheUNvbXBvbmVudHM7XG4gICAgICAgIHJldHVybiBlbmNvZGVBcnJheSh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1ldGVyLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAndHVwbGUnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVUdXBsZSh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlQWRkcmVzcyh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW06IGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCb29sZWFuKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCBwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBjb25zdCBzaWduZWQgPSBwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICAgICAgY29uc3QgWywgLCBzaXplID0gJzI1NiddID0gaW50ZWdlclJlZ2V4LmV4ZWMocGFyYW1ldGVyLnR5cGUpID8/IFtdO1xuICAgICAgICByZXR1cm4gZW5jb2RlTnVtYmVyKHZhbHVlLCB7XG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgICAgICBzaXplOiBOdW1iZXIoc2l6ZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlQnl0ZXModmFsdWUsIHsgdHlwZTogcGFyYW1ldGVyLnR5cGUgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3IocGFyYW1ldGVyLnR5cGUpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpIHtcbiAgICAvLyAxLiBDb21wdXRlIHRoZSBzaXplIG9mIHRoZSBzdGF0aWMgcGFydCBvZiB0aGUgcGFyYW1ldGVycy5cbiAgICBsZXQgc3RhdGljU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgIGlmIChkeW5hbWljKVxuICAgICAgICAgICAgc3RhdGljU2l6ZSArPSAzMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RhdGljU2l6ZSArPSBIZXguc2l6ZShlbmNvZGVkKTtcbiAgICB9XG4gICAgLy8gMi4gU3BsaXQgdGhlIHBhcmFtZXRlcnMgaW50byBzdGF0aWMgYW5kIGR5bmFtaWMgcGFydHMuXG4gICAgY29uc3Qgc3RhdGljUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGR5bmFtaWNQYXJhbWV0ZXJzID0gW107XG4gICAgbGV0IGR5bmFtaWNTaXplID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGR5bmFtaWMsIGVuY29kZWQgfSA9IHByZXBhcmVkUGFyYW1ldGVyc1tpXTtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIHN0YXRpY1BhcmFtZXRlcnMucHVzaChIZXguZnJvbU51bWJlcihzdGF0aWNTaXplICsgZHluYW1pY1NpemUsIHsgc2l6ZTogMzIgfSkpO1xuICAgICAgICAgICAgZHluYW1pY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcbiAgICAgICAgICAgIGR5bmFtaWNTaXplICs9IEhleC5zaXplKGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGljUGFyYW1ldGVycy5wdXNoKGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDMuIENvbmNhdGVuYXRlIHN0YXRpYyBhbmQgZHluYW1pYyBwYXJ0cy5cbiAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5zdGF0aWNQYXJhbWV0ZXJzLCAuLi5keW5hbWljUGFyYW1ldGVycyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQWRkcmVzcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW0gPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBBZGRyZXNzLmFzc2VydCh2YWx1ZSwgeyBzdHJpY3Q6IGNoZWNrc3VtIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXgucGFkTGVmdCh2YWx1ZS50b0xvd2VyQ2FzZSgpKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFycmF5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgcGFyYW1ldGVyIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGR5bmFtaWMgPSBsZW5ndGggPT09IG51bGw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuSW52YWxpZEFycmF5RXJyb3IodmFsdWUpO1xuICAgIGlmICghZHluYW1pYyAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgdHlwZTogYCR7cGFyYW1ldGVyLnR5cGV9WyR7bGVuZ3RofV1gLFxuICAgICAgICB9KTtcbiAgICBsZXQgZHluYW1pY0NoaWxkID0gZmFsc2U7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxuICAgICAgICAgICAgZHluYW1pY0NoaWxkID0gdHJ1ZTtcbiAgICAgICAgcHJlcGFyZWRQYXJhbWV0ZXJzLnB1c2gocHJlcGFyZWRQYXJhbSk7XG4gICAgfVxuICAgIGlmIChkeW5hbWljIHx8IGR5bmFtaWNDaGlsZCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBIZXguZnJvbU51bWJlcihwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoLCB7IHNpemU6IDMyIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuY29kZWQ6IHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGggPiAwID8gSGV4LmNvbmNhdChsZW5ndGgsIGRhdGEpIDogbGVuZ3RoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIHsgZHluYW1pYzogdHJ1ZSwgZW5jb2RlZDogZGF0YSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdCguLi5wcmVwYXJlZFBhcmFtZXRlcnMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQnl0ZXModmFsdWUsIHsgdHlwZSB9KSB7XG4gICAgY29uc3QgWywgcGFyYW1ldGVyc2l6ZV0gPSB0eXBlLnNwbGl0KCdieXRlcycpO1xuICAgIGNvbnN0IGJ5dGVzU2l6ZSA9IEhleC5zaXplKHZhbHVlKTtcbiAgICBpZiAoIXBhcmFtZXRlcnNpemUpIHtcbiAgICAgICAgbGV0IHZhbHVlXyA9IHZhbHVlO1xuICAgICAgICAvLyBJZiB0aGUgc2l6ZSBpcyBub3QgZGl2aXNpYmxlIGJ5IDMyIGJ5dGVzLCBwYWQgdGhlIGVuZFxuICAgICAgICAvLyB3aXRoIGVtcHR5IGJ5dGVzIHRvIHRoZSBjZWlsaW5nIDMyIGJ5dGVzLlxuICAgICAgICBpZiAoYnl0ZXNTaXplICUgMzIgIT09IDApXG4gICAgICAgICAgICB2YWx1ZV8gPSBIZXgucGFkUmlnaHQodmFsdWVfLCBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMiAvIDMyKSAqIDMyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgICAgICBlbmNvZGVkOiBIZXguY29uY2F0KEhleC5wYWRMZWZ0KEhleC5mcm9tTnVtYmVyKGJ5dGVzU2l6ZSwgeyBzaXplOiAzMiB9KSksIHZhbHVlXyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChieXRlc1NpemUgIT09IE51bWJlci5wYXJzZUludChwYXJhbWV0ZXJzaXplKSlcbiAgICAgICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZFNpemU6IE51bWJlci5wYXJzZUludChwYXJhbWV0ZXJzaXplKSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogSGV4LnBhZFJpZ2h0KHZhbHVlKSB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJvb2xlYW4odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJvb2xlYW4gdmFsdWU6IFwiJHt2YWx1ZX1cIiAodHlwZTogJHt0eXBlb2YgdmFsdWV9KS4gRXhwZWN0ZWQ6IFxcYHRydWVcXGAgb3IgXFxgZmFsc2VcXGAuYCk7XG4gICAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IEhleC5wYWRMZWZ0KEhleC5mcm9tQm9vbGVhbih2YWx1ZSkpIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBtYXggPSAybiAqKiAoQmlnSW50KHNpemUpIC0gKHNpZ25lZCA/IDFuIDogMG4pKSAtIDFuO1xuICAgICAgICBjb25zdCBtaW4gPSBzaWduZWQgPyAtbWF4IC0gMW4gOiAwbjtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXg6IG1heC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1pbjogbWluLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUgLyA4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXguZnJvbU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4VmFsdWUgPSBIZXguZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGFydHNMZW5ndGggPSBNYXRoLmNlaWwoSGV4LnNpemUoaGV4VmFsdWUpIC8gMzIpO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goSGV4LnBhZFJpZ2h0KEhleC5zbGljZShoZXhWYWx1ZSwgaSAqIDMyLCAoaSArIDEpICogMzIpKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoSGV4LnBhZFJpZ2h0KEhleC5mcm9tTnVtYmVyKEhleC5zaXplKGhleFZhbHVlKSwgeyBzaXplOiAzMiB9KSksIC4uLnBhcnRzKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVR1cGxlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVyLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyYW1fID0gcGFyYW1ldGVyLmNvbXBvbmVudHNbaV07XG4gICAgICAgIGNvbnN0IGluZGV4ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBpIDogcGFyYW1fLm5hbWU7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkUGFyYW0gPSBwcmVwYXJlUGFyYW1ldGVyKHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1fLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2luZGV4XSxcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgICAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxuICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWMsXG4gICAgICAgIGVuY29kZWQ6IGR5bmFtaWNcbiAgICAgICAgICAgID8gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycylcbiAgICAgICAgICAgIDogSGV4LmNvbmNhdCguLi5wcmVwYXJlZFBhcmFtZXRlcnMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlDb21wb25lbnRzKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdHlwZS5tYXRjaCgvXiguKilcXFsoXFxkKyk/XFxdJC8pO1xuICAgIHJldHVybiBtYXRjaGVzXG4gICAgICAgID8gLy8gUmV0dXJuIGBudWxsYCBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYy5cbiAgICAgICAgICAgIFttYXRjaGVzWzJdID8gTnVtYmVyKG1hdGNoZXNbMl0pIDogbnVsbCwgbWF0Y2hlc1sxXV1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRHluYW1pY0NoaWxkKHBhcmFtKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBwYXJhbTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZS5lbmRzV2l0aCgnW10nKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICd0dXBsZScpXG4gICAgICAgIHJldHVybiBwYXJhbS5jb21wb25lbnRzPy5zb21lKGhhc0R5bmFtaWNDaGlsZCk7XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMgJiZcbiAgICAgICAgaGFzRHluYW1pY0NoaWxkKHtcbiAgICAgICAgICAgIC4uLnBhcmFtLFxuICAgICAgICAgICAgdHlwZTogYXJyYXlDb21wb25lbnRzWzFdLFxuICAgICAgICB9KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpUGFyYW1ldGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/abiParameters.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/base58.js":
/*!*******************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/base58.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alphabetToInteger: () => (/* binding */ alphabetToInteger),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   integerToAlphabet: () => (/* binding */ integerToAlphabet)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n\n/** @internal */\nconst integerToAlphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n/** @internal */\nconst alphabetToInteger = /* __PURE__ */ Object.freeze({\n    1: 0n,\n    2: 1n,\n    3: 2n,\n    4: 3n,\n    5: 4n,\n    6: 5n,\n    7: 6n,\n    8: 7n,\n    9: 8n,\n    A: 9n,\n    B: 10n,\n    C: 11n,\n    D: 12n,\n    E: 13n,\n    F: 14n,\n    G: 15n,\n    H: 16n,\n    J: 17n,\n    K: 18n,\n    L: 19n,\n    M: 20n,\n    N: 21n,\n    P: 22n,\n    Q: 23n,\n    R: 24n,\n    S: 25n,\n    T: 26n,\n    U: 27n,\n    V: 28n,\n    W: 29n,\n    X: 30n,\n    Y: 31n,\n    Z: 32n,\n    a: 33n,\n    b: 34n,\n    c: 35n,\n    d: 36n,\n    e: 37n,\n    f: 38n,\n    g: 39n,\n    h: 40n,\n    i: 41n,\n    j: 42n,\n    k: 43n,\n    m: 44n,\n    n: 45n,\n    o: 46n,\n    p: 47n,\n    q: 48n,\n    r: 49n,\n    s: 50n,\n    t: 51n,\n    u: 52n,\n    v: 53n,\n    w: 54n,\n    x: 55n,\n    y: 56n,\n    z: 57n,\n});\n/** @internal */\nfunction from(value) {\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.from(value);\n    let integer = (() => {\n        let hex = value;\n        if (value instanceof Uint8Array)\n            hex = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n        return BigInt(hex);\n    })();\n    let result = '';\n    while (integer > 0n) {\n        const remainder = Number(integer % 58n);\n        integer = integer / 58n;\n        result = integerToAlphabet[remainder] + result;\n    }\n    while (bytes.length > 1 && bytes[0] === 0) {\n        result = '1' + result;\n        bytes = bytes.slice(1);\n    }\n    return result;\n}\n/** @internal */\n//# sourceMappingURL=base58.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9iYXNlNTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUM7QUFDSjtBQUNqQztBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUCxnQkFBZ0IsMkNBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFhO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9iYXNlNTguanM/MjVhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vSGV4LmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBpbnRlZ2VyVG9BbHBoYWJldCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBhbHBoYWJldFRvSW50ZWdlciA9IC8qIF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICAgIDE6IDBuLFxuICAgIDI6IDFuLFxuICAgIDM6IDJuLFxuICAgIDQ6IDNuLFxuICAgIDU6IDRuLFxuICAgIDY6IDVuLFxuICAgIDc6IDZuLFxuICAgIDg6IDduLFxuICAgIDk6IDhuLFxuICAgIEE6IDluLFxuICAgIEI6IDEwbixcbiAgICBDOiAxMW4sXG4gICAgRDogMTJuLFxuICAgIEU6IDEzbixcbiAgICBGOiAxNG4sXG4gICAgRzogMTVuLFxuICAgIEg6IDE2bixcbiAgICBKOiAxN24sXG4gICAgSzogMThuLFxuICAgIEw6IDE5bixcbiAgICBNOiAyMG4sXG4gICAgTjogMjFuLFxuICAgIFA6IDIybixcbiAgICBROiAyM24sXG4gICAgUjogMjRuLFxuICAgIFM6IDI1bixcbiAgICBUOiAyNm4sXG4gICAgVTogMjduLFxuICAgIFY6IDI4bixcbiAgICBXOiAyOW4sXG4gICAgWDogMzBuLFxuICAgIFk6IDMxbixcbiAgICBaOiAzMm4sXG4gICAgYTogMzNuLFxuICAgIGI6IDM0bixcbiAgICBjOiAzNW4sXG4gICAgZDogMzZuLFxuICAgIGU6IDM3bixcbiAgICBmOiAzOG4sXG4gICAgZzogMzluLFxuICAgIGg6IDQwbixcbiAgICBpOiA0MW4sXG4gICAgajogNDJuLFxuICAgIGs6IDQzbixcbiAgICBtOiA0NG4sXG4gICAgbjogNDVuLFxuICAgIG86IDQ2bixcbiAgICBwOiA0N24sXG4gICAgcTogNDhuLFxuICAgIHI6IDQ5bixcbiAgICBzOiA1MG4sXG4gICAgdDogNTFuLFxuICAgIHU6IDUybixcbiAgICB2OiA1M24sXG4gICAgdzogNTRuLFxuICAgIHg6IDU1bixcbiAgICB5OiA1Nm4sXG4gICAgejogNTduLFxufSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGxldCBieXRlcyA9IEJ5dGVzLmZyb20odmFsdWUpO1xuICAgIGxldCBpbnRlZ2VyID0gKCgpID0+IHtcbiAgICAgICAgbGV0IGhleCA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcyk7XG4gICAgICAgIHJldHVybiBCaWdJbnQoaGV4KTtcbiAgICB9KSgpO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICB3aGlsZSAoaW50ZWdlciA+IDBuKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IE51bWJlcihpbnRlZ2VyICUgNThuKTtcbiAgICAgICAgaW50ZWdlciA9IGludGVnZXIgLyA1OG47XG4gICAgICAgIHJlc3VsdCA9IGludGVnZXJUb0FscGhhYmV0W3JlbWFpbmRlcl0gKyByZXN1bHQ7XG4gICAgfVxuICAgIHdoaWxlIChieXRlcy5sZW5ndGggPiAxICYmIGJ5dGVzWzBdID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9ICcxJyArIHJlc3VsdDtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/base58.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/bytes.js":
/*!******************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/bytes.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */\nfunction assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFxQztBQUNyQztBQUNPO0FBQ1AsUUFBUSwyQ0FBVTtBQUNsQixrQkFBa0Isd0RBQXVCO0FBQ3pDLHVCQUF1QiwyQ0FBVTtBQUNqQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCwwREFBMEQsMkNBQVU7QUFDcEUsa0JBQWtCLGtFQUFpQztBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSwyQ0FBVTtBQUNsQixrQkFBa0Isa0VBQWlDO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQVU7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDO0FBQ3ZDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrRUFBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUM7QUFDeEMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzP2JlNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi4vQnl0ZXMuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoYnl0ZXMsIHNpemVfKSB7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEJ5dGVzLnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgQnl0ZXMuc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNoYXJDb2RlTWFwID0ge1xuICAgIHplcm86IDQ4LFxuICAgIG5pbmU6IDU3LFxuICAgIEE6IDY1LFxuICAgIEY6IDcwLFxuICAgIGE6IDk3LFxuICAgIGY6IDEwMixcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLm5pbmUpXG4gICAgICAgIHJldHVybiBjaGFyIC0gY2hhckNvZGVNYXAuemVybztcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuYSAtIDEwKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnQnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWU7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/cursor.js":
/*!*******************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/cursor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NegativeOffsetError: () => (/* binding */ NegativeOffsetError),\n/* harmony export */   PositionOutOfBoundsError: () => (/* binding */ PositionOutOfBoundsError),\n/* harmony export */   RecursiveReadLimitExceededError: () => (/* binding */ RecursiveReadLimitExceededError),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n\nconst staticCursor = /*#__PURE__*/ {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\n/** @internal */\nfunction create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */\nclass NegativeOffsetError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\n/** @internal */\nclass PositionOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\n/** @internal */\nclass RecursiveReadLimitExceededError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\n//# sourceMappingURL=cursor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9jdXJzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTyx5QkFBeUIsNkJBQTZCLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQsa0JBQWtCLFFBQVE7QUFDMUIsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsaURBQWdCO0FBQzlELGtCQUFrQixrQkFBa0I7QUFDcEMsNEJBQTRCLFNBQVMsd0NBQXdDLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyw4Q0FBOEMsaURBQWdCO0FBQ3JFLGtCQUFrQixjQUFjO0FBQ2hDLDJDQUEyQyxNQUFNLHVDQUF1QyxNQUFNO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvY3Vyc29yLmpzP2U4ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL0Vycm9ycy5qcyc7XG5jb25zdCBzdGF0aWNDdXJzb3IgPSAvKiNfX1BVUkVfXyovIHtcbiAgICBieXRlczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICBkYXRhVmlldzogbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSksXG4gICAgcG9zaXRpb246IDAsXG4gICAgcG9zaXRpb25SZWFkQ291bnQ6IG5ldyBNYXAoKSxcbiAgICByZWN1cnNpdmVSZWFkQ291bnQ6IDAsXG4gICAgcmVjdXJzaXZlUmVhZExpbWl0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgYXNzZXJ0UmVhZExpbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5yZWN1cnNpdmVSZWFkQ291bnQgPj0gdGhpcy5yZWN1cnNpdmVSZWFkTGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgY291bnQ6IHRoaXMucmVjdXJzaXZlUmVhZENvdW50ICsgMSxcbiAgICAgICAgICAgICAgICBsaW1pdDogdGhpcy5yZWN1cnNpdmVSZWFkTGltaXQsXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiB0aGlzLmJ5dGVzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuYnl0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uIC0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG4gICAgZ2V0UmVhZENvdW50KHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uUmVhZENvdW50LmdldChwb3NpdGlvbiB8fCB0aGlzLnBvc2l0aW9uKSB8fCAwO1xuICAgIH0sXG4gICAgaW5jcmVtZW50UG9zaXRpb24ob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5lZ2F0aXZlT2Zmc2V0RXJyb3IoeyBvZmZzZXQgfSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9LFxuICAgIGluc3BlY3RCeXRlKHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbcG9zaXRpb25dO1xuICAgIH0sXG4gICAgaW5zcGVjdEJ5dGVzKGxlbmd0aCwgcG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyBsZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50OChwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3Bvc2l0aW9uXTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MTYocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MjQocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAyKTtcbiAgICAgICAgcmV0dXJuICgodGhpcy5kYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pIDw8IDgpICtcbiAgICAgICAgICAgIHRoaXMuZGF0YVZpZXcuZ2V0VWludDgocG9zaXRpb24gKyAyKSk7XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDMyKHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBwdXNoQnl0ZShieXRlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSBieXRlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfSxcbiAgICBwdXNoQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgYnl0ZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuYnl0ZXMuc2V0KGJ5dGVzLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBieXRlcy5sZW5ndGg7XG4gICAgfSxcbiAgICBwdXNoVWludDgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgfSxcbiAgICBwdXNoVWludDE2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDEpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQxNih0aGlzLnBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgICB9LFxuICAgIHB1c2hVaW50MjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMik7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHZhbHVlID4+IDgpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQ4KHRoaXMucG9zaXRpb24gKyAyLCB2YWx1ZSAmIH40Mjk0OTY3MDQwKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAzO1xuICAgIH0sXG4gICAgcHVzaFVpbnQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAzKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdmFsdWUpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gICAgfSxcbiAgICByZWFkQnl0ZSgpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RCeXRlKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgc2l6ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGVzKGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gc2l6ZSA/PyBsZW5ndGg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50OCgpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50OCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MTYoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDE2KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQyNCgpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MjQoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAzO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDMyKCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQzMigpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGdldCByZW1haW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmxlbmd0aCAtIHRoaXMucG9zaXRpb247XG4gICAgfSxcbiAgICBzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHJldHVybiAoKSA9PiAodGhpcy5wb3NpdGlvbiA9IG9sZFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIF90b3VjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjdXJzaXZlUmVhZExpbWl0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5nZXRSZWFkQ291bnQoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvblJlYWRDb3VudC5zZXQodGhpcy5wb3NpdGlvbiwgY291bnQgKyAxKTtcbiAgICAgICAgaWYgKGNvdW50ID4gMClcbiAgICAgICAgICAgIHRoaXMucmVjdXJzaXZlUmVhZENvdW50Kys7XG4gICAgfSxcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGJ5dGVzLCB7IHJlY3Vyc2l2ZVJlYWRMaW1pdCA9IDhfMTkyIH0gPSB7fSkge1xuICAgIGNvbnN0IGN1cnNvciA9IE9iamVjdC5jcmVhdGUoc3RhdGljQ3Vyc29yKTtcbiAgICBjdXJzb3IuYnl0ZXMgPSBieXRlcztcbiAgICBjdXJzb3IuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICBjdXJzb3IucG9zaXRpb25SZWFkQ291bnQgPSBuZXcgTWFwKCk7XG4gICAgY3Vyc29yLnJlY3Vyc2l2ZVJlYWRMaW1pdCA9IHJlY3Vyc2l2ZVJlYWRMaW1pdDtcbiAgICByZXR1cm4gY3Vyc29yO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIE5lZ2F0aXZlT2Zmc2V0RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCB9KSB7XG4gICAgICAgIHN1cGVyKGBPZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGNhbm5vdCBiZSBuZWdhdGl2ZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5OZWdhdGl2ZU9mZnNldEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBsZW5ndGgsIHBvc2l0aW9uIH0pIHtcbiAgICAgICAgc3VwZXIoYFBvc2l0aW9uIFxcYCR7cG9zaXRpb259XFxgIGlzIG91dCBvZiBib3VuZHMgKFxcYDAgPCBwb3NpdGlvbiA8ICR7bGVuZ3RofVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY291bnQsIGxpbWl0IH0pIHtcbiAgICAgICAgc3VwZXIoYFJlY3Vyc2l2ZSByZWFkIGxpbWl0IG9mIFxcYCR7bGltaXR9XFxgIGV4Y2VlZGVkIChyZWN1cnNpdmUgcmVhZCBjb3VudDogXFxgJHtjb3VudH1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQ3Vyc29yLlJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnNvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/cursor.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/ens.js":
/*!****************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/ens.js ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   packetToBytes: () => (/* binding */ packetToBytes),\n/* harmony export */   unwrapLabelhash: () => (/* binding */ unwrapLabelhash),\n/* harmony export */   wrapLabelhash: () => (/* binding */ wrapLabelhash)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ \"../node_modules/ox/_esm/index.js\");\n/* harmony import */ var _Ens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Ens.js */ \"../node_modules/ox/_esm/core/Ens.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_index_js__WEBPACK_IMPORTED_MODULE_0__, _Ens_js__WEBPACK_IMPORTED_MODULE_1__]);\n([_index_js__WEBPACK_IMPORTED_MODULE_0__, _Ens_js__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */\nfunction packetToBytes(packet) {\n    // strip leading and trailing `.`\n    const value = packet.replace(/^\\.|\\.$/gm, '');\n    if (value.length === 0)\n        return new Uint8Array(1);\n    const bytes = new Uint8Array(_index_js__WEBPACK_IMPORTED_MODULE_0__.Bytes.fromString(value).byteLength + 2);\n    let offset = 0;\n    const list = value.split('.');\n    for (let i = 0; i < list.length; i++) {\n        let encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.Bytes.fromString(list[i]);\n        // if the length is > 255, make the encoded label value a labelhash\n        // this is compatible with the universal resolver\n        if (encoded.byteLength > 255)\n            encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.Bytes.fromString(wrapLabelhash(_Ens_js__WEBPACK_IMPORTED_MODULE_1__.labelhash(list[i])));\n        bytes[offset] = encoded.length;\n        bytes.set(encoded, offset + 1);\n        offset += encoded.length + 1;\n    }\n    if (bytes.byteLength !== offset + 1)\n        return bytes.slice(0, offset + 1);\n    return bytes;\n}\n/** @internal */\nfunction wrapLabelhash(hash) {\n    return `[${hash.slice(2)}]`;\n}\n/** @internal */\nfunction unwrapLabelhash(label) {\n    if (label.length !== 66)\n        return null;\n    if (label.indexOf('[') !== 0)\n        return null;\n    if (label.indexOf(']') !== 65)\n        return null;\n    const hash = `0x${label.slice(1, 65)}`;\n    if (!_Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(hash, { strict: true }))\n        return null;\n    return hash;\n}\n//# sourceMappingURL=ens.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ047QUFDQTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQUs7QUFDdEM7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsc0JBQXNCLDRDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBSywwQkFBMEIsOENBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QyxTQUFTLDZDQUFZLFNBQVMsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSwrQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vucy5qcz8yZTRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnLi4vLi4vaW5kZXguanMnO1xuaW1wb3J0ICogYXMgRW5zIGZyb20gJy4uL0Vucy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vSGV4LmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKiBFbmNvZGVzIGEgW0ROUyBwYWNrZXRdKGh0dHBzOi8vZG9jcy5lbnMuZG9tYWlucy9yZXNvbHV0aW9uL25hbWVzI2RucykgaW50byBhIEJ5dGVBcnJheSBjb250YWluaW5nIGEgVURQIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWNrZXRUb0J5dGVzKHBhY2tldCkge1xuICAgIC8vIHN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIGAuYFxuICAgIGNvbnN0IHZhbHVlID0gcGFja2V0LnJlcGxhY2UoL15cXC58XFwuJC9nbSwgJycpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgxKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KEJ5dGVzLmZyb21TdHJpbmcodmFsdWUpLmJ5dGVMZW5ndGggKyAyKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBsaXN0ID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGVuY29kZWQgPSBCeXRlcy5mcm9tU3RyaW5nKGxpc3RbaV0pO1xuICAgICAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzID4gMjU1LCBtYWtlIHRoZSBlbmNvZGVkIGxhYmVsIHZhbHVlIGEgbGFiZWxoYXNoXG4gICAgICAgIC8vIHRoaXMgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSB1bml2ZXJzYWwgcmVzb2x2ZXJcbiAgICAgICAgaWYgKGVuY29kZWQuYnl0ZUxlbmd0aCA+IDI1NSlcbiAgICAgICAgICAgIGVuY29kZWQgPSBCeXRlcy5mcm9tU3RyaW5nKHdyYXBMYWJlbGhhc2goRW5zLmxhYmVsaGFzaChsaXN0W2ldKSkpO1xuICAgICAgICBieXRlc1tvZmZzZXRdID0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICAgIGJ5dGVzLnNldChlbmNvZGVkLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgb2Zmc2V0ICs9IGVuY29kZWQubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzLmJ5dGVMZW5ndGggIT09IG9mZnNldCArIDEpXG4gICAgICAgIHJldHVybiBieXRlcy5zbGljZSgwLCBvZmZzZXQgKyAxKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcExhYmVsaGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIGBbJHtoYXNoLnNsaWNlKDIpfV1gO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcExhYmVsaGFzaChsYWJlbCkge1xuICAgIGlmIChsYWJlbC5sZW5ndGggIT09IDY2KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobGFiZWwuaW5kZXhPZignWycpICE9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobGFiZWwuaW5kZXhPZignXScpICE9PSA2NSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaGFzaCA9IGAweCR7bGFiZWwuc2xpY2UoMSwgNjUpfWA7XG4gICAgaWYgKCFIZXgudmFsaWRhdGUoaGFzaCwgeyBzdHJpY3Q6IHRydWUgfSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBoYXNoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/ens.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/entropy.js":
/*!********************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/entropy.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extraEntropy: () => (/* binding */ extraEntropy),\n/* harmony export */   setExtraEntropy: () => (/* binding */ setExtraEntropy)\n/* harmony export */ });\nlet extraEntropy = false;\n/** @internal */\nfunction setExtraEntropy(entropy) {\n    extraEntropy = entropy;\n}\n//# sourceMappingURL=entropy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lbnRyb3B5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvZW50cm9weS5qcz80ZjAwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBsZXQgZXh0cmFFbnRyb3B5ID0gZmFsc2U7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RXh0cmFFbnRyb3B5KGVudHJvcHkpIHtcbiAgICBleHRyYUVudHJvcHkgPSBlbnRyb3B5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50cm9weS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/entropy.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/errors.js":
/*!*******************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"../node_modules/ox/_esm/core/version.js\");\n\n/** @internal */\nfunction getUrl(url) {\n    return url;\n}\n/** @internal */\nfunction getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUN4QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGdEQUFPO0FBQ2xCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHLElBQUksMkJBQTJCLEVBQUUsTUFBTTtBQUM5RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lcnJvcnMuanM/NjI4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vdmVyc2lvbi5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKHVybCkge1xuICAgIHJldHVybiB1cmw7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHtcbiAgICByZXR1cm4gdmVyc2lvbjtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV0dHlQcmludChhcmdzKSB7XG4gICAgaWYgKCFhcmdzKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGFyZ3MpXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGVudHJpZXMucmVkdWNlKChhY2MsIFtrZXldKSA9PiBNYXRoLm1heChhY2MsIGtleS5sZW5ndGgpLCAwKTtcbiAgICByZXR1cm4gZW50cmllc1xuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAgICR7YCR7a2V5fTpgLnBhZEVuZChtYXhMZW5ndGggKyAxKX0gICR7dmFsdWV9YClcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/hdKey.js":
/*!******************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/hdKey.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromScure: () => (/* binding */ fromScure)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Secp256k1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Secp256k1.js */ \"../node_modules/ox/_esm/core/Secp256k1.js\");\n\n\n/** @internal */\nfunction fromScure(key) {\n    return {\n        derive: (path) => fromScure(key.derive(path)),\n        depth: key.depth,\n        identifier: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(key.identifier),\n        index: key.index,\n        privateKey: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(key.privateKey),\n        privateExtendedKey: key.privateExtendedKey,\n        publicKey: _Secp256k1_js__WEBPACK_IMPORTED_MODULE_1__.getPublicKey({ privateKey: key.privateKey }),\n        publicExtendedKey: key.publicExtendedKey,\n        versions: key.versions,\n    };\n}\n//# sourceMappingURL=hdKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9oZEtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDWTtBQUM3QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFhO0FBQ2pDO0FBQ0Esb0JBQW9CLDhDQUFhO0FBQ2pDO0FBQ0EsbUJBQW1CLHVEQUFzQixHQUFHLDRCQUE0QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvaGRLZXkuanM/MjI0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFNlY3AyNTZrMSBmcm9tICcuLi9TZWNwMjU2azEuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY3VyZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXJpdmU6IChwYXRoKSA9PiBmcm9tU2N1cmUoa2V5LmRlcml2ZShwYXRoKSksXG4gICAgICAgIGRlcHRoOiBrZXkuZGVwdGgsXG4gICAgICAgIGlkZW50aWZpZXI6IEhleC5mcm9tQnl0ZXMoa2V5LmlkZW50aWZpZXIpLFxuICAgICAgICBpbmRleDoga2V5LmluZGV4LFxuICAgICAgICBwcml2YXRlS2V5OiBIZXguZnJvbUJ5dGVzKGtleS5wcml2YXRlS2V5KSxcbiAgICAgICAgcHJpdmF0ZUV4dGVuZGVkS2V5OiBrZXkucHJpdmF0ZUV4dGVuZGVkS2V5LFxuICAgICAgICBwdWJsaWNLZXk6IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5OiBrZXkucHJpdmF0ZUtleSB9KSxcbiAgICAgICAgcHVibGljRXh0ZW5kZWRLZXk6IGtleS5wdWJsaWNFeHRlbmRlZEtleSxcbiAgICAgICAgdmVyc2lvbnM6IGtleS52ZXJzaW9ucyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGRLZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/hdKey.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/hex.js":
/*!****************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/hex.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */\nfunction assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9oZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBQ2pDO0FBQ087QUFDUCxRQUFRLHlDQUFRO0FBQ2hCLGtCQUFrQixzREFBcUI7QUFDdkMsdUJBQXVCLHlDQUFRO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLDBEQUEwRCx5Q0FBUTtBQUNsRSxrQkFBa0IsZ0VBQStCO0FBQ2pEO0FBQ0E7QUFDQSxrQkFBa0IseUNBQVE7QUFDMUIsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLHlDQUFRO0FBQ2hCLGtCQUFrQixnRUFBK0I7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQix5Q0FBUTtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sK0JBQStCO0FBQ3RDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLDREQUE0RDtBQUM1RTtBQUNBO0FBQ08saUNBQWlDO0FBQ3hDLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvaGV4LmpzPzNhM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U2l6ZShoZXgsIHNpemVfKSB7XG4gICAgaWYgKEhleC5zaXplKGhleCkgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEhleC5zaXplKGhleCksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gSGV4LnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBIZXguc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKGhleF8sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBoZXhfO1xuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPiBzaXplICogMilcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnSGV4JyxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gJ3JpZ2h0JyA/ICdwYWRFbmQnIDogJ3BhZFN0YXJ0J10oc2l6ZSAqIDIsICcwJyl9YDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciA9ICdsZWZ0JyB9ID0gb3B0aW9ucztcbiAgICBsZXQgZGF0YSA9IHZhbHVlLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGxldCBzbGljZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtkaXIgPT09ICdsZWZ0JyA/IGkgOiBkYXRhLmxlbmd0aCAtIGkgLSAxXS50b1N0cmluZygpID09PSAnMCcpXG4gICAgICAgICAgICBzbGljZUxlbmd0aCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZGF0YSA9XG4gICAgICAgIGRpciA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpXG4gICAgICAgICAgICA6IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBzbGljZUxlbmd0aCk7XG4gICAgaWYgKGRhdGEgPT09ICcwJylcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgaWYgKGRpciA9PT0gJ3JpZ2h0JyAmJiBkYXRhLmxlbmd0aCAlIDIgPT09IDEpXG4gICAgICAgIHJldHVybiBgMHgke2RhdGF9MGA7XG4gICAgcmV0dXJuIGAweCR7ZGF0YX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/lru.js":
/*!****************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/lru.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LruMap: () => (/* binding */ LruMap)\n/* harmony export */ });\n/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nclass LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9scnUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvbHJ1LmpzPzYzOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBNYXAgd2l0aCBhIExSVSAoTGVhc3QgcmVjZW50bHkgdXNlZCkgcG9saWN5LlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9yZXBsYWNlbWVudF9wb2xpY2llcyNMUlVcbiAqL1xuZXhwb3J0IGNsYXNzIExydU1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHN1cGVyLmhhcyhrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5zaXplID4gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEtleSA9IHRoaXMua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChmaXJzdEtleSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShmaXJzdEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bHJ1LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/lru.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/mnemonic/wordlists.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/mnemonic/wordlists.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   czech: () => (/* reexport safe */ _scure_bip39_wordlists_czech__WEBPACK_IMPORTED_MODULE_0__.wordlist),\n/* harmony export */   english: () => (/* reexport safe */ _scure_bip39_wordlists_english__WEBPACK_IMPORTED_MODULE_1__.wordlist),\n/* harmony export */   french: () => (/* reexport safe */ _scure_bip39_wordlists_french__WEBPACK_IMPORTED_MODULE_2__.wordlist),\n/* harmony export */   italian: () => (/* reexport safe */ _scure_bip39_wordlists_italian__WEBPACK_IMPORTED_MODULE_3__.wordlist),\n/* harmony export */   japanese: () => (/* reexport safe */ _scure_bip39_wordlists_japanese__WEBPACK_IMPORTED_MODULE_4__.wordlist),\n/* harmony export */   korean: () => (/* reexport safe */ _scure_bip39_wordlists_korean__WEBPACK_IMPORTED_MODULE_5__.wordlist),\n/* harmony export */   portuguese: () => (/* reexport safe */ _scure_bip39_wordlists_portuguese__WEBPACK_IMPORTED_MODULE_6__.wordlist),\n/* harmony export */   simplifiedChinese: () => (/* reexport safe */ _scure_bip39_wordlists_simplified_chinese__WEBPACK_IMPORTED_MODULE_7__.wordlist),\n/* harmony export */   spanish: () => (/* reexport safe */ _scure_bip39_wordlists_spanish__WEBPACK_IMPORTED_MODULE_8__.wordlist),\n/* harmony export */   traditionalChinese: () => (/* reexport safe */ _scure_bip39_wordlists_traditional_chinese__WEBPACK_IMPORTED_MODULE_9__.wordlist)\n/* harmony export */ });\n/* harmony import */ var _scure_bip39_wordlists_czech__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @scure/bip39/wordlists/czech */ \"../node_modules/@scure/bip39/esm/wordlists/czech.js\");\n/* harmony import */ var _scure_bip39_wordlists_english__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/bip39/wordlists/english */ \"../node_modules/@scure/bip39/esm/wordlists/english.js\");\n/* harmony import */ var _scure_bip39_wordlists_french__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/bip39/wordlists/french */ \"../node_modules/@scure/bip39/esm/wordlists/french.js\");\n/* harmony import */ var _scure_bip39_wordlists_italian__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/bip39/wordlists/italian */ \"../node_modules/@scure/bip39/esm/wordlists/italian.js\");\n/* harmony import */ var _scure_bip39_wordlists_japanese__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @scure/bip39/wordlists/japanese */ \"../node_modules/@scure/bip39/esm/wordlists/japanese.js\");\n/* harmony import */ var _scure_bip39_wordlists_korean__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @scure/bip39/wordlists/korean */ \"../node_modules/@scure/bip39/esm/wordlists/korean.js\");\n/* harmony import */ var _scure_bip39_wordlists_portuguese__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @scure/bip39/wordlists/portuguese */ \"../node_modules/@scure/bip39/esm/wordlists/portuguese.js\");\n/* harmony import */ var _scure_bip39_wordlists_simplified_chinese__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @scure/bip39/wordlists/simplified-chinese */ \"../node_modules/@scure/bip39/esm/wordlists/simplified-chinese.js\");\n/* harmony import */ var _scure_bip39_wordlists_spanish__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/bip39/wordlists/spanish */ \"../node_modules/@scure/bip39/esm/wordlists/spanish.js\");\n/* harmony import */ var _scure_bip39_wordlists_traditional_chinese__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @scure/bip39/wordlists/traditional-chinese */ \"../node_modules/@scure/bip39/esm/wordlists/traditional-chinese.js\");\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=wordlists.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9tbmVtb25pYy93b3JkbGlzdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDSTtBQUNGO0FBQ0U7QUFDRTtBQUNKO0FBQ1E7QUFDZTtBQUNyQjtBQUN1QjtBQUM1RiIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL21uZW1vbmljL3dvcmRsaXN0cy5qcz8xNDRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IHdvcmRsaXN0IGFzIGN6ZWNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9jemVjaCc7XG5leHBvcnQgeyB3b3JkbGlzdCBhcyBlbmdsaXNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9lbmdsaXNoJztcbmV4cG9ydCB7IHdvcmRsaXN0IGFzIGZyZW5jaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvZnJlbmNoJztcbmV4cG9ydCB7IHdvcmRsaXN0IGFzIGl0YWxpYW4gfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2l0YWxpYW4nO1xuZXhwb3J0IHsgd29yZGxpc3QgYXMgamFwYW5lc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2phcGFuZXNlJztcbmV4cG9ydCB7IHdvcmRsaXN0IGFzIGtvcmVhbiB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMva29yZWFuJztcbmV4cG9ydCB7IHdvcmRsaXN0IGFzIHBvcnR1Z3Vlc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL3BvcnR1Z3Vlc2UnO1xuZXhwb3J0IHsgd29yZGxpc3QgYXMgc2ltcGxpZmllZENoaW5lc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL3NpbXBsaWZpZWQtY2hpbmVzZSc7XG5leHBvcnQgeyB3b3JkbGlzdCBhcyBzcGFuaXNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9zcGFuaXNoJztcbmV4cG9ydCB7IHdvcmRsaXN0IGFzIHRyYWRpdGlvbmFsQ2hpbmVzZSB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvdHJhZGl0aW9uYWwtY2hpbmVzZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/mnemonic/wordlists.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/promise.js":
/*!********************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/promise.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n\n/** @internal */\nfunction withTimeout(fn, options) {\n    const { errorInstance = new TimeoutError(), timeout, signal } = options;\n    return new Promise((resolve, reject) => {\n        ;\n        (async () => {\n            let timeoutId;\n            try {\n                const controller = new AbortController();\n                if (timeout > 0)\n                    timeoutId = setTimeout(() => {\n                        if (signal) {\n                            controller.abort();\n                        }\n                        else {\n                            reject(errorInstance);\n                        }\n                    }, timeout);\n                resolve(await fn({ signal: controller.signal }));\n            }\n            catch (err) {\n                if (err?.name === 'AbortError')\n                    reject(errorInstance);\n                reject(err);\n            }\n            finally {\n                clearTimeout(timeoutId);\n            }\n        })();\n    });\n}\n/** @internal */\n/**\n * Thrown when an operation times out.\n * @internal\n */\nclass TimeoutError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor() {\n        super('Operation timed out.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Promise.TimeoutError'\n        });\n    }\n}\n//# sourceMappingURL=promise.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9wcm9taXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1QztBQUN2QztBQUNPO0FBQ1AsWUFBWSxzREFBc0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQ0FBbUMsMkJBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLGlEQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9wcm9taXNlLmpzPzY1MGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL0Vycm9ycy5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aFRpbWVvdXQoZm4sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVycm9ySW5zdGFuY2UgPSBuZXcgVGltZW91dEVycm9yKCksIHRpbWVvdXQsIHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICA7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZW91dElkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9ySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGF3YWl0IGZuKHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycj8ubmFtZSA9PT0gJ0Fib3J0RXJyb3InKVxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIHRpbWVzIG91dC5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdPcGVyYXRpb24gdGltZWQgb3V0LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHJvbWlzZS5UaW1lb3V0RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/promise.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/rpcTransport.js":
/*!*************************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/rpcTransport.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _RpcRequest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../RpcRequest.js */ \"../node_modules/ox/_esm/core/RpcRequest.js\");\n/* harmony import */ var _RpcResponse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../RpcResponse.js */ \"../node_modules/ox/_esm/core/RpcResponse.js\");\n\n\n/** @internal */\nfunction create(transport, options_root) {\n    const requestStore = _RpcRequest_js__WEBPACK_IMPORTED_MODULE_0__.createStore();\n    return {\n        request: async ({ method, params }, options = {}) => {\n            const body = requestStore.prepare({ method, params });\n            const data = await transport.request(body, options);\n            return _RpcResponse_js__WEBPACK_IMPORTED_MODULE_1__.parse(data, {\n                raw: options.raw ?? options_root?.raw,\n            });\n        },\n    };\n}\n//# sourceMappingURL=rpcTransport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9ycGNUcmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQ0U7QUFDakQ7QUFDTztBQUNQLHlCQUF5Qix1REFBc0I7QUFDL0M7QUFDQSwwQkFBMEIsZ0JBQWdCLGNBQWM7QUFDeEQsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBLG1CQUFtQixrREFBaUI7QUFDcEM7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL3JwY1RyYW5zcG9ydC5qcz82M2VlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJwY1JlcXVlc3QgZnJvbSAnLi4vUnBjUmVxdWVzdC5qcyc7XG5pbXBvcnQgKiBhcyBScGNSZXNwb25zZSBmcm9tICcuLi9ScGNSZXNwb25zZS5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHRyYW5zcG9ydCwgb3B0aW9uc19yb290KSB7XG4gICAgY29uc3QgcmVxdWVzdFN0b3JlID0gUnBjUmVxdWVzdC5jcmVhdGVTdG9yZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IGFzeW5jICh7IG1ldGhvZCwgcGFyYW1zIH0sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHJlcXVlc3RTdG9yZS5wcmVwYXJlKHsgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdHJhbnNwb3J0LnJlcXVlc3QoYm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gUnBjUmVzcG9uc2UucGFyc2UoZGF0YSwge1xuICAgICAgICAgICAgICAgIHJhdzogb3B0aW9ucy5yYXcgPz8gb3B0aW9uc19yb290Py5yYXcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnBjVHJhbnNwb3J0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/rpcTransport.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/uid.js":
/*!****************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/uid.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uid: () => (/* binding */ uid)\n/* harmony export */ });\nconst size = 256;\nlet index = size;\nlet buffer;\n/** @internal */\nfunction uid(length = 11) {\n    if (!buffer || index + length > size * 2) {\n        buffer = '';\n        index = 0;\n        for (let i = 0; i < size; i++) {\n            buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1);\n        }\n    }\n    return buffer.substring(index, index++ + length);\n}\n//# sourceMappingURL=uid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC91aWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC91aWQuanM/MjM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBzaXplID0gMjU2O1xubGV0IGluZGV4ID0gc2l6ZTtcbmxldCBidWZmZXI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gdWlkKGxlbmd0aCA9IDExKSB7XG4gICAgaWYgKCFidWZmZXIgfHwgaW5kZXggKyBsZW5ndGggPiBzaXplICogMikge1xuICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgYnVmZmVyICs9ICgoMjU2ICsgTWF0aC5yYW5kb20oKSAqIDI1NikgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuc3Vic3RyaW5nKGluZGV4LCBpbmRleCsrICsgbGVuZ3RoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/uid.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/internal/webauthn.js":
/*!*********************************************************!*\
  !*** ../node_modules/ox/_esm/core/internal/webauthn.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAsn1Signature: () => (/* binding */ parseAsn1Signature),\n/* harmony export */   parseCredentialPublicKey: () => (/* binding */ parseCredentialPublicKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/p256 */ \"../node_modules/ox/node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PublicKey.js */ \"../node_modules/ox/_esm/core/PublicKey.js\");\n/* harmony import */ var _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WebAuthnP256.js */ \"../node_modules/ox/_esm/core/WebAuthnP256.js\");\n\n\n\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nfunction parseAsn1Signature(bytes) {\n    const r_start = bytes[4] === 0 ? 5 : 4;\n    const r_end = r_start + 32;\n    const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes.slice(r_start, r_end)));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes.slice(s_start)));\n    return {\n        r,\n        s: s > _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__.p256.CURVE.n / 2n ? _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__.p256.CURVE.n - s : s,\n    };\n}\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nasync function parseCredentialPublicKey(response) {\n    try {\n        const publicKeyBuffer = response.getPublicKey();\n        if (!publicKeyBuffer)\n            throw new _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__.CredentialCreationFailedError();\n        // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n        const publicKeyBytes = new Uint8Array(publicKeyBuffer);\n        const cryptoKey = await crypto.subtle.importKey('spki', new Uint8Array(publicKeyBytes), {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n            hash: 'SHA-256',\n        }, true, ['verify']);\n        const publicKey = new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKey));\n        return _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.from(publicKey);\n    }\n    catch (error) {\n        // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n        // so we need to use `attestationObject` to extract the public key.\n        // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n        if (error.message !== 'Permission denied to access object')\n            throw error;\n        const data = new Uint8Array(response.attestationObject);\n        const coordinateLength = 0x20;\n        const cborPrefix = 0x58;\n        const findStart = (key) => {\n            const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);\n            for (let i = 0; i < data.length - coordinate.length; i++)\n                if (coordinate.every((byte, j) => data[i + j] === byte))\n                    return i + coordinate.length;\n            throw new _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__.CredentialCreationFailedError();\n        };\n        const xStart = findStart(0x21);\n        const yStart = findStart(0x22);\n        return _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.from(new Uint8Array([\n            0x04,\n            ...data.slice(xStart, xStart + coordinateLength),\n            ...data.slice(yStart, yStart + coordinateLength),\n        ]));\n    }\n}\n//# sourceMappingURL=webauthn.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC93ZWJhdXRobi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEM7QUFDVDtBQUNZO0FBQ3NCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBYTtBQUNsQyxxQkFBcUIsOENBQWE7QUFDbEM7QUFDQTtBQUNBLGVBQWUsb0RBQUksZ0JBQWdCLG9EQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyRUFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZUFBZSwrQ0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0NBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC93ZWJhdXRobi5qcz8yY2U2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHAyNTYgfSBmcm9tICdAbm9ibGUvY3VydmVzL3AyNTYnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBQdWJsaWNLZXkgZnJvbSAnLi4vUHVibGljS2V5LmpzJztcbmltcG9ydCB7IENyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yIH0gZnJvbSAnLi4vV2ViQXV0aG5QMjU2LmpzJztcbi8qKlxuICogUGFyc2VzIGFuIEFTTi4xIHNpZ25hdHVyZSBpbnRvIGEgciBhbmQgcyB2YWx1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXNuMVNpZ25hdHVyZShieXRlcykge1xuICAgIGNvbnN0IHJfc3RhcnQgPSBieXRlc1s0XSA9PT0gMCA/IDUgOiA0O1xuICAgIGNvbnN0IHJfZW5kID0gcl9zdGFydCArIDMyO1xuICAgIGNvbnN0IHNfc3RhcnQgPSBieXRlc1tyX2VuZCArIDJdID09PSAwID8gcl9lbmQgKyAzIDogcl9lbmQgKyAyO1xuICAgIGNvbnN0IHIgPSBCaWdJbnQoSGV4LmZyb21CeXRlcyhieXRlcy5zbGljZShyX3N0YXJ0LCByX2VuZCkpKTtcbiAgICBjb25zdCBzID0gQmlnSW50KEhleC5mcm9tQnl0ZXMoYnl0ZXMuc2xpY2Uoc19zdGFydCkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzOiBzID4gcDI1Ni5DVVJWRS5uIC8gMm4gPyBwMjU2LkNVUlZFLm4gLSBzIDogcyxcbiAgICB9O1xufVxuLyoqXG4gKiBQYXJzZXMgYSBwdWJsaWMga2V5IGludG8geCBhbmQgeSBjb29yZGluYXRlcyBmcm9tIHRoZSBwdWJsaWMga2V5XG4gKiBkZWZpbmVkIG9uIHRoZSBjcmVkZW50aWFsLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VDcmVkZW50aWFsUHVibGljS2V5KHJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5QnVmZmVyID0gcmVzcG9uc2UuZ2V0UHVibGljS2V5KCk7XG4gICAgICAgIGlmICghcHVibGljS2V5QnVmZmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IENyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yKCk7XG4gICAgICAgIC8vIENvbnZlcnRpbmcgYHB1YmxpY0tleUJ1ZmZlcmAgdGhyb3dzIHdoZW4gY3JlZGVudGlhbCBpcyBjcmVhdGVkIGJ5IDFQYXNzd29yZCBGaXJlZm94IEFkZC1vblxuICAgICAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IG5ldyBVaW50OEFycmF5KHB1YmxpY0tleUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdzcGtpJywgbmV3IFVpbnQ4QXJyYXkocHVibGljS2V5Qnl0ZXMpLCB7XG4gICAgICAgICAgICBuYW1lOiAnRUNEU0EnLFxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgfSwgdHJ1ZSwgWyd2ZXJpZnknXSk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBVaW50OEFycmF5KGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBjcnlwdG9LZXkpKTtcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3IgMVBhc3N3b3JkIEZpcmVmb3ggQWRkLW9uIHJlc3RyaWN0cyBhY2Nlc3MgdG8gY2VydGFpbiBjcmVkZW50aWFsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byB1c2UgYGF0dGVzdGF0aW9uT2JqZWN0YCB0byBleHRyYWN0IHRoZSBwdWJsaWMga2V5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGFzc3dvcmRsZXNzLWlkL3dlYmF1dGhuL2lzc3Vlcy81MCNpc3N1ZWNvbW1lbnQtMjA3MjkwMjA5NFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSAhPT0gJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5hdHRlc3RhdGlvbk9iamVjdCk7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVMZW5ndGggPSAweDIwO1xuICAgICAgICBjb25zdCBjYm9yUHJlZml4ID0gMHg1ODtcbiAgICAgICAgY29uc3QgZmluZFN0YXJ0ID0gKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IG5ldyBVaW50OEFycmF5KFtrZXksIGNib3JQcmVmaXgsIGNvb3JkaW5hdGVMZW5ndGhdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSBjb29yZGluYXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChjb29yZGluYXRlLmV2ZXJ5KChieXRlLCBqKSA9PiBkYXRhW2kgKyBqXSA9PT0gYnl0ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICsgY29vcmRpbmF0ZS5sZW5ndGg7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbENyZWF0aW9uRmFpbGVkRXJyb3IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeFN0YXJ0ID0gZmluZFN0YXJ0KDB4MjEpO1xuICAgICAgICBjb25zdCB5U3RhcnQgPSBmaW5kU3RhcnQoMHgyMik7XG4gICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDA0LFxuICAgICAgICAgICAgLi4uZGF0YS5zbGljZSh4U3RhcnQsIHhTdGFydCArIGNvb3JkaW5hdGVMZW5ndGgpLFxuICAgICAgICAgICAgLi4uZGF0YS5zbGljZSh5U3RhcnQsIHlTdGFydCArIGNvb3JkaW5hdGVMZW5ndGgpLFxuICAgICAgICBdKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViYXV0aG4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/internal/webauthn.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/core/version.js":
/*!***********************************************!*\
  !*** ../node_modules/ox/_esm/core/version.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */\nconst version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS92ZXJzaW9uLmpzPzg2ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMC4xLjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/core/version.js\n");

/***/ }),

/***/ "../node_modules/ox/_esm/index.js":
/*!****************************************!*\
  !*** ../node_modules/ox/_esm/index.js ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Abi: () => (/* reexport module object */ _core_Abi_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   AbiConstructor: () => (/* reexport module object */ _core_AbiConstructor_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   AbiError: () => (/* reexport module object */ _core_AbiError_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   AbiEvent: () => (/* reexport module object */ _core_AbiEvent_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   AbiFunction: () => (/* reexport module object */ _core_AbiFunction_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   AbiItem: () => (/* reexport module object */ _core_AbiItem_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   AbiParameters: () => (/* reexport module object */ _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   AccessList: () => (/* reexport module object */ _core_AccessList_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   AccountProof: () => (/* reexport module object */ _core_AccountProof_js__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   Address: () => (/* reexport module object */ _core_Address_js__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   AesGcm: () => (/* reexport module object */ _core_AesGcm_js__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   Authorization: () => (/* reexport module object */ _core_Authorization_js__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   Base58: () => (/* reexport module object */ _core_Base58_js__WEBPACK_IMPORTED_MODULE_12__),\n/* harmony export */   Base64: () => (/* reexport module object */ _core_Base64_js__WEBPACK_IMPORTED_MODULE_13__),\n/* harmony export */   BinaryStateTree: () => (/* reexport module object */ _core_BinaryStateTree_js__WEBPACK_IMPORTED_MODULE_14__),\n/* harmony export */   Blobs: () => (/* reexport module object */ _core_Blobs_js__WEBPACK_IMPORTED_MODULE_15__),\n/* harmony export */   Block: () => (/* reexport module object */ _core_Block_js__WEBPACK_IMPORTED_MODULE_16__),\n/* harmony export */   BlockOverrides: () => (/* reexport module object */ _core_BlockOverrides_js__WEBPACK_IMPORTED_MODULE_17__),\n/* harmony export */   Bloom: () => (/* reexport module object */ _core_Bloom_js__WEBPACK_IMPORTED_MODULE_18__),\n/* harmony export */   Bls: () => (/* reexport module object */ _core_Bls_js__WEBPACK_IMPORTED_MODULE_19__),\n/* harmony export */   BlsPoint: () => (/* reexport module object */ _core_BlsPoint_js__WEBPACK_IMPORTED_MODULE_20__),\n/* harmony export */   Bytes: () => (/* reexport module object */ _core_Bytes_js__WEBPACK_IMPORTED_MODULE_21__),\n/* harmony export */   Caches: () => (/* reexport module object */ _core_Caches_js__WEBPACK_IMPORTED_MODULE_22__),\n/* harmony export */   ContractAddress: () => (/* reexport module object */ _core_ContractAddress_js__WEBPACK_IMPORTED_MODULE_23__),\n/* harmony export */   Ens: () => (/* reexport module object */ _core_Ens_js__WEBPACK_IMPORTED_MODULE_24__),\n/* harmony export */   Errors: () => (/* reexport module object */ _core_Errors_js__WEBPACK_IMPORTED_MODULE_25__),\n/* harmony export */   Fee: () => (/* reexport module object */ _core_Fee_js__WEBPACK_IMPORTED_MODULE_30__),\n/* harmony export */   Filter: () => (/* reexport module object */ _core_Filter_js__WEBPACK_IMPORTED_MODULE_26__),\n/* harmony export */   Hash: () => (/* reexport module object */ _core_Hash_js__WEBPACK_IMPORTED_MODULE_27__),\n/* harmony export */   HdKey: () => (/* reexport module object */ _core_HdKey_js__WEBPACK_IMPORTED_MODULE_28__),\n/* harmony export */   Hex: () => (/* reexport module object */ _core_Hex_js__WEBPACK_IMPORTED_MODULE_29__),\n/* harmony export */   Json: () => (/* reexport module object */ _core_Json_js__WEBPACK_IMPORTED_MODULE_31__),\n/* harmony export */   Keystore: () => (/* reexport module object */ _core_Keystore_js__WEBPACK_IMPORTED_MODULE_32__),\n/* harmony export */   Kzg: () => (/* reexport module object */ _core_Kzg_js__WEBPACK_IMPORTED_MODULE_33__),\n/* harmony export */   Log: () => (/* reexport module object */ _core_Log_js__WEBPACK_IMPORTED_MODULE_34__),\n/* harmony export */   Mnemonic: () => (/* reexport module object */ _core_Mnemonic_js__WEBPACK_IMPORTED_MODULE_35__),\n/* harmony export */   P256: () => (/* reexport module object */ _core_P256_js__WEBPACK_IMPORTED_MODULE_45__),\n/* harmony export */   PersonalMessage: () => (/* reexport module object */ _core_PersonalMessage_js__WEBPACK_IMPORTED_MODULE_36__),\n/* harmony export */   Provider: () => (/* reexport module object */ _core_Provider_js__WEBPACK_IMPORTED_MODULE_37__),\n/* harmony export */   PublicKey: () => (/* reexport module object */ _core_PublicKey_js__WEBPACK_IMPORTED_MODULE_38__),\n/* harmony export */   Rlp: () => (/* reexport module object */ _core_Rlp_js__WEBPACK_IMPORTED_MODULE_39__),\n/* harmony export */   RpcRequest: () => (/* reexport module object */ _core_RpcRequest_js__WEBPACK_IMPORTED_MODULE_41__),\n/* harmony export */   RpcResponse: () => (/* reexport module object */ _core_RpcResponse_js__WEBPACK_IMPORTED_MODULE_42__),\n/* harmony export */   RpcSchema: () => (/* reexport module object */ _core_RpcSchema_js__WEBPACK_IMPORTED_MODULE_40__),\n/* harmony export */   RpcTransport: () => (/* reexport module object */ _core_RpcTransport_js__WEBPACK_IMPORTED_MODULE_43__),\n/* harmony export */   Secp256k1: () => (/* reexport module object */ _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_44__),\n/* harmony export */   Signature: () => (/* reexport module object */ _core_Signature_js__WEBPACK_IMPORTED_MODULE_46__),\n/* harmony export */   Siwe: () => (/* reexport module object */ _core_Siwe_js__WEBPACK_IMPORTED_MODULE_47__),\n/* harmony export */   Solidity: () => (/* reexport module object */ _core_Solidity_js__WEBPACK_IMPORTED_MODULE_48__),\n/* harmony export */   StateOverrides: () => (/* reexport module object */ _core_StateOverrides_js__WEBPACK_IMPORTED_MODULE_49__),\n/* harmony export */   Transaction: () => (/* reexport module object */ _core_Transaction_js__WEBPACK_IMPORTED_MODULE_50__),\n/* harmony export */   TransactionEnvelope: () => (/* reexport module object */ _core_TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_51__),\n/* harmony export */   TransactionEnvelopeEip1559: () => (/* reexport module object */ _core_TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_53__),\n/* harmony export */   TransactionEnvelopeEip2930: () => (/* reexport module object */ _core_TransactionEnvelopeEip2930_js__WEBPACK_IMPORTED_MODULE_54__),\n/* harmony export */   TransactionEnvelopeEip4844: () => (/* reexport module object */ _core_TransactionEnvelopeEip4844_js__WEBPACK_IMPORTED_MODULE_55__),\n/* harmony export */   TransactionEnvelopeEip7702: () => (/* reexport module object */ _core_TransactionEnvelopeEip7702_js__WEBPACK_IMPORTED_MODULE_56__),\n/* harmony export */   TransactionEnvelopeLegacy: () => (/* reexport module object */ _core_TransactionEnvelopeLegacy_js__WEBPACK_IMPORTED_MODULE_52__),\n/* harmony export */   TransactionReceipt: () => (/* reexport module object */ _core_TransactionReceipt_js__WEBPACK_IMPORTED_MODULE_57__),\n/* harmony export */   TransactionRequest: () => (/* reexport module object */ _core_TransactionRequest_js__WEBPACK_IMPORTED_MODULE_58__),\n/* harmony export */   TypedData: () => (/* reexport module object */ _core_TypedData_js__WEBPACK_IMPORTED_MODULE_59__),\n/* harmony export */   ValidatorData: () => (/* reexport module object */ _core_ValidatorData_js__WEBPACK_IMPORTED_MODULE_60__),\n/* harmony export */   Value: () => (/* reexport module object */ _core_Value_js__WEBPACK_IMPORTED_MODULE_61__),\n/* harmony export */   WebAuthnP256: () => (/* reexport module object */ _core_WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_62__),\n/* harmony export */   WebCryptoP256: () => (/* reexport module object */ _core_WebCryptoP256_js__WEBPACK_IMPORTED_MODULE_63__),\n/* harmony export */   Withdrawal: () => (/* reexport module object */ _core_Withdrawal_js__WEBPACK_IMPORTED_MODULE_64__)\n/* harmony export */ });\n/* harmony import */ var _core_Abi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Abi.js */ \"../node_modules/ox/_esm/core/Abi.js\");\n/* harmony import */ var _core_AbiConstructor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/AbiConstructor.js */ \"../node_modules/ox/_esm/core/AbiConstructor.js\");\n/* harmony import */ var _core_AbiError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/AbiError.js */ \"../node_modules/ox/_esm/core/AbiError.js\");\n/* harmony import */ var _core_AbiEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/AbiEvent.js */ \"../node_modules/ox/_esm/core/AbiEvent.js\");\n/* harmony import */ var _core_AbiFunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/AbiFunction.js */ \"../node_modules/ox/_esm/core/AbiFunction.js\");\n/* harmony import */ var _core_AbiItem_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/AbiItem.js */ \"../node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/AbiParameters.js */ \"../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_AccessList_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/AccessList.js */ \"../node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _core_AccountProof_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/AccountProof.js */ \"../node_modules/ox/_esm/core/AccountProof.js\");\n/* harmony import */ var _core_Address_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/Address.js */ \"../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _core_AesGcm_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/AesGcm.js */ \"../node_modules/ox/_esm/core/AesGcm.js\");\n/* harmony import */ var _core_Authorization_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/Authorization.js */ \"../node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _core_Base58_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/Base58.js */ \"../node_modules/ox/_esm/core/Base58.js\");\n/* harmony import */ var _core_Base64_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/Base64.js */ \"../node_modules/ox/_esm/core/Base64.js\");\n/* harmony import */ var _core_BinaryStateTree_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./core/BinaryStateTree.js */ \"../node_modules/ox/_esm/core/BinaryStateTree.js\");\n/* harmony import */ var _core_Blobs_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./core/Blobs.js */ \"../node_modules/ox/_esm/core/Blobs.js\");\n/* harmony import */ var _core_Block_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./core/Block.js */ \"../node_modules/ox/_esm/core/Block.js\");\n/* harmony import */ var _core_BlockOverrides_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./core/BlockOverrides.js */ \"../node_modules/ox/_esm/core/BlockOverrides.js\");\n/* harmony import */ var _core_Bloom_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./core/Bloom.js */ \"../node_modules/ox/_esm/core/Bloom.js\");\n/* harmony import */ var _core_Bls_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./core/Bls.js */ \"../node_modules/ox/_esm/core/Bls.js\");\n/* harmony import */ var _core_BlsPoint_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./core/BlsPoint.js */ \"../node_modules/ox/_esm/core/BlsPoint.js\");\n/* harmony import */ var _core_Bytes_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./core/Bytes.js */ \"../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _core_Caches_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./core/Caches.js */ \"../node_modules/ox/_esm/core/Caches.js\");\n/* harmony import */ var _core_ContractAddress_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./core/ContractAddress.js */ \"../node_modules/ox/_esm/core/ContractAddress.js\");\n/* harmony import */ var _core_Ens_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./core/Ens.js */ \"../node_modules/ox/_esm/core/Ens.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./core/Errors.js */ \"../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Filter_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./core/Filter.js */ \"../node_modules/ox/_esm/core/Filter.js\");\n/* harmony import */ var _core_Hash_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./core/Hash.js */ \"../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _core_HdKey_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./core/HdKey.js */ \"../node_modules/ox/_esm/core/HdKey.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./core/Hex.js */ \"../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Fee_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./core/Fee.js */ \"../node_modules/ox/_esm/core/Fee.js\");\n/* harmony import */ var _core_Json_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./core/Json.js */ \"../node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _core_Keystore_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./core/Keystore.js */ \"../node_modules/ox/_esm/core/Keystore.js\");\n/* harmony import */ var _core_Kzg_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./core/Kzg.js */ \"../node_modules/ox/_esm/core/Kzg.js\");\n/* harmony import */ var _core_Log_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./core/Log.js */ \"../node_modules/ox/_esm/core/Log.js\");\n/* harmony import */ var _core_Mnemonic_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./core/Mnemonic.js */ \"../node_modules/ox/_esm/core/Mnemonic.js\");\n/* harmony import */ var _core_PersonalMessage_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./core/PersonalMessage.js */ \"../node_modules/ox/_esm/core/PersonalMessage.js\");\n/* harmony import */ var _core_Provider_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./core/Provider.js */ \"../node_modules/ox/_esm/core/Provider.js\");\n/* harmony import */ var _core_PublicKey_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./core/PublicKey.js */ \"../node_modules/ox/_esm/core/PublicKey.js\");\n/* harmony import */ var _core_Rlp_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./core/Rlp.js */ \"../node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _core_RpcSchema_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./core/RpcSchema.js */ \"../node_modules/ox/_esm/core/RpcSchema.js\");\n/* harmony import */ var _core_RpcRequest_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./core/RpcRequest.js */ \"../node_modules/ox/_esm/core/RpcRequest.js\");\n/* harmony import */ var _core_RpcResponse_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./core/RpcResponse.js */ \"../node_modules/ox/_esm/core/RpcResponse.js\");\n/* harmony import */ var _core_RpcTransport_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./core/RpcTransport.js */ \"../node_modules/ox/_esm/core/RpcTransport.js\");\n/* harmony import */ var _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./core/Secp256k1.js */ \"../node_modules/ox/_esm/core/Secp256k1.js\");\n/* harmony import */ var _core_P256_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./core/P256.js */ \"../node_modules/ox/_esm/core/P256.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./core/Signature.js */ \"../node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _core_Siwe_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./core/Siwe.js */ \"../node_modules/ox/_esm/core/Siwe.js\");\n/* harmony import */ var _core_Solidity_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./core/Solidity.js */ \"../node_modules/ox/_esm/core/Solidity.js\");\n/* harmony import */ var _core_StateOverrides_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./core/StateOverrides.js */ \"../node_modules/ox/_esm/core/StateOverrides.js\");\n/* harmony import */ var _core_Transaction_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./core/Transaction.js */ \"../node_modules/ox/_esm/core/Transaction.js\");\n/* harmony import */ var _core_TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./core/TransactionEnvelope.js */ \"../node_modules/ox/_esm/core/TransactionEnvelope.js\");\n/* harmony import */ var _core_TransactionEnvelopeLegacy_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./core/TransactionEnvelopeLegacy.js */ \"../node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js\");\n/* harmony import */ var _core_TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./core/TransactionEnvelopeEip1559.js */ \"../node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n/* harmony import */ var _core_TransactionEnvelopeEip2930_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./core/TransactionEnvelopeEip2930.js */ \"../node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js\");\n/* harmony import */ var _core_TransactionEnvelopeEip4844_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./core/TransactionEnvelopeEip4844.js */ \"../node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js\");\n/* harmony import */ var _core_TransactionEnvelopeEip7702_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./core/TransactionEnvelopeEip7702.js */ \"../node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js\");\n/* harmony import */ var _core_TransactionReceipt_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./core/TransactionReceipt.js */ \"../node_modules/ox/_esm/core/TransactionReceipt.js\");\n/* harmony import */ var _core_TransactionRequest_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./core/TransactionRequest.js */ \"../node_modules/ox/_esm/core/TransactionRequest.js\");\n/* harmony import */ var _core_TypedData_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./core/TypedData.js */ \"../node_modules/ox/_esm/core/TypedData.js\");\n/* harmony import */ var _core_ValidatorData_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./core/ValidatorData.js */ \"../node_modules/ox/_esm/core/ValidatorData.js\");\n/* harmony import */ var _core_Value_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./core/Value.js */ \"../node_modules/ox/_esm/core/Value.js\");\n/* harmony import */ var _core_WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./core/WebAuthnP256.js */ \"../node_modules/ox/_esm/core/WebAuthnP256.js\");\n/* harmony import */ var _core_WebCryptoP256_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./core/WebCryptoP256.js */ \"../node_modules/ox/_esm/core/WebCryptoP256.js\");\n/* harmony import */ var _core_Withdrawal_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./core/Withdrawal.js */ \"../node_modules/ox/_esm/core/Withdrawal.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_Abi_js__WEBPACK_IMPORTED_MODULE_0__, _core_AbiConstructor_js__WEBPACK_IMPORTED_MODULE_1__, _core_AbiError_js__WEBPACK_IMPORTED_MODULE_2__, _core_AbiEvent_js__WEBPACK_IMPORTED_MODULE_3__, _core_AbiFunction_js__WEBPACK_IMPORTED_MODULE_4__, _core_AbiItem_js__WEBPACK_IMPORTED_MODULE_5__, _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__, _core_Ens_js__WEBPACK_IMPORTED_MODULE_24__, _core_Keystore_js__WEBPACK_IMPORTED_MODULE_32__, _core_Provider_js__WEBPACK_IMPORTED_MODULE_37__, _core_TypedData_js__WEBPACK_IMPORTED_MODULE_59__]);\n([_core_Abi_js__WEBPACK_IMPORTED_MODULE_0__, _core_AbiConstructor_js__WEBPACK_IMPORTED_MODULE_1__, _core_AbiError_js__WEBPACK_IMPORTED_MODULE_2__, _core_AbiEvent_js__WEBPACK_IMPORTED_MODULE_3__, _core_AbiFunction_js__WEBPACK_IMPORTED_MODULE_4__, _core_AbiItem_js__WEBPACK_IMPORTED_MODULE_5__, _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_6__, _core_Ens_js__WEBPACK_IMPORTED_MODULE_24__, _core_Keystore_js__WEBPACK_IMPORTED_MODULE_32__, _core_Provider_js__WEBPACK_IMPORTED_MODULE_37__, _core_TypedData_js__WEBPACK_IMPORTED_MODULE_59__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * Utilities & types for working with [Application Binary Interfaces (ABIs)](https://docs.soliditylang.org/en/latest/abi-spec.html)\n *\n * :::note\n *\n * If you are looking for ABI parameter **encoding** & **decoding** functions, see {@link ox#AbiParameters.(encode:function)} & {@link ox#AbiParameters.(decode:function)}.\n *\n * :::\n *\n * @example\n * ### Instantiating JSON ABIs\n *\n * An {@link ox#Abi.Abi} can be instantiated from a JSON ABI by using {@link ox#Abi.(from:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating Human Readable ABIs\n *\n * An {@link ox#Abi.Abi} can be instantiated from a human-readable ABI by using {@link ox#Abi.(from:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([\n *   'function approve(address spender, uint256 amount) returns (bool)',\n * ])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Formatting ABIs\n *\n * An {@link ox#Abi.Abi} can be formatted into a human-readable ABI by using {@link ox#Abi.(format:function)}:\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n * const abi = Abi.from([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n * //---cut---\n * const formatted = Abi.format(abi)\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @category ABI\n */\n\n/**\n * Utilities & types for working with [Constructors](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiConstructor` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiConstructor` can be instantiated from a JSON ABI by using {@link ox#AbiConstructor.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([\n *   'constructor(address owner)',\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiConstructor.fromAbi(abi) // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiConstructor` can be instantiated from a human-readable ABI by using {@link ox#AbiConstructor.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address owner)')\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Deploy Data\n *\n * Constructor arguments can be ABI-encoded using {@link ox#AbiConstructor.(encode:function)} (with bytecode) into deploy data. This data can then be passed to a transaction to deploy a contract.\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @category ABI\n */\n\n/**\n * Utilities & types for working with [Errors](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiError` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiError` can be instantiated from a JSON ABI by using {@link ox#AbiError.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiError.fromAbi(abi, 'BadSignatureV') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiError` can be instantiated from a human-readable ABI by using {@link ox#AbiError.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from('error BadSignatureV(uint8 v)')\n *\n * error\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Decoding Error Data\n *\n * Error data can be ABI-decoded using the {@link ox#AbiError.(decode:function)} function.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...])\n * const error = AbiError.fromAbi(abi, 'InvalidSignature')\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001') // [!code focus]\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @category ABI\n */\n\n/**\n * Utilities & types for working with [Events](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiEvent` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiEvent` can be instantiated from a JSON ABI by using {@link ox#AbiEvent.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiEvent.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiEvent` can be instantiated from a human-readable ABI by using {@link ox#AbiEvent.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)' // [!code hl]\n * )\n *\n * transfer\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Event Topics\n *\n * Encode an `AbiEvent` into topics using {@link ox#AbiEvent.(encode:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const { topics } = AbiEvent.encode(transfer, {\n *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code hl]\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8' // [!code hl]\n * })\n * // @log: [\n * // @log:   '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0',\n * // @log:   '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * // @log:   '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'\n * // @log: ]\n * ```\n *\n * @example\n * ### Decoding Event Topics and Data\n *\n * Event topics and data can be decoded using {@link ox#AbiEvent.(decode:function)}:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const log = {\n *   // ...\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * } as const\n *\n * const decoded = AbiEvent.decode(transfer, log)\n * // @log: {\n * // @log:   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   value: 1n\n * // @log: }\n * ```\n *\n * @category ABI\n */\n\n/**\n * Utilities & types for working with [Functions](https://docs.soliditylang.org/en/latest/abi-spec.html#json) on ABIs.\n *\n * `AbiFunction` is a sub-type of [`AbiItem`](/api/AbiItem).\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiFunction` can be instantiated from a JSON ABI by using {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'bar') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * An `AbiFunction` can be instantiated from a human-readable ABI by using {@link ox#AbiFunction.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const bar = AbiFunction.from('function bar(string a) returns (uint256 x)')\n *\n * bar\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Encoding to Function Data\n *\n * A Function and its arguments can be ABI-encoded into data using the {@link ox#AbiFunction.(encodeData:function)} function. The output of this function can then be passed to `eth_sendTransaction` or `eth_call` as the `data` parameter.\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### Decoding a Function's Result\n *\n * A Function's result can be ABI-decoded using the {@link ox#AbiFunction.(decodeResult:function)} function.\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n * //     Example data that could be returned from a contract call via `eth_call`.\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data) // [!code focus]\n * // @log: 42n\n * ```\n *\n * @category ABI\n */\n\n/**\n * Utilities & types for working with [ABI Items](https://docs.soliditylang.org/en/latest/abi-spec.html#json)\n *\n * The `AbiItem` type is a super-type of:\n * - [`AbiConstructor`](/api/AbiConstructor)\n * - [`AbiFunction`](/api/AbiFunction)\n * - [`AbiEvent`](/api/AbiEvent)\n * - [`AbiError`](/api/AbiError)\n *\n * @example\n * ### Instantiating via JSON ABI\n *\n * An `AbiItem` can be instantiated from a JSON ABI by using {@link ox#AbiItem.(fromAbi:function)}:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating via Human-Readable ABI Item\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from('function approve(address spender, uint256 amount) returns (bool)')\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Formatting ABI Items\n *\n * An `AbiItem` can be formatted into a human-readable ABI Item by using {@link ox#AbiItem.(format:function)}:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from('function approve(address spender, uint256 amount) returns (bool)')\n *\n * const formatted = AbiItem.format(abiItem)\n * // @log: 'function approve(address spender, uint256 amount) returns (bool)'\n * ```\n *\n * @category ABI\n */\n\n/**\n * Utilities & types for encoding, decoding, and working with [ABI Parameters](https://docs.soliditylang.org/en/latest/abi-spec.html#types)\n *\n * @example\n * ### Encoding ABI Parameters\n *\n * ABI Parameters can be ABI-encoded as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec) using {@link ox#AbiParameters.(encode:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from('string, uint, bool'),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * :::tip\n *\n * The example above uses {@link ox#AbiParameters.(from:function)} to specify human-readable ABI Parameters.\n *\n * However, you can also pass JSON-ABI Parameters:\n *\n * ```ts\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [{ type: 'string' }, { type: 'uint' }, { type: 'bool' }],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * :::\n *\n * @example\n * ### Decoding ABI Parameters\n *\n * ABI-encoded data can be decoded using {@link ox#AbiParameters.(decode:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   AbiParameters.from('string, uint, bool'),\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @example\n * ### JSON-ABI Parameters\n *\n * JSON-ABI Parameters can be instantiated using {@link ox#AbiParameters.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABI Parameters\n *\n * Human Readable ABI Parameters can be instantiated using {@link ox#AbiParameters.(from:function)}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @category ABI\n */\n\n/**\n * Utilities & types for working with Access Lists as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/4140e528360fea53c34a766d86a000c6c039100e/src/schemas/transaction.yaml#L73)\n *\n * @category Execution Spec\n */\n\n/**\n * Utilities & types for working with Account Proofs as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/state.yaml)\n *\n * @category Execution Spec\n */\n\n/**\n * Utility functions for working with Ethereum addresses.\n *\n * @example\n * ### Instantiating Addresses\n *\n * An {@link ox#Address.Address} can be instantiated from a hex string using {@link ox#Address.(from:function)}:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * const address = Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ### Validating Addresses\n *\n * The {@link ox#Address.(validate:function)} function will return `true` if the address is valid, and `false` otherwise:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * const valid = Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * The {@link ox#Address.(assert:function)} function will throw an error if the address is invalid:\n *\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @example\n * ### Addresses from ECDSA Public Keys\n *\n * An {@link ox#Address.Address} can be computed from an ECDSA public key using {@link ox#Address.(fromPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Address, Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n *\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @category Addresses\n */\n\n/**\n * Utilities & types for working with AES-GCM encryption. Internally uses the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API).\n *\n * @example\n * ### Encrypting Data\n *\n * Data can be encrypted using {@link ox#AesGcm.(encrypt:function)}:\n *\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key) // [!code focus]\n * // @log: '0x5e257b25bcf53d5431e54e5a68ca0138306d31bb6154f35a97bb8ea18111e7d82bcf619d3c76c4650688bc5310eed80b8fc86d1e3e'\n * ```\n *\n * @example\n * ### Decrypting Data\n *\n * Data can be decrypted using {@link ox#AesGcm.(decrypt:function)}:\n *\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const encrypted = await AesGcm.encrypt(Hex.fromString('i am a secret message'), key)\n *\n * const decrypted = await AesGcm.decrypt(encrypted, key) // [!code focus]\n * // @log: Hex.fromString('i am a secret message')\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for working with [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization lists & tuples.\n *\n * @example\n * ### Instantiating Authorizations\n *\n * An Authorization can be instantiated using {@link ox#Authorization.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Computing Sign Payload\n *\n * A signing payload can be computed using {@link ox#Authorization.(getSignPayload:function)}. The result can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures to Authorizations\n *\n * A signature can be attached to an Authorization using {@link ox#Authorization.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [authorization_signed],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @category Authorization (EIP-7702)\n */\n\n/**\n * Utility functions for working with [Base58](https://digitalbazaar.github.io/base58-spec/) values.\n *\n * @example\n * ### Encoding to Base58\n *\n * Values can be encoded to Base58 with:\n *\n * - {@link ox#Base58.(fromString:function)}, or\n *\n * - {@link ox#Base58.(fromBytes:function)}, or\n *\n * - {@link ox#Base58.(fromHex:function)}\n *\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value_string = Base58.fromString('Hello World!')\n * // @log: '2NEpo7TZRRrLZSi2U'\n *\n * const value_bytes = Base58.fromBytes(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '2NEpo7TZRRrLZSi2U'\n *\n * const value_hex = Base58.fromHex('0x48656c6c6f20576f726c6421')\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @example\n * ### Decoding Base58\n *\n * Values can be decoded from Base58 with:\n *\n * - {@link ox#Base58.(toString:function)}, or\n *\n * - {@link ox#Base58.(toBytes:function)}, or\n *\n * - {@link ox#Base58.(toHex:function)}\n *\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value_string = Base58.toString('2NEpo7TZRRrLZSi2U')\n * // @log: 'Hello World!'\n *\n * const value_bytes = Base58.toBytes('2NEpo7TZRRrLZSi2U')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n *\n * const value_hex = Base58.toHex('2NEpo7TZRRrLZSi2U')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @category Data\n */\n\n/**\n * Utility functions for working with [RFC-4648](https://datatracker.ietf.org/doc/html/rfc4648) Base64.\n *\n * @example\n * ### Encoding to Base64\n *\n * Values can be encoded to Base64 with:\n *\n * - {@link ox#Base64.(fromString:function)}, or\n *\n * - {@link ox#Base64.(fromBytes:function)}, or\n *\n * - {@link ox#Base64.(fromHex:function)}\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value_string = Base64.fromString('Hello World!')\n * // @log: 'SGVsbG8gV29ybGQh=='\n *\n * const value_bytes = Base64.fromBytes(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'SGVsbG8gV29ybGQh=='\n *\n * const value_hex = Base64.fromHex('0x48656c6c6f20576f726c6421')\n * // @log: 'SGVsbG8gV29ybGQh=='\n * ```\n *\n * ### Decoding Base64\n *\n * Values can be decoded from Base64 with:\n *\n * - {@link ox#Base64.(toString:function)}, or\n *\n * - {@link ox#Base64.(toBytes:function)}, or\n *\n * - {@link ox#Base64.(toHex:function)}\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value_string = Base64.toString('SGVsbG8gV29ybGQh==')\n * // @log: 'Hello World!'\n *\n * const value_bytes = Base64.toBytes('SGVsbG8gV29ybGQh==')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n *\n * const value_hex = Base64.toHex('SGVsbG8gV29ybGQh==')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @category Data\n */\n\n/**\n * Utility functions for working with [EIP-7864](https://eips.ethereum.org/EIPS/eip-7864) Binary State Trees.\n *\n * @category Binary State Tree (EIP-7864)\n */\n\n/**\n * Utility functions for working with [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Blobs.\n *\n * @category Blobs (EIP-4844)\n */\n\n/**\n * Utilities & types for working with Blocks as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Blocks can be converted from RPC format to internal format using {@link ox#Block.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Block } from 'ox'\n *\n * const block = await window.ethereum!\n *   .request({\n *     method: 'eth_getBlockByNumber',\n *     params: ['latest', false],\n *   })\n *   .then(Block.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: 19868020n,\n * // @log:   size: 520n,\n * // @log:   timestamp: 1662222222n,\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\n\n/**\n * Utilities & types for working with **Block Overrides**.\n *\n * @category Execution Spec\n */\n\n/**\n * Utility functions for working with Bloom Filters as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml)\n *\n * @category Execution Spec\n */\n\n/**\n * Utility functions for [BLS12-381](https://hackmd.io/\\@benjaminion/bls12-381) cryptography.\n *\n * :::info\n *\n * The `Bls` module is a friendly wrapper over [`@noble/curves/bls12-381`](https://github.com/paulmillr/noble-curves), an **audited** implementation of BLS12-381.\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#Bls.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#Bls.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const publicKey = Bls.getPublicKey({ privateKey })\n * // @log: { x: 3251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#Bls.(sign:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey })\n * // @log: { x: 1251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#Secp256k1.(verify:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * const publicKey = Bls.getPublicKey({ privateKey })\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = Bls.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @example\n * ### Aggregating Public Keys & Signatures\n *\n * Public keys and signatures can be aggregated using {@link ox#Bls.(aggregate:function)}:\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKeys = [\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n * ]\n * const publicKey = Bls.aggregate(publicKeys)\n *\n * const signatures = [\n *   Bls.sign({ payload: '0x...', privateKey: '0x...' }),\n *   Bls.sign({ payload: '0x...', privateKey: '0x...' }),\n * ]\n * const signature = Bls.aggregate(signatures)\n * ```\n *\n * @example\n * ### Verify Aggregated Signatures\n *\n * We can also pass a public key and signature that was aggregated with {@link ox#Bls.(aggregate:function)} to `Bls.verify`.\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKeys = Array.from({ length: 100 }, () => Bls.randomPrivateKey())\n *\n * const publicKeys = privateKeys.map((privateKey) =>\n *   Bls.getPublicKey({ privateKey }),\n * )\n * const signatures = privateKeys.map((privateKey) =>\n *   Bls.sign({ payload, privateKey }),\n * )\n *\n * const publicKey = Bls.aggregate(publicKeys) // [!code focus]\n * const signature = Bls.aggregate(signatures) // [!code focus]\n *\n * const valid = Bls.verify({ payload, publicKey, signature }) // [!code focus]\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for working with BLS12-381 points.\n *\n * :::info\n *\n * The `BlsPoint` module is a friendly wrapper over [`@noble/curves/bls12-381`](https://github.com/paulmillr/noble-curves), an **audited** implementation of BLS12-381.\n *\n * :::\n *\n * @example\n * ### Public Keys or Signatures to Hex\n *\n * BLS points can be converted to hex using {@link ox#BlsPoint.(toHex:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n * const publicKeyHex = BlsPoint.toHex(publicKey)\n * // @log: '0xacafff52270773ad1728df2807c0f1b0b271fa6b37dfb8b2f75448573c76c81bcd6790328a60e40ef5a13343b32d9e66'\n *\n * const signature = Bls.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n * const signatureHex = BlsPoint.toHex(signature)\n * // @log: '0xb4698f7611999fba87033b9cf72312c76c683bbc48175e2d4cb275907d6a267ab9840a66e3051e5ed36fd13aa712f9a9024f9fa9b67f716dfb74ae4efb7d9f1b7b43b4679abed6644cf476c12e79f309351ea8452487cd93f66e29e04ebe427c'\n * ```\n *\n * @example\n * ### Hex to Public Keys or Signatures\n *\n * BLS points can be converted from hex using {@link ox#BlsPoint.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = BlsPoint.fromHex('0xacafff52270773ad1728df2807c0f1b0b271fa6b37dfb8b2f75448573c76c81bcd6790328a60e40ef5a13343b32d9e66', 'G1')\n * // @log: { x: 172...514n, y: 175...235n, z: 1n }\n *\n * const signature = BlsPoint.fromHex('0xb4698f7611999fba87033b9cf72312c76c683bbc48175e2d4cb275907d6a267ab9840a66e3051e5ed36fd13aa712f9a9024f9fa9b67f716dfb74ae4efb7d9f1b7b43b4679abed6644cf476c12e79f309351ea8452487cd93f66e29e04ebe427c', 'G2')\n * // @log: { x: 1251...5152n, y: 1251...5152n, z: 1n }\n * ```\n *\n * @category Crypto\n */\n\n/**\n * A set of Ethereum-related utility functions for working with [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instances.\n *\n * @example\n * ### Instantiating Bytes\n *\n * Values can be instantiated as {@link ox#Bytes.Bytes} using:\n *\n * - {@link ox#Bytes.(fromArray:function)}\n *\n * - {@link ox#Bytes.(fromBoolean:function)}\n *\n * - {@link ox#Bytes.(fromHex:function)}\n *\n * - {@link ox#Bytes.(fromNumber:function)}\n *\n * - {@link ox#Bytes.(fromString:function)}\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_array = Bytes.from([1, 2, 3, 4, 5])\n * // @log: Uint8Array [1, 2, 3, 4, 5]\n *\n * const value_boolean = Bytes.fromBoolean(true)\n * // @log: Uint8Array [1]\n *\n * const value_hex = Bytes.fromHex('0x1234567890abcdef')\n * // @log: Uint8Array [18, 52, 86, 120, 144, 175, 207, 15]\n *\n * const value_number = Bytes.fromNumber(1234567890)\n * // @log: Uint8Array [4, 160, 216]\n *\n * const value_string = Bytes.fromString('Hello World!')\n * // @log: Uint8Array [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]\n * ```\n *\n * @example\n * ### Converting from Bytes\n *\n * Values can be converted from {@link ox#Bytes.Bytes} using:\n *\n * - {@link ox#Bytes.(toBigInt:function)}\n *\n * - {@link ox#Bytes.(toBoolean:function)}\n *\n * - {@link ox#Bytes.(toHex:function)}\n *\n * - {@link ox#Bytes.(toNumber:function)}\n *\n * - {@link ox#Bytes.(toString:function)}\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_bigint = Bytes.toBigInt(Bytes.from([4, 160, 216]))\n * // @log: 1234567890n\n *\n * const value_boolean = Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n *\n * const value_hex = Bytes.toHex(Bytes.from([222, 173, 190, 239]))\n * // @log: '0xdeadbeef'\n *\n * const value_number = Bytes.toNumber(Bytes.from([4, 160, 216]))\n * // @log: 1234567890\n *\n * const value_string = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello World!'\n * ```\n *\n * @example\n * ### Concatenating Bytes\n *\n * Values can be concatenated using {@link ox#Bytes.(concat:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const a = Bytes.from([1, 2, 3])\n * const b = Bytes.from([4, 5, 6])\n * const c = Bytes.concat(a, b)\n * // @log: Uint8Array [1, 2, 3, 4, 5, 6]\n * ```\n *\n * @example\n * ### Slicing Bytes\n *\n * Values can be sliced using {@link ox#Bytes.(slice:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value = Bytes.slice(Bytes.from([1, 2, 3, 4, 5, 6]), 2, 4)\n * // @log: Uint8Array [3, 4]\n * ```\n *\n * @example\n * ### Padding Bytes\n *\n * Values can be padded with zeroes using {@link ox#Bytes.(padLeft:function)} or {@link ox#Bytes.(padRight:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value_1 = Bytes.padLeft(Bytes.from([1, 2, 3]), 5)\n * // @log: Uint8Array [0, 0, 1, 2, 3]\n *\n * const value_2 = Bytes.padRight(Bytes.from([1, 2, 3]), 5)\n * // @log: Uint8Array [1, 2, 3, 0, 0]\n * ```\n *\n * @example\n * ### Trimming Bytes\n *\n * Zeroes in values can be trimmed using {@link ox#Bytes.(trimLeft:function)} or {@link ox#Bytes.(trimRight:function)}:\n *\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const value = Bytes.trimLeft(Bytes.from([0, 0, 1, 2, 3]))\n * // @log: Uint8Array [1, 2, 3]\n * ```\n *\n * @category Data\n */\n\n\n/**\n * Utility functions for computing Contract Addresses.\n *\n * @example\n * ### Computing Contract Addresses (CREATE)\n *\n * A Contract Address that was instantiated using the `CREATE` opcode can be computed using {@link ox#ContractAddress.(fromCreate:function)}:\n *\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n *\n * ContractAddress.fromCreate({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @example\n * ### Computing Contract Addresses (CREATE2)\n *\n * A Contract Address that was instantiated using the `CREATE2` opcode can be computed using {@link ox#ContractAddress.(fromCreate2:function)}:\n *\n * ```ts twoslash\n * import { Bytes, ContractAddress, Hex } from 'ox'\n *\n * ContractAddress.fromCreate2({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: Bytes.from('0x6394198df16000526103ff60206004601c335afa6040516060f3'),\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @category Addresses\n */\n\n/**\n * Utility functions for working with ENS names.\n *\n * @example\n * ### Normalizing ENS Names\n *\n * ENS names can be normalized using {@link ox#Ens.(normalize:function)}:\n *\n * ```ts twoslash\n * import { Ens } from 'ox'\n *\n * const name = Ens.normalize('wvm.eth')\n * // @log: 'wvm.eth'\n * ```\n *\n * @example\n * ### Namehashing ENS Names\n *\n * ENS names can be namehashed using {@link ox#Ens.(namehash:function)}:\n *\n * ```ts twoslash\n * import { Ens } from 'ox'\n *\n * const name = Ens.namehash('alice.eth')\n * // @log: '0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec'\n * ```\n *\n * @category ENS\n */\n\n\n/**\n * Utilities & types for working with Filters as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/filter.yaml)\n *\n * @category Execution Spec\n */\n\n/**\n * Utility functions for hashing (keccak256, sha256, etc).\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * const value = Hash.keccak256('0xdeadbeef')\n * // '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for generating and working with [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) HD Wallets.\n *\n * :::info\n *\n * The `HdKey` module is a friendly wrapper over [`@scure/bip32`](https://github.com/paulmillr/scure-bip32), an **audited** implementation of [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) HD Wallets.\n *\n * :::\n *\n *\n * @category Crypto\n */\n\n/**\n * A set of Ethereum-related utility functions for working with hexadecimal string values (e.g. `\"0xdeadbeef\"`).\n *\n * @example\n * ### Instantiating Hex\n *\n * Values can be instantiated as {@link ox#Hex.Hex} using:\n *\n * - {@link ox#Hex.(fromBoolean:function)}\n *\n * - {@link ox#Hex.(fromBytes:function)}\n *\n * - {@link ox#Hex.(fromNumber:function)}\n *\n * - {@link ox#Hex.(fromString:function)}\n *\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * const value_boolean = Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * const value_bytes = Hex.fromBytes(Bytes.from([1, 2, 3]))\n * // @log: '0x010203'\n *\n * const value_number = Hex.fromNumber(1234567890)\n * // @log: '0x499602d2'\n *\n * const value_string = Hex.fromString('Hello World!')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @example\n * ### Converting from Hex\n *\n * Values can be converted from {@link ox#Hex.Hex} using:\n *\n * - {@link ox#Hex.(toBoolean:function)}\n *\n * - {@link ox#Hex.(toBytes:function)}\n *\n * - {@link ox#Hex.(toNumber:function)}\n *\n * - {@link ox#Hex.(toString:function)}\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value_boolean = Hex.toBoolean('0x1')\n * // @log: true\n *\n * const value_bytes = Hex.toBytes('0x010203')\n * // @log: Uint8Array [1, 2, 3]\n *\n * const value_number = Hex.toNumber('0x499602d2')\n * // @log: 1234567890\n *\n * const value_string = Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello World!'\n * ```\n *\n * @example\n * ### Concatenating Hex\n *\n * Hex values can be concatenated using {@link ox#Hex.(concat:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const a = Hex.fromString('0x1234567890abcdef')\n * const b = Hex.fromString('0xdeadbeef')\n * const c = Hex.concat(a, b)\n * // @log: '0x1234567890abcdefdeadbeef'\n * ```\n *\n * @example\n * ### Slicing Hex\n *\n * Hex values can be sliced using {@link ox#Hex.(slice:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.slice('0x1234567890abcdefdeadbeef', 2, 8)\n * // @log: '0x34567890'\n * ```\n *\n * @example\n * ### Padding Hex\n *\n * Hex values can be padded with zeroes using {@link ox#Hex.(padLeft:function)} or {@link ox#Hex.(padRight:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.padLeft('0x1234567890abcdef', 16)\n * // @log: '0x00000000000000001234567890abcdef'\n * ```\n *\n * @example\n * ### Trimming Hex\n *\n * Hex values can be trimmed of zeroes using {@link ox#Hex.(trimLeft:function)} or {@link ox#Hex.(trimRight:function)}:\n *\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const value = Hex.trimLeft('0x00000000000000001234567890abcdef')\n * // @log: '0x1234567890abcdef'\n * ```\n *\n * @category Data\n */\n\n/**\n * @category Execution Spec\n */\n\n/**\n * Utility functions for working with JSON (with support for `bigint`).\n *\n * @example\n * ### Stringifying JSON\n *\n * JSON values can be stringified (with `bigint` support) using {@link ox#Json.(stringify:function)}:\n *\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":69420694206942069420694206942069420694206942069420}'\n * ```\n *\n * @example\n * ### Parsing JSON\n *\n * JSON values can be parsed (with `bigint` support) using {@link ox#Json.(parse:function)}:\n *\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const value = Json.parse('{\"foo\":\"bar\",\"baz\":69420694206942069420694206942069420694206942069420}')\n * // @log: { foo: 'bar', baz: 69420694206942069420694206942069420694206942069420n }\n * ```\n *\n * @category JSON\n */\n\n/**\n * Utilities & types for working with [Keystores](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage).\n *\n * @example\n * ### Encrypting & Decrypting Private Keys\n *\n * Private keys can be encrypted into a JSON keystore using {@link ox#Keystore.(encrypt:function)} and decrypted using {@link ox#Keystore.(decrypt:function)}:\n *\n * ```ts twoslash\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // Generate a random private key.\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * // Derive a key from a password.\n * const key = Keystore.pbkdf2({ password: 'testpassword' })\n *\n * // Encrypt the private key.\n * const encrypted = await Keystore.encrypt(privateKey, key)\n * // @log: {\n * // @log:   \"crypto\": {\n * // @log:     \"cipher\": \"aes-128-ctr\",\n * // @log:     \"ciphertext\": \"...\",\n * // @log:     \"cipherparams\": {\n * // @log:       \"iv\": \"...\",\n * // @log:     },\n * // @log:     \"kdf\": \"pbkdf2\",\n * // @log:     \"kdfparams\": {\n * // @log:       \"salt\": \"...\",\n * // @log:       \"dklen\": 32,\n * // @log:       \"prf\": \"hmac-sha256\",\n * // @log:       \"c\": 262144,\n * // @log:     },\n * // @log:     \"mac\": \"...\",\n * // @log:   },\n * // @log:   \"id\": \"...\",\n * // @log:   \"version\": 3,\n * // @log: }\n *\n * // Decrypt the private key.\n * const decrypted = await Keystore.decrypt(encrypted, key)\n * // @log: \"0x...\"\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for working with KZG Commitments.\n *\n * Mainly for [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Blobs.\n *\n * @category Blobs (EIP-4844)\n */\n\n/**\n * Utilities & types for working with Logs as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml)\n *\n * :::tip\n *\n * Utilities for Log encoding & decoding can be found on the {@link ox#AbiEvent} module.\n *\n * :::\n *\n * @example\n * ### Converting from RPC Format\n *\n * Logs can be converted from their RPC format using {@link ox#Log.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex, Log } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 indexed value)',\n * )\n *\n * const { topics } = AbiEvent.encode(transfer)\n *\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n *\n * const log = Log.fromRpc(logs[0]) // [!code focus]\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\n\n/**\n * Utility functions for generating and working with [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) mnemonics.\n *\n * :::info\n *\n * The `Mnemonic` module is a friendly wrapper over [`@scure/bip39`](https://github.com/paulmillr/scure-bip39), an **audited** implementation of [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n *\n * :::\n *\n * @example\n * ### Generating a Random Mnemonic\n *\n * Random mnemonics can be generated using {@link ox#Mnemonic.(random:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * // @log: 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * ```\n *\n * @example\n * ### Converting to Private Key\n *\n * Mnemonics can be converted to a private key using {@link ox#Mnemonic.(toPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const privateKey = Mnemonic.toPrivateKey('buyer zoo end danger ice capable shrug naive twist relief mass bonus')\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Converting to HD Key\n *\n * Mnemonics can be converted to a HD Key using {@link ox#Mnemonic.(toHdKey:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const hdKey = Mnemonic.toHdKey('buyer zoo end danger ice capable shrug naive twist relief mass bonus')\n * ```\n *\n * @example\n * ### Converting to Seed\n *\n * Mnemonics can be converted to a master seed using {@link ox#Mnemonic.(toSeed:function)}:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * const seed = Mnemonic.toSeed(mnemonic)\n * // @log: Uint8Array [...64 bytes]\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utilities & types for working with [EIP-191 Personal Messages](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e)\n *\n * @example\n * ### Computing Sign Payload\n *\n * An EIP-191 personal sign payload can be computed using {@link ox#PersonalMessage.(getSignPayload:function)}:\n *\n * ```ts twoslash\n * import { Hex, PersonalMessage, Secp256k1 } from 'ox'\n *\n * const payload = PersonalMessage.getSignPayload(Hex.fromString('hello world')) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @category Signed & Typed Data\n */\n\n/**\n * Utilities & types for working with [EIP-1193 Providers](https://eips.ethereum.org/EIPS/eip-1193)\n *\n * @example\n * ### Instantiating External Providers\n *\n * External EIP-1193 Providers can be instantiated with {@link ox#Provider.(from:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating with an RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is also EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * Event emitters for EIP-1193 Providers can be created using {@link ox#Provider.(createEmitter:function)}:\n *\n * Useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @category Providers (EIP-1193)\n */\n\n/**\n * Utility functions for working with ECDSA public keys.\n *\n * @example\n * ### Serializing Public Keys\n *\n * Public Keys can be serialized to Hex or Bytes using {@link ox#PublicKey.(toHex:function)}:\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const serialized = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @example\n * ### Deserializing Public Keys\n *\n * Public Keys can be deserialized from Hex or Bytes using {@link ox#PublicKey.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for encoding and decoding [Recursive Length Prefix](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/) structures.\n *\n * @example\n * ```ts twoslash\n * import { Hex, Rlp } from 'ox'\n *\n * const data = Rlp.fromHex([Hex.fromString('hello'), Hex.fromString('world')])\n * // @log: '0xcc8568656c6c6f85776f726c64'\n *\n * const values = Rlp.toHex(data)\n * // @log: [Hex.fromString('hello'), Hex.fromString('world')]\n * ```\n *\n * @category Data\n */\n\n/**\n * Utility types for working with Ethereum JSON-RPC namespaces & schemas.\n *\n * @category JSON-RPC\n */\n\n/**\n * Utility types & functions for working with [JSON-RPC 2.0 Requests](https://www.jsonrpc.org/specification#request_object) and Ethereum JSON-RPC methods as\n * defined on the [Ethereum API specification](https://github.com/ethereum/execution-apis)\n *\n * @example\n * ### Instantiating a Request Store\n *\n * A Request Store can be instantiated using {@link ox#RpcRequest.(createStore:function)}:\n *\n * ```ts twoslash\n * import { RpcRequest } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request_1 = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n * // @log: { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber' }\n *\n * const request_2 = store.prepare({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       to: '0x0000000000000000000000000000000000000000',\n *       data: '0xdeadbeef',\n *     },\n *   ],\n * })\n * // @log: { id: 1, jsonrpc: '2.0', method: 'eth_call', params: [{ to: '0x0000000000000000000000000000000000000000', data: '0xdeadbeef' }] }\n * ```\n *\n * @category JSON-RPC\n */\n\n/**\n * Utility types & functions for working with [JSON-RPC 2.0 Responses](https://www.jsonrpc.org/specification#response_object)\n *\n * @example\n * ### Instantiating an RPC Response\n *\n * RPC Responses can be instantiated using {@link ox#RpcResponse.(from:function)}:\n *\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const response = RpcResponse.from({\n *   id: 0,\n *   jsonrpc: '2.0',\n *   result: '0x69420',\n * })\n * ```\n *\n * :::note\n *\n * Type-safe instantiation from a `request` object is also supported. If a `request` is provided, then the `id` and `jsonrpc` properties will be overridden with the values from the request.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const request = RpcRequest.from({ id: 0, method: 'eth_blockNumber' })\n *\n * const response = RpcResponse.from(\n *   { result: '0x69420' },\n *   { request },\n * )\n * ```\n *\n * :::\n *\n * @example\n * ### Parsing an RPC Response\n *\n * RPC Responses can be parsed using {@link ox#RpcResponse.(parse:function)}:\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @category JSON-RPC\n */\n\n/**\n * Utility functions for working with JSON-RPC Transports.\n *\n * :::note\n * This is a convenience module distributed for experimenting with network connectivity on Ox.\n *\n * Consider using networking functionality from a higher-level library such as [Viem's Transports](https://viem.sh/docs/clients/transports/http)\n * if you need more features such as: retry logic, WebSockets/IPC, middleware, batch JSON-RPC, etc.\n * :::\n *\n * @example\n * ### HTTP Instantiation\n *\n * ```ts twoslash\n * import { RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n *\n * const blockNumber = await transport.request({ method: 'eth_blockNumber' })\n * // @log: '0x1a2b3c'\n * ```\n *\n * @category JSON-RPC\n */\n\n/**\n * Utility functions for [secp256k1](https://www.secg.org/sec2-v2.pdf) ECDSA cryptography.\n *\n * :::info\n *\n * The `Secp256k1` module is a friendly wrapper over [`@noble/curves/secp256k1`](https://github.com/paulmillr/noble-curves), an **audited** implementation of [secp256k1](https://www.secg.org/sec2-v2.pdf)\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#Secp256k1.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#Secp256k1.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey }) // [!code focus]\n * // @log: { x: 3251...5152n, y: 1251...5152n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#Secp256k1.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey }) // [!code focus]\n * // @log: { r: 1251...5152n, s: 1251...5152n, yParity: 1 }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#Secp256k1.(verify:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = Secp256k1.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography.\n *\n * :::info\n *\n * The `P256` module is a friendly wrapper over [`@noble/curves/p256`](https://github.com/paulmillr/noble-curves), an **audited** implementation of [P256](https://www.secg.org/sec2-v2.pdf)\n *\n * :::\n *\n * @example\n * ### Computing a Random Private Key\n *\n * A random private key can be computed using {@link ox#P256.(randomPrivateKey:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Getting a Public Key\n *\n * A public key can be derived from a private key using {@link ox#P256.(getPublicKey:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n *\n * const publicKey = P256.getPublicKey({ privateKey }) // [!code focus]\n * // @log: { x: 3251...5152n, y: 1251...5152n }\n * ```\n *\n * @example\n * ### Signing a Payload\n *\n * A payload can be signed using {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey }) // [!code focus]\n * // @log: { r: 1251...5152n, s: 1251...5152n, yParity: 1 }\n * ```\n *\n * @example\n * ### Verifying a Signature\n *\n * A signature can be verified using {@link ox#P256.(verify:function)}:\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const isValid = P256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for working with ECDSA signatures.\n *\n * @example\n * ### Serializing a Signature\n *\n * Signatures can be serialized to Hex or Bytes using {@link ox#Signature.(toHex:function)}:\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @example\n * ### Deserializing a Signature\n *\n * Signatures can be deserialized from Hex or Bytes using {@link ox#Signature.(fromHex:function)}:\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for working with\n * [EIP-4361: Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361)\n *\n * @example\n * ### Creating a SIWE Message\n *\n * SIWE messages can be created using {@link ox#Siwe.(createMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @log: \"example.com wants you to sign in with your Ethereum account:\n * // @log: 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n * // @log:\n * // @log:\n * // @log: URI: https://example.com/path\n * // @log: Version: 1\n * // @log: Chain ID: 1\n * // @log: Nonce: foobarbaz\n * // @log: Issued At: 2023-02-01T00:00:00.000Z\"\n * ```\n *\n * @example\n * ### Generating SIWE Nonces\n *\n * SIWE nonces can be generated using {@link ox#Siwe.(generateNonce:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.generateNonce()\n * // @log: '65ed4681d4efe0270b923ff5f4b097b1c95974dc33aeebecd5724c42fd86dfd25dc70b27ef836b2aa22e68f19ebcccc1'\n * ```\n *\n * @example\n * ### Parsing a SIWE Message\n *\n * SIWE messages can be parsed using {@link ox#Siwe.(parseMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.parseMessage(`example.com wants you to sign in with your Ethereum account:\n * 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n *\n * I accept the ExampleOrg Terms of Service: https://example.com/tos\n *\n * URI: https://example.com/path\n * Version: 1\n * Chain ID: 1\n * Nonce: foobarbaz\n * Issued At: 2023-02-01T00:00:00.000Z`)\n * // @log: {\n * // @log:   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * // @log:   chainId: 1,\n * // @log:   domain: 'example.com',\n * // @log:   issuedAt: '2023-02-01T00:00:00.000Z',\n * // @log:   nonce: 'foobarbaz',\n * // @log:   statement: 'I accept the ExampleOrg Terms of Service: https://example.com/tos',\n * // @log:   uri: 'https://example.com/path',\n * // @log:   version: '1',\n * // @log: }\n * ```\n *\n * @example\n * ### Validating a SIWE Message\n *\n * SIWE messages can be validated using {@link ox#Siwe.(validateMessage:function)}:\n *\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.validateMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: 'example.com',\n *   message: {\n *     address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *     chainId: 1,\n *     domain: 'example.com',\n *     nonce: 'foobarbaz',\n *     uri: 'https://example.com/path',\n *     version: '1',\n *   },\n *   nonce: 'foobarbaz',\n * })\n * // @log: true\n * ```\n *\n * @category Sign-In with Ethereum (EIP-4361)\n */\n\n\n/**\n * Utilities & types for working with **State Overrides**.\n *\n * @category Execution Spec\n */\n\n/**\n * Utilities & types for working with **Transactions** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Transactions can be converted from RPC format using {@link ox#Transaction.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x2',\n * })\n * ```\n *\n * @category Execution Spec\n */\n\n/**\n * Errors & Types for working with Transaction Envelopes.\n *\n * :::note\n * Refer to the following modules for specific Transaction Envelope types:\n * - [`TransactionEnvelopeLegacy`](/api/TransactionEnvelopeLegacy)\n * - [`TransactionEnvelopeEip1559`](/api/TransactionEnvelopeEip1559)\n * - [`TransactionEnvelopeEip2930`](/api/TransactionEnvelopeEip2930)\n * - [`TransactionEnvelopeEip4844`](/api/TransactionEnvelopeEip4844)\n * - [`TransactionEnvelopeEip7702`](/api/TransactionEnvelopeEip7702)\n * :::\n *\n * @category Transaction Envelopes\n */\n\n/**\n * Utility functions for working\n * with **Legacy Transaction Envelopes**.\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeLegacy.(from:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeLegacy.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeLegacy.(serialize:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeLegacy, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeLegacy.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeLegacy.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\n\n/**\n * Utility functions for working with [EIP-1559 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-1559)\n *\n *  @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip1559.(from:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip1559.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip1559.(serialize:function)}:\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeEip1559, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeEip1559.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip1559.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip1559.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\n\n/**\n * Utility functions for working with [EIP-2930 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-2930)\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip2930.(from:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip2930.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip2930.(serialize:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { RpcTransport, TransactionEnvelopeEip2930, Secp256k1, Value } from 'ox'\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip2930.from({\n *   accessList: [],\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * If you are interfacing with an RPC that supports `eth_sendTransaction`, you can also use\n * {@link ox#TransactionEnvelopeEip2930.(toRpc:function)} to convert an Envelope to an RPC-compatible format.\n * This means you can skip the ceremony of manually filling & signing the Transaction.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   accessList: [],\n *   chainId: 1,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope)\n *\n * const provider = Provider.from(window.ethereum)\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip2930.(hash:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n *   data: '0x',\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\n\n/**\n * Utility functions for working with [EIP-4844 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-4844)\n *\n * @example\n * ### Instantiating Blobs\n *\n * Blobs can be instantiated using {@link ox#Blobs.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello World!'))\n * ```\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip4844.(from:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Hex, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello World!'))\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip4844.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, {\n *   sidecars,\n *   signature\n * })\n * ```\n *\n * @example\n * ### Serializing\n *\n * Transaction Envelopes can be serialized using {@link ox#TransactionEnvelopeEip4844.(serialize:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, RpcTransport, TransactionEnvelopeEip4844, Secp256k1, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * // Compute the Blob Versioned Hashes.\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n *\n * // Construct the Envelope.\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 0n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * // Sign over the Envelope.\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Computing Hashes\n *\n * Transaction Hashes can be computed using {@link ox#TransactionEnvelopeEip4844.(hash:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip4844.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\n\n/**\n * Utility functions for working with [EIP-7702 Typed Transaction Envelopes](https://eips.ethereum.org/EIPS/eip-7702)\n *\n * @example\n * ### Instantiating\n *\n * Transaction Envelopes can be instantiated using {@link ox#TransactionEnvelopeEip7702.(from:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * :::tip\n *\n * See {@link ox#Authorization} for more details on instantiating and signing EIP-7702 Authorizations.\n *\n * :::\n *\n * @example\n * ### Signing\n *\n * Transaction Envelopes can be signed using {@link ox#TransactionEnvelopeEip7702.(getSignPayload:function)} and a signing function such as {@link ox#Secp256k1.(sign:function)} or {@link ox#P256.(sign:function)}:\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature_auth = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature: signature_auth })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope), // [!code focus]\n *   privateKey: '0x...', // [!code focus]\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n * ```\n *\n * @example\n * ### Sending\n *\n * We can send a Transaction Envelope to the network by serializing the signed envelope with `.serialize`, and then broadcasting it over JSON-RPC with `eth_sendRawTransaction`.\n *\n * In this example, we will use {@link ox#RpcTransport.(fromHttp:function)} to broadcast a `eth_sendRawTransaction` request over HTTP JSON-RPC.\n *\n * ```ts twoslash\n * import { Authorization, RpcTransport, TransactionEnvelopeEip7702, Secp256k1, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature_auth = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature: signature_auth })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   nonce: 69n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1.5'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * // Serialize the Envelope with the Signature. // [!code focus]\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature  // [!code focus]\n * }) // [!code focus]\n *\n * // Broadcast the Envelope with `eth_sendRawTransaction`. // [!code focus]\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com') // [!code focus]\n * const hash = await transport.request({ // [!code focus]\n *   method: 'eth_sendRawTransaction', // [!code focus]\n *   params: [serialized], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @category Transaction Envelopes\n */\n\n/**\n * Utilities & types for working with **Transaction Receipts** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml)\n *\n * @example\n * ### Converting from RPC Format\n *\n * Receipts can be converted from RPC format using {@link ox#TransactionReceipt.(fromRpc:function)}:\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = await window.ethereum!\n *   .request({\n *     method: 'eth_getTransactionReceipt',\n *     params: [\n *       '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *     ],\n *   })\n *   .then(TransactionReceipt.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @category Execution Spec\n */\n\n/**\n * Utilities & types for working with **Transaction Requests** as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/4aca1d7a3e5aab24c8f6437131289ad386944eaa/src/schemas/transaction.yaml#L358-L423)\n *\n * @example\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionRequest, Value } from 'ox'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({ // [!code focus]\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', // [!code focus]\n *   value: Value.fromEther('0.01'), // [!code focus]\n * }) // [!code focus]\n *\n * const hash = await provider.request({\n *   method: 'eth_sendTransaction',\n *   params: [request],\n * })\n * ```\n *\n * @category Execution Spec\n */\n\n/**\n * Utility functions for working with [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712)\n *\n * @example\n * ### Getting Sign Payloads\n *\n * Typed Data can be converted to a sign payload using {@link ox#TypedData.(getSignPayload:function)}:\n *\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @category Signed & Typed Data\n */\n\n/**\n * Utilities & types for working with [EIP-191 Validator Data](https://eips.ethereum.org/EIPS/eip-191#0x00)\n *\n * @category Signed & Typed Data\n */\n\n/**\n * Utility functions for displaying and parsing Ethereum Values as defined under **2.1. Value** in the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Value } from 'ox'\n *\n * const value = Value.fromEther('1')\n * // @log: 1_000_000_000_000_000_000n\n *\n * const formattedValue = Value.formatEther(value)\n * // @log: '1'\n *\n * const value = Value.fromEther('1', 'szabo')\n * // @log: 1_000_000n\n * ```\n *\n * @category Data\n */\n\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography using the [Web Authentication API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API)\n *\n * @example\n * ### Creating Credentials\n *\n * Credentials can be created using {@link ox#WebAuthnP256.(createCredential:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @example\n * ### Signing Payloads\n *\n * Payloads can be signed using {@link ox#WebAuthnP256.(sign:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @example\n * ### Verifying Signatures\n *\n * Signatures can be verified using {@link ox#WebAuthnP256.(verify:function)}:\n *\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utility functions for [NIST P256](https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session6-adalier-mehmet.pdf) ECDSA cryptography using the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)\n *\n * @example\n * ### Creating Key Pairs\n *\n * Key pairs can be created using {@link ox#WebCryptoP256.(createKeyPair:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @example\n * ### Signing Payloads\n *\n * Payloads can be signed using {@link ox#WebCryptoP256.(sign:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @example\n * ### Verifying Signatures\n *\n * Signatures can be verified using {@link ox#WebCryptoP256.(verify:function)}:\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @category Crypto\n */\n\n/**\n * Utilities & types for working with Withdrawals as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/withdrawal.yaml)\n *\n * @category Execution Spec\n */\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L19lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsMENBQTBDLEdBQUcseUNBQXlDO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0JBQWtCLDhDQUE4Qyw2QkFBNkI7QUFDcEc7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtCQUFrQix3REFBd0QsNkJBQTZCO0FBQzlHO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrQkFBa0IscURBQXFELCtCQUErQjtBQUM3RztBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUJB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QUNuQyxnREFBZ0QsbUNBQW1DO0FBQ25GO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDbkQsaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L19lc20vaW5kZXguanM/ZTE2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggW0FwcGxpY2F0aW9uIEJpbmFyeSBJbnRlcmZhY2VzIChBQklzKV0oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjLmh0bWwpXG4gKlxuICogOjo6bm90ZVxuICpcbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgQUJJIHBhcmFtZXRlciAqKmVuY29kaW5nKiogJiAqKmRlY29kaW5nKiogZnVuY3Rpb25zLCBzZWUge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuKGVuY29kZTpmdW5jdGlvbil9ICYge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuKGRlY29kZTpmdW5jdGlvbil9LlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyBKU09OIEFCSXNcbiAqXG4gKiBBbiB7QGxpbmsgb3gjQWJpLkFiaX0gY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGEgSlNPTiBBQkkgYnkgdXNpbmcge0BsaW5rIG94I0FiaS4oZnJvbTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbe1xuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBuYW1lOiAnYXBwcm92ZScsXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgICB9LFxuICogICBdLFxuICogICBvdXRwdXRzOiBbeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiB9XSlcbiAqXG4gKiBhYmlcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQW4ge0BsaW5rIG94I0FiaS5BYml9IGNhbiBiZSBpbnN0YW50aWF0ZWQgZnJvbSBhIGh1bWFuLXJlYWRhYmxlIEFCSSBieSB1c2luZyB7QGxpbmsgb3gjQWJpLihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCkgcmV0dXJucyAoYm9vbCknLFxuICogXSlcbiAqXG4gKiBhYmlcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRm9ybWF0dGluZyBBQklzXG4gKlxuICogQW4ge0BsaW5rIG94I0FiaS5BYml9IGNhbiBiZSBmb3JtYXR0ZWQgaW50byBhIGh1bWFuLXJlYWRhYmxlIEFCSSBieSB1c2luZyB7QGxpbmsgb3gjQWJpLihmb3JtYXQ6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpIH0gZnJvbSAnb3gnXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbe1xuICogICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICBuYW1lOiAnYXBwcm92ZScsXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICogICBpbnB1dHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBuYW1lOiAnYW1vdW50JyxcbiAqICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgICB9LFxuICogICBdLFxuICogICBvdXRwdXRzOiBbeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiB9XSlcbiAqIC8vLS0tY3V0LS0tXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmkuZm9ybWF0KGFiaSlcbiAqXG4gKiBmb3JtYXR0ZWRcbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBBQklcbiAqL1xuZXhwb3J0ICogYXMgQWJpIGZyb20gJy4vY29yZS9BYmkuanMnO1xuLyoqXG4gKiBVdGlsaXRpZXMgJiB0eXBlcyBmb3Igd29ya2luZyB3aXRoIFtDb25zdHJ1Y3RvcnNdKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC9hYmktc3BlYy5odG1sI2pzb24pIG9uIEFCSXMuXG4gKlxuICogYEFiaUNvbnN0cnVjdG9yYCBpcyBhIHN1Yi10eXBlIG9mIFtgQWJpSXRlbWBdKC9hcGkvQWJpSXRlbSkuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBJbnN0YW50aWF0aW5nIHZpYSBKU09OIEFCSVxuICpcbiAqIEFuIGBBYmlDb25zdHJ1Y3RvcmAgY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGEgSlNPTiBBQkkgYnkgdXNpbmcge0BsaW5rIG94I0FiaUNvbnN0cnVjdG9yLihmcm9tQWJpOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpQ29uc3RydWN0b3IgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdjb25zdHJ1Y3RvcihhZGRyZXNzIG93bmVyKScsXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICpcbiAqIGNvbnN0IGl0ZW0gPSBBYmlDb25zdHJ1Y3Rvci5mcm9tQWJpKGFiaSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyB2aWEgSHVtYW4tUmVhZGFibGUgQUJJIEl0ZW1cbiAqXG4gKiBBbiBgQWJpQ29uc3RydWN0b3JgIGNhbiBiZSBpbnN0YW50aWF0ZWQgZnJvbSBhIGh1bWFuLXJlYWRhYmxlIEFCSSBieSB1c2luZyB7QGxpbmsgb3gjQWJpQ29uc3RydWN0b3IuKGZyb206ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpQ29uc3RydWN0b3IgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBjb25zdHJ1Y3RvciA9IEFiaUNvbnN0cnVjdG9yLmZyb20oJ2NvbnN0cnVjdG9yKGFkZHJlc3Mgb3duZXIpJylcbiAqXG4gKiBjb25zdHJ1Y3RvclxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmNvZGluZyB0byBEZXBsb3kgRGF0YVxuICpcbiAqIENvbnN0cnVjdG9yIGFyZ3VtZW50cyBjYW4gYmUgQUJJLWVuY29kZWQgdXNpbmcge0BsaW5rIG94I0FiaUNvbnN0cnVjdG9yLihlbmNvZGU6ZnVuY3Rpb24pfSAod2l0aCBieXRlY29kZSkgaW50byBkZXBsb3kgZGF0YS4gVGhpcyBkYXRhIGNhbiB0aGVuIGJlIHBhc3NlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGRlcGxveSBhIGNvbnRyYWN0LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlDb25zdHJ1Y3RvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGNvbnN0cnVjdG9yID0gQWJpQ29uc3RydWN0b3IuZnJvbSgnY29uc3RydWN0b3IoYWRkcmVzcywgdWludDI1NiknKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlDb25zdHJ1Y3Rvci5lbmNvZGUoY29uc3RydWN0b3IsIHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBieXRlY29kZTogJzB4Li4uJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBhcmdzOiBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDEyM25dLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQUJJXG4gKi9cbmV4cG9ydCAqIGFzIEFiaUNvbnN0cnVjdG9yIGZyb20gJy4vY29yZS9BYmlDb25zdHJ1Y3Rvci5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggW0Vycm9yc10oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjLmh0bWwjanNvbikgb24gQUJJcy5cbiAqXG4gKiBgQWJpRXJyb3JgIGlzIGEgc3ViLXR5cGUgb2YgW2BBYmlJdGVtYF0oL2FwaS9BYmlJdGVtKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEluc3RhbnRpYXRpbmcgdmlhIEpTT04gQUJJXG4gKlxuICogQW4gYEFiaUVycm9yYCBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gYSBKU09OIEFCSSBieSB1c2luZyB7QGxpbmsgb3gjQWJpRXJyb3IuKGZyb21BYmk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlFcnJvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2Vycm9yIEJhZFNpZ25hdHVyZVYodWludDggdiknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUVycm9yLmZyb21BYmkoYWJpLCAnQmFkU2lnbmF0dXJlVicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEluc3RhbnRpYXRpbmcgdmlhIEh1bWFuLVJlYWRhYmxlIEFCSSBJdGVtXG4gKlxuICogQW4gYEFiaUVycm9yYCBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gYSBodW1hbi1yZWFkYWJsZSBBQkkgYnkgdXNpbmcge0BsaW5rIG94I0FiaUVycm9yLihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUVycm9yIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZXJyb3IgPSBBYmlFcnJvci5mcm9tKCdlcnJvciBCYWRTaWduYXR1cmVWKHVpbnQ4IHYpJylcbiAqXG4gKiBlcnJvclxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBEZWNvZGluZyBFcnJvciBEYXRhXG4gKlxuICogRXJyb3IgZGF0YSBjYW4gYmUgQUJJLWRlY29kZWQgdXNpbmcgdGhlIHtAbGluayBveCNBYmlFcnJvci4oZGVjb2RlOmZ1bmN0aW9uKX0gZnVuY3Rpb24uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlFcnJvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFsuLi5dKVxuICogY29uc3QgZXJyb3IgPSBBYmlFcnJvci5mcm9tQWJpKGFiaSwgJ0ludmFsaWRTaWduYXR1cmUnKVxuICpcbiAqIGNvbnN0IHZhbHVlID0gQWJpRXJyb3IuZGVjb2RlKGVycm9yLCAnMHhlY2RlNjM0OTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQ1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFs0MjBuLCA2OW4sIDFdXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQUJJXG4gKi9cbmV4cG9ydCAqIGFzIEFiaUVycm9yIGZyb20gJy4vY29yZS9BYmlFcnJvci5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggW0V2ZW50c10oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjLmh0bWwjanNvbikgb24gQUJJcy5cbiAqXG4gKiBgQWJpRXZlbnRgIGlzIGEgc3ViLXR5cGUgb2YgW2BBYmlJdGVtYF0oL2FwaS9BYmlJdGVtKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEluc3RhbnRpYXRpbmcgdmlhIEpTT04gQUJJXG4gKlxuICogQW4gYEFiaUV2ZW50YCBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gYSBKU09OIEFCSSBieSB1c2luZyB7QGxpbmsgb3gjQWJpRXZlbnQuKGZyb21BYmk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUV2ZW50LmZyb21BYmkoYWJpLCAnVHJhbnNmZXInKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBJbnN0YW50aWF0aW5nIHZpYSBIdW1hbi1SZWFkYWJsZSBBQkkgSXRlbVxuICpcbiAqIEFuIGBBYmlFdmVudGAgY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGEgaHVtYW4tcmVhZGFibGUgQUJJIGJ5IHVzaW5nIHtAbGluayBveCNBYmlFdmVudC4oZnJvbTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlFdmVudCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHRyYW5zZmVyID0gQWJpRXZlbnQuZnJvbShcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpJyAvLyBbIWNvZGUgaGxdXG4gKiApXG4gKlxuICogdHJhbnNmZXJcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEVuY29kaW5nIHRvIEV2ZW50IFRvcGljc1xuICpcbiAqIEVuY29kZSBhbiBgQWJpRXZlbnRgIGludG8gdG9waWNzIHVzaW5nIHtAbGluayBveCNBYmlFdmVudC4oZW5jb2RlOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUV2ZW50IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNmZXIgPSBBYmlFdmVudC5mcm9tKFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSknXG4gKiApXG4gKlxuICogY29uc3QgeyB0b3BpY3MgfSA9IEFiaUV2ZW50LmVuY29kZSh0cmFuc2Zlciwge1xuICogICBmcm9tOiAnMHhmMzlmZDZlNTFhYWQ4OGY2ZjRjZTZhYjg4MjcyNzljZmZmYjkyMjY2JywgLy8gWyFjb2RlIGhsXVxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcgLy8gWyFjb2RlIGhsXVxuICogfSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgJzB4NDA2ZGFkZTMxZjdhZTRiNWRiYzI3NjI1OGMyOGRkZTVhZTZkNWMyNzczYzU3NDU4MDJjNDkzYTIzNjBlNTVlMCcsXG4gKiAvLyBAbG9nOiAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NicsXG4gKiAvLyBAbG9nOiAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCdcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVjb2RpbmcgRXZlbnQgVG9waWNzIGFuZCBEYXRhXG4gKlxuICogRXZlbnQgdG9waWNzIGFuZCBkYXRhIGNhbiBiZSBkZWNvZGVkIHVzaW5nIHtAbGluayBveCNBYmlFdmVudC4oZGVjb2RlOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUV2ZW50IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNmZXIgPSBBYmlFdmVudC5mcm9tKFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiB2YWx1ZSknXG4gKiApXG4gKlxuICogY29uc3QgbG9nID0ge1xuICogICAvLyAuLi5cbiAqICAgZGF0YTogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgIHRvcGljczogW1xuICogICAgICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnLFxuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLFxuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGE1Y2MzYzAzOTk0ZGI1YjBkOWE1ZWVkZDEwY2FiYWIwODEzNjc4YWMnLFxuICogICBdLFxuICogfSBhcyBjb25zdFxuICpcbiAqIGNvbnN0IGRlY29kZWQgPSBBYmlFdmVudC5kZWNvZGUodHJhbnNmZXIsIGxvZylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgZnJvbTogJzB4YTVjYzNjMDM5OTRkYjViMGQ5YTVlZWRkMTBjYWJhYjA4MTM2NzhhYycsXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHhhNWNjM2MwMzk5NGRiNWIwZDlhNWVlZGQxMGNhYmFiMDgxMzY3OGFjJyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDFuXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQUJJXG4gKi9cbmV4cG9ydCAqIGFzIEFiaUV2ZW50IGZyb20gJy4vY29yZS9BYmlFdmVudC5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggW0Z1bmN0aW9uc10oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjLmh0bWwjanNvbikgb24gQUJJcy5cbiAqXG4gKiBgQWJpRnVuY3Rpb25gIGlzIGEgc3ViLXR5cGUgb2YgW2BBYmlJdGVtYF0oL2FwaS9BYmlJdGVtKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEluc3RhbnRpYXRpbmcgdmlhIEpTT04gQUJJXG4gKlxuICogQW4gYEFiaUZ1bmN0aW9uYCBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gYSBKU09OIEFCSSBieSB1c2luZyB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uKGZyb21BYmk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnYmFyJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyB2aWEgSHVtYW4tUmVhZGFibGUgQUJJIEl0ZW1cbiAqXG4gKiBBbiBgQWJpRnVuY3Rpb25gIGNhbiBiZSBpbnN0YW50aWF0ZWQgZnJvbSBhIGh1bWFuLXJlYWRhYmxlIEFCSSBieSB1c2luZyB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uKGZyb206ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBiYXIgPSBBYmlGdW5jdGlvbi5mcm9tKCdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknKVxuICpcbiAqIGJhclxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRW5jb2RpbmcgdG8gRnVuY3Rpb24gRGF0YVxuICpcbiAqIEEgRnVuY3Rpb24gYW5kIGl0cyBhcmd1bWVudHMgY2FuIGJlIEFCSS1lbmNvZGVkIGludG8gZGF0YSB1c2luZyB0aGUge0BsaW5rIG94I0FiaUZ1bmN0aW9uLihlbmNvZGVEYXRhOmZ1bmN0aW9uKX0gZnVuY3Rpb24uIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8gYGV0aF9zZW5kVHJhbnNhY3Rpb25gIG9yIGBldGhfY2FsbGAgYXMgdGhlIGBkYXRhYCBwYXJhbWV0ZXIuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcywgdWludDI1NiknKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGFwcHJvdmUsIC8vIFshY29kZSBmb2N1c11cbiAqICAgWycweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUnLCA2OTQyMG5dIC8vIFshY29kZSBmb2N1c11cbiAqICkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4MDk1ZWE3YjMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMGYyYydcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVjb2RpbmcgYSBGdW5jdGlvbidzIFJlc3VsdFxuICpcbiAqIEEgRnVuY3Rpb24ncyByZXN1bHQgY2FuIGJlIEFCSS1kZWNvZGVkIHVzaW5nIHRoZSB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uKGRlY29kZVJlc3VsdDpmdW5jdGlvbil9IGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJhJ1xuICogLy8gICAg4oaRIEV4YW1wbGUgZGF0YSB0aGF0IGNvdWxkIGJlIHJldHVybmVkIGZyb20gYSBjb250cmFjdCBjYWxsIHZpYSBgZXRoX2NhbGxgLlxuICpcbiAqIGNvbnN0IHRvdGFsU3VwcGx5ID0gQWJpRnVuY3Rpb24uZnJvbSgnZnVuY3Rpb24gdG90YWxTdXBwbHkoKSByZXR1cm5zICh1aW50MjU2KScpXG4gKlxuICogY29uc3Qgb3V0cHV0ID0gQWJpRnVuY3Rpb24uZGVjb2RlUmVzdWx0KHRvdGFsU3VwcGx5LCBkYXRhKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiA0Mm5cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBBQklcbiAqL1xuZXhwb3J0ICogYXMgQWJpRnVuY3Rpb24gZnJvbSAnLi9jb3JlL0FiaUZ1bmN0aW9uLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCBbQUJJIEl0ZW1zXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvYWJpLXNwZWMuaHRtbCNqc29uKVxuICpcbiAqIFRoZSBgQWJpSXRlbWAgdHlwZSBpcyBhIHN1cGVyLXR5cGUgb2Y6XG4gKiAtIFtgQWJpQ29uc3RydWN0b3JgXSgvYXBpL0FiaUNvbnN0cnVjdG9yKVxuICogLSBbYEFiaUZ1bmN0aW9uYF0oL2FwaS9BYmlGdW5jdGlvbilcbiAqIC0gW2BBYmlFdmVudGBdKC9hcGkvQWJpRXZlbnQpXG4gKiAtIFtgQWJpRXJyb3JgXSgvYXBpL0FiaUVycm9yKVxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyB2aWEgSlNPTiBBQklcbiAqXG4gKiBBbiBgQWJpSXRlbWAgY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGEgSlNPTiBBQkkgYnkgdXNpbmcge0BsaW5rIG94I0FiaUl0ZW0uKGZyb21BYmk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqXG4gKiBjb25zdCBpdGVtID0gQWJpSXRlbS5mcm9tQWJpKGFiaSwgJ1RyYW5zZmVyJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyB2aWEgSHVtYW4tUmVhZGFibGUgQUJJIEl0ZW1cbiAqXG4gKiBBIEh1bWFuIFJlYWRhYmxlIEFCSSBjYW4gYmUgcGFyc2VkIGludG8gYSB0eXBlZCBBQkkgb2JqZWN0OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbSgnZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50KSByZXR1cm5zIChib29sKScpXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRm9ybWF0dGluZyBBQkkgSXRlbXNcbiAqXG4gKiBBbiBgQWJpSXRlbWAgY2FuIGJlIGZvcm1hdHRlZCBpbnRvIGEgaHVtYW4tcmVhZGFibGUgQUJJIEl0ZW0gYnkgdXNpbmcge0BsaW5rIG94I0FiaUl0ZW0uKGZvcm1hdDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbSgnZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50KSByZXR1cm5zIChib29sKScpXG4gKlxuICogY29uc3QgZm9ybWF0dGVkID0gQWJpSXRlbS5mb3JtYXQoYWJpSXRlbSlcbiAqIC8vIEBsb2c6ICdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHJldHVybnMgKGJvb2wpJ1xuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEFCSVxuICovXG5leHBvcnQgKiBhcyBBYmlJdGVtIGZyb20gJy4vY29yZS9BYmlJdGVtLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIGVuY29kaW5nLCBkZWNvZGluZywgYW5kIHdvcmtpbmcgd2l0aCBbQUJJIFBhcmFtZXRlcnNdKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC9hYmktc3BlYy5odG1sI3R5cGVzKVxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRW5jb2RpbmcgQUJJIFBhcmFtZXRlcnNcbiAqXG4gKiBBQkkgUGFyYW1ldGVycyBjYW4gYmUgQUJJLWVuY29kZWQgYXMgcGVyIHRoZSBbQXBwbGljYXRpb24gQmluYXJ5IEludGVyZmFjZSAoQUJJKSBTcGVjaWZpY2F0aW9uXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvYWJpLXNwZWMpIHVzaW5nIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLihlbmNvZGU6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlQYXJhbWV0ZXJzLmVuY29kZShcbiAqICAgQWJpUGFyYW1ldGVycy5mcm9tKCdzdHJpbmcsIHVpbnQsIGJvb2wnKSxcbiAqICAgWyd3YWdtaScsIDQyMG4sIHRydWVdLFxuICogKVxuICogYGBgXG4gKlxuICogOjo6dGlwXG4gKlxuICogVGhlIGV4YW1wbGUgYWJvdmUgdXNlcyB7QGxpbmsgb3gjQWJpUGFyYW1ldGVycy4oZnJvbTpmdW5jdGlvbil9IHRvIHNwZWNpZnkgaHVtYW4tcmVhZGFibGUgQUJJIFBhcmFtZXRlcnMuXG4gKlxuICogSG93ZXZlciwgeW91IGNhbiBhbHNvIHBhc3MgSlNPTi1BQkkgUGFyYW1ldGVyczpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlQYXJhbWV0ZXJzLmVuY29kZShcbiAqICAgW3sgdHlwZTogJ3N0cmluZycgfSwgeyB0eXBlOiAndWludCcgfSwgeyB0eXBlOiAnYm9vbCcgfV0sXG4gKiAgIFsnd2FnbWknLCA0MjBuLCB0cnVlXSxcbiAqIClcbiAqIGBgYFxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVjb2RpbmcgQUJJIFBhcmFtZXRlcnNcbiAqXG4gKiBBQkktZW5jb2RlZCBkYXRhIGNhbiBiZSBkZWNvZGVkIHVzaW5nIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLihkZWNvZGU6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShcbiAqICAgQWJpUGFyYW1ldGVycy5mcm9tKCdzdHJpbmcsIHVpbnQsIGJvb2wnKSxcbiAqICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNTc3NjE2NzZkNjkwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogKVxuICogLy8gQGxvZzogWyd3YWdtaScsIDQyMG4sIHRydWVdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04tQUJJIFBhcmFtZXRlcnNcbiAqXG4gKiBKU09OLUFCSSBQYXJhbWV0ZXJzIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuKGZyb206ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oW1xuICogICB7XG4gKiAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgfSxcbiAqICAge1xuICogICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgfSxcbiAqIF0pXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSHVtYW4gUmVhZGFibGUgQUJJIFBhcmFtZXRlcnNcbiAqXG4gKiBIdW1hbiBSZWFkYWJsZSBBQkkgUGFyYW1ldGVycyBjYW4gYmUgaW5zdGFudGlhdGVkIHVzaW5nIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKCdhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50JylcbiAqXG4gKiBwYXJhbWV0ZXJzXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEFCSVxuICovXG5leHBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4vY29yZS9BYmlQYXJhbWV0ZXJzLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCBBY2Nlc3MgTGlzdHMgYXMgZGVmaW5lZCBpbiB0aGUgW0V4ZWN1dGlvbiBBUEkgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2V4ZWN1dGlvbi1hcGlzL2Jsb2IvNDE0MGU1MjgzNjBmZWE1M2MzNGE3NjZkODZhMDAwYzZjMDM5MTAwZS9zcmMvc2NoZW1hcy90cmFuc2FjdGlvbi55YW1sI0w3MylcbiAqXG4gKiBAY2F0ZWdvcnkgRXhlY3V0aW9uIFNwZWNcbiAqL1xuZXhwb3J0ICogYXMgQWNjZXNzTGlzdCBmcm9tICcuL2NvcmUvQWNjZXNzTGlzdC5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggQWNjb3VudCBQcm9vZnMgYXMgZGVmaW5lZCBpbiB0aGUgW0V4ZWN1dGlvbiBBUEkgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2V4ZWN1dGlvbi1hcGlzL2Jsb2IvbWFpbi9zcmMvc2NoZW1hcy9zdGF0ZS55YW1sKVxuICpcbiAqIEBjYXRlZ29yeSBFeGVjdXRpb24gU3BlY1xuICovXG5leHBvcnQgKiBhcyBBY2NvdW50UHJvb2YgZnJvbSAnLi9jb3JlL0FjY291bnRQcm9vZi5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggRXRoZXJldW0gYWRkcmVzc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyBBZGRyZXNzZXNcbiAqXG4gKiBBbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfSBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gYSBoZXggc3RyaW5nIHVzaW5nIHtAbGluayBveCNBZGRyZXNzLihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmFsaWRhdGluZyBBZGRyZXNzZXNcbiAqXG4gKiBUaGUge0BsaW5rIG94I0FkZHJlc3MuKHZhbGlkYXRlOmZ1bmN0aW9uKX0gZnVuY3Rpb24gd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBhZGRyZXNzIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2U6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IEFkZHJlc3MudmFsaWRhdGUoJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZScpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBUaGUge0BsaW5rIG94I0FkZHJlc3MuKGFzc2VydDpmdW5jdGlvbil9IGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGFkZHJlc3MgaXMgaW52YWxpZDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuYXNzZXJ0KCcweGRlYWRiZWVmJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZEFkZHJlc3NFcnJvcjogQWRkcmVzcyBcIjB4ZGVhZGJlZWZcIiBpcyBpbnZhbGlkLlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBZGRyZXNzZXMgZnJvbSBFQ0RTQSBQdWJsaWMgS2V5c1xuICpcbiAqIEFuIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9IGNhbiBiZSBjb21wdXRlZCBmcm9tIGFuIEVDRFNBIHB1YmxpYyBrZXkgdXNpbmcge0BsaW5rIG94I0FkZHJlc3MuKGZyb21QdWJsaWNLZXk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcywgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgYWRkcmVzcyA9IEFkZHJlc3MuZnJvbVB1YmxpY0tleShwdWJsaWNLZXkpXG4gKiAvLyBAbG9nOiAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ1xuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEFkZHJlc3Nlc1xuICovXG5leHBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vY29yZS9BZGRyZXNzLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCBBRVMtR0NNIGVuY3J5cHRpb24uIEludGVybmFsbHkgdXNlcyB0aGUgW1dlYiBDcnlwdG8gQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0NyeXB0b19BUEkpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRW5jcnlwdGluZyBEYXRhXG4gKlxuICogRGF0YSBjYW4gYmUgZW5jcnlwdGVkIHVzaW5nIHtAbGluayBveCNBZXNHY20uKGVuY3J5cHQ6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWVzR2NtLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBrZXkgPSBhd2FpdCBBZXNHY20uZ2V0S2V5KHsgcGFzc3dvcmQ6ICdxd2VydHknIH0pXG4gKiBjb25zdCBzZWNyZXQgPSBIZXguZnJvbVN0cmluZygnaSBhbSBhIHNlY3JldCBtZXNzYWdlJylcbiAqXG4gKiBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBBZXNHY20uZW5jcnlwdChzZWNyZXQsIGtleSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4NWUyNTdiMjViY2Y1M2Q1NDMxZTU0ZTVhNjhjYTAxMzgzMDZkMzFiYjYxNTRmMzVhOTdiYjhlYTE4MTExZTdkODJiY2Y2MTlkM2M3NmM0NjUwNjg4YmM1MzEwZWVkODBiOGZjODZkMWUzZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVjcnlwdGluZyBEYXRhXG4gKlxuICogRGF0YSBjYW4gYmUgZGVjcnlwdGVkIHVzaW5nIHtAbGluayBveCNBZXNHY20uKGRlY3J5cHQ6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWVzR2NtLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBrZXkgPSBhd2FpdCBBZXNHY20uZ2V0S2V5KHsgcGFzc3dvcmQ6ICdxd2VydHknIH0pXG4gKiBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBBZXNHY20uZW5jcnlwdChIZXguZnJvbVN0cmluZygnaSBhbSBhIHNlY3JldCBtZXNzYWdlJyksIGtleSlcbiAqXG4gKiBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBBZXNHY20uZGVjcnlwdChlbmNyeXB0ZWQsIGtleSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogSGV4LmZyb21TdHJpbmcoJ2kgYW0gYSBzZWNyZXQgbWVzc2FnZScpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmV4cG9ydCAqIGFzIEFlc0djbSBmcm9tICcuL2NvcmUvQWVzR2NtLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiBsaXN0cyAmIHR1cGxlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEluc3RhbnRpYXRpbmcgQXV0aG9yaXphdGlvbnNcbiAqXG4gKiBBbiBBdXRob3JpemF0aW9uIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcge0BsaW5rIG94I0F1dGhvcml6YXRpb24uKGZyb206ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbXB1dGluZyBTaWduIFBheWxvYWRcbiAqXG4gKiBBIHNpZ25pbmcgcGF5bG9hZCBjYW4gYmUgY29tcHV0ZWQgdXNpbmcge0BsaW5rIG94I0F1dGhvcml6YXRpb24uKGdldFNpZ25QYXlsb2FkOmZ1bmN0aW9uKX0uIFRoZSByZXN1bHQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHNpZ25pbmcgZnVuY3Rpb25zIGxpa2Uge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQsXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlcyB0byBBdXRob3JpemF0aW9uc1xuICpcbiAqIEEgc2lnbmF0dXJlIGNhbiBiZSBhdHRhY2hlZCB0byBhbiBBdXRob3JpemF0aW9uIHVzaW5nIHtAbGluayBveCNBdXRob3JpemF0aW9uLihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogW2F1dGhvcml6YXRpb25fc2lnbmVkXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEF1dGhvcml6YXRpb24gKEVJUC03NzAyKVxuICovXG5leHBvcnQgKiBhcyBBdXRob3JpemF0aW9uIGZyb20gJy4vY29yZS9BdXRob3JpemF0aW9uLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBbQmFzZTU4XShodHRwczovL2RpZ2l0YWxiYXphYXIuZ2l0aHViLmlvL2Jhc2U1OC1zcGVjLykgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRW5jb2RpbmcgdG8gQmFzZTU4XG4gKlxuICogVmFsdWVzIGNhbiBiZSBlbmNvZGVkIHRvIEJhc2U1OCB3aXRoOlxuICpcbiAqIC0ge0BsaW5rIG94I0Jhc2U1OC4oZnJvbVN0cmluZzpmdW5jdGlvbil9LCBvclxuICpcbiAqIC0ge0BsaW5rIG94I0Jhc2U1OC4oZnJvbUJ5dGVzOmZ1bmN0aW9uKX0sIG9yXG4gKlxuICogLSB7QGxpbmsgb3gjQmFzZTU4Lihmcm9tSGV4OmZ1bmN0aW9uKX1cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTU4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWVfc3RyaW5nID0gQmFzZTU4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScpXG4gKiAvLyBAbG9nOiAnMk5FcG83VFpSUnJMWlNpMlUnXG4gKlxuICogY29uc3QgdmFsdWVfYnl0ZXMgPSBCYXNlNTguZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICcyTkVwbzdUWlJSckxaU2kyVSdcbiAqXG4gKiBjb25zdCB2YWx1ZV9oZXggPSBCYXNlNTguZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJzJORXBvN1RaUlJyTFpTaTJVJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBEZWNvZGluZyBCYXNlNThcbiAqXG4gKiBWYWx1ZXMgY2FuIGJlIGRlY29kZWQgZnJvbSBCYXNlNTggd2l0aDpcbiAqXG4gKiAtIHtAbGluayBveCNCYXNlNTguKHRvU3RyaW5nOmZ1bmN0aW9uKX0sIG9yXG4gKlxuICogLSB7QGxpbmsgb3gjQmFzZTU4Lih0b0J5dGVzOmZ1bmN0aW9uKX0sIG9yXG4gKlxuICogLSB7QGxpbmsgb3gjQmFzZTU4Lih0b0hleDpmdW5jdGlvbil9XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U1OCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlX3N0cmluZyA9IEJhc2U1OC50b1N0cmluZygnMk5FcG83VFpSUnJMWlNpMlUnKVxuICogLy8gQGxvZzogJ0hlbGxvIFdvcmxkISdcbiAqXG4gKiBjb25zdCB2YWx1ZV9ieXRlcyA9IEJhc2U1OC50b0J5dGVzKCcyTkVwbzdUWlJSckxaU2kyVScpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdXG4gKlxuICogY29uc3QgdmFsdWVfaGV4ID0gQmFzZTU4LnRvSGV4KCcyTkVwbzdUWlJSckxaU2kyVScpXG4gKiAvLyBAbG9nOiAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgRGF0YVxuICovXG5leHBvcnQgKiBhcyBCYXNlNTggZnJvbSAnLi9jb3JlL0Jhc2U1OC5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggW1JGQy00NjQ4XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2NDgpIEJhc2U2NC5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEVuY29kaW5nIHRvIEJhc2U2NFxuICpcbiAqIFZhbHVlcyBjYW4gYmUgZW5jb2RlZCB0byBCYXNlNjQgd2l0aDpcbiAqXG4gKiAtIHtAbGluayBveCNCYXNlNjQuKGZyb21TdHJpbmc6ZnVuY3Rpb24pfSwgb3JcbiAqXG4gKiAtIHtAbGluayBveCNCYXNlNjQuKGZyb21CeXRlczpmdW5jdGlvbil9LCBvclxuICpcbiAqIC0ge0BsaW5rIG94I0Jhc2U2NC4oZnJvbUhleDpmdW5jdGlvbil9XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlX3N0cmluZyA9IEJhc2U2NC5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKVxuICogLy8gQGxvZzogJ1NHVnNiRzhnVjI5eWJHUWg9PSdcbiAqXG4gKiBjb25zdCB2YWx1ZV9ieXRlcyA9IEJhc2U2NC5mcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJ1NHVnNiRzhnVjI5eWJHUWg9PSdcbiAqXG4gKiBjb25zdCB2YWx1ZV9oZXggPSBCYXNlNjQuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJ1NHVnNiRzhnVjI5eWJHUWg9PSdcbiAqIGBgYFxuICpcbiAqICMjIyBEZWNvZGluZyBCYXNlNjRcbiAqXG4gKiBWYWx1ZXMgY2FuIGJlIGRlY29kZWQgZnJvbSBCYXNlNjQgd2l0aDpcbiAqXG4gKiAtIHtAbGluayBveCNCYXNlNjQuKHRvU3RyaW5nOmZ1bmN0aW9uKX0sIG9yXG4gKlxuICogLSB7QGxpbmsgb3gjQmFzZTY0Lih0b0J5dGVzOmZ1bmN0aW9uKX0sIG9yXG4gKlxuICogLSB7QGxpbmsgb3gjQmFzZTY0Lih0b0hleDpmdW5jdGlvbil9XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlX3N0cmluZyA9IEJhc2U2NC50b1N0cmluZygnU0dWc2JHOGdWMjl5YkdRaD09JylcbiAqIC8vIEBsb2c6ICdIZWxsbyBXb3JsZCEnXG4gKlxuICogY29uc3QgdmFsdWVfYnl0ZXMgPSBCYXNlNjQudG9CeXRlcygnU0dWc2JHOGdWMjl5YkdRaD09JylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM11cbiAqXG4gKiBjb25zdCB2YWx1ZV9oZXggPSBCYXNlNjQudG9IZXgoJ1NHVnNiRzhnVjI5eWJHUWg9PScpXG4gKiAvLyBAbG9nOiAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgRGF0YVxuICovXG5leHBvcnQgKiBhcyBCYXNlNjQgZnJvbSAnLi9jb3JlL0Jhc2U2NC5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggW0VJUC03ODY0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc4NjQpIEJpbmFyeSBTdGF0ZSBUcmVlcy5cbiAqXG4gKiBAY2F0ZWdvcnkgQmluYXJ5IFN0YXRlIFRyZWUgKEVJUC03ODY0KVxuICovXG5leHBvcnQgKiBhcyBCaW5hcnlTdGF0ZVRyZWUgZnJvbSAnLi9jb3JlL0JpbmFyeVN0YXRlVHJlZS5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggW0VJUC00ODQ0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQ4NDQpIEJsb2JzLlxuICpcbiAqIEBjYXRlZ29yeSBCbG9icyAoRUlQLTQ4NDQpXG4gKi9cbmV4cG9ydCAqIGFzIEJsb2JzIGZyb20gJy4vY29yZS9CbG9icy5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggQmxvY2tzIGFzIGRlZmluZWQgaW4gdGhlIFtFeGVjdXRpb24gQVBJIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9leGVjdXRpb24tYXBpcy9ibG9iL21haW4vc3JjL3NjaGVtYXMvYmxvY2sueWFtbClcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbnZlcnRpbmcgZnJvbSBSUEMgRm9ybWF0XG4gKlxuICogQmxvY2tzIGNhbiBiZSBjb252ZXJ0ZWQgZnJvbSBSUEMgZm9ybWF0IHRvIGludGVybmFsIGZvcm1hdCB1c2luZyB7QGxpbmsgb3gjQmxvY2suKGZyb21ScGM6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBCbG9jayB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrID0gYXdhaXQgd2luZG93LmV0aGVyZXVtIVxuICogICAucmVxdWVzdCh7XG4gKiAgICAgbWV0aG9kOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLFxuICogICAgIHBhcmFtczogWydsYXRlc3QnLCBmYWxzZV0sXG4gKiAgIH0pXG4gKiAgIC50aGVuKEJsb2NrLmZyb21ScGMpIC8vIFshY29kZSBobF1cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgLy8gLi4uXG4gKiAvLyBAbG9nOiAgIGhhc2g6ICcweGViYzM2NDQ4MDRlNDA0MGMwYTc0YzVhNWJiYmM2YjQ2YTcxYTVkNDAxMGZlMGM5MmViYjJmZGY0YTQzZWE1ZGQnLFxuICogLy8gQGxvZzogICBudW1iZXI6IDE5ODY4MDIwbixcbiAqIC8vIEBsb2c6ICAgc2l6ZTogNTIwbixcbiAqIC8vIEBsb2c6ICAgdGltZXN0YW1wOiAxNjYyMjIyMjIybixcbiAqIC8vIEBsb2c6ICAgLy8gLi4uXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgRXhlY3V0aW9uIFNwZWNcbiAqL1xuZXhwb3J0ICogYXMgQmxvY2sgZnJvbSAnLi9jb3JlL0Jsb2NrLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCAqKkJsb2NrIE92ZXJyaWRlcyoqLlxuICpcbiAqIEBjYXRlZ29yeSBFeGVjdXRpb24gU3BlY1xuICovXG5leHBvcnQgKiBhcyBCbG9ja092ZXJyaWRlcyBmcm9tICcuL2NvcmUvQmxvY2tPdmVycmlkZXMuanMnO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIEJsb29tIEZpbHRlcnMgYXMgZGVmaW5lZCBpbiB0aGUgW0V4ZWN1dGlvbiBBUEkgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2V4ZWN1dGlvbi1hcGlzL2Jsb2IvbWFpbi9zcmMvc2NoZW1hcy9ibG9jay55YW1sKVxuICpcbiAqIEBjYXRlZ29yeSBFeGVjdXRpb24gU3BlY1xuICovXG5leHBvcnQgKiBhcyBCbG9vbSBmcm9tICcuL2NvcmUvQmxvb20uanMnO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgW0JMUzEyLTM4MV0oaHR0cHM6Ly9oYWNrbWQuaW8vXFxAYmVuamFtaW5pb24vYmxzMTItMzgxKSBjcnlwdG9ncmFwaHkuXG4gKlxuICogOjo6aW5mb1xuICpcbiAqIFRoZSBgQmxzYCBtb2R1bGUgaXMgYSBmcmllbmRseSB3cmFwcGVyIG92ZXIgW2BAbm9ibGUvY3VydmVzL2JsczEyLTM4MWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtY3VydmVzKSwgYW4gKiphdWRpdGVkKiogaW1wbGVtZW50YXRpb24gb2YgQkxTMTItMzgxLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ29tcHV0aW5nIGEgUmFuZG9tIFByaXZhdGUgS2V5XG4gKlxuICogQSByYW5kb20gcHJpdmF0ZSBrZXkgY2FuIGJlIGNvbXB1dGVkIHVzaW5nIHtAbGluayBveCNCbHMuKHJhbmRvbVByaXZhdGVLZXk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IEJscy5yYW5kb21Qcml2YXRlS2V5KClcbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgR2V0dGluZyBhIFB1YmxpYyBLZXlcbiAqXG4gKiBBIHB1YmxpYyBrZXkgY2FuIGJlIGRlcml2ZWQgZnJvbSBhIHByaXZhdGUga2V5IHVzaW5nIHtAbGluayBveCNCbHMuKGdldFB1YmxpY0tleTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbHMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gQmxzLnJhbmRvbVByaXZhdGVLZXkoKVxuICogY29uc3QgcHVibGljS2V5ID0gQmxzLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSlcbiAqIC8vIEBsb2c6IHsgeDogMzI1MS4uLjUxNTJuLCB5OiAxMjUxLi4uNTE1Mm4sIHo6IDFuIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2lnbmluZyBhIFBheWxvYWRcbiAqXG4gKiBBIHBheWxvYWQgY2FuIGJlIHNpZ25lZCB1c2luZyB7QGxpbmsgb3gjQmxzLihzaWduOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJscyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBCbHMucmFuZG9tUHJpdmF0ZUtleSgpXG4gKiBjb25zdCBzaWduYXR1cmUgPSBCbHMuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleSB9KVxuICogLy8gQGxvZzogeyB4OiAxMjUxLi4uNTE1Mm4sIHk6IDEyNTEuLi41MTUybiwgejogMW4gfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJpZnlpbmcgYSBTaWduYXR1cmVcbiAqXG4gKiBBIHNpZ25hdHVyZSBjYW4gYmUgdmVyaWZpZWQgdXNpbmcge0BsaW5rIG94I1NlY3AyNTZrMS4odmVyaWZ5OmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJscyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBCbHMucmFuZG9tUHJpdmF0ZUtleSgpXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBCbHMuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KVxuICogY29uc3Qgc2lnbmF0dXJlID0gQmxzLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCBpc1ZhbGlkID0gQmxzLnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQWdncmVnYXRpbmcgUHVibGljIEtleXMgJiBTaWduYXR1cmVzXG4gKlxuICogUHVibGljIGtleXMgYW5kIHNpZ25hdHVyZXMgY2FuIGJlIGFnZ3JlZ2F0ZWQgdXNpbmcge0BsaW5rIG94I0Jscy4oYWdncmVnYXRlOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJscyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleXMgPSBbXG4gKiAgIEJscy5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5OiAnMHguLi4nIH0pLFxuICogICBCbHMuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleTogJzB4Li4uJyB9KSxcbiAqIF1cbiAqIGNvbnN0IHB1YmxpY0tleSA9IEJscy5hZ2dyZWdhdGUocHVibGljS2V5cylcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVzID0gW1xuICogICBCbHMuc2lnbih7IHBheWxvYWQ6ICcweC4uLicsIHByaXZhdGVLZXk6ICcweC4uLicgfSksXG4gKiAgIEJscy5zaWduKHsgcGF5bG9hZDogJzB4Li4uJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KSxcbiAqIF1cbiAqIGNvbnN0IHNpZ25hdHVyZSA9IEJscy5hZ2dyZWdhdGUoc2lnbmF0dXJlcylcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmVyaWZ5IEFnZ3JlZ2F0ZWQgU2lnbmF0dXJlc1xuICpcbiAqIFdlIGNhbiBhbHNvIHBhc3MgYSBwdWJsaWMga2V5IGFuZCBzaWduYXR1cmUgdGhhdCB3YXMgYWdncmVnYXRlZCB3aXRoIHtAbGluayBveCNCbHMuKGFnZ3JlZ2F0ZTpmdW5jdGlvbil9IHRvIGBCbHMudmVyaWZ5YC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gSGV4LnJhbmRvbSgzMilcbiAqIGNvbnN0IHByaXZhdGVLZXlzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sICgpID0+IEJscy5yYW5kb21Qcml2YXRlS2V5KCkpXG4gKlxuICogY29uc3QgcHVibGljS2V5cyA9IHByaXZhdGVLZXlzLm1hcCgocHJpdmF0ZUtleSkgPT5cbiAqICAgQmxzLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSksXG4gKiApXG4gKiBjb25zdCBzaWduYXR1cmVzID0gcHJpdmF0ZUtleXMubWFwKChwcml2YXRlS2V5KSA9PlxuICogICBCbHMuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXkgfSksXG4gKiApXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gQmxzLmFnZ3JlZ2F0ZShwdWJsaWNLZXlzKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCBzaWduYXR1cmUgPSBCbHMuYWdncmVnYXRlKHNpZ25hdHVyZXMpIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCB2YWxpZCA9IEJscy52ZXJpZnkoeyBwYXlsb2FkLCBwdWJsaWNLZXksIHNpZ25hdHVyZSB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmV4cG9ydCAqIGFzIEJscyBmcm9tICcuL2NvcmUvQmxzLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBCTFMxMi0zODEgcG9pbnRzLlxuICpcbiAqIDo6OmluZm9cbiAqXG4gKiBUaGUgYEJsc1BvaW50YCBtb2R1bGUgaXMgYSBmcmllbmRseSB3cmFwcGVyIG92ZXIgW2BAbm9ibGUvY3VydmVzL2JsczEyLTM4MWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtY3VydmVzKSwgYW4gKiphdWRpdGVkKiogaW1wbGVtZW50YXRpb24gb2YgQkxTMTItMzgxLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgUHVibGljIEtleXMgb3IgU2lnbmF0dXJlcyB0byBIZXhcbiAqXG4gKiBCTFMgcG9pbnRzIGNhbiBiZSBjb252ZXJ0ZWQgdG8gaGV4IHVzaW5nIHtAbGluayBveCNCbHNQb2ludC4odG9IZXg6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxzLCBCbHNQb2ludCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IEJscy5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBjb25zdCBwdWJsaWNLZXlIZXggPSBCbHNQb2ludC50b0hleChwdWJsaWNLZXkpXG4gKiAvLyBAbG9nOiAnMHhhY2FmZmY1MjI3MDc3M2FkMTcyOGRmMjgwN2MwZjFiMGIyNzFmYTZiMzdkZmI4YjJmNzU0NDg1NzNjNzZjODFiY2Q2NzkwMzI4YTYwZTQwZWY1YTEzMzQzYjMyZDllNjYnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gQmxzLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGNvbnN0IHNpZ25hdHVyZUhleCA9IEJsc1BvaW50LnRvSGV4KHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6ICcweGI0Njk4Zjc2MTE5OTlmYmE4NzAzM2I5Y2Y3MjMxMmM3NmM2ODNiYmM0ODE3NWUyZDRjYjI3NTkwN2Q2YTI2N2FiOTg0MGE2NmUzMDUxZTVlZDM2ZmQxM2FhNzEyZjlhOTAyNGY5ZmE5YjY3ZjcxNmRmYjc0YWU0ZWZiN2Q5ZjFiN2I0M2I0Njc5YWJlZDY2NDRjZjQ3NmMxMmU3OWYzMDkzNTFlYTg0NTI0ODdjZDkzZjY2ZTI5ZTA0ZWJlNDI3YydcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSGV4IHRvIFB1YmxpYyBLZXlzIG9yIFNpZ25hdHVyZXNcbiAqXG4gKiBCTFMgcG9pbnRzIGNhbiBiZSBjb252ZXJ0ZWQgZnJvbSBoZXggdXNpbmcge0BsaW5rIG94I0Jsc1BvaW50Lihmcm9tSGV4OmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJscywgQmxzUG9pbnQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBCbHNQb2ludC5mcm9tSGV4KCcweGFjYWZmZjUyMjcwNzczYWQxNzI4ZGYyODA3YzBmMWIwYjI3MWZhNmIzN2RmYjhiMmY3NTQ0ODU3M2M3NmM4MWJjZDY3OTAzMjhhNjBlNDBlZjVhMTMzNDNiMzJkOWU2NicsICdHMScpXG4gKiAvLyBAbG9nOiB7IHg6IDE3Mi4uLjUxNG4sIHk6IDE3NS4uLjIzNW4sIHo6IDFuIH1cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBCbHNQb2ludC5mcm9tSGV4KCcweGI0Njk4Zjc2MTE5OTlmYmE4NzAzM2I5Y2Y3MjMxMmM3NmM2ODNiYmM0ODE3NWUyZDRjYjI3NTkwN2Q2YTI2N2FiOTg0MGE2NmUzMDUxZTVlZDM2ZmQxM2FhNzEyZjlhOTAyNGY5ZmE5YjY3ZjcxNmRmYjc0YWU0ZWZiN2Q5ZjFiN2I0M2I0Njc5YWJlZDY2NDRjZjQ3NmMxMmU3OWYzMDkzNTFlYTg0NTI0ODdjZDkzZjY2ZTI5ZTA0ZWJlNDI3YycsICdHMicpXG4gKiAvLyBAbG9nOiB7IHg6IDEyNTEuLi41MTUybiwgeTogMTI1MS4uLjUxNTJuLCB6OiAxbiB9XG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmV4cG9ydCAqIGFzIEJsc1BvaW50IGZyb20gJy4vY29yZS9CbHNQb2ludC5qcyc7XG4vKipcbiAqIEEgc2V0IG9mIEV0aGVyZXVtLXJlbGF0ZWQgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBbYFVpbnQ4QXJyYXlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9VaW50OEFycmF5KSBpbnN0YW5jZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBJbnN0YW50aWF0aW5nIEJ5dGVzXG4gKlxuICogVmFsdWVzIGNhbiBiZSBpbnN0YW50aWF0ZWQgYXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB1c2luZzpcbiAqXG4gKiAtIHtAbGluayBveCNCeXRlcy4oZnJvbUFycmF5OmZ1bmN0aW9uKX1cbiAqXG4gKiAtIHtAbGluayBveCNCeXRlcy4oZnJvbUJvb2xlYW46ZnVuY3Rpb24pfVxuICpcbiAqIC0ge0BsaW5rIG94I0J5dGVzLihmcm9tSGV4OmZ1bmN0aW9uKX1cbiAqXG4gKiAtIHtAbGluayBveCNCeXRlcy4oZnJvbU51bWJlcjpmdW5jdGlvbil9XG4gKlxuICogLSB7QGxpbmsgb3gjQnl0ZXMuKGZyb21TdHJpbmc6ZnVuY3Rpb24pfVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlX2FycmF5ID0gQnl0ZXMuZnJvbShbMSwgMiwgMywgNCwgNV0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxLCAyLCAzLCA0LCA1XVxuICpcbiAqIGNvbnN0IHZhbHVlX2Jvb2xlYW4gPSBCeXRlcy5mcm9tQm9vbGVhbih0cnVlKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMV1cbiAqXG4gKiBjb25zdCB2YWx1ZV9oZXggPSBCeXRlcy5mcm9tSGV4KCcweDEyMzQ1Njc4OTBhYmNkZWYnKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTgsIDUyLCA4NiwgMTIwLCAxNDQsIDE3NSwgMjA3LCAxNV1cbiAqXG4gKiBjb25zdCB2YWx1ZV9udW1iZXIgPSBCeXRlcy5mcm9tTnVtYmVyKDEyMzQ1Njc4OTApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFs0LCAxNjAsIDIxNl1cbiAqXG4gKiBjb25zdCB2YWx1ZV9zdHJpbmcgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb252ZXJ0aW5nIGZyb20gQnl0ZXNcbiAqXG4gKiBWYWx1ZXMgY2FuIGJlIGNvbnZlcnRlZCBmcm9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gdXNpbmc6XG4gKlxuICogLSB7QGxpbmsgb3gjQnl0ZXMuKHRvQmlnSW50OmZ1bmN0aW9uKX1cbiAqXG4gKiAtIHtAbGluayBveCNCeXRlcy4odG9Cb29sZWFuOmZ1bmN0aW9uKX1cbiAqXG4gKiAtIHtAbGluayBveCNCeXRlcy4odG9IZXg6ZnVuY3Rpb24pfVxuICpcbiAqIC0ge0BsaW5rIG94I0J5dGVzLih0b051bWJlcjpmdW5jdGlvbil9XG4gKlxuICogLSB7QGxpbmsgb3gjQnl0ZXMuKHRvU3RyaW5nOmZ1bmN0aW9uKX1cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZV9iaWdpbnQgPSBCeXRlcy50b0JpZ0ludChCeXRlcy5mcm9tKFs0LCAxNjAsIDIxNl0pKVxuICogLy8gQGxvZzogMTIzNDU2Nzg5MG5cbiAqXG4gKiBjb25zdCB2YWx1ZV9ib29sZWFuID0gQnl0ZXMudG9Cb29sZWFuKEJ5dGVzLmZyb20oWzFdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqXG4gKiBjb25zdCB2YWx1ZV9oZXggPSBCeXRlcy50b0hleChCeXRlcy5mcm9tKFsyMjIsIDE3MywgMTkwLCAyMzldKSlcbiAqIC8vIEBsb2c6ICcweGRlYWRiZWVmJ1xuICpcbiAqIGNvbnN0IHZhbHVlX251bWJlciA9IEJ5dGVzLnRvTnVtYmVyKEJ5dGVzLmZyb20oWzQsIDE2MCwgMjE2XSkpXG4gKiAvLyBAbG9nOiAxMjM0NTY3ODkwXG4gKlxuICogY29uc3QgdmFsdWVfc3RyaW5nID0gQnl0ZXMudG9TdHJpbmcoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnSGVsbG8gV29ybGQhJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb25jYXRlbmF0aW5nIEJ5dGVzXG4gKlxuICogVmFsdWVzIGNhbiBiZSBjb25jYXRlbmF0ZWQgdXNpbmcge0BsaW5rIG94I0J5dGVzLihjb25jYXQ6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhID0gQnl0ZXMuZnJvbShbMSwgMiwgM10pXG4gKiBjb25zdCBiID0gQnl0ZXMuZnJvbShbNCwgNSwgNl0pXG4gKiBjb25zdCBjID0gQnl0ZXMuY29uY2F0KGEsIGIpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxLCAyLCAzLCA0LCA1LCA2XVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTbGljaW5nIEJ5dGVzXG4gKlxuICogVmFsdWVzIGNhbiBiZSBzbGljZWQgdXNpbmcge0BsaW5rIG94I0J5dGVzLihzbGljZTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQnl0ZXMuc2xpY2UoQnl0ZXMuZnJvbShbMSwgMiwgMywgNCwgNSwgNl0pLCAyLCA0KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMywgNF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgUGFkZGluZyBCeXRlc1xuICpcbiAqIFZhbHVlcyBjYW4gYmUgcGFkZGVkIHdpdGggemVyb2VzIHVzaW5nIHtAbGluayBveCNCeXRlcy4ocGFkTGVmdDpmdW5jdGlvbil9IG9yIHtAbGluayBveCNCeXRlcy4ocGFkUmlnaHQ6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZV8xID0gQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tKFsxLCAyLCAzXSksIDUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFswLCAwLCAxLCAyLCAzXVxuICpcbiAqIGNvbnN0IHZhbHVlXzIgPSBCeXRlcy5wYWRSaWdodChCeXRlcy5mcm9tKFsxLCAyLCAzXSksIDUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxLCAyLCAzLCAwLCAwXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBUcmltbWluZyBCeXRlc1xuICpcbiAqIFplcm9lcyBpbiB2YWx1ZXMgY2FuIGJlIHRyaW1tZWQgdXNpbmcge0BsaW5rIG94I0J5dGVzLih0cmltTGVmdDpmdW5jdGlvbil9IG9yIHtAbGluayBveCNCeXRlcy4odHJpbVJpZ2h0OmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCeXRlcy50cmltTGVmdChCeXRlcy5mcm9tKFswLCAwLCAxLCAyLCAzXSkpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxLCAyLCAzXVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IERhdGFcbiAqL1xuZXhwb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9jb3JlL0J5dGVzLmpzJztcbmV4cG9ydCAqIGFzIENhY2hlcyBmcm9tICcuL2NvcmUvQ2FjaGVzLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbXB1dGluZyBDb250cmFjdCBBZGRyZXNzZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb21wdXRpbmcgQ29udHJhY3QgQWRkcmVzc2VzIChDUkVBVEUpXG4gKlxuICogQSBDb250cmFjdCBBZGRyZXNzIHRoYXQgd2FzIGluc3RhbnRpYXRlZCB1c2luZyB0aGUgYENSRUFURWAgb3Bjb2RlIGNhbiBiZSBjb21wdXRlZCB1c2luZyB7QGxpbmsgb3gjQ29udHJhY3RBZGRyZXNzLihmcm9tQ3JlYXRlOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IENvbnRyYWN0QWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIENvbnRyYWN0QWRkcmVzcy5mcm9tQ3JlYXRlKHtcbiAqICAgZnJvbTogJzB4MWExZTAyMWEzMDJjMjM3NDUzZDNkNDVjN2I4MmIxOWNlZWI3ZTJlNicsXG4gKiAgIG5vbmNlOiAwbixcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHhGQkEzOTEyQ2EwNGRkNDU4Yzg0M2UyRUUwODk2N2ZDMDRmMzU3OWMyJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb21wdXRpbmcgQ29udHJhY3QgQWRkcmVzc2VzIChDUkVBVEUyKVxuICpcbiAqIEEgQ29udHJhY3QgQWRkcmVzcyB0aGF0IHdhcyBpbnN0YW50aWF0ZWQgdXNpbmcgdGhlIGBDUkVBVEUyYCBvcGNvZGUgY2FuIGJlIGNvbXB1dGVkIHVzaW5nIHtAbGluayBveCNDb250cmFjdEFkZHJlc3MuKGZyb21DcmVhdGUyOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBDb250cmFjdEFkZHJlc3MsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIENvbnRyYWN0QWRkcmVzcy5mcm9tQ3JlYXRlMih7XG4gKiAgIGZyb206ICcweDFhMWUwMjFhMzAyYzIzNzQ1M2QzZDQ1YzdiODJiMTljZWViN2UyZTYnLFxuICogICBieXRlY29kZTogQnl0ZXMuZnJvbSgnMHg2Mzk0MTk4ZGYxNjAwMDUyNjEwM2ZmNjAyMDYwMDQ2MDFjMzM1YWZhNjA0MDUxNjA2MGYzJyksXG4gKiAgIHNhbHQ6IEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpLFxuICogfSlcbiAqIC8vIEBsb2c6ICcweDU5ZmJCNTkzQUJlMjdDYjE5M2I2ZWU1QzVEQzdiYmRlMzEyMjkwYUInXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQWRkcmVzc2VzXG4gKi9cbmV4cG9ydCAqIGFzIENvbnRyYWN0QWRkcmVzcyBmcm9tICcuL2NvcmUvQ29udHJhY3RBZGRyZXNzLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBFTlMgbmFtZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBOb3JtYWxpemluZyBFTlMgTmFtZXNcbiAqXG4gKiBFTlMgbmFtZXMgY2FuIGJlIG5vcm1hbGl6ZWQgdXNpbmcge0BsaW5rIG94I0Vucy4obm9ybWFsaXplOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IG5hbWUgPSBFbnMubm9ybWFsaXplKCd38J2do3ZtLmV0aCcpXG4gKiAvLyBAbG9nOiAnd86+dm0uZXRoJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBOYW1laGFzaGluZyBFTlMgTmFtZXNcbiAqXG4gKiBFTlMgbmFtZXMgY2FuIGJlIG5hbWVoYXNoZWQgdXNpbmcge0BsaW5rIG94I0Vucy4obmFtZWhhc2g6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgRW5zIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbmFtZSA9IEVucy5uYW1laGFzaCgnYWxpY2UuZXRoJylcbiAqIC8vIEBsb2c6ICcweDc4NzE5MmZjNTM3OGNjMzJhYTk1NmRkZmRlZGJmMjZiMjRlOGQ3OGU0MDEwOWFkZDBlZWEyYzFhMDEyYzNkZWMnXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgRU5TXG4gKi9cbmV4cG9ydCAqIGFzIEVucyBmcm9tICcuL2NvcmUvRW5zLmpzJztcbmV4cG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL2NvcmUvRXJyb3JzLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCBGaWx0ZXJzIGFzIGRlZmluZWQgaW4gdGhlIFtFeGVjdXRpb24gQVBJIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9leGVjdXRpb24tYXBpcy9ibG9iL21haW4vc3JjL3NjaGVtYXMvZmlsdGVyLnlhbWwpXG4gKlxuICogQGNhdGVnb3J5IEV4ZWN1dGlvbiBTcGVjXG4gKi9cbmV4cG9ydCAqIGFzIEZpbHRlciBmcm9tICcuL2NvcmUvRmlsdGVyLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGhhc2hpbmcgKGtlY2NhazI1Niwgc2hhMjU2LCBldGMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gJzB4ZDRmZDRlMTg5MTMyMjczMDM2NDQ5ZmM5ZTExMTk4YzczOTE2MWI0YzAxMTZhOWEyZGNjZGZhMWM0OTIwMDZmMSdcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBDcnlwdG9cbiAqL1xuZXhwb3J0ICogYXMgSGFzaCBmcm9tICcuL2NvcmUvSGFzaC5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBnZW5lcmF0aW5nIGFuZCB3b3JraW5nIHdpdGggW0JJUC0zMl0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzMi5tZWRpYXdpa2kpIEhEIFdhbGxldHMuXG4gKlxuICogOjo6aW5mb1xuICpcbiAqIFRoZSBgSGRLZXlgIG1vZHVsZSBpcyBhIGZyaWVuZGx5IHdyYXBwZXIgb3ZlciBbYEBzY3VyZS9iaXAzMmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvc2N1cmUtYmlwMzIpLCBhbiAqKmF1ZGl0ZWQqKiBpbXBsZW1lbnRhdGlvbiBvZiBbQklQLTMyXShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDMyLm1lZGlhd2lraSkgSEQgV2FsbGV0cy5cbiAqXG4gKiA6OjpcbiAqXG4gKlxuICogQGNhdGVnb3J5IENyeXB0b1xuICovXG5leHBvcnQgKiBhcyBIZEtleSBmcm9tICcuL2NvcmUvSGRLZXkuanMnO1xuLyoqXG4gKiBBIHNldCBvZiBFdGhlcmV1bS1yZWxhdGVkIHV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcyAoZS5nLiBgXCIweGRlYWRiZWVmXCJgKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEluc3RhbnRpYXRpbmcgSGV4XG4gKlxuICogVmFsdWVzIGNhbiBiZSBpbnN0YW50aWF0ZWQgYXMge0BsaW5rIG94I0hleC5IZXh9IHVzaW5nOlxuICpcbiAqIC0ge0BsaW5rIG94I0hleC4oZnJvbUJvb2xlYW46ZnVuY3Rpb24pfVxuICpcbiAqIC0ge0BsaW5rIG94I0hleC4oZnJvbUJ5dGVzOmZ1bmN0aW9uKX1cbiAqXG4gKiAtIHtAbGluayBveCNIZXguKGZyb21OdW1iZXI6ZnVuY3Rpb24pfVxuICpcbiAqIC0ge0BsaW5rIG94I0hleC4oZnJvbVN0cmluZzpmdW5jdGlvbil9XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZV9ib29sZWFuID0gSGV4LmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiAnMHgxJ1xuICpcbiAqIGNvbnN0IHZhbHVlX2J5dGVzID0gSGV4LmZyb21CeXRlcyhCeXRlcy5mcm9tKFsxLCAyLCAzXSkpXG4gKiAvLyBAbG9nOiAnMHgwMTAyMDMnXG4gKlxuICogY29uc3QgdmFsdWVfbnVtYmVyID0gSGV4LmZyb21OdW1iZXIoMTIzNDU2Nzg5MClcbiAqIC8vIEBsb2c6ICcweDQ5OTYwMmQyJ1xuICpcbiAqIGNvbnN0IHZhbHVlX3N0cmluZyA9IEhleC5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb252ZXJ0aW5nIGZyb20gSGV4XG4gKlxuICogVmFsdWVzIGNhbiBiZSBjb252ZXJ0ZWQgZnJvbSB7QGxpbmsgb3gjSGV4LkhleH0gdXNpbmc6XG4gKlxuICogLSB7QGxpbmsgb3gjSGV4Lih0b0Jvb2xlYW46ZnVuY3Rpb24pfVxuICpcbiAqIC0ge0BsaW5rIG94I0hleC4odG9CeXRlczpmdW5jdGlvbil9XG4gKlxuICogLSB7QGxpbmsgb3gjSGV4Lih0b051bWJlcjpmdW5jdGlvbil9XG4gKlxuICogLSB7QGxpbmsgb3gjSGV4Lih0b1N0cmluZzpmdW5jdGlvbil9XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlX2Jvb2xlYW4gPSBIZXgudG9Cb29sZWFuKCcweDEnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIGNvbnN0IHZhbHVlX2J5dGVzID0gSGV4LnRvQnl0ZXMoJzB4MDEwMjAzJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzEsIDIsIDNdXG4gKlxuICogY29uc3QgdmFsdWVfbnVtYmVyID0gSGV4LnRvTnVtYmVyKCcweDQ5OTYwMmQyJylcbiAqIC8vIEBsb2c6IDEyMzQ1Njc4OTBcbiAqXG4gKiBjb25zdCB2YWx1ZV9zdHJpbmcgPSBIZXgudG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6ICdIZWxsbyBXb3JsZCEnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbmNhdGVuYXRpbmcgSGV4XG4gKlxuICogSGV4IHZhbHVlcyBjYW4gYmUgY29uY2F0ZW5hdGVkIHVzaW5nIHtAbGluayBveCNIZXguKGNvbmNhdDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhID0gSGV4LmZyb21TdHJpbmcoJzB4MTIzNDU2Nzg5MGFiY2RlZicpXG4gKiBjb25zdCBiID0gSGV4LmZyb21TdHJpbmcoJzB4ZGVhZGJlZWYnKVxuICogY29uc3QgYyA9IEhleC5jb25jYXQoYSwgYilcbiAqIC8vIEBsb2c6ICcweDEyMzQ1Njc4OTBhYmNkZWZkZWFkYmVlZidcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2xpY2luZyBIZXhcbiAqXG4gKiBIZXggdmFsdWVzIGNhbiBiZSBzbGljZWQgdXNpbmcge0BsaW5rIG94I0hleC4oc2xpY2U6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBIZXguc2xpY2UoJzB4MTIzNDU2Nzg5MGFiY2RlZmRlYWRiZWVmJywgMiwgOClcbiAqIC8vIEBsb2c6ICcweDM0NTY3ODkwJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBQYWRkaW5nIEhleFxuICpcbiAqIEhleCB2YWx1ZXMgY2FuIGJlIHBhZGRlZCB3aXRoIHplcm9lcyB1c2luZyB7QGxpbmsgb3gjSGV4LihwYWRMZWZ0OmZ1bmN0aW9uKX0gb3Ige0BsaW5rIG94I0hleC4ocGFkUmlnaHQ6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBIZXgucGFkTGVmdCgnMHgxMjM0NTY3ODkwYWJjZGVmJywgMTYpXG4gKiAvLyBAbG9nOiAnMHgwMDAwMDAwMDAwMDAwMDAwMTIzNDU2Nzg5MGFiY2RlZidcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVHJpbW1pbmcgSGV4XG4gKlxuICogSGV4IHZhbHVlcyBjYW4gYmUgdHJpbW1lZCBvZiB6ZXJvZXMgdXNpbmcge0BsaW5rIG94I0hleC4odHJpbUxlZnQ6ZnVuY3Rpb24pfSBvciB7QGxpbmsgb3gjSGV4Lih0cmltUmlnaHQ6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBIZXgudHJpbUxlZnQoJzB4MDAwMDAwMDAwMDAwMDAwMDEyMzQ1Njc4OTBhYmNkZWYnKVxuICogLy8gQGxvZzogJzB4MTIzNDU2Nzg5MGFiY2RlZidcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBEYXRhXG4gKi9cbmV4cG9ydCAqIGFzIEhleCBmcm9tICcuL2NvcmUvSGV4LmpzJztcbi8qKlxuICogQGNhdGVnb3J5IEV4ZWN1dGlvbiBTcGVjXG4gKi9cbmV4cG9ydCAqIGFzIEZlZSBmcm9tICcuL2NvcmUvRmVlLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBKU09OICh3aXRoIHN1cHBvcnQgZm9yIGBiaWdpbnRgKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFN0cmluZ2lmeWluZyBKU09OXG4gKlxuICogSlNPTiB2YWx1ZXMgY2FuIGJlIHN0cmluZ2lmaWVkICh3aXRoIGBiaWdpbnRgIHN1cHBvcnQpIHVzaW5nIHtAbGluayBveCNKc29uLihzdHJpbmdpZnk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSnNvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGpzb24gPSBKc29uLnN0cmluZ2lmeSh7XG4gKiAgIGZvbzogJ2JhcicsXG4gKiAgIGJhejogNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjBuLFxuICogfSlcbiAqIC8vIEBsb2c6ICd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6Njk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjB9J1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBQYXJzaW5nIEpTT05cbiAqXG4gKiBKU09OIHZhbHVlcyBjYW4gYmUgcGFyc2VkICh3aXRoIGBiaWdpbnRgIHN1cHBvcnQpIHVzaW5nIHtAbGluayBveCNKc29uLihwYXJzZTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBKc29uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBKc29uLnBhcnNlKCd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6Njk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjB9JylcbiAqIC8vIEBsb2c6IHsgZm9vOiAnYmFyJywgYmF6OiA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMG4gfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEpTT05cbiAqL1xuZXhwb3J0ICogYXMgSnNvbiBmcm9tICcuL2NvcmUvSnNvbi5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggW0tleXN0b3Jlc10oaHR0cHM6Ly9ldGhlcmV1bS5vcmcvZW4vZGV2ZWxvcGVycy9kb2NzL2RhdGEtc3RydWN0dXJlcy1hbmQtZW5jb2Rpbmcvd2ViMy1zZWNyZXQtc3RvcmFnZSkuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmNyeXB0aW5nICYgRGVjcnlwdGluZyBQcml2YXRlIEtleXNcbiAqXG4gKiBQcml2YXRlIGtleXMgY2FuIGJlIGVuY3J5cHRlZCBpbnRvIGEgSlNPTiBrZXlzdG9yZSB1c2luZyB7QGxpbmsgb3gjS2V5c3RvcmUuKGVuY3J5cHQ6ZnVuY3Rpb24pfSBhbmQgZGVjcnlwdGVkIHVzaW5nIHtAbGluayBveCNLZXlzdG9yZS4oZGVjcnlwdDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBLZXlzdG9yZSwgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogLy8gR2VuZXJhdGUgYSByYW5kb20gcHJpdmF0ZSBrZXkuXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICpcbiAqIC8vIERlcml2ZSBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG4gKiBjb25zdCBrZXkgPSBLZXlzdG9yZS5wYmtkZjIoeyBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZCcgfSlcbiAqXG4gKiAvLyBFbmNyeXB0IHRoZSBwcml2YXRlIGtleS5cbiAqIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IEtleXN0b3JlLmVuY3J5cHQocHJpdmF0ZUtleSwga2V5KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBcImNyeXB0b1wiOiB7XG4gKiAvLyBAbG9nOiAgICAgXCJjaXBoZXJcIjogXCJhZXMtMTI4LWN0clwiLFxuICogLy8gQGxvZzogICAgIFwiY2lwaGVydGV4dFwiOiBcIi4uLlwiLFxuICogLy8gQGxvZzogICAgIFwiY2lwaGVycGFyYW1zXCI6IHtcbiAqIC8vIEBsb2c6ICAgICAgIFwiaXZcIjogXCIuLi5cIixcbiAqIC8vIEBsb2c6ICAgICB9LFxuICogLy8gQGxvZzogICAgIFwia2RmXCI6IFwicGJrZGYyXCIsXG4gKiAvLyBAbG9nOiAgICAgXCJrZGZwYXJhbXNcIjoge1xuICogLy8gQGxvZzogICAgICAgXCJzYWx0XCI6IFwiLi4uXCIsXG4gKiAvLyBAbG9nOiAgICAgICBcImRrbGVuXCI6IDMyLFxuICogLy8gQGxvZzogICAgICAgXCJwcmZcIjogXCJobWFjLXNoYTI1NlwiLFxuICogLy8gQGxvZzogICAgICAgXCJjXCI6IDI2MjE0NCxcbiAqIC8vIEBsb2c6ICAgICB9LFxuICogLy8gQGxvZzogICAgIFwibWFjXCI6IFwiLi4uXCIsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIFwiaWRcIjogXCIuLi5cIixcbiAqIC8vIEBsb2c6ICAgXCJ2ZXJzaW9uXCI6IDMsXG4gKiAvLyBAbG9nOiB9XG4gKlxuICogLy8gRGVjcnlwdCB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBLZXlzdG9yZS5kZWNyeXB0KGVuY3J5cHRlZCwga2V5KVxuICogLy8gQGxvZzogXCIweC4uLlwiXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmV4cG9ydCAqIGFzIEtleXN0b3JlIGZyb20gJy4vY29yZS9LZXlzdG9yZS5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggS1pHIENvbW1pdG1lbnRzLlxuICpcbiAqIE1haW5seSBmb3IgW0VJUC00ODQ0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQ4NDQpIEJsb2JzLlxuICpcbiAqIEBjYXRlZ29yeSBCbG9icyAoRUlQLTQ4NDQpXG4gKi9cbmV4cG9ydCAqIGFzIEt6ZyBmcm9tICcuL2NvcmUvS3pnLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCBMb2dzIGFzIGRlZmluZWQgaW4gdGhlIFtFeGVjdXRpb24gQVBJIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9leGVjdXRpb24tYXBpcy9ibG9iL21haW4vc3JjL3NjaGVtYXMvcmVjZWlwdC55YW1sKVxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFV0aWxpdGllcyBmb3IgTG9nIGVuY29kaW5nICYgZGVjb2RpbmcgY2FuIGJlIGZvdW5kIG9uIHRoZSB7QGxpbmsgb3gjQWJpRXZlbnR9IG1vZHVsZS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbnZlcnRpbmcgZnJvbSBSUEMgRm9ybWF0XG4gKlxuICogTG9ncyBjYW4gYmUgY29udmVydGVkIGZyb20gdGhlaXIgUlBDIGZvcm1hdCB1c2luZyB7QGxpbmsgb3gjTG9nLihmcm9tUnBjOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCAnb3gvd2luZG93J1xuICogaW1wb3J0IHsgQWJpRXZlbnQsIEhleCwgTG9nIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNmZXIgPSBBYmlFdmVudC5mcm9tKFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBpbmRleGVkIGZyb20sIGFkZHJlc3MgaW5kZXhlZCB0bywgdWludDI1NiBpbmRleGVkIHZhbHVlKScsXG4gKiApXG4gKlxuICogY29uc3QgeyB0b3BpY3MgfSA9IEFiaUV2ZW50LmVuY29kZSh0cmFuc2ZlcilcbiAqXG4gKiBjb25zdCBsb2dzID0gYXdhaXQgd2luZG93LmV0aGVyZXVtIS5yZXF1ZXN0KHtcbiAqICAgbWV0aG9kOiAnZXRoX2dldExvZ3MnLFxuICogICBwYXJhbXM6IFtcbiAqICAgICB7XG4gKiAgICAgICBhZGRyZXNzOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgICAgIGZyb21CbG9jazogSGV4LmZyb21OdW1iZXIoMTk3NjAyMzVuKSxcbiAqICAgICAgIHRvQmxvY2s6IEhleC5mcm9tTnVtYmVyKDE5NzYwMjQwbiksXG4gKiAgICAgICB0b3BpY3MsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqIH0pXG4gKlxuICogY29uc3QgbG9nID0gTG9nLmZyb21ScGMobG9nc1swXSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqIC8vIEBsb2c6ICAgYmxvY2tIYXNoOiAnMHhhYmU2OTEzNGU4MGExMmY2YTkzZDBhYTE4MjE1YjViODZjMmZiMzM4YmFlOTExNzkwY2EzNzRhODcxNmUwMWE0JyxcbiAqIC8vIEBsb2c6ICAgYmxvY2tOdW1iZXI6IDE5NzYwMjM2bixcbiAqIC8vIEBsb2c6ICAgZGF0YTogJzB4JyxcbiAqIC8vIEBsb2c6ICAgbG9nSW5kZXg6IDI3MSxcbiAqIC8vIEBsb2c6ICAgcmVtb3ZlZDogZmFsc2UsXG4gKiAvLyBAbG9nOiAgIHRvcGljczogW1xuICogLy8gQGxvZzogICAgIFwiMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmXCIsXG4gKiAvLyBAbG9nOiAgICAgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAqIC8vIEBsb2c6ICAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGMwNGQ5ZTkyNzhlYzVlNGQ0MjQ0NzZkM2ViZWM3MGNiNWQ2NDhkMVwiLFxuICogLy8gQGxvZzogICAgIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjViXCIsXG4gKiAvLyBAbG9nOiAgIHRyYW5zYWN0aW9uSGFzaDpcbiAqIC8vIEBsb2c6ICAgICAnMHhjZmE1MmRiMGJjMmNiNWJkY2IyYzViZDg4MTZkZjdhMmYwMThhMGUzOTY0YWIxZWY0ZDc5NGNmMzI3OTY2ZTkzJyxcbiAqIC8vIEBsb2c6ICAgdHJhbnNhY3Rpb25JbmRleDogMTQ1LFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEV4ZWN1dGlvbiBTcGVjXG4gKi9cbmV4cG9ydCAqIGFzIExvZyBmcm9tICcuL2NvcmUvTG9nLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGdlbmVyYXRpbmcgYW5kIHdvcmtpbmcgd2l0aCBbQklQLTM5XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDM5Lm1lZGlhd2lraSkgbW5lbW9uaWNzLlxuICpcbiAqIDo6OmluZm9cbiAqXG4gKiBUaGUgYE1uZW1vbmljYCBtb2R1bGUgaXMgYSBmcmllbmRseSB3cmFwcGVyIG92ZXIgW2BAc2N1cmUvYmlwMzlgXShodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJpcDM5KSwgYW4gKiphdWRpdGVkKiogaW1wbGVtZW50YXRpb24gb2YgW0JJUC0zOV0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzOS5tZWRpYXdpa2kpXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBHZW5lcmF0aW5nIGEgUmFuZG9tIE1uZW1vbmljXG4gKlxuICogUmFuZG9tIG1uZW1vbmljcyBjYW4gYmUgZ2VuZXJhdGVkIHVzaW5nIHtAbGluayBveCNNbmVtb25pYy4ocmFuZG9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IE1uZW1vbmljIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbW5lbW9uaWMgPSBNbmVtb25pYy5yYW5kb20oTW5lbW9uaWMuZW5nbGlzaClcbiAqIC8vIEBsb2c6ICdidXllciB6b28gZW5kIGRhbmdlciBpY2UgY2FwYWJsZSBzaHJ1ZyBuYWl2ZSB0d2lzdCByZWxpZWYgbWFzcyBib251cydcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ29udmVydGluZyB0byBQcml2YXRlIEtleVxuICpcbiAqIE1uZW1vbmljcyBjYW4gYmUgY29udmVydGVkIHRvIGEgcHJpdmF0ZSBrZXkgdXNpbmcge0BsaW5rIG94I01uZW1vbmljLih0b1ByaXZhdGVLZXk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gTW5lbW9uaWMudG9Qcml2YXRlS2V5KCdidXllciB6b28gZW5kIGRhbmdlciBpY2UgY2FwYWJsZSBzaHJ1ZyBuYWl2ZSB0d2lzdCByZWxpZWYgbWFzcyBib251cycpXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbnZlcnRpbmcgdG8gSEQgS2V5XG4gKlxuICogTW5lbW9uaWNzIGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBIRCBLZXkgdXNpbmcge0BsaW5rIG94I01uZW1vbmljLih0b0hkS2V5OmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IE1uZW1vbmljIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgaGRLZXkgPSBNbmVtb25pYy50b0hkS2V5KCdidXllciB6b28gZW5kIGRhbmdlciBpY2UgY2FwYWJsZSBzaHJ1ZyBuYWl2ZSB0d2lzdCByZWxpZWYgbWFzcyBib251cycpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbnZlcnRpbmcgdG8gU2VlZFxuICpcbiAqIE1uZW1vbmljcyBjYW4gYmUgY29udmVydGVkIHRvIGEgbWFzdGVyIHNlZWQgdXNpbmcge0BsaW5rIG94I01uZW1vbmljLih0b1NlZWQ6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgTW5lbW9uaWMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBtbmVtb25pYyA9ICdidXllciB6b28gZW5kIGRhbmdlciBpY2UgY2FwYWJsZSBzaHJ1ZyBuYWl2ZSB0d2lzdCByZWxpZWYgbWFzcyBib251cydcbiAqIGNvbnN0IHNlZWQgPSBNbmVtb25pYy50b1NlZWQobW5lbW9uaWMpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsuLi42NCBieXRlc11cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBDcnlwdG9cbiAqL1xuZXhwb3J0ICogYXMgTW5lbW9uaWMgZnJvbSAnLi9jb3JlL01uZW1vbmljLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCBbRUlQLTE5MSBQZXJzb25hbCBNZXNzYWdlc10oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xOTEjdmVyc2lvbi0weDQ1LWUpXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb21wdXRpbmcgU2lnbiBQYXlsb2FkXG4gKlxuICogQW4gRUlQLTE5MSBwZXJzb25hbCBzaWduIHBheWxvYWQgY2FuIGJlIGNvbXB1dGVkIHVzaW5nIHtAbGluayBveCNQZXJzb25hbE1lc3NhZ2UuKGdldFNpZ25QYXlsb2FkOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCwgUGVyc29uYWxNZXNzYWdlLCBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gUGVyc29uYWxNZXNzYWdlLmdldFNpZ25QYXlsb2FkKEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgU2lnbmVkICYgVHlwZWQgRGF0YVxuICovXG5leHBvcnQgKiBhcyBQZXJzb25hbE1lc3NhZ2UgZnJvbSAnLi9jb3JlL1BlcnNvbmFsTWVzc2FnZS5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggW0VJUC0xMTkzIFByb3ZpZGVyc10oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkzKVxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyBFeHRlcm5hbCBQcm92aWRlcnNcbiAqXG4gKiBFeHRlcm5hbCBFSVAtMTE5MyBQcm92aWRlcnMgY2FuIGJlIGluc3RhbnRpYXRlZCB3aXRoIHtAbGluayBveCNQcm92aWRlci4oZnJvbTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJvdmlkZXIgPSBQcm92aWRlci5mcm9tKHdpbmRvdy5ldGhlcmV1bSlcbiAqXG4gKiBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfYmxvY2tOdW1iZXInIH0pXG4gKiBgYGBcbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUaGVyZSBhcmUgYWxzbyBsaWJyYXJpZXMgdGhhdCBkaXN0cmlidXRlIEVJUC0xMTkzIFByb3ZpZGVyIG9iamVjdHMgdGhhdCB5b3UgY2FuIHVzZSB3aXRoIGBQcm92aWRlci5mcm9tYDpcbiAqXG4gKiAtIFtgQHdhbGxldGNvbm5lY3QvZXRoZXJldW0tcHJvdmlkZXJgXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9cXEB3YWxsZXRjb25uZWN0L2V0aGVyZXVtLXByb3ZpZGVyKVxuICpcbiAqIC0gW2BAY29pbmJhc2Uvd2FsbGV0LXNka2BdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL1xcQGNvaW5iYXNlL3dhbGxldC1zZGspXG4gKlxuICogLSBbYEBtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXJgXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9cXEBtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXIpXG4gKlxuICogLSBbYEBzYWZlLWdsb2JhbC9zYWZlLWFwcHMtcHJvdmlkZXJgXShodHRwczovL2dpdGh1Yi5jb20vc2FmZS1nbG9iYWwvc2FmZS1hcHBzLXNkay90cmVlL21haW4vcGFja2FnZXMvc2FmZS1hcHBzLXByb3ZpZGVyKVxuICpcbiAqIC0gW2BtaXBkYF0oaHR0cHM6Ly9naXRodWIuY29tL3dldm0vbWlwZCk6IEVJUC02OTYzIE11bHRpIEluamVjdGVkIFByb3ZpZGVyc1xuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyB3aXRoIGFuIFJQQyBUcmFuc3BvcnRcbiAqXG4gKiBPeCdzIHtAbGluayBveCNScGNUcmFuc3BvcnR9IGlzIGFsc28gRUlQLTExOTMgY29tcGxpYW50LCBhbmQgY2FuIGJlIHVzZWQgdG8gaW5zdGFudGlhdGUgYW4gRUlQLTExOTMgUHJvdmlkZXIuIFRoaXMgbWVhbnMgeW91IGNhbiB1c2UgYW55IEhUVFAgUlBDIGVuZHBvaW50IGFzIGFuIEVJUC0xMTkzIFByb3ZpZGVyLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQcm92aWRlciwgUnBjVHJhbnNwb3J0IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNwb3J0ID0gUnBjVHJhbnNwb3J0LmZyb21IdHRwKCdodHRwczovLzEucnBjLnRoaXJkd2ViLmNvbScpXG4gKiBjb25zdCBwcm92aWRlciA9IFByb3ZpZGVyLmZyb20odHJhbnNwb3J0KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBJbnN0YW50aWF0aW5nIGEgUHJvdmlkZXIgd2l0aCBFdmVudHNcbiAqXG4gKiBFdmVudCBlbWl0dGVycyBmb3IgRUlQLTExOTMgUHJvdmlkZXJzIGNhbiBiZSBjcmVhdGVkIHVzaW5nIHtAbGluayBveCNQcm92aWRlci4oY3JlYXRlRW1pdHRlcjpmdW5jdGlvbil9OlxuICpcbiAqIFVzZWZ1bCBmb3IgV2FsbGV0cyB0aGF0IGRpc3RyaWJ1dGUgYW4gRUlQLTExOTMgUHJvdmlkZXIgKGUuZy4gd2VicGFnZSBpbmplY3Rpb24gdmlhIGB3aW5kb3cuZXRoZXJldW1gKS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBQcm92aWRlciwgUnBjUmVxdWVzdCwgUnBjUmVzcG9uc2UgfSBmcm9tICdveCdcbiAqXG4gKiAvLyAxLiBJbnN0YW50aWF0ZSBhIFByb3ZpZGVyIEVtaXR0ZXIuXG4gKiBjb25zdCBlbWl0dGVyID0gUHJvdmlkZXIuY3JlYXRlRW1pdHRlcigpIC8vIFshY29kZSArK11cbiAqXG4gKiBjb25zdCBzdG9yZSA9IFJwY1JlcXVlc3QuY3JlYXRlU3RvcmUoKVxuICpcbiAqIGNvbnN0IHByb3ZpZGVyID0gUHJvdmlkZXIuZnJvbSh7XG4gKiAgIC8vIDIuIFBhc3MgdGhlIEVtaXR0ZXIgdG8gdGhlIFByb3ZpZGVyLlxuICogICAuLi5lbWl0dGVyLCAvLyBbIWNvZGUgKytdXG4gKiAgIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICogICAgIHJldHVybiBhd2FpdCBmZXRjaCgnaHR0cHM6Ly8xLnJwYy50aGlyZHdlYi5jb20nLCB7XG4gKiAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzdG9yZS5wcmVwYXJlKGFyZ3MpKSxcbiAqICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICogICAgICAgaGVhZGVyczoge1xuICogICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICogICAgICAgfSxcbiAqICAgICB9KVxuICogICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSlcbiAqICAgICAgIC50aGVuKFJwY1Jlc3BvbnNlLnBhcnNlKVxuICogICB9LFxuICogfSlcbiAqXG4gKiAvLyAzLiBFbWl0IFByb3ZpZGVyIEV2ZW50cy5cbiAqIGVtaXR0ZXIuZW1pdCgnYWNjb3VudHNDaGFuZ2VkJywgWycweC4uLiddKSAvLyBbIWNvZGUgKytdXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgUHJvdmlkZXJzIChFSVAtMTE5MylcbiAqL1xuZXhwb3J0ICogYXMgUHJvdmlkZXIgZnJvbSAnLi9jb3JlL1Byb3ZpZGVyLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBFQ0RTQSBwdWJsaWMga2V5cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNlcmlhbGl6aW5nIFB1YmxpYyBLZXlzXG4gKlxuICogUHVibGljIEtleXMgY2FuIGJlIHNlcmlhbGl6ZWQgdG8gSGV4IG9yIEJ5dGVzIHVzaW5nIHtAbGluayBveCNQdWJsaWNLZXkuKHRvSGV4OmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFB1YmxpY0tleS50b0hleChwdWJsaWNLZXkpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweDA0ODMxODUzNWI1NDEwNWQ0YTdhYWU2MGMwOGZjNDVmOTY4NzE4MWI0ZmRmYzYyNWJkMWE3NTNmYTczOTdmZWQ3NTM1NDdmMTFjYTg2OTY2NDZmMmYzYWNiMDhlMzEwMTZhZmFjMjNlNjMwYzVkMTFmNTlmNjFmZWY1N2IwZDJhYTUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIERlc2VyaWFsaXppbmcgUHVibGljIEtleXNcbiAqXG4gKiBQdWJsaWMgS2V5cyBjYW4gYmUgZGVzZXJpYWxpemVkIGZyb20gSGV4IG9yIEJ5dGVzIHVzaW5nIHtAbGluayBveCNQdWJsaWNLZXkuKGZyb21IZXg6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb21IZXgoJzB4ODMxODUzNWI1NDEwNWQ0YTdhYWU2MGMwOGZjNDVmOTY4NzE4MWI0ZmRmYzYyNWJkMWE3NTNmYTczOTdmZWQ3NTM1NDdmMTFjYTg2OTY2NDZmMmYzYWNiMDhlMzEwMTZhZmFjMjNlNjMwYzVkMTFmNTlmNjFmZWY1N2IwZDJhYTUnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IENyeXB0b1xuICovXG5leHBvcnQgKiBhcyBQdWJsaWNLZXkgZnJvbSAnLi9jb3JlL1B1YmxpY0tleS5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgW1JlY3Vyc2l2ZSBMZW5ndGggUHJlZml4XShodHRwczovL2V0aGVyZXVtLm9yZy9lbi9kZXZlbG9wZXJzL2RvY3MvZGF0YS1zdHJ1Y3R1cmVzLWFuZC1lbmNvZGluZy9ybHAvKSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4LCBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gUmxwLmZyb21IZXgoW0hleC5mcm9tU3RyaW5nKCdoZWxsbycpLCBIZXguZnJvbVN0cmluZygnd29ybGQnKV0pXG4gKiAvLyBAbG9nOiAnMHhjYzg1Njg2NTZjNmM2Zjg1Nzc2ZjcyNmM2NCdcbiAqXG4gKiBjb25zdCB2YWx1ZXMgPSBSbHAudG9IZXgoZGF0YSlcbiAqIC8vIEBsb2c6IFtIZXguZnJvbVN0cmluZygnaGVsbG8nKSwgSGV4LmZyb21TdHJpbmcoJ3dvcmxkJyldXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgRGF0YVxuICovXG5leHBvcnQgKiBhcyBSbHAgZnJvbSAnLi9jb3JlL1JscC5qcyc7XG4vKipcbiAqIFV0aWxpdHkgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCBFdGhlcmV1bSBKU09OLVJQQyBuYW1lc3BhY2VzICYgc2NoZW1hcy5cbiAqXG4gKiBAY2F0ZWdvcnkgSlNPTi1SUENcbiAqL1xuZXhwb3J0ICogYXMgUnBjU2NoZW1hIGZyb20gJy4vY29yZS9ScGNTY2hlbWEuanMnO1xuLyoqXG4gKiBVdGlsaXR5IHR5cGVzICYgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggW0pTT04tUlBDIDIuMCBSZXF1ZXN0c10oaHR0cHM6Ly93d3cuanNvbnJwYy5vcmcvc3BlY2lmaWNhdGlvbiNyZXF1ZXN0X29iamVjdCkgYW5kIEV0aGVyZXVtIEpTT04tUlBDIG1ldGhvZHMgYXNcbiAqIGRlZmluZWQgb24gdGhlIFtFdGhlcmV1bSBBUEkgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2V4ZWN1dGlvbi1hcGlzKVxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyBhIFJlcXVlc3QgU3RvcmVcbiAqXG4gKiBBIFJlcXVlc3QgU3RvcmUgY2FuIGJlIGluc3RhbnRpYXRlZCB1c2luZyB7QGxpbmsgb3gjUnBjUmVxdWVzdC4oY3JlYXRlU3RvcmU6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHN0b3JlID0gUnBjUmVxdWVzdC5jcmVhdGVTdG9yZSgpXG4gKlxuICogY29uc3QgcmVxdWVzdF8xID0gc3RvcmUucHJlcGFyZSh7XG4gKiAgIG1ldGhvZDogJ2V0aF9ibG9ja051bWJlcicsXG4gKiB9KVxuICogLy8gQGxvZzogeyBpZDogMCwganNvbnJwYzogJzIuMCcsIG1ldGhvZDogJ2V0aF9ibG9ja051bWJlcicgfVxuICpcbiAqIGNvbnN0IHJlcXVlc3RfMiA9IHN0b3JlLnByZXBhcmUoe1xuICogICBtZXRob2Q6ICdldGhfY2FsbCcsXG4gKiAgIHBhcmFtczogW1xuICogICAgIHtcbiAqICAgICAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICAgIGRhdGE6ICcweGRlYWRiZWVmJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqIC8vIEBsb2c6IHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnLCBtZXRob2Q6ICdldGhfY2FsbCcsIHBhcmFtczogW3sgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCBkYXRhOiAnMHhkZWFkYmVlZicgfV0gfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEpTT04tUlBDXG4gKi9cbmV4cG9ydCAqIGFzIFJwY1JlcXVlc3QgZnJvbSAnLi9jb3JlL1JwY1JlcXVlc3QuanMnO1xuLyoqXG4gKiBVdGlsaXR5IHR5cGVzICYgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggW0pTT04tUlBDIDIuMCBSZXNwb25zZXNdKGh0dHBzOi8vd3d3Lmpzb25ycGMub3JnL3NwZWNpZmljYXRpb24jcmVzcG9uc2Vfb2JqZWN0KVxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSW5zdGFudGlhdGluZyBhbiBSUEMgUmVzcG9uc2VcbiAqXG4gKiBSUEMgUmVzcG9uc2VzIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcge0BsaW5rIG94I1JwY1Jlc3BvbnNlLihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJwY1Jlc3BvbnNlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcmVzcG9uc2UgPSBScGNSZXNwb25zZS5mcm9tKHtcbiAqICAgaWQ6IDAsXG4gKiAgIGpzb25ycGM6ICcyLjAnLFxuICogICByZXN1bHQ6ICcweDY5NDIwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogVHlwZS1zYWZlIGluc3RhbnRpYXRpb24gZnJvbSBhIGByZXF1ZXN0YCBvYmplY3QgaXMgYWxzbyBzdXBwb3J0ZWQuIElmIGEgYHJlcXVlc3RgIGlzIHByb3ZpZGVkLCB0aGVuIHRoZSBgaWRgIGFuZCBganNvbnJwY2AgcHJvcGVydGllcyB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aCB0aGUgdmFsdWVzIGZyb20gdGhlIHJlcXVlc3QuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJwY1JlcXVlc3QsIFJwY1Jlc3BvbnNlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7IGlkOiAwLCBtZXRob2Q6ICdldGhfYmxvY2tOdW1iZXInIH0pXG4gKlxuICogY29uc3QgcmVzcG9uc2UgPSBScGNSZXNwb25zZS5mcm9tKFxuICogICB7IHJlc3VsdDogJzB4Njk0MjAnIH0sXG4gKiAgIHsgcmVxdWVzdCB9LFxuICogKVxuICogYGBgXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBQYXJzaW5nIGFuIFJQQyBSZXNwb25zZVxuICpcbiAqIFJQQyBSZXNwb25zZXMgY2FuIGJlIHBhcnNlZCB1c2luZyB7QGxpbmsgb3gjUnBjUmVzcG9uc2UuKHBhcnNlOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJwY1JlcXVlc3QsIFJwY1Jlc3BvbnNlIH0gZnJvbSAnb3gnXG4gKlxuICogLy8gMS4gQ3JlYXRlIGEgcmVxdWVzdCBzdG9yZS5cbiAqIGNvbnN0IHN0b3JlID0gUnBjUmVxdWVzdC5jcmVhdGVTdG9yZSgpXG4gKlxuICogLy8gMi4gR2V0IGEgcmVxdWVzdCBvYmplY3QuXG4gKiBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHJlcGFyZSh7XG4gKiAgIG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAqICAgcGFyYW1zOiBbJzB4MScsIGZhbHNlXSxcbiAqIH0pXG4gKlxuICogLy8gMy4gU2VuZCB0aGUgSlNPTi1SUEMgcmVxdWVzdCB2aWEgSFRUUC5cbiAqIGNvbnN0IGJsb2NrID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vMS5ycGMudGhpcmR3ZWIuY29tJywge1xuICogICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAqICAgaGVhZGVyczoge1xuICogICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gKiAgIH0sXG4gKiAgIG1ldGhvZDogJ1BPU1QnLFxuICogfSlcbiAqICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAqICAvLyA0LiBQYXJzZSB0aGUgSlNPTi1SUEMgcmVzcG9uc2UgaW50byBhIHR5cGUtc2FmZSByZXN1bHQuIC8vIFshY29kZSBmb2N1c11cbiAqICAudGhlbigocmVzcG9uc2UpID0+IFJwY1Jlc3BvbnNlLnBhcnNlKHJlc3BvbnNlLCB7IHJlcXVlc3QgfSkpIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBibG9jayAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgSlNPTi1SUENcbiAqL1xuZXhwb3J0ICogYXMgUnBjUmVzcG9uc2UgZnJvbSAnLi9jb3JlL1JwY1Jlc3BvbnNlLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBKU09OLVJQQyBUcmFuc3BvcnRzLlxuICpcbiAqIDo6Om5vdGVcbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtb2R1bGUgZGlzdHJpYnV0ZWQgZm9yIGV4cGVyaW1lbnRpbmcgd2l0aCBuZXR3b3JrIGNvbm5lY3Rpdml0eSBvbiBPeC5cbiAqXG4gKiBDb25zaWRlciB1c2luZyBuZXR3b3JraW5nIGZ1bmN0aW9uYWxpdHkgZnJvbSBhIGhpZ2hlci1sZXZlbCBsaWJyYXJ5IHN1Y2ggYXMgW1ZpZW0ncyBUcmFuc3BvcnRzXShodHRwczovL3ZpZW0uc2gvZG9jcy9jbGllbnRzL3RyYW5zcG9ydHMvaHR0cClcbiAqIGlmIHlvdSBuZWVkIG1vcmUgZmVhdHVyZXMgc3VjaCBhczogcmV0cnkgbG9naWMsIFdlYlNvY2tldHMvSVBDLCBtaWRkbGV3YXJlLCBiYXRjaCBKU09OLVJQQywgZXRjLlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIVFRQIEluc3RhbnRpYXRpb25cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjVHJhbnNwb3J0IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNwb3J0ID0gUnBjVHJhbnNwb3J0LmZyb21IdHRwKCdodHRwczovLzEucnBjLnRoaXJkd2ViLmNvbScpXG4gKlxuICogY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0cmFuc3BvcnQucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9ibG9ja051bWJlcicgfSlcbiAqIC8vIEBsb2c6ICcweDFhMmIzYydcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBKU09OLVJQQ1xuICovXG5leHBvcnQgKiBhcyBScGNUcmFuc3BvcnQgZnJvbSAnLi9jb3JlL1JwY1RyYW5zcG9ydC5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBbc2VjcDI1NmsxXShodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZikgRUNEU0EgY3J5cHRvZ3JhcGh5LlxuICpcbiAqIDo6OmluZm9cbiAqXG4gKiBUaGUgYFNlY3AyNTZrMWAgbW9kdWxlIGlzIGEgZnJpZW5kbHkgd3JhcHBlciBvdmVyIFtgQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFgXShodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLWN1cnZlcyksIGFuICoqYXVkaXRlZCoqIGltcGxlbWVudGF0aW9uIG9mIFtzZWNwMjU2azFdKGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzItdjIucGRmKVxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ29tcHV0aW5nIGEgUmFuZG9tIFByaXZhdGUgS2V5XG4gKlxuICogQSByYW5kb20gcHJpdmF0ZSBrZXkgY2FuIGJlIGNvbXB1dGVkIHVzaW5nIHtAbGluayBveCNTZWNwMjU2azEuKHJhbmRvbVByaXZhdGVLZXk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgR2V0dGluZyBhIFB1YmxpYyBLZXlcbiAqXG4gKiBBIHB1YmxpYyBrZXkgY2FuIGJlIGRlcml2ZWQgZnJvbSBhIHByaXZhdGUga2V5IHVzaW5nIHtAbGluayBveCNTZWNwMjU2azEuKGdldFB1YmxpY0tleTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHsgeDogMzI1MS4uLjUxNTJuLCB5OiAxMjUxLi4uNTE1Mm4gfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTaWduaW5nIGEgUGF5bG9hZFxuICpcbiAqIEEgcGF5bG9hZCBjYW4gYmUgc2lnbmVkIHVzaW5nIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleSB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7IHI6IDEyNTEuLi41MTUybiwgczogMTI1MS4uLjUxNTJuLCB5UGFyaXR5OiAxIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmVyaWZ5aW5nIGEgU2lnbmF0dXJlXG4gKlxuICogQSBzaWduYXR1cmUgY2FuIGJlIHZlcmlmaWVkIHVzaW5nIHtAbGluayBveCNTZWNwMjU2azEuKHZlcmlmeTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICogY29uc3QgcHVibGljS2V5ID0gU2VjcDI1NmsxLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSlcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgaXNWYWxpZCA9IFNlY3AyNTZrMS52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwdWJsaWNLZXksIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmV4cG9ydCAqIGFzIFNlY3AyNTZrMSBmcm9tICcuL2NvcmUvU2VjcDI1NmsxLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIFtOSVNUIFAyNTZdKGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9jc3JjL21lZGlhL2V2ZW50cy93b3Jrc2hvcC1vbi1lbGxpcHRpYy1jdXJ2ZS1jcnlwdG9ncmFwaHktc3RhbmRhcmRzL2RvY3VtZW50cy9wYXBlcnMvc2Vzc2lvbjYtYWRhbGllci1tZWhtZXQucGRmKSBFQ0RTQSBjcnlwdG9ncmFwaHkuXG4gKlxuICogOjo6aW5mb1xuICpcbiAqIFRoZSBgUDI1NmAgbW9kdWxlIGlzIGEgZnJpZW5kbHkgd3JhcHBlciBvdmVyIFtgQG5vYmxlL2N1cnZlcy9wMjU2YF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1jdXJ2ZXMpLCBhbiAqKmF1ZGl0ZWQqKiBpbXBsZW1lbnRhdGlvbiBvZiBbUDI1Nl0oaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMi12Mi5wZGYpXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb21wdXRpbmcgYSBSYW5kb20gUHJpdmF0ZSBLZXlcbiAqXG4gKiBBIHJhbmRvbSBwcml2YXRlIGtleSBjYW4gYmUgY29tcHV0ZWQgdXNpbmcge0BsaW5rIG94I1AyNTYuKHJhbmRvbVByaXZhdGVLZXk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBQMjU2LnJhbmRvbVByaXZhdGVLZXkoKVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBHZXR0aW5nIGEgUHVibGljIEtleVxuICpcbiAqIEEgcHVibGljIGtleSBjYW4gYmUgZGVyaXZlZCBmcm9tIGEgcHJpdmF0ZSBrZXkgdXNpbmcge0BsaW5rIG94I1AyNTYuKGdldFB1YmxpY0tleTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFAyNTYucmFuZG9tUHJpdmF0ZUtleSgpXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUDI1Ni5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHsgeDogMzI1MS4uLjUxNTJuLCB5OiAxMjUxLi4uNTE1Mm4gfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTaWduaW5nIGEgUGF5bG9hZFxuICpcbiAqIEEgcGF5bG9hZCBjYW4gYmUgc2lnbmVkIHVzaW5nIHtAbGluayBveCNQMjU2LihzaWduOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gUDI1Ni5yYW5kb21Qcml2YXRlS2V5KClcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBQMjU2LnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogeyByOiAxMjUxLi4uNTE1Mm4sIHM6IDEyNTEuLi41MTUybiwgeVBhcml0eTogMSB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFZlcmlmeWluZyBhIFNpZ25hdHVyZVxuICpcbiAqIEEgc2lnbmF0dXJlIGNhbiBiZSB2ZXJpZmllZCB1c2luZyB7QGxpbmsgb3gjUDI1Ni4odmVyaWZ5OmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gUDI1Ni5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFAyNTYuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KVxuICogY29uc3Qgc2lnbmF0dXJlID0gUDI1Ni5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgaXNWYWxpZCA9IFAyNTYudmVyaWZ5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHVibGljS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IENyeXB0b1xuICovXG5leHBvcnQgKiBhcyBQMjU2IGZyb20gJy4vY29yZS9QMjU2LmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBFQ0RTQSBzaWduYXR1cmVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2VyaWFsaXppbmcgYSBTaWduYXR1cmVcbiAqXG4gKiBTaWduYXR1cmVzIGNhbiBiZSBzZXJpYWxpemVkIHRvIEhleCBvciBCeXRlcyB1c2luZyB7QGxpbmsgb3gjU2lnbmF0dXJlLih0b0hleDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9IZXgoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIC8vIEBsb2c6ICcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIERlc2VyaWFsaXppbmcgYSBTaWduYXR1cmVcbiAqXG4gKiBTaWduYXR1cmVzIGNhbiBiZSBkZXNlcmlhbGl6ZWQgZnJvbSBIZXggb3IgQnl0ZXMgdXNpbmcge0BsaW5rIG94I1NpZ25hdHVyZS4oZnJvbUhleDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbUhleCgnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODFjJylcbiAqIC8vIEBsb2c6IHsgcjogNTIzMS4uLm4sIHM6IDM1MjIuLi5uLCB5UGFyaXR5OiAwIH1cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBDcnlwdG9cbiAqL1xuZXhwb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4vY29yZS9TaWduYXR1cmUuanMnO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoXG4gKiBbRUlQLTQzNjE6IFNpZ24tSW4gd2l0aCBFdGhlcmV1bV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC00MzYxKVxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ3JlYXRpbmcgYSBTSVdFIE1lc3NhZ2VcbiAqXG4gKiBTSVdFIG1lc3NhZ2VzIGNhbiBiZSBjcmVhdGVkIHVzaW5nIHtAbGluayBveCNTaXdlLihjcmVhdGVNZXNzYWdlOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpd2UgfSBmcm9tICdveCdcbiAqXG4gKiBTaXdlLmNyZWF0ZU1lc3NhZ2Uoe1xuICogICBhZGRyZXNzOiAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZG9tYWluOiAnZXhhbXBsZS5jb20nLFxuICogICBub25jZTogJ2Zvb2JhcmJheicsXG4gKiAgIHVyaTogJ2h0dHBzOi8vZXhhbXBsZS5jb20vcGF0aCcsXG4gKiAgIHZlcnNpb246ICcxJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiBcImV4YW1wbGUuY29tIHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50OlxuICogLy8gQGxvZzogMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlXG4gKiAvLyBAbG9nOlxuICogLy8gQGxvZzpcbiAqIC8vIEBsb2c6IFVSSTogaHR0cHM6Ly9leGFtcGxlLmNvbS9wYXRoXG4gKiAvLyBAbG9nOiBWZXJzaW9uOiAxXG4gKiAvLyBAbG9nOiBDaGFpbiBJRDogMVxuICogLy8gQGxvZzogTm9uY2U6IGZvb2JhcmJhelxuICogLy8gQGxvZzogSXNzdWVkIEF0OiAyMDIzLTAyLTAxVDAwOjAwOjAwLjAwMFpcIlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBHZW5lcmF0aW5nIFNJV0UgTm9uY2VzXG4gKlxuICogU0lXRSBub25jZXMgY2FuIGJlIGdlbmVyYXRlZCB1c2luZyB7QGxpbmsgb3gjU2l3ZS4oZ2VuZXJhdGVOb25jZTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaXdlIH0gZnJvbSAnb3gnXG4gKlxuICogU2l3ZS5nZW5lcmF0ZU5vbmNlKClcbiAqIC8vIEBsb2c6ICc2NWVkNDY4MWQ0ZWZlMDI3MGI5MjNmZjVmNGIwOTdiMWM5NTk3NGRjMzNhZWViZWNkNTcyNGM0MmZkODZkZmQyNWRjNzBiMjdlZjgzNmIyYWEyMmU2OGYxOWViY2NjYzEnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFBhcnNpbmcgYSBTSVdFIE1lc3NhZ2VcbiAqXG4gKiBTSVdFIG1lc3NhZ2VzIGNhbiBiZSBwYXJzZWQgdXNpbmcge0BsaW5rIG94I1Npd2UuKHBhcnNlTWVzc2FnZTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaXdlIH0gZnJvbSAnb3gnXG4gKlxuICogU2l3ZS5wYXJzZU1lc3NhZ2UoYGV4YW1wbGUuY29tIHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50OlxuICogMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlXG4gKlxuICogSSBhY2NlcHQgdGhlIEV4YW1wbGVPcmcgVGVybXMgb2YgU2VydmljZTogaHR0cHM6Ly9leGFtcGxlLmNvbS90b3NcbiAqXG4gKiBVUkk6IGh0dHBzOi8vZXhhbXBsZS5jb20vcGF0aFxuICogVmVyc2lvbjogMVxuICogQ2hhaW4gSUQ6IDFcbiAqIE5vbmNlOiBmb29iYXJiYXpcbiAqIElzc3VlZCBBdDogMjAyMy0wMi0wMVQwMDowMDowMC4wMDBaYClcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZScsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGRvbWFpbjogJ2V4YW1wbGUuY29tJyxcbiAqIC8vIEBsb2c6ICAgaXNzdWVkQXQ6ICcyMDIzLTAyLTAxVDAwOjAwOjAwLjAwMFonLFxuICogLy8gQGxvZzogICBub25jZTogJ2Zvb2JhcmJheicsXG4gKiAvLyBAbG9nOiAgIHN0YXRlbWVudDogJ0kgYWNjZXB0IHRoZSBFeGFtcGxlT3JnIFRlcm1zIG9mIFNlcnZpY2U6IGh0dHBzOi8vZXhhbXBsZS5jb20vdG9zJyxcbiAqIC8vIEBsb2c6ICAgdXJpOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9wYXRoJyxcbiAqIC8vIEBsb2c6ICAgdmVyc2lvbjogJzEnLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWYWxpZGF0aW5nIGEgU0lXRSBNZXNzYWdlXG4gKlxuICogU0lXRSBtZXNzYWdlcyBjYW4gYmUgdmFsaWRhdGVkIHVzaW5nIHtAbGluayBveCNTaXdlLih2YWxpZGF0ZU1lc3NhZ2U6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2l3ZSB9IGZyb20gJ294J1xuICpcbiAqIFNpd2UudmFsaWRhdGVNZXNzYWdlKHtcbiAqICAgYWRkcmVzczogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZScsXG4gKiAgIGRvbWFpbjogJ2V4YW1wbGUuY29tJyxcbiAqICAgbWVzc2FnZToge1xuICogICAgIGFkZHJlc3M6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnLFxuICogICAgIGNoYWluSWQ6IDEsXG4gKiAgICAgZG9tYWluOiAnZXhhbXBsZS5jb20nLFxuICogICAgIG5vbmNlOiAnZm9vYmFyYmF6JyxcbiAqICAgICB1cmk6ICdodHRwczovL2V4YW1wbGUuY29tL3BhdGgnLFxuICogICAgIHZlcnNpb246ICcxJyxcbiAqICAgfSxcbiAqICAgbm9uY2U6ICdmb29iYXJiYXonLFxuICogfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBTaWduLUluIHdpdGggRXRoZXJldW0gKEVJUC00MzYxKVxuICovXG5leHBvcnQgKiBhcyBTaXdlIGZyb20gJy4vY29yZS9TaXdlLmpzJztcbmV4cG9ydCAqIGFzIFNvbGlkaXR5IGZyb20gJy4vY29yZS9Tb2xpZGl0eS5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggKipTdGF0ZSBPdmVycmlkZXMqKi5cbiAqXG4gKiBAY2F0ZWdvcnkgRXhlY3V0aW9uIFNwZWNcbiAqL1xuZXhwb3J0ICogYXMgU3RhdGVPdmVycmlkZXMgZnJvbSAnLi9jb3JlL1N0YXRlT3ZlcnJpZGVzLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCAqKlRyYW5zYWN0aW9ucyoqIGFzIGRlZmluZWQgaW4gdGhlIFtFeGVjdXRpb24gQVBJIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9leGVjdXRpb24tYXBpcy9ibG9iL21haW4vc3JjL3NjaGVtYXMvdHJhbnNhY3Rpb24ueWFtbClcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbnZlcnRpbmcgZnJvbSBSUEMgRm9ybWF0XG4gKlxuICogVHJhbnNhY3Rpb25zIGNhbiBiZSBjb252ZXJ0ZWQgZnJvbSBSUEMgZm9ybWF0IHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvbi4oZnJvbVJwYzpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24uZnJvbVJwYyh7XG4gKiAgIGhhc2g6ICcweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDAnLFxuICogICBub25jZTogJzB4MzU3JyxcbiAqICAgYmxvY2tIYXNoOlxuICogICAgICcweGMzNTBkODA3NTA1ZmI4MzU2NTBmMDAxMzYzMmM1NTE1NTkyOTg3YmExNjliYmM2NjI2ZDlmYzU0ZDkxZjBmMGInLFxuICogICBibG9ja051bWJlcjogJzB4MTJmMjk2ZicsXG4gKiAgIHRyYW5zYWN0aW9uSW5kZXg6ICcweDInLFxuICogICBmcm9tOiAnMHg4MTRlNWUwZTMxMDE2YjlhN2YxMzhjNzZiN2U3YjJiYjVjMWFiNmE2JyxcbiAqICAgdG86ICcweDNmYzkxYTNhZmQ3MDM5NWNkNDk2YzY0N2Q1YTZjYzlkNGIyYjdmYWQnLFxuICogICB2YWx1ZTogJzB4OWI2ZTY0YThlYzYwMDAwJyxcbiAqICAgZ2FzOiAnMHg0M2Y1ZCcsXG4gKiAgIG1heEZlZVBlckdhczogJzB4MmNhNmFlNDk0JyxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6ICcweDQxY2MzYzAnLFxuICogICBpbnB1dDpcbiAqICAgICAnMHgzNTkzNTY0YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NjQzNTA0NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwYjA4MDYwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkxMjRiYjVhZTk3OGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzAyYWFhMzliMjIzZmU4ZDBhMGU1YzRmMjdlYWQ5MDgzYzc1NmNjMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZlZTEzYTEwM2ExMGQ1OTNiOWFlMDZiM2UwNWYyZTdlMWMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDI0MDAwMWI5ODcyYicsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBhY2Nlc3NMaXN0OiBbXSxcbiAqICAgdHlwZTogJzB4MicsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEV4ZWN1dGlvbiBTcGVjXG4gKi9cbmV4cG9ydCAqIGFzIFRyYW5zYWN0aW9uIGZyb20gJy4vY29yZS9UcmFuc2FjdGlvbi5qcyc7XG4vKipcbiAqIEVycm9ycyAmIFR5cGVzIGZvciB3b3JraW5nIHdpdGggVHJhbnNhY3Rpb24gRW52ZWxvcGVzLlxuICpcbiAqIDo6Om5vdGVcbiAqIFJlZmVyIHRvIHRoZSBmb2xsb3dpbmcgbW9kdWxlcyBmb3Igc3BlY2lmaWMgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdHlwZXM6XG4gKiAtIFtgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeWBdKC9hcGkvVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSlcbiAqIC0gW2BUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OWBdKC9hcGkvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkpXG4gKiAtIFtgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzBgXSgvYXBpL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwKVxuICogLSBbYFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0YF0oL2FwaS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NClcbiAqIC0gW2BUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMmBdKC9hcGkvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIpXG4gKiA6OjpcbiAqXG4gKiBAY2F0ZWdvcnkgVHJhbnNhY3Rpb24gRW52ZWxvcGVzXG4gKi9cbmV4cG9ydCAqIGFzIFRyYW5zYWN0aW9uRW52ZWxvcGUgZnJvbSAnLi9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZ1xuICogd2l0aCAqKkxlZ2FjeSBUcmFuc2FjdGlvbiBFbnZlbG9wZXMqKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEluc3RhbnRpYXRpbmdcbiAqXG4gKiBUcmFuc2FjdGlvbiBFbnZlbG9wZXMgY2FuIGJlIGluc3RhbnRpYXRlZCB1c2luZyB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS4oZnJvbTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiAqIEBleGFtcGxlXG4gKiAjIyMgU2lnbmluZ1xuICpcbiAqIFRyYW5zYWN0aW9uIEVudmVsb3BlcyBjYW4gYmUgc2lnbmVkIHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LihnZXRTaWduUGF5bG9hZDpmdW5jdGlvbil9IGFuZCBhIHNpZ25pbmcgZnVuY3Rpb24gc3VjaCBhcyB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0gb3Ige0BsaW5rIG94I1AyNTYuKHNpZ246ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwcml2YXRlS2V5OiAnMHguLi4nIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNlcmlhbGl6aW5nXG4gKlxuICogVHJhbnNhY3Rpb24gRW52ZWxvcGVzIGNhbiBiZSBzZXJpYWxpemVkIHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LihzZXJpYWxpemU6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LnNlcmlhbGl6ZShlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTZW5kaW5nXG4gKlxuICogV2UgY2FuIHNlbmQgYSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byB0aGUgbmV0d29yayBieSBzZXJpYWxpemluZyB0aGUgc2lnbmVkIGVudmVsb3BlIHdpdGggYC5zZXJpYWxpemVgLCBhbmQgdGhlbiBicm9hZGNhc3RpbmcgaXQgb3ZlciBKU09OLVJQQyB3aXRoIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYC5cbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUsIHdlIHdpbGwgdXNlIHtAbGluayBveCNScGNUcmFuc3BvcnQuKGZyb21IdHRwOmZ1bmN0aW9uKX0gdG8gYnJvYWRjYXN0IGEgYGV0aF9zZW5kUmF3VHJhbnNhY3Rpb25gIHJlcXVlc3Qgb3ZlciBIVFRQIEpTT04tUlBDLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBScGNUcmFuc3BvcnQsIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3ksIFNlY3AyNTZrMSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiAvLyBDb25zdHJ1Y3QgdGhlIEVudmVsb3BlLlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMS41JyksXG4gKiB9KVxuICpcbiAqIC8vIFNpZ24gb3ZlciB0aGUgRW52ZWxvcGUuXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiAvLyBTZXJpYWxpemUgdGhlIEVudmVsb3BlIHdpdGggdGhlIFNpZ25hdHVyZS4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlICAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gQnJvYWRjYXN0IHRoZSBFbnZlbG9wZSB3aXRoIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3QgdHJhbnNwb3J0ID0gUnBjVHJhbnNwb3J0LmZyb21IdHRwKCdodHRwczovLzEucnBjLnRoaXJkd2ViLmNvbScpIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IGhhc2ggPSBhd2FpdCB0cmFuc3BvcnQucmVxdWVzdCh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGFyYW1zOiBbc2VyaWFsaXplZF0sIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIElmIHlvdSBhcmUgaW50ZXJmYWNpbmcgd2l0aCBhbiBSUEMgdGhhdCBzdXBwb3J0cyBgZXRoX3NlbmRUcmFuc2FjdGlvbmAsIHlvdSBjYW4gYWxzbyB1c2VcbiAqIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5Lih0b1JwYzpmdW5jdGlvbil9IHRvIGNvbnZlcnQgYW4gRW52ZWxvcGUgdG8gYW4gUlBDLWNvbXBhdGlibGUgZm9ybWF0LlxuICogVGhpcyBtZWFucyB5b3UgY2FuIHNraXAgdGhlIGNlcmVtb255IG9mIG1hbnVhbGx5IGZpbGxpbmcgJiBzaWduaW5nIHRoZSBUcmFuc2FjdGlvbi5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBQcm92aWRlciwgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMS41JyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kudG9ScGMoZW52ZWxvcGUpXG4gKlxuICogY29uc3QgcHJvdmlkZXIgPSBQcm92aWRlci5mcm9tKHdpbmRvdy5ldGhlcmV1bSlcbiAqIGNvbnN0IGhhc2ggPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gKiAgIHBhcmFtczogW2VudmVsb3BlX3JwY10sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb21wdXRpbmcgSGFzaGVzXG4gKlxuICogVHJhbnNhY3Rpb24gSGFzaGVzIGNhbiBiZSBjb21wdXRlZCB1c2luZyB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS4oaGFzaDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAgIGRhdGE6ICcweCcsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLidcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKGVudmVsb3BlLCB7IHNpZ25hdHVyZSB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5Lmhhc2goZW52ZWxvcGVfc2lnbmVkKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgVHJhbnNhY3Rpb24gRW52ZWxvcGVzXG4gKi9cbmV4cG9ydCAqIGFzIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgZnJvbSAnLi9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuanMnO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIFtFSVAtMTU1OSBUeXBlZCBUcmFuc2FjdGlvbiBFbnZlbG9wZXNdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTU1OSlcbiAqXG4gKiAgQGV4YW1wbGVcbiAqICMjIyBJbnN0YW50aWF0aW5nXG4gKlxuICogVHJhbnNhY3Rpb24gRW52ZWxvcGVzIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5Lihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMScpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDE1NTknLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNpZ25pbmdcbiAqXG4gKiBUcmFuc2FjdGlvbiBFbnZlbG9wZXMgY2FuIGJlIHNpZ25lZCB1c2luZyB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuKGdldFNpZ25QYXlsb2FkOmZ1bmN0aW9uKX0gYW5kIGEgc2lnbmluZyBmdW5jdGlvbiBzdWNoIGFzIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfSBvciB7QGxpbmsgb3gjUDI1Ni4oc2lnbjpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXNQcmljZTogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwcml2YXRlS2V5OiAnMHguLi4nIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKGVudmVsb3BlLCB7IHNpZ25hdHVyZSB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTZXJpYWxpemluZ1xuICpcbiAqIFRyYW5zYWN0aW9uIEVudmVsb3BlcyBjYW4gYmUgc2VyaWFsaXplZCB1c2luZyB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuKHNlcmlhbGl6ZTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2VuZGluZ1xuICpcbiAqIFdlIGNhbiBzZW5kIGEgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gdGhlIG5ldHdvcmsgYnkgc2VyaWFsaXppbmcgdGhlIHNpZ25lZCBlbnZlbG9wZSB3aXRoIGAuc2VyaWFsaXplYCwgYW5kIHRoZW4gYnJvYWRjYXN0aW5nIGl0IG92ZXIgSlNPTi1SUEMgd2l0aCBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmAuXG4gKlxuICogSW4gdGhpcyBleGFtcGxlLCB3ZSB3aWxsIHVzZSB7QGxpbmsgb3gjUnBjVHJhbnNwb3J0Lihmcm9tSHR0cDpmdW5jdGlvbil9IHRvIGJyb2FkY2FzdCBhIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYCByZXF1ZXN0IG92ZXIgSFRUUCBKU09OLVJQQy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjVHJhbnNwb3J0LCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIC8vIENvbnN0cnVjdCB0aGUgRW52ZWxvcGUuXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgbm9uY2U6IDY5bixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxLjUnKSxcbiAqIH0pXG4gKlxuICogLy8gU2lnbiBvdmVyIHRoZSBFbnZlbG9wZS5cbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiAvLyBTZXJpYWxpemUgdGhlIEVudmVsb3BlIHdpdGggdGhlIFNpZ25hdHVyZS4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSAgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEJyb2FkY2FzdCB0aGUgRW52ZWxvcGUgd2l0aCBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmAuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHRyYW5zcG9ydCA9IFJwY1RyYW5zcG9ydC5mcm9tSHR0cCgnaHR0cHM6Ly8xLnJwYy50aGlyZHdlYi5jb20nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgdHJhbnNwb3J0LnJlcXVlc3QoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1ldGhvZDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBhcmFtczogW3NlcmlhbGl6ZWRdLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBJZiB5b3UgYXJlIGludGVyZmFjaW5nIHdpdGggYW4gUlBDIHRoYXQgc3VwcG9ydHMgYGV0aF9zZW5kVHJhbnNhY3Rpb25gLCB5b3UgY2FuIGFsc28gdXNlXG4gKiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuKHRvUnBjOmZ1bmN0aW9uKX0gdG8gY29udmVydCBhbiBFbnZlbG9wZSB0byBhbiBSUEMtY29tcGF0aWJsZSBmb3JtYXQuXG4gKiBUaGlzIG1lYW5zIHlvdSBjYW4gc2tpcCB0aGUgY2VyZW1vbnkgb2YgbWFudWFsbHkgZmlsbGluZyAmIHNpZ25pbmcgdGhlIFRyYW5zYWN0aW9uLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IFByb3ZpZGVyLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEuNScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9ycGMgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS50b1JwYyhlbnZlbG9wZSlcbiAqXG4gKiBjb25zdCBwcm92aWRlciA9IFByb3ZpZGVyLmZyb20od2luZG93LmV0aGVyZXVtKVxuICogY29uc3QgaGFzaCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbXB1dGluZyBIYXNoZXNcbiAqXG4gKiBUcmFuc2FjdGlvbiBIYXNoZXMgY2FuIGJlIGNvbXB1dGVkIHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS4oaGFzaDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqICAgZGF0YTogJzB4JyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLidcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbShlbnZlbG9wZSwgeyBzaWduYXR1cmUgfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBUcmFuc2FjdGlvbiBFbnZlbG9wZXNcbiAqL1xuZXhwb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgZnJvbSAnLi9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBbRUlQLTI5MzAgVHlwZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGVzXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI5MzApXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBJbnN0YW50aWF0aW5nXG4gKlxuICogVHJhbnNhY3Rpb24gRW52ZWxvcGVzIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgYWNjZXNzTGlzdDogWy4uLl0sXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTaWduaW5nXG4gKlxuICogVHJhbnNhY3Rpb24gRW52ZWxvcGVzIGNhbiBiZSBzaWduZWQgdXNpbmcge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLihnZXRTaWduUGF5bG9hZDpmdW5jdGlvbil9IGFuZCBhIHNpZ25pbmcgZnVuY3Rpb24gc3VjaCBhcyB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0gb3Ige0BsaW5rIG94I1AyNTYuKHNpZ246ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTZXJpYWxpemluZ1xuICpcbiAqIFRyYW5zYWN0aW9uIEVudmVsb3BlcyBjYW4gYmUgc2VyaWFsaXplZCB1c2luZyB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuKHNlcmlhbGl6ZTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2VuZGluZ1xuICpcbiAqIFdlIGNhbiBzZW5kIGEgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gdGhlIG5ldHdvcmsgYnkgc2VyaWFsaXppbmcgdGhlIHNpZ25lZCBlbnZlbG9wZSB3aXRoIGAuc2VyaWFsaXplYCwgYW5kIHRoZW4gYnJvYWRjYXN0aW5nIGl0IG92ZXIgSlNPTi1SUEMgd2l0aCBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmAuXG4gKlxuICogSW4gdGhpcyBleGFtcGxlLCB3ZSB3aWxsIHVzZSB7QGxpbmsgb3gjUnBjVHJhbnNwb3J0Lihmcm9tSHR0cDpmdW5jdGlvbil9IHRvIGJyb2FkY2FzdCBhIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYCByZXF1ZXN0IG92ZXIgSFRUUCBKU09OLVJQQy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjVHJhbnNwb3J0LCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIC8vIENvbnN0cnVjdCB0aGUgRW52ZWxvcGUuXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBhY2Nlc3NMaXN0OiBbXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBub25jZTogNjluLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEuNScpLFxuICogfSlcbiAqXG4gKiAvLyBTaWduIG92ZXIgdGhlIEVudmVsb3BlLlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIC8vIFNlcmlhbGl6ZSB0aGUgRW52ZWxvcGUgd2l0aCB0aGUgU2lnbmF0dXJlLiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlICAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gQnJvYWRjYXN0IHRoZSBFbnZlbG9wZSB3aXRoIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3QgdHJhbnNwb3J0ID0gUnBjVHJhbnNwb3J0LmZyb21IdHRwKCdodHRwczovLzEucnBjLnRoaXJkd2ViLmNvbScpIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IGhhc2ggPSBhd2FpdCB0cmFuc3BvcnQucmVxdWVzdCh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGFyYW1zOiBbc2VyaWFsaXplZF0sIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIElmIHlvdSBhcmUgaW50ZXJmYWNpbmcgd2l0aCBhbiBSUEMgdGhhdCBzdXBwb3J0cyBgZXRoX3NlbmRUcmFuc2FjdGlvbmAsIHlvdSBjYW4gYWxzbyB1c2VcbiAqIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC4odG9ScGM6ZnVuY3Rpb24pfSB0byBjb252ZXJ0IGFuIEVudmVsb3BlIHRvIGFuIFJQQy1jb21wYXRpYmxlIGZvcm1hdC5cbiAqIFRoaXMgbWVhbnMgeW91IGNhbiBza2lwIHRoZSBjZXJlbW9ueSBvZiBtYW51YWxseSBmaWxsaW5nICYgc2lnbmluZyB0aGUgVHJhbnNhY3Rpb24uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCAnb3gvd2luZG93J1xuICogaW1wb3J0IHsgUHJvdmlkZXIsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGFjY2Vzc0xpc3Q6IFtdLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEuNScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9ycGMgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC50b1JwYyhlbnZlbG9wZSlcbiAqXG4gKiBjb25zdCBwcm92aWRlciA9IFByb3ZpZGVyLmZyb20od2luZG93LmV0aGVyZXVtKVxuICogY29uc3QgaGFzaCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbXB1dGluZyBIYXNoZXNcbiAqXG4gKiBUcmFuc2FjdGlvbiBIYXNoZXMgY2FuIGJlIGNvbXB1dGVkIHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC4oaGFzaDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXNQcmljZTogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqICAgZGF0YTogJzB4JyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLidcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbShlbnZlbG9wZSwgeyBzaWduYXR1cmUgfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBUcmFuc2FjdGlvbiBFbnZlbG9wZXNcbiAqL1xuZXhwb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgZnJvbSAnLi9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBbRUlQLTQ4NDQgVHlwZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGVzXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQ4NDQpXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBJbnN0YW50aWF0aW5nIEJsb2JzXG4gKlxuICogQmxvYnMgY2FuIGJlIGluc3RhbnRpYXRlZCB1c2luZyB7QGxpbmsgb3gjQmxvYnMuKGZyb206ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvYnMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbShIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJykpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEluc3RhbnRpYXRpbmdcbiAqXG4gKiBUcmFuc2FjdGlvbiBFbnZlbG9wZXMgY2FuIGJlIGluc3RhbnRpYXRlZCB1c2luZyB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuKGZyb206ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9icywgSGV4LCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NCwgVmFsdWUgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IGt6ZyB9IGZyb20gJy4va3pnJ1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbShIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJykpXG4gKiBjb25zdCBibG9iVmVyc2lvbmVkSGFzaGVzID0gQmxvYnMudG9WZXJzaW9uZWRIYXNoZXMoYmxvYnMsIHsga3pnIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAqICAgbWF4RmVlUGVyQmxvYkdhczogVmFsdWUuZnJvbUd3ZWkoJzMnKSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2lnbmluZ1xuICpcbiAqIFRyYW5zYWN0aW9uIEVudmVsb3BlcyBjYW4gYmUgc2lnbmVkIHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC4oZ2V0U2lnblBheWxvYWQ6ZnVuY3Rpb24pfSBhbmQgYSBzaWduaW5nIGZ1bmN0aW9uIHN1Y2ggYXMge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9IG9yIHtAbGluayBveCNQMjU2LihzaWduOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQmxvYnMsIFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IGt6ZyB9IGZyb20gJy4va3pnJ1xuICpcbiAqIGNvbnN0IGJsb2JzID0gQmxvYnMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiBjb25zdCBibG9iVmVyc2lvbmVkSGFzaGVzID0gQmxvYnMudG9WZXJzaW9uZWRIYXNoZXMoYmxvYnMsIHsga3pnIH0pXG4gKiBjb25zdCBzaWRlY2FycyA9IEJsb2JzLnRvU2lkZWNhcnMoYmxvYnMsIHsga3pnIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5mcm9tKHtcbiAqICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJCbG9iR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMycpLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuZnJvbShlbnZlbG9wZSwge1xuICogICBzaWRlY2FycyxcbiAqICAgc2lnbmF0dXJlXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTZXJpYWxpemluZ1xuICpcbiAqIFRyYW5zYWN0aW9uIEVudmVsb3BlcyBjYW4gYmUgc2VyaWFsaXplZCB1c2luZyB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuKHNlcmlhbGl6ZTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NCB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGJsb2JWZXJzaW9uZWRIYXNoZXMgPSBCbG9icy50b1ZlcnNpb25lZEhhc2hlcyhibG9icywgeyBremcgfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmZyb20oe1xuICogICBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJCbG9iR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMycpLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2VuZGluZ1xuICpcbiAqIFdlIGNhbiBzZW5kIGEgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gdGhlIG5ldHdvcmsgYnkgc2VyaWFsaXppbmcgdGhlIHNpZ25lZCBlbnZlbG9wZSB3aXRoIGAuc2VyaWFsaXplYCwgYW5kIHRoZW4gYnJvYWRjYXN0aW5nIGl0IG92ZXIgSlNPTi1SUEMgd2l0aCBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmAuXG4gKlxuICogSW4gdGhpcyBleGFtcGxlLCB3ZSB3aWxsIHVzZSB7QGxpbmsgb3gjUnBjVHJhbnNwb3J0Lihmcm9tSHR0cDpmdW5jdGlvbil9IHRvIGJyb2FkY2FzdCBhIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYCByZXF1ZXN0IG92ZXIgSFRUUCBKU09OLVJQQy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCbG9icywgUnBjVHJhbnNwb3J0LCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NCwgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogLy8gQ29tcHV0ZSB0aGUgQmxvYiBWZXJzaW9uZWQgSGFzaGVzLlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGJsb2JWZXJzaW9uZWRIYXNoZXMgPSBCbG9icy50b1ZlcnNpb25lZEhhc2hlcyhibG9icywgeyBremcgfSlcbiAqIGNvbnN0IHNpZGVjYXJzID0gQmxvYnMudG9TaWRlY2FycyhibG9icywgeyBremcgfSlcbiAqXG4gKiAvLyBDb25zdHJ1Y3QgdGhlIEVudmVsb3BlLlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAqICAgbWF4RmVlUGVyQmxvYkdhczogVmFsdWUuZnJvbUd3ZWkoJzMnKSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxLjUnKSxcbiAqIH0pXG4gKlxuICogLy8gU2lnbiBvdmVyIHRoZSBFbnZlbG9wZS5cbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiAvLyBTZXJpYWxpemUgdGhlIEVudmVsb3BlIHdpdGggdGhlIFNpZ25hdHVyZS4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZGVjYXJzLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSAgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEJyb2FkY2FzdCB0aGUgRW52ZWxvcGUgd2l0aCBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmAuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHRyYW5zcG9ydCA9IFJwY1RyYW5zcG9ydC5mcm9tSHR0cCgnaHR0cHM6Ly8xLnJwYy50aGlyZHdlYi5jb20nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgdHJhbnNwb3J0LnJlcXVlc3QoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1ldGhvZDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBhcmFtczogW3NlcmlhbGl6ZWRdLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbXB1dGluZyBIYXNoZXNcbiAqXG4gKiBUcmFuc2FjdGlvbiBIYXNoZXMgY2FuIGJlIGNvbXB1dGVkIHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC4oaGFzaDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJsb2JzLCBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsga3pnIH0gZnJvbSAnLi9remcnXG4gKlxuICogY29uc3QgYmxvYnMgPSBCbG9icy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIGNvbnN0IGJsb2JWZXJzaW9uZWRIYXNoZXMgPSBCbG9icy50b1ZlcnNpb25lZEhhc2hlcyhibG9icywgeyBremcgfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmZyb20oe1xuICogICBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNDg0NC5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLidcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuZnJvbShlbnZlbG9wZSwgeyBzaWduYXR1cmUgfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQuaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBUcmFuc2FjdGlvbiBFbnZlbG9wZXNcbiAqL1xuZXhwb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDQ4NDQgZnJvbSAnLi9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA0ODQ0LmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBbRUlQLTc3MDIgVHlwZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGVzXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBJbnN0YW50aWF0aW5nXG4gKlxuICogVHJhbnNhY3Rpb24gRW52ZWxvcGVzIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLihmcm9tOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBbQXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pXVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgYXV0aG9yaXphdGlvbkxpc3QsIC8vIFshY29kZSBmb2N1c11cbiAqICAgY2hhaW5JZDogMSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMScpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFNlZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbn0gZm9yIG1vcmUgZGV0YWlscyBvbiBpbnN0YW50aWF0aW5nIGFuZCBzaWduaW5nIEVJUC03NzAyIEF1dGhvcml6YXRpb25zLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2lnbmluZ1xuICpcbiAqIFRyYW5zYWN0aW9uIEVudmVsb3BlcyBjYW4gYmUgc2lnbmVkIHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi4oZ2V0U2lnblBheWxvYWQ6ZnVuY3Rpb24pfSBhbmQgYSBzaWduaW5nIGZ1bmN0aW9uIHN1Y2ggYXMge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9IG9yIHtAbGluayBveCNQMjU2LihzaWduOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZV9hdXRoID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IFtBdXRob3JpemF0aW9uLmZyb20oYXV0aG9yaXphdGlvbiwgeyBzaWduYXR1cmU6IHNpZ25hdHVyZV9hdXRoIH0pXVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0LFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKGVudmVsb3BlLCB7IHNpZ25hdHVyZSB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTZW5kaW5nXG4gKlxuICogV2UgY2FuIHNlbmQgYSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byB0aGUgbmV0d29yayBieSBzZXJpYWxpemluZyB0aGUgc2lnbmVkIGVudmVsb3BlIHdpdGggYC5zZXJpYWxpemVgLCBhbmQgdGhlbiBicm9hZGNhc3RpbmcgaXQgb3ZlciBKU09OLVJQQyB3aXRoIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYC5cbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUsIHdlIHdpbGwgdXNlIHtAbGluayBveCNScGNUcmFuc3BvcnQuKGZyb21IdHRwOmZ1bmN0aW9uKX0gdG8gYnJvYWRjYXN0IGEgYGV0aF9zZW5kUmF3VHJhbnNhY3Rpb25gIHJlcXVlc3Qgb3ZlciBIVFRQIEpTT04tUlBDLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBScGNUcmFuc3BvcnQsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLCBTZWNwMjU2azEsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZV9hdXRoID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IFtBdXRob3JpemF0aW9uLmZyb20oYXV0aG9yaXphdGlvbiwgeyBzaWduYXR1cmU6IHNpZ25hdHVyZV9hdXRoIH0pXVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0LFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgbm9uY2U6IDY5bixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxLjUnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIC8vIFNlcmlhbGl6ZSB0aGUgRW52ZWxvcGUgd2l0aCB0aGUgU2lnbmF0dXJlLiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlICAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gQnJvYWRjYXN0IHRoZSBFbnZlbG9wZSB3aXRoIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3QgdHJhbnNwb3J0ID0gUnBjVHJhbnNwb3J0LmZyb21IdHRwKCdodHRwczovLzEucnBjLnRoaXJkd2ViLmNvbScpIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IGhhc2ggPSBhd2FpdCB0cmFuc3BvcnQucmVxdWVzdCh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGFyYW1zOiBbc2VyaWFsaXplZF0sIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBUcmFuc2FjdGlvbiBFbnZlbG9wZXNcbiAqL1xuZXhwb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgZnJvbSAnLi9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCAqKlRyYW5zYWN0aW9uIFJlY2VpcHRzKiogYXMgZGVmaW5lZCBpbiB0aGUgW0V4ZWN1dGlvbiBBUEkgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2V4ZWN1dGlvbi1hcGlzL2Jsb2IvbWFpbi9zcmMvc2NoZW1hcy9yZWNlaXB0LnlhbWwpXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb252ZXJ0aW5nIGZyb20gUlBDIEZvcm1hdFxuICpcbiAqIFJlY2VpcHRzIGNhbiBiZSBjb252ZXJ0ZWQgZnJvbSBSUEMgZm9ybWF0IHVzaW5nIHtAbGluayBveCNUcmFuc2FjdGlvblJlY2VpcHQuKGZyb21ScGM6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvblJlY2VpcHQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2luZG93LmV0aGVyZXVtIVxuICogICAucmVxdWVzdCh7XG4gKiAgICAgbWV0aG9kOiAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG4gKiAgICAgcGFyYW1zOiBbXG4gKiAgICAgICAnMHgzNTNmZGZjMzhhMmYyNjExNWRhYWRlZTlmNWI4MzkyY2U2MmI4NGY0MTA5NTc5NjdlMmVkNTZiMzUzMzhjZGQwJyxcbiAqICAgICBdLFxuICogICB9KVxuICogICAudGhlbihUcmFuc2FjdGlvblJlY2VpcHQuZnJvbVJwYykgLy8gWyFjb2RlIGhsXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBibG9iR2FzUHJpY2U6IDI3MDQ0MW4sXG4gKiAvLyBAbG9nOiAgIGJsb2JHYXNVc2VkOiA0OTE5bixcbiAqIC8vIEBsb2c6ICAgYmxvY2tIYXNoOiBcIjB4YzM1MGQ4MDc1MDVmYjgzNTY1MGYwMDEzNjMyYzU1MTU1OTI5ODdiYTE2OWJiYzY2MjZkOWZjNTRkOTFmMGYwYlwiLFxuICogLy8gQGxvZzogICBibG9ja051bWJlcjogMTk4NjgwMTVuLFxuICogLy8gQGxvZzogICBjb250cmFjdEFkZHJlc3M6IG51bGwsXG4gKiAvLyBAbG9nOiAgIGN1bXVsYXRpdmVHYXNVc2VkOiA1MzM3ODFuLFxuICogLy8gQGxvZzogICBlZmZlY3RpdmVHYXNQcmljZTogOTA2MjgwNDQ4OW4sXG4gKiAvLyBAbG9nOiAgIGZyb206IFwiMHg4MTRlNWUwZTMxMDE2YjlhN2YxMzhjNzZiN2U3YjJiYjVjMWFiNmE2XCIsXG4gKiAvLyBAbG9nOiAgIGdhc1VzZWQ6IDE3NTAzNG4sXG4gKiAvLyBAbG9nOiAgIGxvZ3M6IFtdLFxuICogLy8gQGxvZzogICBsb2dzQmxvb206IFwiMHgwMDIwMDAwMDAwMDAwMDAwMDAwMDAwODA4MDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMjAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwODAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwODAyMDQwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMTAwMDAwMDA4MDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICogLy8gQGxvZzogICByb290OiB1bmRlZmluZWQsXG4gKiAvLyBAbG9nOiAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gKiAvLyBAbG9nOiAgIHRvOiBcIjB4M2ZjOTFhM2FmZDcwMzk1Y2Q0OTZjNjQ3ZDVhNmNjOWQ0YjJiN2ZhZFwiLFxuICogLy8gQGxvZzogICB0cmFuc2FjdGlvbkhhc2g6IFwiMHgzNTNmZGZjMzhhMmYyNjExNWRhYWRlZTlmNWI4MzkyY2U2MmI4NGY0MTA5NTc5NjdlMmVkNTZiMzUzMzhjZGQwXCIsXG4gKiAvLyBAbG9nOiAgIHRyYW5zYWN0aW9uSW5kZXg6IDIsXG4gKiAvLyBAbG9nOiAgIHR5cGU6IFwiZWlwMTU1OVwiLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEV4ZWN1dGlvbiBTcGVjXG4gKi9cbmV4cG9ydCAqIGFzIFRyYW5zYWN0aW9uUmVjZWlwdCBmcm9tICcuL2NvcmUvVHJhbnNhY3Rpb25SZWNlaXB0LmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCAqKlRyYW5zYWN0aW9uIFJlcXVlc3RzKiogYXMgZGVmaW5lZCBpbiB0aGUgW0V4ZWN1dGlvbiBBUEkgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2V4ZWN1dGlvbi1hcGlzL2Jsb2IvNGFjYTFkN2EzZTVhYWIyNGM4ZjY0MzcxMzEyODlhZDM4Njk0NGVhYS9zcmMvc2NoZW1hcy90cmFuc2FjdGlvbi55YW1sI0wzNTgtTDQyMylcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCAnb3gvd2luZG93J1xuICogaW1wb3J0IHsgUHJvdmlkZXIsIFRyYW5zYWN0aW9uUmVxdWVzdCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcm92aWRlciA9IFByb3ZpZGVyLmZyb20od2luZG93LmV0aGVyZXVtISlcbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gVHJhbnNhY3Rpb25SZXF1ZXN0LnRvUnBjKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsIC8vIFshY29kZSBmb2N1c11cbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMC4wMScpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgaGFzaCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbcmVxdWVzdF0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEV4ZWN1dGlvbiBTcGVjXG4gKi9cbmV4cG9ydCAqIGFzIFRyYW5zYWN0aW9uUmVxdWVzdCBmcm9tICcuL2NvcmUvVHJhbnNhY3Rpb25SZXF1ZXN0LmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBbRUlQLTcxMiBUeXBlZCBEYXRhXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMilcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEdldHRpbmcgU2lnbiBQYXlsb2Fkc1xuICpcbiAqIFR5cGVkIERhdGEgY2FuIGJlIGNvbnZlcnRlZCB0byBhIHNpZ24gcGF5bG9hZCB1c2luZyB7QGxpbmsgb3gjVHlwZWREYXRhLihnZXRTaWduUGF5bG9hZDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFR5cGVkRGF0YSwgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBUeXBlZERhdGEuZ2V0U2lnblBheWxvYWQoeyAvLyBbIWNvZGUgZm9jdXM6OTldXG4gKiAgIGRvbWFpbjoge1xuICogICAgIG5hbWU6ICdFdGhlciBNYWlsJyxcbiAqICAgICB2ZXJzaW9uOiAnMScsXG4gKiAgICAgY2hhaW5JZDogMSxcbiAqICAgICB2ZXJpZnlpbmdDb250cmFjdDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIH0sXG4gKiAgIHR5cGVzOiB7XG4gKiAgICAgUGVyc29uOiBbXG4gKiAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ3N0cmluZycgfSxcbiAqICAgICAgIHsgbmFtZTogJ3dhbGxldCcsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICogICAgIF0sXG4gKiAgICAgTWFpbDogW1xuICogICAgICAgeyBuYW1lOiAnZnJvbScsIHR5cGU6ICdQZXJzb24nIH0sXG4gKiAgICAgICB7IG5hbWU6ICd0bycsIHR5cGU6ICdQZXJzb24nIH0sXG4gKiAgICAgICB7IG5hbWU6ICdjb250ZW50cycsIHR5cGU6ICdzdHJpbmcnIH0sXG4gKiAgICAgXSxcbiAqICAgfSxcbiAqICAgcHJpbWFyeVR5cGU6ICdNYWlsJyxcbiAqICAgbWVzc2FnZToge1xuICogICAgIGZyb206IHtcbiAqICAgICAgIG5hbWU6ICdDb3cnLFxuICogICAgICAgd2FsbGV0OiAnMHhDRDJhM2Q5RjkzOEUxM0NEOTQ3RWMwNUFiQzdGRTczNERmOEREODI2JyxcbiAqICAgICB9LFxuICogICAgIHRvOiB7XG4gKiAgICAgICBuYW1lOiAnQm9iJyxcbiAqICAgICAgIHdhbGxldDogJzB4YkJiQkJCQmJiQkJCYmJiQmJiQmJiYmJCQmJCYmJiYkJiQmJiQkJiQicsXG4gKiAgICAgfSxcbiAqICAgICBjb250ZW50czogJ0hlbGxvLCBCb2IhJyxcbiAqICAgfSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgU2lnbmVkICYgVHlwZWQgRGF0YVxuICovXG5leHBvcnQgKiBhcyBUeXBlZERhdGEgZnJvbSAnLi9jb3JlL1R5cGVkRGF0YS5qcyc7XG4vKipcbiAqIFV0aWxpdGllcyAmIHR5cGVzIGZvciB3b3JraW5nIHdpdGggW0VJUC0xOTEgVmFsaWRhdG9yIERhdGFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTkxIzB4MDApXG4gKlxuICogQGNhdGVnb3J5IFNpZ25lZCAmIFR5cGVkIERhdGFcbiAqL1xuZXhwb3J0ICogYXMgVmFsaWRhdG9yRGF0YSBmcm9tICcuL2NvcmUvVmFsaWRhdG9yRGF0YS5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkaXNwbGF5aW5nIGFuZCBwYXJzaW5nIEV0aGVyZXVtIFZhbHVlcyBhcyBkZWZpbmVkIHVuZGVyICoqMi4xLiBWYWx1ZSoqIGluIHRoZSBbRXRoZXJldW0gWWVsbG93IFBhcGVyXShodHRwczovL2V0aGVyZXVtLmdpdGh1Yi5pby95ZWxsb3dwYXBlci9wYXBlci5wZGYpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBWYWx1ZS5mcm9tRXRoZXIoJzEnKVxuICogLy8gQGxvZzogMV8wMDBfMDAwXzAwMF8wMDBfMDAwXzAwMG5cbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IFZhbHVlLmZvcm1hdEV0aGVyKHZhbHVlKVxuICogLy8gQGxvZzogJzEnXG4gKlxuICogY29uc3QgdmFsdWUgPSBWYWx1ZS5mcm9tRXRoZXIoJzEnLCAnc3phYm8nKVxuICogLy8gQGxvZzogMV8wMDBfMDAwblxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IERhdGFcbiAqL1xuZXhwb3J0ICogYXMgVmFsdWUgZnJvbSAnLi9jb3JlL1ZhbHVlLmpzJztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIFtOSVNUIFAyNTZdKGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9jc3JjL21lZGlhL2V2ZW50cy93b3Jrc2hvcC1vbi1lbGxpcHRpYy1jdXJ2ZS1jcnlwdG9ncmFwaHktc3RhbmRhcmRzL2RvY3VtZW50cy9wYXBlcnMvc2Vzc2lvbjYtYWRhbGllci1tZWhtZXQucGRmKSBFQ0RTQSBjcnlwdG9ncmFwaHkgdXNpbmcgdGhlIFtXZWIgQXV0aGVudGljYXRpb24gQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0F1dGhlbnRpY2F0aW9uX0FQSSlcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENyZWF0aW5nIENyZWRlbnRpYWxzXG4gKlxuICogQ3JlZGVudGlhbHMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcge0BsaW5rIG94I1dlYkF1dGhuUDI1Ni4oY3JlYXRlQ3JlZGVudGlhbDpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJBdXRoblAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgV2ViQXV0aG5QMjU2LmNyZWF0ZUNyZWRlbnRpYWwoeyBuYW1lOiAnRXhhbXBsZScgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBpZDogJ29aNDguLi4nLFxuICogLy8gQGxvZzogICBwdWJsaWNLZXk6IHsgeDogNTE0MjEuLi41MTIzbiwgeTogMTIzNDUuLi42Nzg5biB9LFxuICogLy8gQGxvZzogICByYXc6IFB1YmxpY0tleUNyZWRlbnRpYWwge30sXG4gKiAvLyBAbG9nOiB9XG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7XG4gKiAgIGNyZWRlbnRpYWxJZDogY3JlZGVudGlhbC5pZCxcbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTaWduaW5nIFBheWxvYWRzXG4gKlxuICogUGF5bG9hZHMgY2FuIGJlIHNpZ25lZCB1c2luZyB7QGxpbmsgb3gjV2ViQXV0aG5QMjU2LihzaWduOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCBXZWJBdXRoblAyNTYuY3JlYXRlQ3JlZGVudGlhbCh7XG4gKiAgIG5hbWU6ICdFeGFtcGxlJyxcbiAqIH0pXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7IC8vIFshY29kZSBmb2N1c11cbiAqICAgY3JlZGVudGlhbElkOiBjcmVkZW50aWFsLmlkLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIG1ldGFkYXRhOiB7XG4gKiAvLyBAbG9nOiAgICAgYXV0aGVudGljYXRvckRhdGE6ICcweDQ5OTYwZGU1ODgwZThjNjg3NDM0MTcwZjY0NzY2MDViOGZlNGFlYjlhMjg2MzJjNzk5NWNmM2JhODMxZDk3NjMwNTAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgICBjbGllbnREYXRhSlNPTjogJ3tcInR5cGVcIjpcIndlYmF1dGhuLmdldFwiLFwiY2hhbGxlbmdlXCI6XCI5akVGaWp1aEVXck00U09XLXRDaEpiVUVIRVA0NFZjamNKLUJxbzFmVE04XCIsXCJvcmlnaW5cIjpcImh0dHA6Ly9sb2NhbGhvc3Q6NTE3M1wiLFwiY3Jvc3NPcmlnaW5cIjpmYWxzZX0nLFxuICogLy8gQGxvZzogICAgIGNoYWxsZW5nZUluZGV4OiAyMyxcbiAqIC8vIEBsb2c6ICAgICB0eXBlSW5kZXg6IDEsXG4gKiAvLyBAbG9nOiAgICAgdXNlclZlcmlmaWNhdGlvblJlcXVpcmVkOiB0cnVlLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogICBzaWduYXR1cmU6IHsgcjogNTEyMzEuLi40MjE1biwgczogMTIzNDUuLi42Nzg5biB9LFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJpZnlpbmcgU2lnbmF0dXJlc1xuICpcbiAqIFNpZ25hdHVyZXMgY2FuIGJlIHZlcmlmaWVkIHVzaW5nIHtAbGluayBveCNXZWJBdXRoblAyNTYuKHZlcmlmeTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJBdXRoblAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgV2ViQXV0aG5QMjU2LmNyZWF0ZUNyZWRlbnRpYWwoe1xuICogICBuYW1lOiAnRXhhbXBsZScsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHsgbWV0YWRhdGEsIHNpZ25hdHVyZSB9ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnNpZ24oe1xuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsXG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLFxuICogfSlcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBXZWJBdXRoblAyNTYudmVyaWZ5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBtZXRhZGF0YSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwdWJsaWNLZXk6IGNyZWRlbnRpYWwucHVibGljS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IENyeXB0b1xuICovXG5leHBvcnQgKiBhcyBXZWJBdXRoblAyNTYgZnJvbSAnLi9jb3JlL1dlYkF1dGhuUDI1Ni5qcyc7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBbTklTVCBQMjU2XShodHRwczovL2NzcmMubmlzdC5nb3YvY3NyYy9tZWRpYS9ldmVudHMvd29ya3Nob3Atb24tZWxsaXB0aWMtY3VydmUtY3J5cHRvZ3JhcGh5LXN0YW5kYXJkcy9kb2N1bWVudHMvcGFwZXJzL3Nlc3Npb242LWFkYWxpZXItbWVobWV0LnBkZikgRUNEU0EgY3J5cHRvZ3JhcGh5IHVzaW5nIHRoZSBbV2ViIENyeXB0byBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQ3J5cHRvX0FQSSlcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENyZWF0aW5nIEtleSBQYWlyc1xuICpcbiAqIEtleSBwYWlycyBjYW4gYmUgY3JlYXRlZCB1c2luZyB7QGxpbmsgb3gjV2ViQ3J5cHRvUDI1Ni4oY3JlYXRlS2V5UGFpcjpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwdWJsaWNLZXksIHByaXZhdGVLZXkgfSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByaXZhdGVLZXk6IENyeXB0b0tleSB7fSxcbiAqIC8vIEBsb2c6ICAgcHVibGljS2V5OiB7XG4gKiAvLyBAbG9nOiAgICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6ICAgICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNpZ25pbmcgUGF5bG9hZHNcbiAqXG4gKiBQYXlsb2FkcyBjYW4gYmUgc2lnbmVkIHVzaW5nIHtAbGluayBveCNXZWJDcnlwdG9QMjU2LihzaWduOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdlYkNyeXB0b1AyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXkgfSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5zaWduKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHJpdmF0ZUtleSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiAxNTEyMzEuLi40NDIzbixcbiAqIC8vIEBsb2c6ICAgczogNTE2MTIzLi4uNTUxMm4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFZlcmlmeWluZyBTaWduYXR1cmVzXG4gKlxuICogU2lnbmF0dXJlcyBjYW4gYmUgdmVyaWZpZWQgdXNpbmcge0BsaW5rIG94I1dlYkNyeXB0b1AyNTYuKHZlcmlmeTpmdW5jdGlvbil9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IFdlYkNyeXB0b1AyNTYudmVyaWZ5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHVibGljS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IENyeXB0b1xuICovXG5leHBvcnQgKiBhcyBXZWJDcnlwdG9QMjU2IGZyb20gJy4vY29yZS9XZWJDcnlwdG9QMjU2LmpzJztcbi8qKlxuICogVXRpbGl0aWVzICYgdHlwZXMgZm9yIHdvcmtpbmcgd2l0aCBXaXRoZHJhd2FscyBhcyBkZWZpbmVkIGluIHRoZSBbRXhlY3V0aW9uIEFQSSBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZXhlY3V0aW9uLWFwaXMvYmxvYi9tYWluL3NyYy9zY2hlbWFzL3dpdGhkcmF3YWwueWFtbClcbiAqXG4gKiBAY2F0ZWdvcnkgRXhlY3V0aW9uIFNwZWNcbiAqL1xuZXhwb3J0ICogYXMgV2l0aGRyYXdhbCBmcm9tICcuL2NvcmUvV2l0aGRyYXdhbC5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/_esm/index.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!**************************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"../node_modules/ox/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n/** connects noble-curves to noble-hashes */\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwQztBQUNxQjtBQUNQO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFJLFlBQVksZ0VBQVc7QUFDM0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixxRUFBVyxHQUFHLCtCQUErQjtBQUMxRSxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/NDYxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3Igc2hvcnQgd2VpZXJzdHJhc3MgY3VydmVzLCBjb21iaW5lZCB3aXRoIG5vYmxlLWhhc2hlcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSBcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIjtcbi8qKiBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gaG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiB3ZWllcnN0cmFzcyh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiB7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/abstract/bls.js":
/*!*************************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/abstract/bls.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls: () => (/* binding */ bls)\n/* harmony export */ });\n/* harmony import */ var _hash_to_curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hash-to-curve.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _weierstrass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./weierstrass.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y = x + 4.\n * - G2 is a subgroup of ((x, x+i), (y, y+i)) E(Fq) over y = x + 4(1 + i) where i is -1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two main ways to use it:\n * 1. Fp for short private keys, Fp for signatures\n * 2. Fp for short signatures, Fp for private keys\n * @module\n **/\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// TODO: import { AffinePoint } from './curve.ts';\n\n\n\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a) {\n    const res = [];\n    // a>1 because of marker bit\n    for (; a > _1n; a >>= _1n) {\n        if ((a & _1n) === _0n)\n            res.unshift(0);\n        else if ((a & _3n) === _3n) {\n            res.unshift(-1);\n            a += _1n;\n        }\n        else\n            res.unshift(1);\n    }\n    return res;\n}\nfunction bls(CURVE) {\n    // Fields are specific for curve, so for now we'll need to pass them with opts\n    const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n    const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;\n    const TWIST = CURVE.params.twistType;\n    // Point on G1 curve: (x, y)\n    const G1_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__.weierstrassPoints)({ n: Fr.ORDER, ...CURVE.G1 });\n    const G1 = Object.assign(G1_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G1.htfDefaults,\n    }));\n    // Point on G2 curve (complex numbers): (x, x+i), (y, y+i)\n    const G2_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__.weierstrassPoints)({ n: Fr.ORDER, ...CURVE.G2 });\n    const G2 = Object.assign(G2_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G2.htfDefaults,\n    }));\n    // Applies sparse multiplication as line function\n    let lineFunction;\n    if (TWIST === 'multiplicative') {\n        lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n    }\n    else if (TWIST === 'divisive') {\n        // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n        // precompute calculations.\n        lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n    }\n    else\n        throw new Error('bls: unknown twist type');\n    const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n    function pointDouble(ell, Rx, Ry, Rz) {\n        const t0 = Fp2.sqr(Ry); // Ry\n        const t1 = Fp2.sqr(Rz); // Rz\n        const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n        const t3 = Fp2.mul(t2, _3n); // 3 * T2\n        const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz) - T1 - T0\n        const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n        const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx\n        const c2 = Fp2.neg(t4); // -T4 (-h)\n        ell.push([c0, c1, c2]);\n        Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n        Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2) - 3 * T2\n        Rz = Fp2.mul(t0, t4); // T0 * T4\n        return { Rx, Ry, Rz };\n    }\n    function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {\n        // Addition\n        const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n        const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n        const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n        const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n        const c2 = t1; // == Rx - Qx * Rz\n        ell.push([c0, c1, c2]);\n        const t2 = Fp2.sqr(t1); // T1\n        const t3 = Fp2.mul(t2, t1); // T2 * T1\n        const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n        const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0 * Rz\n        Rx = Fp2.mul(t1, t5); // T1 * T5\n        Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n        Rz = Fp2.mul(Rz, t3); // Rz * T3\n        return { Rx, Ry, Rz };\n    }\n    // Pre-compute coefficients for sparse multiplication\n    // Point addition and point double calculations is reused for coefficients\n    // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n    // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n    const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);\n    const calcPairingPrecomputes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.memoized)((point) => {\n        const p = point;\n        const { x, y } = p.toAffine();\n        // prettier-ignore\n        const Qx = x, Qy = y, negQy = Fp2.neg(y);\n        // prettier-ignore\n        let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n        const ell = [];\n        for (const bit of ATE_NAF) {\n            const cur = [];\n            ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n            if (bit)\n                ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n            ell.push(cur);\n        }\n        if (CURVE.postPrecompute) {\n            const last = ell[ell.length - 1];\n            CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n        }\n        return ell;\n    });\n    function millerLoopBatch(pairs, withFinalExponent = false) {\n        let f12 = Fp12.ONE;\n        if (pairs.length) {\n            const ellLen = pairs[0][0].length;\n            for (let i = 0; i < ellLen; i++) {\n                f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n                // NOTE: we apply multiple pairings in parallel here\n                for (const [ell, Px, Py] of pairs) {\n                    for (const [c0, c1, c2] of ell[i])\n                        f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n                }\n            }\n        }\n        if (BLS_X_IS_NEGATIVE)\n            f12 = Fp12.conjugate(f12);\n        return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n    }\n    // Calculates product of multiple pairings\n    // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n    function pairingBatch(pairs, withFinalExponent = true) {\n        const res = [];\n        // Cache precomputed toAffine for all points\n        G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));\n        G2.ProjectivePoint.normalizeZ(pairs.map(({ g2 }) => g2));\n        for (const { g1, g2 } of pairs) {\n            if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO))\n                throw new Error('pairing is not available for ZERO point');\n            // This uses toAffine inside\n            g1.assertValidity();\n            g2.assertValidity();\n            const Qa = g1.toAffine();\n            res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n        }\n        return millerLoopBatch(res, withFinalExponent);\n    }\n    // Calculates bilinear pairing\n    function pairing(Q, P, withFinalExponent = true) {\n        return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n    }\n    const utils = {\n        randomPrivateKey: () => {\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.getMinHashLength)(Fr.ORDER);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.mapHashToField)(CURVE.randomBytes(length), Fr.ORDER);\n        },\n        calcPairingPrecomputes,\n    };\n    const { ShortSignature } = CURVE.G1;\n    const { Signature } = CURVE.G2;\n    function normP1(point) {\n        return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);\n    }\n    function normP1Hash(point, htfOpts) {\n        return point instanceof G1.ProjectivePoint\n            ? point\n            : G1.hashToCurve((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.ensureBytes)('point', point), htfOpts);\n    }\n    function normP2(point) {\n        return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n    }\n    function normP2Hash(point, htfOpts) {\n        return point instanceof G2.ProjectivePoint\n            ? point\n            : G2.hashToCurve((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.ensureBytes)('point', point), htfOpts);\n    }\n    // Multiplies generator (G1) by private key.\n    // P = pk x G\n    function getPublicKey(privateKey) {\n        return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    // Multiplies generator (G2) by private key.\n    // P = pk x G\n    function getPublicKeyForShortSignatures(privateKey) {\n        return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    function sign(message, privateKey, htfOpts) {\n        const msgPoint = normP2Hash(message, htfOpts);\n        msgPoint.assertValidity();\n        const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n        if (message instanceof G2.ProjectivePoint)\n            return sigPoint;\n        return Signature.toRawBytes(sigPoint);\n    }\n    function signShortSignature(message, privateKey, htfOpts) {\n        const msgPoint = normP1Hash(message, htfOpts);\n        msgPoint.assertValidity();\n        const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n        if (message instanceof G1.ProjectivePoint)\n            return sigPoint;\n        return ShortSignature.toRawBytes(sigPoint);\n    }\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    function verify(signature, message, publicKey, htfOpts) {\n        const P = normP1(publicKey);\n        const Hm = normP2Hash(message, htfOpts);\n        const G = G1.ProjectivePoint.BASE;\n        const S = normP2(signature);\n        const exp = pairingBatch([\n            { g1: P.negate(), g2: Hm }, // ePHM = pairing(P.negate(), Hm, false);\n            { g1: G, g2: S }, // eGS = pairing(G, S, false);\n        ]);\n        return Fp12.eql(exp, Fp12.ONE);\n    }\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(S, G) == e(H(m), P)\n    function verifyShortSignature(signature, message, publicKey, htfOpts) {\n        const P = normP2(publicKey);\n        const Hm = normP1Hash(message, htfOpts);\n        const G = G2.ProjectivePoint.BASE;\n        const S = normP1(signature);\n        const exp = pairingBatch([\n            { g1: Hm, g2: P }, // eHmP = pairing(Hm, P, false);\n            { g1: S, g2: G.negate() }, // eSG = pairing(S, G.negate(), false);\n        ]);\n        return Fp12.eql(exp, Fp12.ONE);\n    }\n    function aNonEmpty(arr) {\n        if (!Array.isArray(arr) || arr.length === 0)\n            throw new Error('expected non-empty array');\n    }\n    function aggregatePublicKeys(publicKeys) {\n        aNonEmpty(publicKeys);\n        const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (publicKeys[0] instanceof G1.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        // toRawBytes ensures point validity\n        return aggAffine.toRawBytes(true);\n    }\n    function aggregateSignatures(signatures) {\n        aNonEmpty(signatures);\n        const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (signatures[0] instanceof G2.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        return Signature.toRawBytes(aggAffine);\n    }\n    function aggregateShortSignatures(signatures) {\n        aNonEmpty(signatures);\n        const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (signatures[0] instanceof G1.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        return ShortSignature.toRawBytes(aggAffine);\n    }\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    function verifyBatch(signature, \n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    messages, publicKeys, htfOpts) {\n        aNonEmpty(messages);\n        if (publicKeys.length !== messages.length)\n            throw new Error('amount of public keys and messages should be equal');\n        const sig = normP2(signature);\n        const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\n        const nPublicKeys = publicKeys.map(normP1);\n        // NOTE: this works only for exact same object\n        const messagePubKeyMap = new Map();\n        for (let i = 0; i < nPublicKeys.length; i++) {\n            const pub = nPublicKeys[i];\n            const msg = nMessages[i];\n            let keys = messagePubKeyMap.get(msg);\n            if (keys === undefined) {\n                keys = [];\n                messagePubKeyMap.set(msg, keys);\n            }\n            keys.push(pub);\n        }\n        const paired = [];\n        try {\n            for (const [msg, keys] of messagePubKeyMap) {\n                const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n                paired.push({ g1: groupPublicKey, g2: msg });\n            }\n            paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });\n            return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n        }\n        catch {\n            return false;\n        }\n    }\n    G1.ProjectivePoint.BASE._setWindowSize(4);\n    return {\n        getPublicKey,\n        getPublicKeyForShortSignatures,\n        sign,\n        signShortSignature,\n        verify,\n        verifyBatch,\n        verifyShortSignature,\n        aggregatePublicKeys,\n        aggregateSignatures,\n        aggregateShortSignatures,\n        millerLoopBatch,\n        pairing,\n        pairingBatch,\n        G1,\n        G2,\n        Signature,\n        ShortSignature,\n        fields: {\n            Fr,\n            Fp,\n            Fp2,\n            Fp6,\n            Fp12,\n        },\n        params: {\n            ateLoopSize: CURVE.params.ateLoopSize,\n            r: CURVE.params.r,\n            G1b: CURVE.G1.b,\n            G2b: CURVE.G2.b,\n        },\n        utils,\n    };\n}\n//# sourceMappingURL=bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9ibHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNtQjtBQUNhO0FBQ2I7QUFDRztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWlCLEdBQUcsMEJBQTBCO0FBQzlELGtDQUFrQywrREFBWTtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGtFQUFpQixHQUFHLDBCQUEwQjtBQUM5RCxrQ0FBa0MsK0RBQVk7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxpREFBaUQ7QUFDakQscUNBQXFDO0FBQ3JDLHVFQUF1RTtBQUN2RSxvQ0FBb0M7QUFDcEMsOENBQThDO0FBQzlDLGdDQUFnQztBQUNoQztBQUNBLDBFQUEwRTtBQUMxRSw2RkFBNkY7QUFDN0YsOEJBQThCO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELDhEQUE4RDtBQUM5RCxnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCO0FBQ0EsZ0NBQWdDO0FBQ2hDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMscUZBQXFGO0FBQ3JGLDhCQUE4QjtBQUM5QixxRUFBcUU7QUFDckUsOEJBQThCO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbURBQVE7QUFDM0M7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLFlBQVksTUFBTTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RCxtREFBbUQsSUFBSTtBQUN2RCxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQWdCO0FBQzNDLG1CQUFtQiwyREFBYztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0EsMEJBQTBCLCtDQUErQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvYmxzLmpzP2ZjZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCTFMgKEJhcnJldG8tTHlubi1TY290dCkgZmFtaWx5IG9mIHBhaXJpbmctZnJpZW5kbHkgY3VydmVzLlxuICogQkxTICE9IEJMUy5cbiAqIFRoZSBmaWxlIGltcGxlbWVudHMgQkxTIChCb25laC1MeW5uLVNoYWNoYW0pIHNpZ25hdHVyZXMuXG4gKiBVc2VkIGluIGJvdGggQkxTIChCYXJyZXRvLUx5bm4tU2NvdHQpIGFuZCBCTiAoQmFycmV0by1OYWVocmlnKVxuICogZmFtaWxpZXMgb2YgcGFpcmluZy1mcmllbmRseSBjdXJ2ZXMuXG4gKiBDb25zaXN0cyBvZiB0d28gY3VydmVzOiBHMSBhbmQgRzI6XG4gKiAtIEcxIGlzIGEgc3ViZ3JvdXAgb2YgKHgsIHkpIEUoRnEpIG92ZXIgecKyID0geMKzICsgNC5cbiAqIC0gRzIgaXMgYSBzdWJncm91cCBvZiAoKHjigoEsIHjigoIraSksICh54oKBLCB54oKCK2kpKSBFKEZxwrIpIG92ZXIgecKyID0geMKzICsgNCgxICsgaSkgd2hlcmUgaSBpcyDiiJotMVxuICogLSBHdCwgY3JlYXRlZCBieSBiaWxpbmVhciAoYXRlKSBwYWlyaW5nIGUoRzEsIEcyKSwgY29uc2lzdHMgb2YgcC10aCByb290cyBvZiB1bml0eSBpblxuICogICBGcV5rIHdoZXJlIGsgaXMgZW1iZWRkaW5nIGRlZ3JlZS4gT25seSBkZWdyZWUgMTIgaXMgY3VycmVudGx5IHN1cHBvcnRlZCwgMjQgaXMgbm90LlxuICogUGFpcmluZyBpcyB1c2VkIHRvIGFnZ3JlZ2F0ZSBhbmQgdmVyaWZ5IHNpZ25hdHVyZXMuXG4gKiBUaGVyZSBhcmUgdHdvIG1haW4gd2F5cyB0byB1c2UgaXQ6XG4gKiAxLiBGcCBmb3Igc2hvcnQgcHJpdmF0ZSBrZXlzLCBGcOKCgiBmb3Igc2lnbmF0dXJlc1xuICogMi4gRnAgZm9yIHNob3J0IHNpZ25hdHVyZXMsIEZw4oKCIGZvciBwcml2YXRlIGtleXNcbiAqIEBtb2R1bGVcbiAqKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFRPRE86IGltcG9ydCB7IEFmZmluZVBvaW50IH0gZnJvbSAnLi9jdXJ2ZS50cyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIH0gZnJvbSBcIi4vaGFzaC10by1jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgZ2V0TWluSGFzaExlbmd0aCwgbWFwSGFzaFRvRmllbGQgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcywgbWVtb2l6ZWQgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3NQb2ludHMsIH0gZnJvbSBcIi4vd2VpZXJzdHJhc3MuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gTm90IHVzZWQgd2l0aCBCTFMxMi0zODEgKG5vIHNlcXVlbnRpYWwgYDExYCBpbiBYKS4gVXNlZnVsIGZvciBvdGhlciBjdXJ2ZXMuXG5mdW5jdGlvbiBOQWZEZWNvbXBvc2l0aW9uKGEpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICAvLyBhPjEgYmVjYXVzZSBvZiBtYXJrZXIgYml0XG4gICAgZm9yICg7IGEgPiBfMW47IGEgPj49IF8xbikge1xuICAgICAgICBpZiAoKGEgJiBfMW4pID09PSBfMG4pXG4gICAgICAgICAgICByZXMudW5zaGlmdCgwKTtcbiAgICAgICAgZWxzZSBpZiAoKGEgJiBfM24pID09PSBfM24pIHtcbiAgICAgICAgICAgIHJlcy51bnNoaWZ0KC0xKTtcbiAgICAgICAgICAgIGEgKz0gXzFuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlcy51bnNoaWZ0KDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJscyhDVVJWRSkge1xuICAgIC8vIEZpZWxkcyBhcmUgc3BlY2lmaWMgZm9yIGN1cnZlLCBzbyBmb3Igbm93IHdlJ2xsIG5lZWQgdG8gcGFzcyB0aGVtIHdpdGggb3B0c1xuICAgIGNvbnN0IHsgRnAsIEZyLCBGcDIsIEZwNiwgRnAxMiB9ID0gQ1VSVkUuZmllbGRzO1xuICAgIGNvbnN0IEJMU19YX0lTX05FR0FUSVZFID0gQ1VSVkUucGFyYW1zLnhOZWdhdGl2ZTtcbiAgICBjb25zdCBUV0lTVCA9IENVUlZFLnBhcmFtcy50d2lzdFR5cGU7XG4gICAgLy8gUG9pbnQgb24gRzEgY3VydmU6ICh4LCB5KVxuICAgIGNvbnN0IEcxXyA9IHdlaWVyc3RyYXNzUG9pbnRzKHsgbjogRnIuT1JERVIsIC4uLkNVUlZFLkcxIH0pO1xuICAgIGNvbnN0IEcxID0gT2JqZWN0LmFzc2lnbihHMV8sIGNyZWF0ZUhhc2hlcihHMV8uUHJvamVjdGl2ZVBvaW50LCBDVVJWRS5HMS5tYXBUb0N1cnZlLCB7XG4gICAgICAgIC4uLkNVUlZFLmh0ZkRlZmF1bHRzLFxuICAgICAgICAuLi5DVVJWRS5HMS5odGZEZWZhdWx0cyxcbiAgICB9KSk7XG4gICAgLy8gUG9pbnQgb24gRzIgY3VydmUgKGNvbXBsZXggbnVtYmVycyk6ICh44oKBLCB44oKCK2kpLCAoeeKCgSwgeeKCgitpKVxuICAgIGNvbnN0IEcyXyA9IHdlaWVyc3RyYXNzUG9pbnRzKHsgbjogRnIuT1JERVIsIC4uLkNVUlZFLkcyIH0pO1xuICAgIGNvbnN0IEcyID0gT2JqZWN0LmFzc2lnbihHMl8sIGNyZWF0ZUhhc2hlcihHMl8uUHJvamVjdGl2ZVBvaW50LCBDVVJWRS5HMi5tYXBUb0N1cnZlLCB7XG4gICAgICAgIC4uLkNVUlZFLmh0ZkRlZmF1bHRzLFxuICAgICAgICAuLi5DVVJWRS5HMi5odGZEZWZhdWx0cyxcbiAgICB9KSk7XG4gICAgLy8gQXBwbGllcyBzcGFyc2UgbXVsdGlwbGljYXRpb24gYXMgbGluZSBmdW5jdGlvblxuICAgIGxldCBsaW5lRnVuY3Rpb247XG4gICAgaWYgKFRXSVNUID09PSAnbXVsdGlwbGljYXRpdmUnKSB7XG4gICAgICAgIGxpbmVGdW5jdGlvbiA9IChjMCwgYzEsIGMyLCBmLCBQeCwgUHkpID0+IEZwMTIubXVsMDE0KGYsIGMwLCBGcDIubXVsKGMxLCBQeCksIEZwMi5tdWwoYzIsIFB5KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFRXSVNUID09PSAnZGl2aXNpdmUnKSB7XG4gICAgICAgIC8vIE5PVEU6IGl0IHNob3VsZCBiZSBbYzAsIGMxLCBjMl0sIGJ1dCB3ZSB1c2UgZGlmZmVyZW50IG9yZGVyIGhlcmUgdG8gcmVkdWNlIGNvbXBsZXhpdHkgb2ZcbiAgICAgICAgLy8gcHJlY29tcHV0ZSBjYWxjdWxhdGlvbnMuXG4gICAgICAgIGxpbmVGdW5jdGlvbiA9IChjMCwgYzEsIGMyLCBmLCBQeCwgUHkpID0+IEZwMTIubXVsMDM0KGYsIEZwMi5tdWwoYzIsIFB5KSwgRnAyLm11bChjMSwgUHgpLCBjMCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibHM6IHVua25vd24gdHdpc3QgdHlwZScpO1xuICAgIGNvbnN0IEZwMmRpdjIgPSBGcDIuZGl2KEZwMi5PTkUsIEZwMi5tdWwoRnAyLk9ORSwgXzJuKSk7XG4gICAgZnVuY3Rpb24gcG9pbnREb3VibGUoZWxsLCBSeCwgUnksIFJ6KSB7XG4gICAgICAgIGNvbnN0IHQwID0gRnAyLnNxcihSeSk7IC8vIFJ5wrJcbiAgICAgICAgY29uc3QgdDEgPSBGcDIuc3FyKFJ6KTsgLy8gUnrCslxuICAgICAgICBjb25zdCB0MiA9IEZwMi5tdWxCeUIoRnAyLm11bCh0MSwgXzNuKSk7IC8vIDMgKiBUMSAqIEJcbiAgICAgICAgY29uc3QgdDMgPSBGcDIubXVsKHQyLCBfM24pOyAvLyAzICogVDJcbiAgICAgICAgY29uc3QgdDQgPSBGcDIuc3ViKEZwMi5zdWIoRnAyLnNxcihGcDIuYWRkKFJ5LCBSeikpLCB0MSksIHQwKTsgLy8gKFJ5ICsgUnopwrIgLSBUMSAtIFQwXG4gICAgICAgIGNvbnN0IGMwID0gRnAyLnN1Yih0MiwgdDApOyAvLyBUMiAtIFQwIChpKVxuICAgICAgICBjb25zdCBjMSA9IEZwMi5tdWwoRnAyLnNxcihSeCksIF8zbik7IC8vIDMgKiBSeMKyXG4gICAgICAgIGNvbnN0IGMyID0gRnAyLm5lZyh0NCk7IC8vIC1UNCAoLWgpXG4gICAgICAgIGVsbC5wdXNoKFtjMCwgYzEsIGMyXSk7XG4gICAgICAgIFJ4ID0gRnAyLm11bChGcDIubXVsKEZwMi5tdWwoRnAyLnN1Yih0MCwgdDMpLCBSeCksIFJ5KSwgRnAyZGl2Mik7IC8vICgoVDAgLSBUMykgKiBSeCAqIFJ5KSAvIDJcbiAgICAgICAgUnkgPSBGcDIuc3ViKEZwMi5zcXIoRnAyLm11bChGcDIuYWRkKHQwLCB0MyksIEZwMmRpdjIpKSwgRnAyLm11bChGcDIuc3FyKHQyKSwgXzNuKSk7IC8vICgoVDAgKyBUMykgLyAyKcKyIC0gMyAqIFQywrJcbiAgICAgICAgUnogPSBGcDIubXVsKHQwLCB0NCk7IC8vIFQwICogVDRcbiAgICAgICAgcmV0dXJuIHsgUngsIFJ5LCBSeiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludEFkZChlbGwsIFJ4LCBSeSwgUnosIFF4LCBReSkge1xuICAgICAgICAvLyBBZGRpdGlvblxuICAgICAgICBjb25zdCB0MCA9IEZwMi5zdWIoUnksIEZwMi5tdWwoUXksIFJ6KSk7IC8vIFJ5IC0gUXkgKiBSelxuICAgICAgICBjb25zdCB0MSA9IEZwMi5zdWIoUngsIEZwMi5tdWwoUXgsIFJ6KSk7IC8vIFJ4IC0gUXggKiBSelxuICAgICAgICBjb25zdCBjMCA9IEZwMi5zdWIoRnAyLm11bCh0MCwgUXgpLCBGcDIubXVsKHQxLCBReSkpOyAvLyBUMCAqIFF4IC0gVDEgKiBReSA9PSBSeSAqIFF4ICAtIFJ4ICogUXlcbiAgICAgICAgY29uc3QgYzEgPSBGcDIubmVnKHQwKTsgLy8gLVQwID09IFF5ICogUnogLSBSeVxuICAgICAgICBjb25zdCBjMiA9IHQxOyAvLyA9PSBSeCAtIFF4ICogUnpcbiAgICAgICAgZWxsLnB1c2goW2MwLCBjMSwgYzJdKTtcbiAgICAgICAgY29uc3QgdDIgPSBGcDIuc3FyKHQxKTsgLy8gVDHCslxuICAgICAgICBjb25zdCB0MyA9IEZwMi5tdWwodDIsIHQxKTsgLy8gVDIgKiBUMVxuICAgICAgICBjb25zdCB0NCA9IEZwMi5tdWwodDIsIFJ4KTsgLy8gVDIgKiBSeFxuICAgICAgICBjb25zdCB0NSA9IEZwMi5hZGQoRnAyLnN1Yih0MywgRnAyLm11bCh0NCwgXzJuKSksIEZwMi5tdWwoRnAyLnNxcih0MCksIFJ6KSk7IC8vIFQzIC0gMiAqIFQ0ICsgVDDCsiAqIFJ6XG4gICAgICAgIFJ4ID0gRnAyLm11bCh0MSwgdDUpOyAvLyBUMSAqIFQ1XG4gICAgICAgIFJ5ID0gRnAyLnN1YihGcDIubXVsKEZwMi5zdWIodDQsIHQ1KSwgdDApLCBGcDIubXVsKHQzLCBSeSkpOyAvLyAoVDQgLSBUNSkgKiBUMCAtIFQzICogUnlcbiAgICAgICAgUnogPSBGcDIubXVsKFJ6LCB0Myk7IC8vIFJ6ICogVDNcbiAgICAgICAgcmV0dXJuIHsgUngsIFJ5LCBSeiB9O1xuICAgIH1cbiAgICAvLyBQcmUtY29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIHNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgIC8vIFBvaW50IGFkZGl0aW9uIGFuZCBwb2ludCBkb3VibGUgY2FsY3VsYXRpb25zIGlzIHJldXNlZCBmb3IgY29lZmZpY2llbnRzXG4gICAgLy8gcG9pbnRBZGQgaGFwcGVucyBvbmx5IGlmIGJpdCBzZXQsIHNvIHdOQUYgaXMgcmVhc29uYWJsZS4gVW5mb3J0dW5hdGVseSB3ZSBjYW5ub3QgY29tYmluZVxuICAgIC8vIGFkZCArIGRvdWJsZSBpbiB3aW5kb3dlZCBwcmVjb21wdXRlcyBoZXJlLCBvdGhlcndpc2UgaXQgd291bGQgYmUgc2luZ2xlIG9wIChzaW5jZSBYIGlzIHN0YXRpYylcbiAgICBjb25zdCBBVEVfTkFGID0gTkFmRGVjb21wb3NpdGlvbihDVVJWRS5wYXJhbXMuYXRlTG9vcFNpemUpO1xuICAgIGNvbnN0IGNhbGNQYWlyaW5nUHJlY29tcHV0ZXMgPSBtZW1vaXplZCgocG9pbnQpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IHBvaW50O1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IFF4ID0geCwgUXkgPSB5LCBuZWdReSA9IEZwMi5uZWcoeSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgUnggPSBReCwgUnkgPSBReSwgUnogPSBGcDIuT05FO1xuICAgICAgICBjb25zdCBlbGwgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBiaXQgb2YgQVRFX05BRikge1xuICAgICAgICAgICAgY29uc3QgY3VyID0gW107XG4gICAgICAgICAgICAoeyBSeCwgUnksIFJ6IH0gPSBwb2ludERvdWJsZShjdXIsIFJ4LCBSeSwgUnopKTtcbiAgICAgICAgICAgIGlmIChiaXQpXG4gICAgICAgICAgICAgICAgKHsgUngsIFJ5LCBSeiB9ID0gcG9pbnRBZGQoY3VyLCBSeCwgUnksIFJ6LCBReCwgYml0ID09PSAtMSA/IG5lZ1F5IDogUXkpKTtcbiAgICAgICAgICAgIGVsbC5wdXNoKGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENVUlZFLnBvc3RQcmVjb21wdXRlKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gZWxsW2VsbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIENVUlZFLnBvc3RQcmVjb21wdXRlKFJ4LCBSeSwgUnosIFF4LCBReSwgcG9pbnRBZGQuYmluZChudWxsLCBsYXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsbDtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtaWxsZXJMb29wQmF0Y2gocGFpcnMsIHdpdGhGaW5hbEV4cG9uZW50ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGYxMiA9IEZwMTIuT05FO1xuICAgICAgICBpZiAocGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlbGxMZW4gPSBwYWlyc1swXVswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZjEyID0gRnAxMi5zcXIoZjEyKTsgLy8gVGhpcyBhbGxvd3MgdXMgdG8gZG8gc3FyIG9ubHkgb25lIHRpbWUgZm9yIGFsbCBwYWlyaW5nc1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIGFwcGx5IG11bHRpcGxlIHBhaXJpbmdzIGluIHBhcmFsbGVsIGhlcmVcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbGwsIFB4LCBQeV0gb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbYzAsIGMxLCBjMl0gb2YgZWxsW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgZjEyID0gbGluZUZ1bmN0aW9uKGMwLCBjMSwgYzIsIGYxMiwgUHgsIFB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJMU19YX0lTX05FR0FUSVZFKVxuICAgICAgICAgICAgZjEyID0gRnAxMi5jb25qdWdhdGUoZjEyKTtcbiAgICAgICAgcmV0dXJuIHdpdGhGaW5hbEV4cG9uZW50ID8gRnAxMi5maW5hbEV4cG9uZW50aWF0ZShmMTIpIDogZjEyO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGVzIHByb2R1Y3Qgb2YgbXVsdGlwbGUgcGFpcmluZ3NcbiAgICAvLyBUaGlzIHVwIHRvIHgyIGZhc3RlciB0aGFuIGp1c3QgYG1hcCgoe2cxLCBnMn0pPT5wYWlyaW5nKHtnMSxnMn0pKWBcbiAgICBmdW5jdGlvbiBwYWlyaW5nQmF0Y2gocGFpcnMsIHdpdGhGaW5hbEV4cG9uZW50ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgLy8gQ2FjaGUgcHJlY29tcHV0ZWQgdG9BZmZpbmUgZm9yIGFsbCBwb2ludHNcbiAgICAgICAgRzEuUHJvamVjdGl2ZVBvaW50Lm5vcm1hbGl6ZVoocGFpcnMubWFwKCh7IGcxIH0pID0+IGcxKSk7XG4gICAgICAgIEcyLlByb2plY3RpdmVQb2ludC5ub3JtYWxpemVaKHBhaXJzLm1hcCgoeyBnMiB9KSA9PiBnMikpO1xuICAgICAgICBmb3IgKGNvbnN0IHsgZzEsIGcyIH0gb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGlmIChnMS5lcXVhbHMoRzEuUHJvamVjdGl2ZVBvaW50LlpFUk8pIHx8IGcyLmVxdWFscyhHMi5Qcm9qZWN0aXZlUG9pbnQuWkVSTykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWlyaW5nIGlzIG5vdCBhdmFpbGFibGUgZm9yIFpFUk8gcG9pbnQnKTtcbiAgICAgICAgICAgIC8vIFRoaXMgdXNlcyB0b0FmZmluZSBpbnNpZGVcbiAgICAgICAgICAgIGcxLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICBnMi5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgY29uc3QgUWEgPSBnMS50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmVzLnB1c2goW2NhbGNQYWlyaW5nUHJlY29tcHV0ZXMoZzIpLCBRYS54LCBRYS55XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbGxlckxvb3BCYXRjaChyZXMsIHdpdGhGaW5hbEV4cG9uZW50KTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlcyBiaWxpbmVhciBwYWlyaW5nXG4gICAgZnVuY3Rpb24gcGFpcmluZyhRLCBQLCB3aXRoRmluYWxFeHBvbmVudCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJpbmdCYXRjaChbeyBnMTogUSwgZzI6IFAgfV0sIHdpdGhGaW5hbEV4cG9uZW50KTtcbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE1pbkhhc2hMZW5ndGgoRnIuT1JERVIpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIEZyLk9SREVSKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY1BhaXJpbmdQcmVjb21wdXRlcyxcbiAgICB9O1xuICAgIGNvbnN0IHsgU2hvcnRTaWduYXR1cmUgfSA9IENVUlZFLkcxO1xuICAgIGNvbnN0IHsgU2lnbmF0dXJlIH0gPSBDVVJWRS5HMjtcbiAgICBmdW5jdGlvbiBub3JtUDEocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50IGluc3RhbmNlb2YgRzEuUHJvamVjdGl2ZVBvaW50ID8gcG9pbnQgOiBHMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChwb2ludCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1QMUhhc2gocG9pbnQsIGh0Zk9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50IGluc3RhbmNlb2YgRzEuUHJvamVjdGl2ZVBvaW50XG4gICAgICAgICAgICA/IHBvaW50XG4gICAgICAgICAgICA6IEcxLmhhc2hUb0N1cnZlKGVuc3VyZUJ5dGVzKCdwb2ludCcsIHBvaW50KSwgaHRmT3B0cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1QMihwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQgaW5zdGFuY2VvZiBHMi5Qcm9qZWN0aXZlUG9pbnQgPyBwb2ludCA6IFNpZ25hdHVyZS5mcm9tSGV4KHBvaW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybVAySGFzaChwb2ludCwgaHRmT3B0cykge1xuICAgICAgICByZXR1cm4gcG9pbnQgaW5zdGFuY2VvZiBHMi5Qcm9qZWN0aXZlUG9pbnRcbiAgICAgICAgICAgID8gcG9pbnRcbiAgICAgICAgICAgIDogRzIuaGFzaFRvQ3VydmUoZW5zdXJlQnl0ZXMoJ3BvaW50JywgcG9pbnQpLCBodGZPcHRzKTtcbiAgICB9XG4gICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgKEcxKSBieSBwcml2YXRlIGtleS5cbiAgICAvLyBQID0gcGsgeCBHXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIEcxLlByb2plY3RpdmVQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKHRydWUpO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciAoRzIpIGJ5IHByaXZhdGUga2V5LlxuICAgIC8vIFAgPSBwayB4IEdcbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXlGb3JTaG9ydFNpZ25hdHVyZXMocHJpdmF0ZUtleSkge1xuICAgICAgICByZXR1cm4gRzIuUHJvamVjdGl2ZVBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBtc2dQb2ludCA9IG5vcm1QMkhhc2gobWVzc2FnZSwgaHRmT3B0cyk7XG4gICAgICAgIG1zZ1BvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIGNvbnN0IHNpZ1BvaW50ID0gbXNnUG9pbnQubXVsdGlwbHkoRzEubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRzIuUHJvamVjdGl2ZVBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHNpZ1BvaW50O1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnRvUmF3Qnl0ZXMoc2lnUG9pbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWduU2hvcnRTaWduYXR1cmUobWVzc2FnZSwgcHJpdmF0ZUtleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBtc2dQb2ludCA9IG5vcm1QMUhhc2gobWVzc2FnZSwgaHRmT3B0cyk7XG4gICAgICAgIG1zZ1BvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIGNvbnN0IHNpZ1BvaW50ID0gbXNnUG9pbnQubXVsdGlwbHkoRzEubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRzEuUHJvamVjdGl2ZVBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHNpZ1BvaW50O1xuICAgICAgICByZXR1cm4gU2hvcnRTaWduYXR1cmUudG9SYXdCeXRlcyhzaWdQb2ludCk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBwYWlyaW5nIG9mIHB1YmxpYyBrZXkgJiBoYXNoIGlzIGVxdWFsIHRvIHBhaXJpbmcgb2YgZ2VuZXJhdG9yICYgc2lnbmF0dXJlLlxuICAgIC8vIGUoUCwgSChtKSkgPT0gZShHLCBTKVxuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBQID0gbm9ybVAxKHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IEhtID0gbm9ybVAySGFzaChtZXNzYWdlLCBodGZPcHRzKTtcbiAgICAgICAgY29uc3QgRyA9IEcxLlByb2plY3RpdmVQb2ludC5CQVNFO1xuICAgICAgICBjb25zdCBTID0gbm9ybVAyKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IGV4cCA9IHBhaXJpbmdCYXRjaChbXG4gICAgICAgICAgICB7IGcxOiBQLm5lZ2F0ZSgpLCBnMjogSG0gfSwgLy8gZVBITSA9IHBhaXJpbmcoUC5uZWdhdGUoKSwgSG0sIGZhbHNlKTtcbiAgICAgICAgICAgIHsgZzE6IEcsIGcyOiBTIH0sIC8vIGVHUyA9IHBhaXJpbmcoRywgUywgZmFsc2UpO1xuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIEZwMTIuZXFsKGV4cCwgRnAxMi5PTkUpO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgcGFpcmluZyBvZiBwdWJsaWMga2V5ICYgaGFzaCBpcyBlcXVhbCB0byBwYWlyaW5nIG9mIGdlbmVyYXRvciAmIHNpZ25hdHVyZS5cbiAgICAvLyBlKFMsIEcpID09IGUoSChtKSwgUClcbiAgICBmdW5jdGlvbiB2ZXJpZnlTaG9ydFNpZ25hdHVyZShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBQID0gbm9ybVAyKHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IEhtID0gbm9ybVAxSGFzaChtZXNzYWdlLCBodGZPcHRzKTtcbiAgICAgICAgY29uc3QgRyA9IEcyLlByb2plY3RpdmVQb2ludC5CQVNFO1xuICAgICAgICBjb25zdCBTID0gbm9ybVAxKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IGV4cCA9IHBhaXJpbmdCYXRjaChbXG4gICAgICAgICAgICB7IGcxOiBIbSwgZzI6IFAgfSwgLy8gZUhtUCA9IHBhaXJpbmcoSG0sIFAsIGZhbHNlKTtcbiAgICAgICAgICAgIHsgZzE6IFMsIGcyOiBHLm5lZ2F0ZSgpIH0sIC8vIGVTRyA9IHBhaXJpbmcoUywgRy5uZWdhdGUoKSwgZmFsc2UpO1xuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIEZwMTIuZXFsKGV4cCwgRnAxMi5PTkUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhTm9uRW1wdHkoYXJyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpIHx8IGFyci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG5vbi1lbXB0eSBhcnJheScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZ2dyZWdhdGVQdWJsaWNLZXlzKHB1YmxpY0tleXMpIHtcbiAgICAgICAgYU5vbkVtcHR5KHB1YmxpY0tleXMpO1xuICAgICAgICBjb25zdCBhZ2cgPSBwdWJsaWNLZXlzLm1hcChub3JtUDEpLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0uYWRkKHApLCBHMS5Qcm9qZWN0aXZlUG9pbnQuWkVSTyk7XG4gICAgICAgIGNvbnN0IGFnZ0FmZmluZSA9IGFnZzsgLy8udG9BZmZpbmUoKTtcbiAgICAgICAgaWYgKHB1YmxpY0tleXNbMF0gaW5zdGFuY2VvZiBHMS5Qcm9qZWN0aXZlUG9pbnQpIHtcbiAgICAgICAgICAgIGFnZ0FmZmluZS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFnZ0FmZmluZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0b1Jhd0J5dGVzIGVuc3VyZXMgcG9pbnQgdmFsaWRpdHlcbiAgICAgICAgcmV0dXJuIGFnZ0FmZmluZS50b1Jhd0J5dGVzKHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZ2dyZWdhdGVTaWduYXR1cmVzKHNpZ25hdHVyZXMpIHtcbiAgICAgICAgYU5vbkVtcHR5KHNpZ25hdHVyZXMpO1xuICAgICAgICBjb25zdCBhZ2cgPSBzaWduYXR1cmVzLm1hcChub3JtUDIpLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0uYWRkKHMpLCBHMi5Qcm9qZWN0aXZlUG9pbnQuWkVSTyk7XG4gICAgICAgIGNvbnN0IGFnZ0FmZmluZSA9IGFnZzsgLy8udG9BZmZpbmUoKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZXNbMF0gaW5zdGFuY2VvZiBHMi5Qcm9qZWN0aXZlUG9pbnQpIHtcbiAgICAgICAgICAgIGFnZ0FmZmluZS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFnZ0FmZmluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnRvUmF3Qnl0ZXMoYWdnQWZmaW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWdncmVnYXRlU2hvcnRTaWduYXR1cmVzKHNpZ25hdHVyZXMpIHtcbiAgICAgICAgYU5vbkVtcHR5KHNpZ25hdHVyZXMpO1xuICAgICAgICBjb25zdCBhZ2cgPSBzaWduYXR1cmVzLm1hcChub3JtUDEpLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0uYWRkKHMpLCBHMS5Qcm9qZWN0aXZlUG9pbnQuWkVSTyk7XG4gICAgICAgIGNvbnN0IGFnZ0FmZmluZSA9IGFnZzsgLy8udG9BZmZpbmUoKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZXNbMF0gaW5zdGFuY2VvZiBHMS5Qcm9qZWN0aXZlUG9pbnQpIHtcbiAgICAgICAgICAgIGFnZ0FmZmluZS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFnZ0FmZmluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2hvcnRTaWduYXR1cmUudG9SYXdCeXRlcyhhZ2dBZmZpbmUpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2V0aHJlc2Vhci5jaC90L2Zhc3QtdmVyaWZpY2F0aW9uLW9mLW11bHRpcGxlLWJscy1zaWduYXR1cmVzLzU0MDdcbiAgICAvLyBlKEcsIFMpID0gZShHLCBTVU0obikoU2kpKSA9IE1VTChuKShlKEcsIFNpKSlcbiAgICBmdW5jdGlvbiB2ZXJpZnlCYXRjaChzaWduYXR1cmUsIFxuICAgIC8vIFRPRE86IG1heWJlIGB7bWVzc2FnZTogRzJIZXgsIHB1YmxpY0tleTogRzFIZXh9W11gIGluc3RlYWQ/XG4gICAgbWVzc2FnZXMsIHB1YmxpY0tleXMsIGh0Zk9wdHMpIHtcbiAgICAgICAgYU5vbkVtcHR5KG1lc3NhZ2VzKTtcbiAgICAgICAgaWYgKHB1YmxpY0tleXMubGVuZ3RoICE9PSBtZXNzYWdlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Ftb3VudCBvZiBwdWJsaWMga2V5cyBhbmQgbWVzc2FnZXMgc2hvdWxkIGJlIGVxdWFsJyk7XG4gICAgICAgIGNvbnN0IHNpZyA9IG5vcm1QMihzaWduYXR1cmUpO1xuICAgICAgICBjb25zdCBuTWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKGkpID0+IG5vcm1QMkhhc2goaSwgaHRmT3B0cykpO1xuICAgICAgICBjb25zdCBuUHVibGljS2V5cyA9IHB1YmxpY0tleXMubWFwKG5vcm1QMSk7XG4gICAgICAgIC8vIE5PVEU6IHRoaXMgd29ya3Mgb25seSBmb3IgZXhhY3Qgc2FtZSBvYmplY3RcbiAgICAgICAgY29uc3QgbWVzc2FnZVB1YktleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUHVibGljS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHViID0gblB1YmxpY0tleXNbaV07XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBuTWVzc2FnZXNbaV07XG4gICAgICAgICAgICBsZXQga2V5cyA9IG1lc3NhZ2VQdWJLZXlNYXAuZ2V0KG1zZyk7XG4gICAgICAgICAgICBpZiAoa2V5cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQdWJLZXlNYXAuc2V0KG1zZywga2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlzLnB1c2gocHViKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlyZWQgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW21zZywga2V5c10gb2YgbWVzc2FnZVB1YktleU1hcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwUHVibGljS2V5ID0ga2V5cy5yZWR1Y2UoKGFjYywgbXNnKSA9PiBhY2MuYWRkKG1zZykpO1xuICAgICAgICAgICAgICAgIHBhaXJlZC5wdXNoKHsgZzE6IGdyb3VwUHVibGljS2V5LCBnMjogbXNnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFpcmVkLnB1c2goeyBnMTogRzEuUHJvamVjdGl2ZVBvaW50LkJBU0UubmVnYXRlKCksIGcyOiBzaWcgfSk7XG4gICAgICAgICAgICByZXR1cm4gRnAxMi5lcWwocGFpcmluZ0JhdGNoKHBhaXJlZCksIEZwMTIuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRzEuUHJvamVjdGl2ZVBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoNCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRQdWJsaWNLZXlGb3JTaG9ydFNpZ25hdHVyZXMsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHNpZ25TaG9ydFNpZ25hdHVyZSxcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICB2ZXJpZnlCYXRjaCxcbiAgICAgICAgdmVyaWZ5U2hvcnRTaWduYXR1cmUsXG4gICAgICAgIGFnZ3JlZ2F0ZVB1YmxpY0tleXMsXG4gICAgICAgIGFnZ3JlZ2F0ZVNpZ25hdHVyZXMsXG4gICAgICAgIGFnZ3JlZ2F0ZVNob3J0U2lnbmF0dXJlcyxcbiAgICAgICAgbWlsbGVyTG9vcEJhdGNoLFxuICAgICAgICBwYWlyaW5nLFxuICAgICAgICBwYWlyaW5nQmF0Y2gsXG4gICAgICAgIEcxLFxuICAgICAgICBHMixcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICBTaG9ydFNpZ25hdHVyZSxcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBGcixcbiAgICAgICAgICAgIEZwLFxuICAgICAgICAgICAgRnAyLFxuICAgICAgICAgICAgRnA2LFxuICAgICAgICAgICAgRnAxMixcbiAgICAgICAgfSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBhdGVMb29wU2l6ZTogQ1VSVkUucGFyYW1zLmF0ZUxvb3BTaXplLFxuICAgICAgICAgICAgcjogQ1VSVkUucGFyYW1zLnIsXG4gICAgICAgICAgICBHMWI6IENVUlZFLkcxLmIsXG4gICAgICAgICAgICBHMmI6IENVUlZFLkcyLmIsXG4gICAgICAgIH0sXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/abstract/bls.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js":
/*!***************************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                }\n                else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                if (n === _0n)\n                    break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // Window bits are 0: skip processing.\n                    // Move to next window.\n                    continue;\n                }\n                else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQscUNBQXFDO0FBQ3JDLDhCQUE4QjtBQUM5QixpQkFBaUIsa0RBQU8sS0FBSztBQUM3QiwrQkFBK0I7QUFDL0IsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRCxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3QixxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixz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LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcz9mNGQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWV0aG9kcyBmb3IgZWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gYnkgc2NhbGFycy5cbiAqIENvbnRhaW5zIHdOQUYsIHBpcHBlbmdlclxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBuTGVuZ3RoLCB2YWxpZGF0ZUZpZWxkIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgYml0TGVuLCBiaXRNYXNrLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiBjb25zdFRpbWVOZWdhdGUoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLicgKyBiaXRzICsgJ10sIGdvdCBXPScgKyBXKTtcbn1cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBzY2FsYXJCaXRzKSB7XG4gICAgdmFsaWRhdGVXKFcsIHNjYWxhckJpdHMpO1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoc2NhbGFyQml0cyAvIFcpICsgMTsgLy8gVz04IDMzLiBOb3QgMzIsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gVz04IDEyOC4gTm90IDI1NiwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7IC8vIFc9OCAyNTZcbiAgICBjb25zdCBtYXNrID0gYml0TWFzayhXKTsgLy8gVz04IDI1NSA9PSBtYXNrIDBiMTExMTExMTFcbiAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpOyAvLyBXPTggOFxuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9O1xufVxuZnVuY3Rpb24gY2FsY09mZnNldHMobiwgd2luZG93LCB3T3B0cykge1xuICAgIGNvbnN0IHsgd2luZG93U2l6ZSwgbWFzaywgbWF4TnVtYmVyLCBzaGlmdEJ5IH0gPSB3T3B0cztcbiAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgICBsZXQgbmV4dE4gPSBuID4+IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgLy8gV2hhdCBhY3R1YWxseSBoYXBwZW5zIGhlcmU6XG4gICAgLy8gY29uc3QgaGlnaGVzdEJpdCA9IE51bWJlcihtYXNrIF4gKG1hc2sgPj4gMW4pKTtcbiAgICAvLyBsZXQgd2JpdHMyID0gd2JpdHMgLSAxOyAvLyBza2lwIHplcm9cbiAgICAvLyBpZiAod2JpdHMyICYgaGlnaGVzdEJpdCkgeyB3Yml0czIgXj0gTnVtYmVyKG1hc2spOyAvLyAofik7XG4gICAgLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgIC8vIHdlIHNraXAgemVybywgd2hpY2ggbWVhbnMgaW5zdGVhZCBvZiBgPj0gc2l6ZS0xYCwgd2UgZG8gYD4gc2l6ZWBcbiAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyOyAvLyAtMzIsIGNhbiBiZSBtYXhOdW1iZXIgLSB3Yml0cywgYnV0IHRoZW4gd2UgbmVlZCB0byBzZXQgaXNOZWcgaGVyZS5cbiAgICAgICAgbmV4dE4gKz0gXzFuOyAvLyArMjU2IChjYXJyeSlcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFN0YXJ0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBpc1plcm8gPSB3Yml0cyA9PT0gMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgYSAwP1xuICAgIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBuZWdhdGl2ZT9cbiAgICBjb25zdCBpc05lZ0YgPSB3aW5kb3cgJSAyICE9PSAwOyAvLyBmYWtlIHJhbmRvbSBzdGF0ZW1lbnQgZm9yIG5vaXNlXG4gICAgY29uc3Qgb2Zmc2V0RiA9IG9mZnNldFN0YXJ0OyAvLyBmYWtlIG9mZnNldCBmb3Igbm9pc2VcbiAgICByZXR1cm4geyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlcy5cbi8vIEFsbG93cyB0byBtYWtlIHBvaW50cyBmcm96ZW4gLyBpbW11dGFibGUuXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0VyhQKSB7XG4gICAgcmV0dXJuIHBvaW50V2luZG93U2l6ZXMuZ2V0KFApIHx8IDE7XG59XG4vKipcbiAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbiAqIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuICogQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4gKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbiAqIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3JcbiAqIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbiAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuICogLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuICogLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbiAqXG4gKiBAdG9kbyBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuXG4gKiBUaGlzIHdvdWxkIGFsbG93IHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgaGFzUHJlY29tcHV0ZXMoZWxtKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VyhlbG0pICE9PSAxO1xuICAgICAgICB9LFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbiwgcCA9IGMuWkVSTykge1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcGFyYW0gZWxtIFBvaW50IGluc3RhbmNlXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IGNhbGNXT3B0cyhXLCBiaXRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vIGk9MSwgYmMgd2Ugc2tpcCAwXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFNtYWxsZXIgdmVyc2lvbjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtc2VjcDI1NmsxL2Jsb2IvNDdjYjE2NjliNmU1MDZhZDY2YjM1ZmU3ZDc2MTMyYWU5NzQ2NWRhMi9pbmRleC50cyNMNTAyLUw1NDFcbiAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIHRoZSBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyP1xuICAgICAgICAgICAgLy8gd05BRiBiZWhhdmlvciBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlLiBCdXQgaGF2ZSB0byBjYXJlZnVsbHkgcmVtb3ZlXG4gICAgICAgICAgICAvLyBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZS5cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdG9yc1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3by53aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIC8vIChuID09PSBfMG4pIGlzIGhhbmRsZWQgYW5kIG5vdCBlYXJseS1leGl0ZWQuIGlzRXZlbiBhbmQgb2Zmc2V0RiBhcmUgdXNlZCBmb3Igbm9pc2VcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcsIGlzTmVnRiwgb2Zmc2V0RiB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICAgICAgbiA9IG5leHROO1xuICAgICAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMDogYWRkIGdhcmJhZ2UgdG8gZmFrZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyBJbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXk6IGFkZCByYW5kb20gXCJub2lzZVwiIHBvaW50IHRvIGYuXG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoaXNOZWdGLCBwcmVjb21wdXRlc1tvZmZzZXRGXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMTogYWRkIHRvIHJlc3VsdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGlzTmVnLCBwcmVjb21wdXRlc1tvZmZzZXRdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIGJvdGggcmVhbCBhbmQgZmFrZSBwb2ludHM6IEpJVCB3b24ndCBlbGltaW5hdGUgZi5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIHVuc2FmZSAobm9uIGNvbnN0LXRpbWUpIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHBhcmFtIGFjYyBhY2N1bXVsYXRvciBwb2ludCB0byBhZGQgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICB3TkFGVW5zYWZlKFcsIHByZWNvbXB1dGVzLCBuLCBhY2MgPSBjLlpFUk8pIHtcbiAgICAgICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gRWFybHktZXhpdCwgc2tpcCAwIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgICAgICAgICAgICBuID0gbmV4dE47XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3cgYml0cyBhcmUgMDogc2tpcCBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwcmVjb21wdXRlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICBhY2MgPSBhY2MuYWRkKGlzTmVnID8gaXRlbS5uZWdhdGUoKSA6IGl0ZW0pOyAvLyBSZS11c2luZyBhY2MgYWxsb3dzIHRvIHNhdmUgYWRkcyBpbiBNU01cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwb2ludFByZWNvbXB1dGVzLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4pO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkVW5zYWZlKFAsIG4sIHRyYW5zZm9ybSwgcHJldikge1xuICAgICAgICAgICAgY29uc3QgVyA9IGdldFcoUCk7XG4gICAgICAgICAgICBpZiAoVyA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNhZmVMYWRkZXIoUCwgbiwgcHJldik7IC8vIEZvciBXPTEgbGFkZGVyIGlzIH54MiBmYXN0ZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUZVbnNhZmUoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pLCBuLCBwcmV2KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2UgY2FsY3VsYXRlIHByZWNvbXB1dGVzIGZvciBlbGxpcHRpYyBjdXJ2ZSBwb2ludCBtdWx0aXBsaWNhdGlvblxuICAgICAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAgICAgICAvLyBzdG9yZXMgcHJlY29tcHV0ZWQgdmFsdWVzLiBVc3VhbGx5IG9ubHkgYmFzZSBwb2ludCB3b3VsZCBiZSBwcmVjb21wdXRlZC5cbiAgICAgICAgc2V0V2luZG93U2l6ZShQLCBXKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVcoVywgYml0cyk7XG4gICAgICAgICAgICBwb2ludFdpbmRvd1NpemVzLnNldChQLCBXKTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKFApO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBpcHBlbmdlciBhbGdvcml0aG0gZm9yIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogMzB4IGZhc3RlciB2cyBuYWl2ZSBhZGRpdGlvbiBvbiBMPTQwOTYsIDEweCBmYXN0ZXIgdGhhbiBwcmVjb21wdXRlcy5cbiAqIEZvciBOPTI1NGJpdCwgTD0xLCBpdCBkb2VzOiAxMDI0IEFERCArIDI1NCBEQkwuIEZvciBMPTU6IDE1MzYgQUREICsgMjU0IERCTC5cbiAqIEFsZ29yaXRobWljYWxseSBjb25zdGFudC10aW1lIChmb3Igc2FtZSBMKSwgZXZlbiB3aGVuIDEgcG9pbnQgKyBzY2FsYXIsIG9yIHdoZW4gc2NhbGFyID0gMC5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHBhcmFtIHNjYWxhcnMgYXJyYXkgb2YgTCBzY2FsYXJzIChha2EgcHJpdmF0ZSBrZXlzIC8gYmlnaW50cylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpcHBlbmdlcihjLCBmaWVsZE4sIHBvaW50cywgc2NhbGFycykge1xuICAgIC8vIElmIHdlIHNwbGl0IHNjYWxhcnMgYnkgc29tZSB3aW5kb3cgKGxldCdzIHNheSA4IGJpdHMpLCBldmVyeSBjaHVuayB3aWxsIG9ubHlcbiAgICAvLyB0YWtlIDI1NiBidWNrZXRzIGV2ZW4gaWYgdGhlcmUgYXJlIDQwOTYgc2NhbGFycywgYWxzbyByZS11c2VzIGRvdWJsZS5cbiAgICAvLyBUT0RPOlxuICAgIC8vIC0gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAyNC83NTAucGRmXG4gICAgLy8gLSBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvMTAyODdcbiAgICAvLyAwIGlzIGFjY2VwdGVkIGluIHNjYWxhcnNcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgIGNvbnN0IHBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHNsZW5ndGggPSBzY2FsYXJzLmxlbmd0aDtcbiAgICBpZiAocGxlbmd0aCAhPT0gc2xlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGgnKTtcbiAgICAvLyBpZiAocGxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBtdXN0IGJlIG9mIGxlbmd0aCA+PSAyJyk7XG4gICAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgICBjb25zdCB3Yml0cyA9IGJpdExlbihCaWdJbnQocGxlbmd0aCkpO1xuICAgIGxldCB3aW5kb3dTaXplID0gMTsgLy8gYml0c1xuICAgIGlmICh3Yml0cyA+IDEyKVxuICAgICAgICB3aW5kb3dTaXplID0gd2JpdHMgLSAzO1xuICAgIGVsc2UgaWYgKHdiaXRzID4gNClcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMjtcbiAgICBlbHNlIGlmICh3Yml0cyA+IDApXG4gICAgICAgIHdpbmRvd1NpemUgPSAyO1xuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTnVtYmVyKE1BU0spICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkTi5CSVRTIC0gMSkgLyB3aW5kb3dTaXplKSAqIHdpbmRvd1NpemU7XG4gICAgbGV0IHN1bSA9IHplcm87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgTUFTSyk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgICAgICAvLyBTa2lwIGZpcnN0IGJ1Y2tldCwgYmVjYXVzZSBpdCBpcyB6ZXJvXG4gICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB3aGljaCBtdWx0aXBsaWVzIHBvaW50cyB3aXRoIHNjYWFyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcHV0ZU1TTVVuc2FmZShjLCBmaWVsZE4sIHBvaW50cywgd2luZG93U2l6ZSkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuICAgICAqXG4gICAgICogQmFzZSBDYXNlICgyNTYtYml0IHNjYWxhciwgOC1iaXQgd2luZG93KTpcbiAgICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuICAgICAqICAgLSAzMSBhZGRpdGlvbnMgcGVyIHNjYWxhciDDlyAyNTYgc2NhbGFycyA9IDcsOTM2IG9wc1xuICAgICAqICAgLSBQbHVzIDI1NSBzdW1tYXJ5IGFkZGl0aW9ucyA9IDgsMTkxIHRvdGFsIG9wc1xuICAgICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3JcbiAgICAgKlxuICAgICAqIENodW5rZWQgUHJlY29tcHV0YXRpb24gQW5hbHlzaXM6XG4gICAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG4gICAgICogICAtIDI1NSBhZGRpdGlvbnMgcGVyIGNodW5rXG4gICAgICogICAtIDI1NiBkb3VibGluZ3NcbiAgICAgKiAgIC0gVG90YWw6ICgyNTUgw5cgMzIpICsgMjU2ID0gOCw0MTYgb3BzXG4gICAgICpcbiAgICAgKiBNZW1vcnkgVXNhZ2UgQ29tcGFyaXNvbjpcbiAgICAgKiBXaW5kb3cgU2l6ZSB8IFN0YW5kYXJkIFBvaW50cyB8IENodW5rZWQgUG9pbnRzXG4gICAgICogLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLVxuICAgICAqICAgICA0LWJpdCAgIHwgICAgIDUyMCAgICAgICAgIHwgICAgICAxNVxuICAgICAqICAgICA4LWJpdCAgIHwgICAgNCwyMjQgICAgICAgIHwgICAgIDI1NVxuICAgICAqICAgIDEwLWJpdCAgIHwgICAxMyw4MjQgICAgICAgIHwgICAxLDAyM1xuICAgICAqICAgIDE2LWJpdCAgIHwgIDU1NywwNTYgICAgICAgIHwgIDY1LDUzNVxuICAgICAqXG4gICAgICogS2V5IEFkdmFudGFnZXM6XG4gICAgICogMS4gRW5hYmxlcyBsYXJnZXIgd2luZG93IHNpemVzIGR1ZSB0byByZWR1Y2VkIG1lbW9yeSBvdmVyaGVhZFxuICAgICAqIDIuIE1vcmUgZWZmaWNpZW50IGZvciBzbWFsbGVyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAgLSAxNiBjaHVua3M6ICgxNiDDlyAyNTUpICsgMjU2ID0gNCwzMzYgb3BzXG4gICAgICogICAgLSB+MnggZmFzdGVyIHRoYW4gc3RhbmRhcmQgOCwxOTEgb3BzXG4gICAgICpcbiAgICAgKiBMaW1pdGF0aW9uczpcbiAgICAgKiAtIE5vdCBzdWl0YWJsZSBmb3IgcGxhaW4gcHJlY29tcHV0ZXMgKHJlcXVpcmVzIDI1NiBjb25zdGFudCBkb3VibGluZ3MpXG4gICAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgLSBPcHRpbWFsIGZvciB+MjU2IHNjYWxhcnNcbiAgICAgKiAgIC0gTGVzcyBlZmZpY2llbnQgZm9yIDQwOTYrIHNjYWxhcnMgKFBpcHBlbmdlciBwcmVmZXJyZWQpXG4gICAgICovXG4gICAgdmFsaWRhdGVXKHdpbmRvd1NpemUsIGZpZWxkTi5CSVRTKTtcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3QgdGFibGVTaXplID0gMiAqKiB3aW5kb3dTaXplIC0gMTsgLy8gdGFibGUgc2l6ZSAod2l0aG91dCB6ZXJvKVxuICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChmaWVsZE4uQklUUyAvIHdpbmRvd1NpemUpOyAvLyBjaHVua3Mgb2YgaXRlbVxuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBhY2MgPSBwOyBpIDwgdGFibGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGFjYyk7XG4gICAgICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIChzY2FsYXJzKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgICAgICBpZiAoc2NhbGFycy5sZW5ndGggPiBwb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIG11c3QgYmUgc21hbGxlciB0aGFuIGFycmF5IG9mIHBvaW50cycpO1xuICAgICAgICBsZXQgcmVzID0gemVybztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkb3VibGUgaWYgYWNjdW11bGF0b3IgaXMgc3RpbGwgemVyby5cbiAgICAgICAgICAgIGlmIChyZXMgIT09IHplcm8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5kb3VibGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoKG4gPj4gc2hpZnRCeSkgJiBNQVNLKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHplcm8gc2NhbGFycyBjaHVua3NcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.FpInvertBatch)(field, [xd, yd], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nfunction createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO))\n            return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...defaults, DST: defaults.DST, ...options });\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...defaults, DST: defaults.encodeDST, ...options });\n            return clear(map(u[0]));\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('expected array of bigints');\n            return clear(map(scalars));\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBa0Q7QUFDNkM7QUFDL0Y7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGlEQUFNO0FBQ1YsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sU0FBUyxzREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUNBQW1DO0FBQy9DLElBQUksaURBQU07QUFDVjtBQUNBLDJDQUEyQyxzREFBVztBQUN0RDtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLGlDQUFpQywwREFBYTtBQUM5QyxtQ0FBbUM7QUFDbkMsaURBQWlEO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0Q0FBNEM7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrREFBa0Q7QUFDaEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzP2NkYTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnBJbnZlcnRCYXRjaCwgbW9kIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgYWJ5dGVzLCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcywgdmFsaWRhdGVPYmplY3QgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBhbnVtKHZhbHVlKTtcbiAgICBhbnVtKGxlbmd0aCk7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEkyT1NQIGlucHV0OiAnICsgdmFsdWUpO1xuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0cy5cbiAqIFtSRkMgOTM4MCA1LjMuMV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG1kOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuICogMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4gKiAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuICogICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4gKiBbUkZDIDkzODAgNS4zLjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjIpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgY29lZmYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4biwgeGQsIHluLCB5ZF0gPSBjb2VmZi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIC8vIDYuNi4zXG4gICAgICAgIC8vIEV4Y2VwdGlvbmFsIGNhc2VzIG9mIGlzb19tYXAgYXJlIGlucHV0cyB0aGF0IGNhdXNlIHRoZSBkZW5vbWluYXRvciBvZlxuICAgICAgICAvLyBlaXRoZXIgcmF0aW9uYWwgZnVuY3Rpb24gdG8gZXZhbHVhdGUgdG8gemVybzsgc3VjaCBjYXNlcyBNVVNUIHJldHVyblxuICAgICAgICAvLyB0aGUgaWRlbnRpdHkgcG9pbnQgb24gRS5cbiAgICAgICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9IEZwSW52ZXJ0QmF0Y2goZmllbGQsIFt4ZCwgeWRdLCB0cnVlKTtcbiAgICAgICAgeCA9IGZpZWxkLm11bCh4biwgeGRfaW52KTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5tdWwoeW4sIHlkX2ludikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmYXVsdHMpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIGZ1bmN0aW9uIG1hcChudW0pIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZShudW0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXIoaW5pdGlhbCkge1xuICAgICAgICBjb25zdCBQID0gaW5pdGlhbC5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgIGlmIChQLmVxdWFscyhQb2ludC5aRVJPKSlcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPOyAvLyB6ZXJvIHdpbGwgdGhyb3cgaW4gYXNzZXJ0XG4gICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIFA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZmF1bHRzLCBEU1Q6IGRlZmF1bHRzLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gbWFwKHVbMF0pO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBtYXAodVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXIodTAuYWRkKHUxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZmF1bHRzLCBEU1Q6IGRlZmF1bHRzLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAodVswXSkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTYW1lIGFzIGVuY29kZVRvQ3VydmUsIGJ1dCB3aXRob3V0IGhhc2hcbiAgICAgICAgbWFwVG9DdXJ2ZShzY2FsYXJzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2NhbGFycylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAoc2NhbGFycykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3))\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nfunction FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nfunction FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDeUY7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLHlDQUF5QztBQUN6QyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcz9kMDlmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbHMgZm9yIG1vZHVsYXIgZGl2aXNpb24gYW5kIGZpbml0ZSBmaWVsZHMuXG4gKiBBIGZpbml0ZSBmaWVsZCBvdmVyIDExIGlzIGludGVnZXIgbnVtYmVyIG9wZXJhdGlvbnMgYG1vZCAxMWAuXG4gKiBUaGVyZSBpcyBubyBkaXZpc2lvbjogaXQgaXMgcmVwbGFjZWQgYnkgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBhbnVtYmVyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBiaXRNYXNrLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgXzNuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KSwgXzVuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgXzhuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBUT0RPOiByZW1vdmUuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICByZXR1cm4gRnBQb3coRmllbGQobW9kdWxvKSwgbnVtLCBwb3dlcik7XG59XG4vKiogRG9lcyBgeF4oMl5wb3dlcilgIG1vZCBwLiBgcG93MigzMCwgNClgID09IGAzMF4oMl40KWAgKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG8uXG4gKiBJbXBsZW1lbnRlZCB1c2luZyBbRXVjbGlkZWFuIEdDRF0oaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS8pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgbm9uLXplcm8gbnVtYmVyJyk7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBtb2R1bHVzLCBnb3QgJyArIG1vZHVsbyk7XG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vLyBOb3QgYWxsIHJvb3RzIGFyZSBwb3NzaWJsZSEgRXhhbXBsZSB3aGljaCB3aWxsIHRocm93OlxuLy8gY29uc3QgTlVNID1cbi8vIG4gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4vLyBGcCA9IEZpZWxkKEJpZ0ludCgnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWInKSk7XG5mdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICBjb25zdCBwMWRpdjQgPSAoRnAuT1JERVIgKyBfMW4pIC8gXzRuO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAvLyBUaHJvdyBpZiByb290XjIgIT0gblxuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgIGNvbnN0IHA1ZGl2OCA9IChGcC5PUkRFUiAtIF81bikgLyBfOG47XG4gICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICBjb25zdCB2ID0gRnAucG93KG4yLCBwNWRpdjgpO1xuICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuLy8gVE9ETzogQ29tbWVudGVkLW91dCBmb3Igbm93LiBQcm92aWRlIHRlc3QgdmVjdG9ycy5cbi8vIFRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGV4dGVuc2lvbiBmaWVsZHMgRnAyLlxuLy8gVGhhdCBtZWFucyB3ZSBjYW4ndCB1c2Ugc3FydCAoYzEsIGMyLi4uKSBldmVuIGZvciBpbml0aWFsaXphdGlvbiBjb25zdGFudHMuXG4vLyBpZiAoUCAlIF8xNm4gPT09IF85bikgcmV0dXJuIHNxcnQ5bW9kMTY7XG4vLyAvLyBwcmV0dGllci1pZ25vcmVcbi8vIGZ1bmN0aW9uIHNxcnQ5bW9kMTY8VD4oRnA6IElGaWVsZDxUPiwgbjogVCwgcDdkaXYxNj86IGJpZ2ludCkge1xuLy8gICBpZiAocDdkaXYxNiA9PT0gdW5kZWZpbmVkKSBwN2RpdjE2ID0gKEZwLk9SREVSICsgQmlnSW50KDcpKSAvIF8xNm47XG4vLyAgIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWcoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4vLyAgIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4vLyAgIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWcoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbi8vICAgY29uc3QgYzQgPSBwN2RpdjE2OyAgICAgICAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuLy8gICBsZXQgdHYxID0gRnAucG93KG4sIGM0KTsgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbi8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4vLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuLy8gICBjb25zdCBlMSA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7ICAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4vLyAgIGNvbnN0IGUyID0gRnAuZXFsKEZwLnNxcih0djMpLCBuKTsgIC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbi8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4vLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuLy8gICBjb25zdCBlMyA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7ICAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4vLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4vLyB9XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBJbml0aWFsaXphdGlvbiAocHJlY29tcHV0YXRpb24pLlxuICAgIGlmIChQIDwgQmlnSW50KDMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxcnQgaXMgbm90IGRlZmluZWQgZm9yIHNtYWxsIGZpZWxkJyk7XG4gICAgLy8gRmFjdG9yIFAgLSAxID0gUSAqIDJeUywgd2hlcmUgUSBpcyBvZGRcbiAgICBsZXQgUSA9IFAgLSBfMW47XG4gICAgbGV0IFMgPSAwO1xuICAgIHdoaWxlIChRICUgXzJuID09PSBfMG4pIHtcbiAgICAgICAgUSAvPSBfMm47XG4gICAgICAgIFMrKztcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgcXVhZHJhdGljIG5vbi1yZXNpZHVlIFogPj0gMlxuICAgIGxldCBaID0gXzJuO1xuICAgIGNvbnN0IF9GcCA9IEZpZWxkKFApO1xuICAgIHdoaWxlIChGcExlZ2VuZHJlKF9GcCwgWikgPT09IDEpIHtcbiAgICAgICAgLy8gQmFzaWMgcHJpbWFsaXR5IHRlc3QgZm9yIFAuIEFmdGVyIHggaXRlcmF0aW9ucywgY2hhbmNlIG9mXG4gICAgICAgIC8vIG5vdCBmaW5kaW5nIHF1YWRyYXRpYyBub24tcmVzaWR1ZSBpcyAyXngsIHNvIDJeMTAwMC5cbiAgICAgICAgaWYgKForKyA+IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290OiBwcm9iYWJseSBub24tcHJpbWUgUCcpO1xuICAgIH1cbiAgICAvLyBGYXN0LXBhdGg7IHVzdWFsbHkgZG9uZSBiZWZvcmUgWiwgYnV0IHdlIGRvIFwicHJpbWFsaXR5IHRlc3RcIi5cbiAgICBpZiAoUyA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHNxcnQzbW9kNDtcbiAgICAvLyBTbG93LXBhdGhcbiAgICAvLyBUT0RPOiB0ZXN0IG9uIEZwMiBhbmQgb3RoZXJzXG4gICAgbGV0IGNjID0gX0ZwLnBvdyhaLCBRKTsgLy8gYyA9IHpeUVxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgaWYgKEZwLmlzMChuKSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAvLyBDaGVjayBpZiBuIGlzIGEgcXVhZHJhdGljIHJlc2lkdWUgdXNpbmcgTGVnZW5kcmUgc3ltYm9sXG4gICAgICAgIGlmIChGcExlZ2VuZHJlKEZwLCBuKSAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMgZm9yIHRoZSBtYWluIGxvb3BcbiAgICAgICAgbGV0IE0gPSBTO1xuICAgICAgICBsZXQgYyA9IEZwLm11bChGcC5PTkUsIGNjKTsgLy8gYyA9IHpeUSwgbW92ZSBjYyBmcm9tIGZpZWxkIF9GcCBpbnRvIGZpZWxkIEZwXG4gICAgICAgIGxldCB0ID0gRnAucG93KG4sIFEpOyAvLyB0ID0gbl5RLCBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIGxldCBSID0gRnAucG93KG4sIFExZGl2Mik7IC8vIFIgPSBuXigoUSsxKS8yKSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIC8vIE1haW4gbG9vcFxuICAgICAgICAvLyB3aGlsZSB0ICE9IDFcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwodCwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmlzMCh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaWYgdD0wIHJldHVybiBSPTBcbiAgICAgICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IGkgPj0gMSBzdWNoIHRoYXQgdF4oMl5pKSDiiaEgMSAobW9kIFApXG4gICAgICAgICAgICBsZXQgdF90bXAgPSBGcC5zcXIodCk7IC8vIHReKDJeMSlcbiAgICAgICAgICAgIHdoaWxlICghRnAuZXFsKHRfdG1wLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHRfdG1wID0gRnAuc3FyKHRfdG1wKTsgLy8gdF4oMl4yKS4uLlxuICAgICAgICAgICAgICAgIGlmIChpID09PSBNKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGV4cG9uZW50IGZvciBiOiAyXihNIC0gaSAtIDEpXG4gICAgICAgICAgICBjb25zdCBleHBvbmVudCA9IF8xbiA8PCBCaWdJbnQoTSAtIGkgLSAxKTsgLy8gYmlnaW50IGlzIGltcG9ydGFudFxuICAgICAgICAgICAgY29uc3QgYiA9IEZwLnBvdyhjLCBleHBvbmVudCk7IC8vIGIgPSAyXihNIC0gaSAtIDEpXG4gICAgICAgICAgICAvLyBVcGRhdGUgdmFyaWFibGVzXG4gICAgICAgICAgICBNID0gaTtcbiAgICAgICAgICAgIGMgPSBGcC5zcXIoYik7IC8vIGMgPSBiXjJcbiAgICAgICAgICAgIHQgPSBGcC5tdWwodCwgYyk7IC8vIHQgPSAodCAqIGJeMilcbiAgICAgICAgICAgIFIgPSBGcC5tdWwoUiwgYik7IC8vIFIgPSBSKmJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUjtcbiAgICB9O1xufVxuLyoqXG4gKiBTcXVhcmUgcm9vdCBmb3IgYSBmaW5pdGUgZmllbGQuIFdpbGwgdHJ5IG9wdGltaXplZCB2ZXJzaW9ucyBmaXJzdDpcbiAqXG4gKiAxLiBQIOKJoSAzIChtb2QgNClcbiAqIDIuIFAg4omhIDUgKG1vZCA4KVxuICogMy4gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gKlxuICogRGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICogRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIFAg4omhIDMgKG1vZCA0KSA9PiDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKVxuICAgICAgICByZXR1cm4gc3FydDNtb2Q0O1xuICAgIC8vIFAg4omhIDUgKG1vZCA4KSA9PiBBdGtpbiBhbGdvcml0aG0sIHBhZ2UgMTAgb2YgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bilcbiAgICAgICAgcmV0dXJuIHNxcnQ1bW9kODtcbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpIG5vdCBpbXBsZW1lbnRlZCwgc2VlIGFib3ZlXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KEZwLCBudW0sIHBvd2VyKSB7XG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZXhwb25lbnQsIG5lZ2F0aXZlcyB1bnN1cHBvcnRlZCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gRnAuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gRnAuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gRnAubXVsKHAsIGQpO1xuICAgICAgICBkID0gRnAuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogRXhjZXB0aW9uLWZyZWUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGZvciAwIGVsZW1lbnRzLlxuICogQHBhcmFtIHBhc3NaZXJvIG1hcCAwIHRvIDAgKGluc3RlYWQgb2YgdW5kZWZpbmVkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChGcCwgbnVtcywgcGFzc1plcm8gPSBmYWxzZSkge1xuICAgIGNvbnN0IGludmVydGVkID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKS5maWxsKHBhc3NaZXJvID8gRnAuWkVSTyA6IHVuZGVmaW5lZCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IG11bHRpcGxpZWRBY2MgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKEZwLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgaW52ZXJ0ZWRbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICAgIH0sIEZwLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkQWNjID0gRnAuaW52KG11bHRpcGxpZWRBY2MpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoRnAuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBpbnZlcnRlZFtpXSA9IEZwLm11bChhY2MsIGludmVydGVkW2ldKTtcbiAgICAgICAgcmV0dXJuIEZwLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWRBY2MpO1xuICAgIHJldHVybiBpbnZlcnRlZDtcbn1cbi8vIFRPRE86IHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KEZwLCBsaHMsIHJocykge1xuICAgIHJldHVybiBGcC5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIEZwLk9SREVSKSA6IEZwLmludihyaHMpKTtcbn1cbi8qKlxuICogTGVnZW5kcmUgc3ltYm9sLlxuICogTGVnZW5kcmUgY29uc3RhbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcClcbiAqIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gKlxuICogKiAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIHJlc2lkdWVcbiAqICogKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgbm9uIHJlc2lkdWVcbiAqICogKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwTGVnZW5kcmUoRnAsIG4pIHtcbiAgICAvLyBXZSBjYW4gdXNlIDNyZCBhcmd1bWVudCBhcyBvcHRpb25hbCBjYWNoZSBvZiB0aGlzIHZhbHVlXG4gICAgLy8gYnV0IHNlZW1zIHVubmVlZGVkIGZvciBub3cuIFRoZSBvcGVyYXRpb24gaXMgdmVyeSBmYXN0LlxuICAgIGNvbnN0IHAxbW9kMiA9IChGcC5PUkRFUiAtIF8xbikgLyBfMm47XG4gICAgY29uc3QgcG93ZXJlZCA9IEZwLnBvdyhuLCBwMW1vZDIpO1xuICAgIGNvbnN0IHllcyA9IEZwLmVxbChwb3dlcmVkLCBGcC5PTkUpO1xuICAgIGNvbnN0IHplcm8gPSBGcC5lcWwocG93ZXJlZCwgRnAuWkVSTyk7XG4gICAgY29uc3Qgbm8gPSBGcC5lcWwocG93ZXJlZCwgRnAubmVnKEZwLk9ORSkpO1xuICAgIGlmICgheWVzICYmICF6ZXJvICYmICFubylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIExlZ2VuZHJlIHN5bWJvbCByZXN1bHQnKTtcbiAgICByZXR1cm4geWVzID8gMSA6IHplcm8gPyAwIDogLTE7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKEZwLCBuKSB7XG4gICAgY29uc3QgbCA9IEZwTGVnZW5kcmUoRnAsIG4pO1xuICAgIHJldHVybiBsID09PSAxO1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgaWYgKG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYW51bWJlcihuQml0TGVuZ3RoKTtcbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogRnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIFNlY3VyaXR5IG5vdGU6IG9wZXJhdGlvbnMgZG9uJ3QgY2hlY2sgJ2lzVmFsaWQnIGZvciBhbGwgZWxlbWVudHMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsXG4gKiBpdCBpcyBjYWxsZXIgcmVzcG9uc2liaWxpdHkgdG8gY2hlY2sgdGhpcy5cbiAqIFRoaXMgaXMgbG93LWxldmVsIGNvZGUsIHBsZWFzZSBtYWtlIHN1cmUgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZDogZXhwZWN0ZWQgT1JERVIgPiAwLCBnb3QgJyArIE9SREVSKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAnICsgdHlwZW9mIG51bSk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHxcbiAgICAgICAgICAgICgobikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3FydFApXG4gICAgICAgICAgICAgICAgICAgIHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FydFAoZiwgbik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5mcm9tQnl0ZXM6IGV4cGVjdGVkICcgKyBCWVRFUyArICcgYnl0ZXMsIGdvdCAnICsgYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE86IHdlIGRvbid0IG5lZWQgaXQgaGVyZSwgbW92ZSBvdXQgdG8gc2VwYXJhdGUgZm5cbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gV2UgY2FuJ3QgbW92ZSB0aGlzIG91dCBiZWNhdXNlIEZwNiwgRnAxMiBpbXBsZW1lbnQgaXRcbiAgICAgICAgLy8gYW5kIGl0J3MgdW5jbGVhciB3aGF0IHRvIHJldHVybiBpbiB0aGVyZS5cbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIGBtYXBLZXlUb0ZpZWxkYCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBoYXNoTGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBsZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJCRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/abstract/tower.js":
/*!***************************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/abstract/tower.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   psiFrobenius: () => (/* binding */ psiFrobenius),\n/* harmony export */   tower12: () => (/* binding */ tower12)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\nfunction calcFrobeniusCoefficients(Fp, nonResidue, modulus, degree, num = 1, divisor) {\n    const _divisor = BigInt(divisor === undefined ? degree : divisor);\n    const towerModulus = modulus ** BigInt(degree);\n    const res = [];\n    for (let i = 0; i < num; i++) {\n        const a = BigInt(i + 1);\n        const powers = [];\n        for (let j = 0, qPower = _1n; j < degree; j++) {\n            const power = ((a * qPower - a) / _divisor) % towerModulus;\n            powers.push(Fp.pow(nonResidue, power));\n            qPower *= modulus;\n        }\n        res.push(powers);\n    }\n    return res;\n}\n// This works same at least for bls12-381, bn254 and bls12-377\nfunction psiFrobenius(Fp, Fp2, base) {\n    // GLV endomorphism (P)\n    const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n    const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n    function psi(x, y) {\n        // This x10 faster than previous version in bls12-381\n        const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n        const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n        return [x2, y2];\n    }\n    // (P) endomorphism (psi2(x) = psi(psi(x)))\n    const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n    // This equals -1, which causes y to be Fp2.neg(y).\n    // But not sure if there are case when this is not true?\n    const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n    if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE)))\n        throw new Error('psiFrobenius: PSI2_Y!==-1');\n    function psi2(x, y) {\n        return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n    }\n    // Map points\n    const mapAffine = (fn) => (c, P) => {\n        const affine = P.toAffine();\n        const p = fn(affine.x, affine.y);\n        return c.fromAffine({ x: p[0], y: p[1] });\n    };\n    const G2psi = mapAffine(psi);\n    const G2psi2 = mapAffine(psi2);\n    return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\n}\nfunction tower12(opts) {\n    const { ORDER } = opts;\n    // Fp\n    const Fp = _modular_js__WEBPACK_IMPORTED_MODULE_0__.Field(ORDER);\n    const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n    const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\n    // Fp2\n    const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\n    const Fp2Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n        c0: Fp.add(c0, r0),\n        c1: Fp.add(c1, r1),\n    });\n    const Fp2Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n        c0: Fp.sub(c0, r0),\n        c1: Fp.sub(c1, r1),\n    });\n    const Fp2Multiply = ({ c0, c1 }, rhs) => {\n        if (typeof rhs === 'bigint')\n            return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n        // (a+bi)(c+di) = (acbd) + (ad+bc)i\n        const { c0: r0, c1: r1 } = rhs;\n        let t1 = Fp.mul(c0, r0); // c0 * o0\n        let t2 = Fp.mul(c1, r1); // c1 * o1\n        // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n        const o0 = Fp.sub(t1, t2);\n        const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n        return { c0: o0, c1: o1 };\n    };\n    const Fp2Square = ({ c0, c1 }) => {\n        const a = Fp.add(c0, c1);\n        const b = Fp.sub(c0, c1);\n        const c = Fp.add(c0, c0);\n        return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n    };\n    const Fp2fromBigTuple = (tuple) => {\n        if (tuple.length !== 2)\n            throw new Error('invalid tuple');\n        const fps = tuple.map((n) => Fp.create(n));\n        return { c0: fps[0], c1: fps[1] };\n    };\n    const FP2_ORDER = ORDER * ORDER;\n    const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n    const Fp2 = {\n        ORDER: FP2_ORDER,\n        isLE: Fp.isLE,\n        NONRESIDUE: Fp2Nonresidue,\n        BITS: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER),\n        BYTES: Math.ceil((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER) / 8),\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER)),\n        ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\n        ONE: { c0: Fp.ONE, c1: Fp.ZERO },\n        create: (num) => num,\n        isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n        is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\n        eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n        neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\n        pow: (num, power) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp2, num, power),\n        invertBatch: (nums) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp2, nums),\n        // Normalized\n        add: Fp2Add,\n        sub: Fp2Subtract,\n        mul: Fp2Multiply,\n        sqr: Fp2Square,\n        // NonNormalized stuff\n        addN: Fp2Add,\n        subN: Fp2Subtract,\n        mulN: Fp2Multiply,\n        sqrN: Fp2Square,\n        // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n        div: (lhs, rhs) => Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n        inv: ({ c0: a, c1: b }) => {\n            // We wish to find the multiplicative inverse of a nonzero\n            // element a + bu in Fp2. We leverage an identity\n            //\n            // (a + bu)(a - bu) = a + b\n            //\n            // which holds because u = -1. This can be rewritten as\n            //\n            // (a + bu)(a - bu)/(a + b) = 1\n            //\n            // because a + b = 0 has no nonzero solutions for (a, b).\n            // This gives that (a - bu)/(a + b) is the inverse\n            // of (a + bu). Importantly, this can be computing using\n            // only a single inversion in Fp.\n            const factor = Fp.inv(Fp.create(a * a + b * b));\n            return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n        },\n        sqrt: (num) => {\n            if (opts.Fp2sqrt)\n                return opts.Fp2sqrt(num);\n            // This is generic for all quadratic extensions (Fp2)\n            const { c0, c1 } = num;\n            if (Fp.is0(c1)) {\n                // if c0 is quadratic residue\n                if (_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpLegendre(Fp, c0) === 1)\n                    return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\n                else\n                    return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE)) });\n            }\n            const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\n            let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\n            const legendre = _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpLegendre(Fp, d);\n            // -1, Quadratic non residue\n            if (legendre === -1)\n                d = Fp.sub(d, a);\n            const a0 = Fp.sqrt(d);\n            const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, Fpdiv2), a0) });\n            if (!Fp2.eql(Fp2.sqr(candidateSqrt), num))\n                throw new Error('Cannot find square root');\n            // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n            const x1 = candidateSqrt;\n            const x2 = Fp2.neg(x1);\n            const { re: re1, im: im1 } = Fp2.reim(x1);\n            const { re: re2, im: im2 } = Fp2.reim(x2);\n            if (im1 > im2 || (im1 === im2 && re1 > re2))\n                return x1;\n            return x2;\n        },\n        // Same as sgn0_m_eq_2 in RFC 9380\n        isOdd: (x) => {\n            const { re: x0, im: x1 } = Fp2.reim(x);\n            const sign_0 = x0 % _2n;\n            const zero_0 = x0 === _0n;\n            const sign_1 = x1 % _2n;\n            return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n        },\n        // Bytes util\n        fromBytes(b) {\n            if (b.length !== Fp2.BYTES)\n                throw new Error('fromBytes invalid length=' + b.length);\n            return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n        },\n        toBytes: ({ c0, c1 }) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp.toBytes(c0), Fp.toBytes(c1)),\n        cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n            c0: Fp.cmov(c0, r0, c),\n            c1: Fp.cmov(c1, r1, c),\n        }),\n        reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n        // multiply by u + 1\n        mulByNonresidue: ({ c0, c1 }) => Fp2.mul({ c0, c1 }, Fp2Nonresidue),\n        mulByB: opts.Fp2mulByB,\n        fromBigTuple: Fp2fromBigTuple,\n        frobeniusMap: ({ c0, c1 }, power) => ({\n            c0,\n            c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\n        }),\n    };\n    // Fp6\n    const Fp6Add = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n        c0: Fp2.add(c0, r0),\n        c1: Fp2.add(c1, r1),\n        c2: Fp2.add(c2, r2),\n    });\n    const Fp6Subtract = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n        c0: Fp2.sub(c0, r0),\n        c1: Fp2.sub(c1, r1),\n        c2: Fp2.sub(c2, r2),\n    });\n    const Fp6Multiply = ({ c0, c1, c2 }, rhs) => {\n        if (typeof rhs === 'bigint') {\n            return {\n                c0: Fp2.mul(c0, rhs),\n                c1: Fp2.mul(c1, rhs),\n                c2: Fp2.mul(c2, rhs),\n            };\n        }\n        const { c0: r0, c1: r1, c2: r2 } = rhs;\n        const t0 = Fp2.mul(c0, r0); // c0 * o0\n        const t1 = Fp2.mul(c1, r1); // c1 * o1\n        const t2 = Fp2.mul(c2, r2); // c2 * o2\n        return {\n            // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n            c0: Fp2.add(t0, Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))),\n            // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n            c1: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)), Fp2.mulByNonresidue(t2)),\n            // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n            c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n        };\n    };\n    const Fp6Square = ({ c0, c1, c2 }) => {\n        let t0 = Fp2.sqr(c0); // c0\n        let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n        let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n        let t4 = Fp2.sqr(c2); // c2\n        return {\n            c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n            c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n            // T1 + (c0 - c1 + c2) + T3 - T0 - T4\n            c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n        };\n    };\n    const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(Fp2, Fp2Nonresidue, Fp.ORDER, 6, 2, 3);\n    const Fp6 = {\n        ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n        isLE: Fp2.isLE,\n        BITS: 3 * Fp2.BITS,\n        BYTES: 3 * Fp2.BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(3 * Fp2.BITS),\n        ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\n        ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\n        create: (num) => num,\n        isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n        is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n        neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\n        eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n        sqrt: _utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented,\n        // Do we need division by bigint at all? Should be done via order:\n        div: (lhs, rhs) => Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n        pow: (num, power) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp6, num, power),\n        invertBatch: (nums) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp6, nums),\n        // Normalized\n        add: Fp6Add,\n        sub: Fp6Subtract,\n        mul: Fp6Multiply,\n        sqr: Fp6Square,\n        // NonNormalized stuff\n        addN: Fp6Add,\n        subN: Fp6Subtract,\n        mulN: Fp6Multiply,\n        sqrN: Fp6Square,\n        inv: ({ c0, c1, c2 }) => {\n            let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0 - c2 * c1 * (u + 1)\n            let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2 * (u + 1) - c0 * c1\n            let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1 - c0 * c2\n            // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n            let t4 = Fp2.inv(Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0)));\n            return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n        },\n        // Bytes utils\n        fromBytes: (b) => {\n            if (b.length !== Fp6.BYTES)\n                throw new Error('fromBytes invalid length=' + b.length);\n            return {\n                c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n                c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n                c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\n            };\n        },\n        toBytes: ({ c0, c1, c2 }) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n        cmov: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) => ({\n            c0: Fp2.cmov(c0, r0, c),\n            c1: Fp2.cmov(c1, r1, c),\n            c2: Fp2.cmov(c2, r2, c),\n        }),\n        fromBigSix: (t) => {\n            if (!Array.isArray(t) || t.length !== 6)\n                throw new Error('invalid Fp6 usage');\n            return {\n                c0: Fp2.fromBigTuple(t.slice(0, 2)),\n                c1: Fp2.fromBigTuple(t.slice(2, 4)),\n                c2: Fp2.fromBigTuple(t.slice(4, 6)),\n            };\n        },\n        frobeniusMap: ({ c0, c1, c2 }, power) => ({\n            c0: Fp2.frobeniusMap(c0, power),\n            c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n            c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\n        }),\n        mulByFp2: ({ c0, c1, c2 }, rhs) => ({\n            c0: Fp2.mul(c0, rhs),\n            c1: Fp2.mul(c1, rhs),\n            c2: Fp2.mul(c2, rhs),\n        }),\n        mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\n        // Sparse multiplication\n        mul1: ({ c0, c1, c2 }, b1) => ({\n            c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n            c1: Fp2.mul(c0, b1),\n            c2: Fp2.mul(c1, b1),\n        }),\n        // Sparse multiplication\n        mul01({ c0, c1, c2 }, b0, b1) {\n            let t0 = Fp2.mul(c0, b0); // c0 * b0\n            let t1 = Fp2.mul(c1, b1); // c1 * b1\n            return {\n                // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n                c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n                // (b0 + b1) * (c0 + c1) - T0 - T1\n                c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n                // (c0 + c2) * b0 - T0 + T1\n                c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n            };\n        },\n    };\n    // Fp12\n    const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp2, Fp2Nonresidue, Fp.ORDER, 12, 1, 6)[0];\n    const Fp12Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n        c0: Fp6.add(c0, r0),\n        c1: Fp6.add(c1, r1),\n    });\n    const Fp12Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n        c0: Fp6.sub(c0, r0),\n        c1: Fp6.sub(c1, r1),\n    });\n    const Fp12Multiply = ({ c0, c1 }, rhs) => {\n        if (typeof rhs === 'bigint')\n            return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n        let { c0: r0, c1: r1 } = rhs;\n        let t1 = Fp6.mul(c0, r0); // c0 * r0\n        let t2 = Fp6.mul(c1, r1); // c1 * r1\n        return {\n            c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n            // (c0 + c1) * (r0 + r1) - (T1 + T2)\n            c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n        };\n    };\n    const Fp12Square = ({ c0, c1 }) => {\n        let ab = Fp6.mul(c0, c1); // c0 * c1\n        return {\n            // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n            c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),\n            c1: Fp6.add(ab, ab),\n        }; // AB + AB\n    };\n    function Fp4Square(a, b) {\n        const a2 = Fp2.sqr(a);\n        const b2 = Fp2.sqr(b);\n        return {\n            first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b * Nonresidue + a\n            second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b) - a - b\n        };\n    }\n    const Fp12 = {\n        ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n        isLE: Fp6.isLE,\n        BITS: 2 * Fp6.BITS,\n        BYTES: 2 * Fp6.BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(2 * Fp6.BITS),\n        ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\n        ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\n        create: (num) => num,\n        isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n        is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\n        neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\n        eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n        sqrt: _utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented,\n        inv: ({ c0, c1 }) => {\n            let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0 - c1 * v)\n            return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n        },\n        div: (lhs, rhs) => Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n        pow: (num, power) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp12, num, power),\n        invertBatch: (nums) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp12, nums),\n        // Normalized\n        add: Fp12Add,\n        sub: Fp12Subtract,\n        mul: Fp12Multiply,\n        sqr: Fp12Square,\n        // NonNormalized stuff\n        addN: Fp12Add,\n        subN: Fp12Subtract,\n        mulN: Fp12Multiply,\n        sqrN: Fp12Square,\n        // Bytes utils\n        fromBytes: (b) => {\n            if (b.length !== Fp12.BYTES)\n                throw new Error('fromBytes invalid length=' + b.length);\n            return {\n                c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n                c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n            };\n        },\n        toBytes: ({ c0, c1 }) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n        cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n            c0: Fp6.cmov(c0, r0, c),\n            c1: Fp6.cmov(c1, r1, c),\n        }),\n        // Utils\n        // toString() {\n        //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n        // },\n        // fromTuple(c: [Fp6, Fp6]) {\n        //   return new Fp12(...c);\n        // }\n        fromBigTwelve: (t) => ({\n            c0: Fp6.fromBigSix(t.slice(0, 6)),\n            c1: Fp6.fromBigSix(t.slice(6, 12)),\n        }),\n        // Raises to q**i -th power\n        frobeniusMap(lhs, power) {\n            const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n            const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n            return {\n                c0: Fp6.frobeniusMap(lhs.c0, power),\n                c1: Fp6.create({\n                    c0: Fp2.mul(c0, coeff),\n                    c1: Fp2.mul(c1, coeff),\n                    c2: Fp2.mul(c2, coeff),\n                }),\n            };\n        },\n        mulByFp2: ({ c0, c1 }, rhs) => ({\n            c0: Fp6.mulByFp2(c0, rhs),\n            c1: Fp6.mulByFp2(c1, rhs),\n        }),\n        conjugate: ({ c0, c1 }) => ({ c0, c1: Fp6.neg(c1) }),\n        // Sparse multiplication\n        mul014: ({ c0, c1 }, o0, o1, o4) => {\n            let t0 = Fp6.mul01(c0, o0, o1);\n            let t1 = Fp6.mul1(c1, o4);\n            return {\n                c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n                // (c1 + c0) * [o0, o1+o4] - T0 - T1\n                c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n            };\n        },\n        mul034: ({ c0, c1 }, o0, o3, o4) => {\n            const a = Fp6.create({\n                c0: Fp2.mul(c0.c0, o0),\n                c1: Fp2.mul(c0.c1, o0),\n                c2: Fp2.mul(c0.c2, o0),\n            });\n            const b = Fp6.mul01(c1, o3, o4);\n            const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n            return {\n                c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n                c1: Fp6.sub(e, Fp6.add(a, b)),\n            };\n        },\n        // A cyclotomic group is a subgroup of Fp^n defined by\n        //   G(p) = {  Fp : ^(p) = 1}\n        // The result of any pairing is in a cyclotomic subgroup\n        // https://eprint.iacr.org/2009/565.pdf\n        _cyclotomicSquare: opts.Fp12cyclotomicSquare,\n        _cyclotomicExp: opts.Fp12cyclotomicExp,\n        // https://eprint.iacr.org/2010/354.pdf\n        // https://eprint.iacr.org/2009/565.pdf\n        finalExponentiate: opts.Fp12finalExponentiate,\n    };\n    return { Fp, Fp2, Fp6, Fp4Square, Fp12 };\n}\n//# sourceMappingURL=tower.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC90b3dlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29DO0FBQ3NDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx5REFBeUQ7QUFDekQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLFlBQVksUUFBUTtBQUNwQjtBQUNBLGVBQWUsOENBQVM7QUFDeEI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHNCQUFzQixRQUFRLElBQUksZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLFFBQVEsSUFBSSxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7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USxrQ0FBa0M7QUFDbEUsZ0JBQWdCLFFBQVEsSUFBSSxnQkFBZ0I7QUFDNUMsY0FBYyxxREFBYztBQUM1QixnQkFBZ0IsUUFBUTtBQUN4QixxRkFBcUY7QUFDckYscUJBQXFCLG1EQUFtRDtBQUN4RSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIsOENBQVM7QUFDdEMsK0JBQStCLHNEQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CLFFBQVEsS0FBSyxzREFBVztBQUM1QyxpQkFBaUIsUUFBUSxJQUFJLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0JBQXNCLFFBQVEsUUFBUSxxQkFBcUI7QUFDM0Q7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdG93ZXIuanM/YmNmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRvd2VyZWQgZXh0ZW5zaW9uIGZpZWxkcy5cbiAqIFJhdGhlciB0aGFuIGltcGxlbWVudGluZyBhIG1hc3NpdmUgMTJ0aC1kZWdyZWUgZXh0ZW5zaW9uIGRpcmVjdGx5LCBpdCBpcyBtb3JlIGVmZmljaWVudFxuICogdG8gYnVpbGQgaXQgdXAgZnJvbSBzbWFsbGVyIGV4dGVuc2lvbnM6IGEgdG93ZXIgb2YgZXh0ZW5zaW9ucy5cbiAqXG4gKiBGb3IgQkxTMTItMzgxLCB0aGUgRnAxMiBmaWVsZCBpcyBpbXBsZW1lbnRlZCBhcyBhIHF1YWRyYXRpYyAoZGVncmVlIHR3bykgZXh0ZW5zaW9uLFxuICogb24gdG9wIG9mIGEgY3ViaWMgKGRlZ3JlZSB0aHJlZSkgZXh0ZW5zaW9uLCBvbiB0b3Agb2YgYSBxdWFkcmF0aWMgZXh0ZW5zaW9uIG9mIEZwLlxuICpcbiAqIEZvciBtb3JlIGluZm86IFwiUGFpcmluZ3MgZm9yIGJlZ2lubmVyc1wiIGJ5IENvc3RlbGxvLCBzZWN0aW9uIDcuMy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0ICogYXMgbW9kIGZyb20gXCIuL21vZHVsYXIuanNcIjtcbmltcG9ydCB7IGJpdExlbiwgYml0TWFzaywgY29uY2F0Qnl0ZXMsIG5vdEltcGxlbWVudGVkIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG5mdW5jdGlvbiBjYWxjRnJvYmVuaXVzQ29lZmZpY2llbnRzKEZwLCBub25SZXNpZHVlLCBtb2R1bHVzLCBkZWdyZWUsIG51bSA9IDEsIGRpdmlzb3IpIHtcbiAgICBjb25zdCBfZGl2aXNvciA9IEJpZ0ludChkaXZpc29yID09PSB1bmRlZmluZWQgPyBkZWdyZWUgOiBkaXZpc29yKTtcbiAgICBjb25zdCB0b3dlck1vZHVsdXMgPSBtb2R1bHVzICoqIEJpZ0ludChkZWdyZWUpO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IEJpZ0ludChpICsgMSk7XG4gICAgICAgIGNvbnN0IHBvd2VycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgcVBvd2VyID0gXzFuOyBqIDwgZGVncmVlOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBvd2VyID0gKChhICogcVBvd2VyIC0gYSkgLyBfZGl2aXNvcikgJSB0b3dlck1vZHVsdXM7XG4gICAgICAgICAgICBwb3dlcnMucHVzaChGcC5wb3cobm9uUmVzaWR1ZSwgcG93ZXIpKTtcbiAgICAgICAgICAgIHFQb3dlciAqPSBtb2R1bHVzO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKHBvd2Vycyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBUaGlzIHdvcmtzIHNhbWUgYXQgbGVhc3QgZm9yIGJsczEyLTM4MSwgYm4yNTQgYW5kIGJsczEyLTM3N1xuZXhwb3J0IGZ1bmN0aW9uIHBzaUZyb2Jlbml1cyhGcCwgRnAyLCBiYXNlKSB7XG4gICAgLy8gR0xWIGVuZG9tb3JwaGlzbSDOqChQKVxuICAgIGNvbnN0IFBTSV9YID0gRnAyLnBvdyhiYXNlLCAoRnAuT1JERVIgLSBfMW4pIC8gXzNuKTsgLy8gdV4oKHAtMSkvMylcbiAgICBjb25zdCBQU0lfWSA9IEZwMi5wb3coYmFzZSwgKEZwLk9SREVSIC0gXzFuKSAvIF8ybik7IC8vIHVeKChwLTEpLzIpXG4gICAgZnVuY3Rpb24gcHNpKHgsIHkpIHtcbiAgICAgICAgLy8gVGhpcyB4MTAgZmFzdGVyIHRoYW4gcHJldmlvdXMgdmVyc2lvbiBpbiBibHMxMi0zODFcbiAgICAgICAgY29uc3QgeDIgPSBGcDIubXVsKEZwMi5mcm9iZW5pdXNNYXAoeCwgMSksIFBTSV9YKTtcbiAgICAgICAgY29uc3QgeTIgPSBGcDIubXVsKEZwMi5mcm9iZW5pdXNNYXAoeSwgMSksIFBTSV9ZKTtcbiAgICAgICAgcmV0dXJuIFt4MiwgeTJdO1xuICAgIH1cbiAgICAvLyDOqMKyKFApIGVuZG9tb3JwaGlzbSAocHNpMih4KSA9IHBzaShwc2koeCkpKVxuICAgIGNvbnN0IFBTSTJfWCA9IEZwMi5wb3coYmFzZSwgKEZwLk9SREVSICoqIF8ybiAtIF8xbikgLyBfM24pOyAvLyB1XigocF4yIC0gMSkvMylcbiAgICAvLyBUaGlzIGVxdWFscyAtMSwgd2hpY2ggY2F1c2VzIHkgdG8gYmUgRnAyLm5lZyh5KS5cbiAgICAvLyBCdXQgbm90IHN1cmUgaWYgdGhlcmUgYXJlIGNhc2Ugd2hlbiB0aGlzIGlzIG5vdCB0cnVlP1xuICAgIGNvbnN0IFBTSTJfWSA9IEZwMi5wb3coYmFzZSwgKEZwLk9SREVSICoqIF8ybiAtIF8xbikgLyBfMm4pOyAvLyB1XigocF4yIC0gMSkvMylcbiAgICBpZiAoIUZwMi5lcWwoUFNJMl9ZLCBGcDIubmVnKEZwMi5PTkUpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwc2lGcm9iZW5pdXM6IFBTSTJfWSE9PS0xJyk7XG4gICAgZnVuY3Rpb24gcHNpMih4LCB5KSB7XG4gICAgICAgIHJldHVybiBbRnAyLm11bCh4LCBQU0kyX1gpLCBGcDIubmVnKHkpXTtcbiAgICB9XG4gICAgLy8gTWFwIHBvaW50c1xuICAgIGNvbnN0IG1hcEFmZmluZSA9IChmbikgPT4gKGMsIFApID0+IHtcbiAgICAgICAgY29uc3QgYWZmaW5lID0gUC50b0FmZmluZSgpO1xuICAgICAgICBjb25zdCBwID0gZm4oYWZmaW5lLngsIGFmZmluZS55KTtcbiAgICAgICAgcmV0dXJuIGMuZnJvbUFmZmluZSh7IHg6IHBbMF0sIHk6IHBbMV0gfSk7XG4gICAgfTtcbiAgICBjb25zdCBHMnBzaSA9IG1hcEFmZmluZShwc2kpO1xuICAgIGNvbnN0IEcycHNpMiA9IG1hcEFmZmluZShwc2kyKTtcbiAgICByZXR1cm4geyBwc2ksIHBzaTIsIEcycHNpLCBHMnBzaTIsIFBTSV9YLCBQU0lfWSwgUFNJMl9YLCBQU0kyX1kgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b3dlcjEyKG9wdHMpIHtcbiAgICBjb25zdCB7IE9SREVSIH0gPSBvcHRzO1xuICAgIC8vIEZwXG4gICAgY29uc3QgRnAgPSBtb2QuRmllbGQoT1JERVIpO1xuICAgIGNvbnN0IEZwTk9OUkVTSURVRSA9IEZwLmNyZWF0ZShvcHRzLk5PTlJFU0lEVUUgfHwgQmlnSW50KC0xKSk7XG4gICAgY29uc3QgRnBkaXYyID0gRnAuZGl2KEZwLk9ORSwgXzJuKTsgLy8gMS8yXG4gICAgLy8gRnAyXG4gICAgY29uc3QgRlAyX0ZST0JFTklVU19DT0VGRklDSUVOVFMgPSBjYWxjRnJvYmVuaXVzQ29lZmZpY2llbnRzKEZwLCBGcE5PTlJFU0lEVUUsIEZwLk9SREVSLCAyKVswXTtcbiAgICBjb25zdCBGcDJBZGQgPSAoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSA9PiAoe1xuICAgICAgICBjMDogRnAuYWRkKGMwLCByMCksXG4gICAgICAgIGMxOiBGcC5hZGQoYzEsIHIxKSxcbiAgICB9KTtcbiAgICBjb25zdCBGcDJTdWJ0cmFjdCA9ICh7IGMwLCBjMSB9LCB7IGMwOiByMCwgYzE6IHIxIH0pID0+ICh7XG4gICAgICAgIGMwOiBGcC5zdWIoYzAsIHIwKSxcbiAgICAgICAgYzE6IEZwLnN1YihjMSwgcjEpLFxuICAgIH0pO1xuICAgIGNvbnN0IEZwMk11bHRpcGx5ID0gKHsgYzAsIGMxIH0sIHJocykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geyBjMDogRnAubXVsKGMwLCByaHMpLCBjMTogRnAubXVsKGMxLCByaHMpIH07XG4gICAgICAgIC8vIChhK2JpKShjK2RpKSA9IChhY+KIkmJkKSArIChhZCtiYylpXG4gICAgICAgIGNvbnN0IHsgYzA6IHIwLCBjMTogcjEgfSA9IHJocztcbiAgICAgICAgbGV0IHQxID0gRnAubXVsKGMwLCByMCk7IC8vIGMwICogbzBcbiAgICAgICAgbGV0IHQyID0gRnAubXVsKGMxLCByMSk7IC8vIGMxICogbzFcbiAgICAgICAgLy8gKFQxIC0gVDIpICsgKChjMCArIGMxKSAqIChyMCArIHIxKSAtIChUMSArIFQyKSkqaVxuICAgICAgICBjb25zdCBvMCA9IEZwLnN1Yih0MSwgdDIpO1xuICAgICAgICBjb25zdCBvMSA9IEZwLnN1YihGcC5tdWwoRnAuYWRkKGMwLCBjMSksIEZwLmFkZChyMCwgcjEpKSwgRnAuYWRkKHQxLCB0MikpO1xuICAgICAgICByZXR1cm4geyBjMDogbzAsIGMxOiBvMSB9O1xuICAgIH07XG4gICAgY29uc3QgRnAyU3F1YXJlID0gKHsgYzAsIGMxIH0pID0+IHtcbiAgICAgICAgY29uc3QgYSA9IEZwLmFkZChjMCwgYzEpO1xuICAgICAgICBjb25zdCBiID0gRnAuc3ViKGMwLCBjMSk7XG4gICAgICAgIGNvbnN0IGMgPSBGcC5hZGQoYzAsIGMwKTtcbiAgICAgICAgcmV0dXJuIHsgYzA6IEZwLm11bChhLCBiKSwgYzE6IEZwLm11bChjLCBjMSkgfTtcbiAgICB9O1xuICAgIGNvbnN0IEZwMmZyb21CaWdUdXBsZSA9ICh0dXBsZSkgPT4ge1xuICAgICAgICBpZiAodHVwbGUubGVuZ3RoICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR1cGxlJyk7XG4gICAgICAgIGNvbnN0IGZwcyA9IHR1cGxlLm1hcCgobikgPT4gRnAuY3JlYXRlKG4pKTtcbiAgICAgICAgcmV0dXJuIHsgYzA6IGZwc1swXSwgYzE6IGZwc1sxXSB9O1xuICAgIH07XG4gICAgY29uc3QgRlAyX09SREVSID0gT1JERVIgKiBPUkRFUjtcbiAgICBjb25zdCBGcDJOb25yZXNpZHVlID0gRnAyZnJvbUJpZ1R1cGxlKG9wdHMuRlAyX05PTlJFU0lEVUUpO1xuICAgIGNvbnN0IEZwMiA9IHtcbiAgICAgICAgT1JERVI6IEZQMl9PUkRFUixcbiAgICAgICAgaXNMRTogRnAuaXNMRSxcbiAgICAgICAgTk9OUkVTSURVRTogRnAyTm9ucmVzaWR1ZSxcbiAgICAgICAgQklUUzogYml0TGVuKEZQMl9PUkRFUiksXG4gICAgICAgIEJZVEVTOiBNYXRoLmNlaWwoYml0TGVuKEZQMl9PUkRFUikgLyA4KSxcbiAgICAgICAgTUFTSzogYml0TWFzayhiaXRMZW4oRlAyX09SREVSKSksXG4gICAgICAgIFpFUk86IHsgYzA6IEZwLlpFUk8sIGMxOiBGcC5aRVJPIH0sXG4gICAgICAgIE9ORTogeyBjMDogRnAuT05FLCBjMTogRnAuWkVSTyB9LFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG51bSxcbiAgICAgICAgaXNWYWxpZDogKHsgYzAsIGMxIH0pID0+IHR5cGVvZiBjMCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIGMxID09PSAnYmlnaW50JyxcbiAgICAgICAgaXMwOiAoeyBjMCwgYzEgfSkgPT4gRnAuaXMwKGMwKSAmJiBGcC5pczAoYzEpLFxuICAgICAgICBlcWw6ICh7IGMwLCBjMSB9LCB7IGMwOiByMCwgYzE6IHIxIH0pID0+IEZwLmVxbChjMCwgcjApICYmIEZwLmVxbChjMSwgcjEpLFxuICAgICAgICBuZWc6ICh7IGMwLCBjMSB9KSA9PiAoeyBjMDogRnAubmVnKGMwKSwgYzE6IEZwLm5lZyhjMSkgfSksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IG1vZC5GcFBvdyhGcDIsIG51bSwgcG93ZXIpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKG51bXMpID0+IG1vZC5GcEludmVydEJhdGNoKEZwMiwgbnVtcyksXG4gICAgICAgIC8vIE5vcm1hbGl6ZWRcbiAgICAgICAgYWRkOiBGcDJBZGQsXG4gICAgICAgIHN1YjogRnAyU3VidHJhY3QsXG4gICAgICAgIG11bDogRnAyTXVsdGlwbHksXG4gICAgICAgIHNxcjogRnAyU3F1YXJlLFxuICAgICAgICAvLyBOb25Ob3JtYWxpemVkIHN0dWZmXG4gICAgICAgIGFkZE46IEZwMkFkZCxcbiAgICAgICAgc3ViTjogRnAyU3VidHJhY3QsXG4gICAgICAgIG11bE46IEZwMk11bHRpcGx5LFxuICAgICAgICBzcXJOOiBGcDJTcXVhcmUsXG4gICAgICAgIC8vIFdoeSBpbnZlcnNpb24gZm9yIGJpZ2ludCBpbnNpZGUgRnAgaW5zdGVhZCBvZiBGcDI/IGl0IGlzIGV2ZW4gdXNlZCBpbiB0aGF0IGNvbnRleHQ/XG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBGcDIubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBGcC5pbnYoRnAuY3JlYXRlKHJocykpIDogRnAyLmludihyaHMpKSxcbiAgICAgICAgaW52OiAoeyBjMDogYSwgYzE6IGIgfSkgPT4ge1xuICAgICAgICAgICAgLy8gV2Ugd2lzaCB0byBmaW5kIHRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGEgbm9uemVyb1xuICAgICAgICAgICAgLy8gZWxlbWVudCBhICsgYnUgaW4gRnAyLiBXZSBsZXZlcmFnZSBhbiBpZGVudGl0eVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIChhICsgYnUpKGEgLSBidSkgPSBhwrIgKyBiwrJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB3aGljaCBob2xkcyBiZWNhdXNlIHXCsiA9IC0xLiBUaGlzIGNhbiBiZSByZXdyaXR0ZW4gYXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAoYSArIGJ1KShhIC0gYnUpLyhhwrIgKyBiwrIpID0gMVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGJlY2F1c2UgYcKyICsgYsKyID0gMCBoYXMgbm8gbm9uemVybyBzb2x1dGlvbnMgZm9yIChhLCBiKS5cbiAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdGhhdCAoYSAtIGJ1KS8oYcKyICsgYsKyKSBpcyB0aGUgaW52ZXJzZVxuICAgICAgICAgICAgLy8gb2YgKGEgKyBidSkuIEltcG9ydGFudGx5LCB0aGlzIGNhbiBiZSBjb21wdXRpbmcgdXNpbmdcbiAgICAgICAgICAgIC8vIG9ubHkgYSBzaW5nbGUgaW52ZXJzaW9uIGluIEZwLlxuICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gRnAuaW52KEZwLmNyZWF0ZShhICogYSArIGIgKiBiKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjMDogRnAubXVsKGZhY3RvciwgRnAuY3JlYXRlKGEpKSwgYzE6IEZwLm11bChmYWN0b3IsIEZwLmNyZWF0ZSgtYikpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNxcnQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRzLkZwMnNxcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMuRnAyc3FydChudW0pO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBnZW5lcmljIGZvciBhbGwgcXVhZHJhdGljIGV4dGVuc2lvbnMgKEZwMilcbiAgICAgICAgICAgIGNvbnN0IHsgYzAsIGMxIH0gPSBudW07XG4gICAgICAgICAgICBpZiAoRnAuaXMwKGMxKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGMwIGlzIHF1YWRyYXRpYyByZXNpZHVlXG4gICAgICAgICAgICAgICAgaWYgKG1vZC5GcExlZ2VuZHJlKEZwLCBjMCkgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGcDIuY3JlYXRlKHsgYzA6IEZwLnNxcnQoYzApLCBjMTogRnAuWkVSTyB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGcDIuY3JlYXRlKHsgYzA6IEZwLlpFUk8sIGMxOiBGcC5zcXJ0KEZwLmRpdihjMCwgRnBOT05SRVNJRFVFKSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhID0gRnAuc3FydChGcC5zdWIoRnAuc3FyKGMwKSwgRnAubXVsKEZwLnNxcihjMSksIEZwTk9OUkVTSURVRSkpKTtcbiAgICAgICAgICAgIGxldCBkID0gRnAubXVsKEZwLmFkZChhLCBjMCksIEZwZGl2Mik7XG4gICAgICAgICAgICBjb25zdCBsZWdlbmRyZSA9IG1vZC5GcExlZ2VuZHJlKEZwLCBkKTtcbiAgICAgICAgICAgIC8vIC0xLCBRdWFkcmF0aWMgbm9uIHJlc2lkdWVcbiAgICAgICAgICAgIGlmIChsZWdlbmRyZSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgZCA9IEZwLnN1YihkLCBhKTtcbiAgICAgICAgICAgIGNvbnN0IGEwID0gRnAuc3FydChkKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZVNxcnQgPSBGcDIuY3JlYXRlKHsgYzA6IGEwLCBjMTogRnAuZGl2KEZwLm11bChjMSwgRnBkaXYyKSwgYTApIH0pO1xuICAgICAgICAgICAgaWYgKCFGcDIuZXFsKEZwMi5zcXIoY2FuZGlkYXRlU3FydCksIG51bSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHJvb3Q6IGF0IHRoaXMgcG9pbnQgY2FuZGlkYXRlU3FydCAqKiAyID0gbnVtLCBidXQgYWxzbyAtY2FuZGlkYXRlU3FydCAqKiAyID0gbnVtXG4gICAgICAgICAgICBjb25zdCB4MSA9IGNhbmRpZGF0ZVNxcnQ7XG4gICAgICAgICAgICBjb25zdCB4MiA9IEZwMi5uZWcoeDEpO1xuICAgICAgICAgICAgY29uc3QgeyByZTogcmUxLCBpbTogaW0xIH0gPSBGcDIucmVpbSh4MSk7XG4gICAgICAgICAgICBjb25zdCB7IHJlOiByZTIsIGltOiBpbTIgfSA9IEZwMi5yZWltKHgyKTtcbiAgICAgICAgICAgIGlmIChpbTEgPiBpbTIgfHwgKGltMSA9PT0gaW0yICYmIHJlMSA+IHJlMikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgxO1xuICAgICAgICAgICAgcmV0dXJuIHgyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTYW1lIGFzIHNnbjBfbV9lcV8yIGluIFJGQyA5MzgwXG4gICAgICAgIGlzT2RkOiAoeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyByZTogeDAsIGltOiB4MSB9ID0gRnAyLnJlaW0oeCk7XG4gICAgICAgICAgICBjb25zdCBzaWduXzAgPSB4MCAlIF8ybjtcbiAgICAgICAgICAgIGNvbnN0IHplcm9fMCA9IHgwID09PSBfMG47XG4gICAgICAgICAgICBjb25zdCBzaWduXzEgPSB4MSAlIF8ybjtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoc2lnbl8wIHx8ICh6ZXJvXzAgJiYgc2lnbl8xKSkgPT0gXzFuO1xuICAgICAgICB9LFxuICAgICAgICAvLyBCeXRlcyB1dGlsXG4gICAgICAgIGZyb21CeXRlcyhiKSB7XG4gICAgICAgICAgICBpZiAoYi5sZW5ndGggIT09IEZwMi5CWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21CeXRlcyBpbnZhbGlkIGxlbmd0aD0nICsgYi5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgYzA6IEZwLmZyb21CeXRlcyhiLnN1YmFycmF5KDAsIEZwLkJZVEVTKSksIGMxOiBGcC5mcm9tQnl0ZXMoYi5zdWJhcnJheShGcC5CWVRFUykpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHRvQnl0ZXM6ICh7IGMwLCBjMSB9KSA9PiBjb25jYXRCeXRlcyhGcC50b0J5dGVzKGMwKSwgRnAudG9CeXRlcyhjMSkpLFxuICAgICAgICBjbW92OiAoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9LCBjKSA9PiAoe1xuICAgICAgICAgICAgYzA6IEZwLmNtb3YoYzAsIHIwLCBjKSxcbiAgICAgICAgICAgIGMxOiBGcC5jbW92KGMxLCByMSwgYyksXG4gICAgICAgIH0pLFxuICAgICAgICByZWltOiAoeyBjMCwgYzEgfSkgPT4gKHsgcmU6IGMwLCBpbTogYzEgfSksXG4gICAgICAgIC8vIG11bHRpcGx5IGJ5IHUgKyAxXG4gICAgICAgIG11bEJ5Tm9ucmVzaWR1ZTogKHsgYzAsIGMxIH0pID0+IEZwMi5tdWwoeyBjMCwgYzEgfSwgRnAyTm9ucmVzaWR1ZSksXG4gICAgICAgIG11bEJ5Qjogb3B0cy5GcDJtdWxCeUIsXG4gICAgICAgIGZyb21CaWdUdXBsZTogRnAyZnJvbUJpZ1R1cGxlLFxuICAgICAgICBmcm9iZW5pdXNNYXA6ICh7IGMwLCBjMSB9LCBwb3dlcikgPT4gKHtcbiAgICAgICAgICAgIGMwLFxuICAgICAgICAgICAgYzE6IEZwLm11bChjMSwgRlAyX0ZST0JFTklVU19DT0VGRklDSUVOVFNbcG93ZXIgJSAyXSksXG4gICAgICAgIH0pLFxuICAgIH07XG4gICAgLy8gRnA2XG4gICAgY29uc3QgRnA2QWRkID0gKHsgYzAsIGMxLCBjMiB9LCB7IGMwOiByMCwgYzE6IHIxLCBjMjogcjIgfSkgPT4gKHtcbiAgICAgICAgYzA6IEZwMi5hZGQoYzAsIHIwKSxcbiAgICAgICAgYzE6IEZwMi5hZGQoYzEsIHIxKSxcbiAgICAgICAgYzI6IEZwMi5hZGQoYzIsIHIyKSxcbiAgICB9KTtcbiAgICBjb25zdCBGcDZTdWJ0cmFjdCA9ICh7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0pID0+ICh7XG4gICAgICAgIGMwOiBGcDIuc3ViKGMwLCByMCksXG4gICAgICAgIGMxOiBGcDIuc3ViKGMxLCByMSksXG4gICAgICAgIGMyOiBGcDIuc3ViKGMyLCByMiksXG4gICAgfSk7XG4gICAgY29uc3QgRnA2TXVsdGlwbHkgPSAoeyBjMCwgYzEsIGMyIH0sIHJocykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYzA6IEZwMi5tdWwoYzAsIHJocyksXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5tdWwoYzEsIHJocyksXG4gICAgICAgICAgICAgICAgYzI6IEZwMi5tdWwoYzIsIHJocyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYzA6IHIwLCBjMTogcjEsIGMyOiByMiB9ID0gcmhzO1xuICAgICAgICBjb25zdCB0MCA9IEZwMi5tdWwoYzAsIHIwKTsgLy8gYzAgKiBvMFxuICAgICAgICBjb25zdCB0MSA9IEZwMi5tdWwoYzEsIHIxKTsgLy8gYzEgKiBvMVxuICAgICAgICBjb25zdCB0MiA9IEZwMi5tdWwoYzIsIHIyKTsgLy8gYzIgKiBvMlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gdDAgKyAoYzEgKyBjMikgKiAocjEgKiByMikgLSAoVDEgKyBUMikgKiAodSArIDEpXG4gICAgICAgICAgICBjMDogRnAyLmFkZCh0MCwgRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChjMSwgYzIpLCBGcDIuYWRkKHIxLCByMikpLCBGcDIuYWRkKHQxLCB0MikpKSksXG4gICAgICAgICAgICAvLyAoYzAgKyBjMSkgKiAocjAgKyByMSkgLSAoVDAgKyBUMSkgKyBUMiAqICh1ICsgMSlcbiAgICAgICAgICAgIGMxOiBGcDIuYWRkKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGMwLCBjMSksIEZwMi5hZGQocjAsIHIxKSksIEZwMi5hZGQodDAsIHQxKSksIEZwMi5tdWxCeU5vbnJlc2lkdWUodDIpKSxcbiAgICAgICAgICAgIC8vIFQxICsgKGMwICsgYzIpICogKHIwICsgcjIpIC0gVDAgKyBUMlxuICAgICAgICAgICAgYzI6IEZwMi5zdWIoRnAyLmFkZCh0MSwgRnAyLm11bChGcDIuYWRkKGMwLCBjMiksIEZwMi5hZGQocjAsIHIyKSkpLCBGcDIuYWRkKHQwLCB0MikpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgRnA2U3F1YXJlID0gKHsgYzAsIGMxLCBjMiB9KSA9PiB7XG4gICAgICAgIGxldCB0MCA9IEZwMi5zcXIoYzApOyAvLyBjMMKyXG4gICAgICAgIGxldCB0MSA9IEZwMi5tdWwoRnAyLm11bChjMCwgYzEpLCBfMm4pOyAvLyAyICogYzAgKiBjMVxuICAgICAgICBsZXQgdDMgPSBGcDIubXVsKEZwMi5tdWwoYzEsIGMyKSwgXzJuKTsgLy8gMiAqIGMxICogYzJcbiAgICAgICAgbGV0IHQ0ID0gRnAyLnNxcihjMik7IC8vIGMywrJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDIuYWRkKEZwMi5tdWxCeU5vbnJlc2lkdWUodDMpLCB0MCksIC8vIFQzICogKHUgKyAxKSArIFQwXG4gICAgICAgICAgICBjMTogRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKHQ0KSwgdDEpLCAvLyBUNCAqICh1ICsgMSkgKyBUMVxuICAgICAgICAgICAgLy8gVDEgKyAoYzAgLSBjMSArIGMyKcKyICsgVDMgLSBUMCAtIFQ0XG4gICAgICAgICAgICBjMjogRnAyLnN1YihGcDIuc3ViKEZwMi5hZGQoRnAyLmFkZCh0MSwgRnAyLnNxcihGcDIuYWRkKEZwMi5zdWIoYzAsIGMxKSwgYzIpKSksIHQzKSwgdDApLCB0NCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBbRlA2X0ZST0JFTklVU19DT0VGRklDSUVOVFNfMSwgRlA2X0ZST0JFTklVU19DT0VGRklDSUVOVFNfMl0gPSBjYWxjRnJvYmVuaXVzQ29lZmZpY2llbnRzKEZwMiwgRnAyTm9ucmVzaWR1ZSwgRnAuT1JERVIsIDYsIDIsIDMpO1xuICAgIGNvbnN0IEZwNiA9IHtcbiAgICAgICAgT1JERVI6IEZwMi5PUkRFUiwgLy8gVE9ETzogdW51c2VkLCBidXQgbmVlZCB0byB2ZXJpZnlcbiAgICAgICAgaXNMRTogRnAyLmlzTEUsXG4gICAgICAgIEJJVFM6IDMgKiBGcDIuQklUUyxcbiAgICAgICAgQllURVM6IDMgKiBGcDIuQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soMyAqIEZwMi5CSVRTKSxcbiAgICAgICAgWkVSTzogeyBjMDogRnAyLlpFUk8sIGMxOiBGcDIuWkVSTywgYzI6IEZwMi5aRVJPIH0sXG4gICAgICAgIE9ORTogeyBjMDogRnAyLk9ORSwgYzE6IEZwMi5aRVJPLCBjMjogRnAyLlpFUk8gfSxcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBudW0sXG4gICAgICAgIGlzVmFsaWQ6ICh7IGMwLCBjMSwgYzIgfSkgPT4gRnAyLmlzVmFsaWQoYzApICYmIEZwMi5pc1ZhbGlkKGMxKSAmJiBGcDIuaXNWYWxpZChjMiksXG4gICAgICAgIGlzMDogKHsgYzAsIGMxLCBjMiB9KSA9PiBGcDIuaXMwKGMwKSAmJiBGcDIuaXMwKGMxKSAmJiBGcDIuaXMwKGMyKSxcbiAgICAgICAgbmVnOiAoeyBjMCwgYzEsIGMyIH0pID0+ICh7IGMwOiBGcDIubmVnKGMwKSwgYzE6IEZwMi5uZWcoYzEpLCBjMjogRnAyLm5lZyhjMikgfSksXG4gICAgICAgIGVxbDogKHsgYzAsIGMxLCBjMiB9LCB7IGMwOiByMCwgYzE6IHIxLCBjMjogcjIgfSkgPT4gRnAyLmVxbChjMCwgcjApICYmIEZwMi5lcWwoYzEsIHIxKSAmJiBGcDIuZXFsKGMyLCByMiksXG4gICAgICAgIHNxcnQ6IG5vdEltcGxlbWVudGVkLFxuICAgICAgICAvLyBEbyB3ZSBuZWVkIGRpdmlzaW9uIGJ5IGJpZ2ludCBhdCBhbGw/IFNob3VsZCBiZSBkb25lIHZpYSBvcmRlcjpcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IEZwNi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IEZwLmludihGcC5jcmVhdGUocmhzKSkgOiBGcDYuaW52KHJocykpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBtb2QuRnBQb3coRnA2LCBudW0sIHBvd2VyKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChudW1zKSA9PiBtb2QuRnBJbnZlcnRCYXRjaChGcDYsIG51bXMpLFxuICAgICAgICAvLyBOb3JtYWxpemVkXG4gICAgICAgIGFkZDogRnA2QWRkLFxuICAgICAgICBzdWI6IEZwNlN1YnRyYWN0LFxuICAgICAgICBtdWw6IEZwNk11bHRpcGx5LFxuICAgICAgICBzcXI6IEZwNlNxdWFyZSxcbiAgICAgICAgLy8gTm9uTm9ybWFsaXplZCBzdHVmZlxuICAgICAgICBhZGROOiBGcDZBZGQsXG4gICAgICAgIHN1Yk46IEZwNlN1YnRyYWN0LFxuICAgICAgICBtdWxOOiBGcDZNdWx0aXBseSxcbiAgICAgICAgc3FyTjogRnA2U3F1YXJlLFxuICAgICAgICBpbnY6ICh7IGMwLCBjMSwgYzIgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHQwID0gRnAyLnN1YihGcDIuc3FyKGMwKSwgRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIubXVsKGMyLCBjMSkpKTsgLy8gYzDCsiAtIGMyICogYzEgKiAodSArIDEpXG4gICAgICAgICAgICBsZXQgdDEgPSBGcDIuc3ViKEZwMi5tdWxCeU5vbnJlc2lkdWUoRnAyLnNxcihjMikpLCBGcDIubXVsKGMwLCBjMSkpOyAvLyBjMsKyICogKHUgKyAxKSAtIGMwICogYzFcbiAgICAgICAgICAgIGxldCB0MiA9IEZwMi5zdWIoRnAyLnNxcihjMSksIEZwMi5tdWwoYzAsIGMyKSk7IC8vIGMxwrIgLSBjMCAqIGMyXG4gICAgICAgICAgICAvLyAxLygoKGMyICogVDEgKyBjMSAqIFQyKSAqIHYpICsgYzAgKiBUMClcbiAgICAgICAgICAgIGxldCB0NCA9IEZwMi5pbnYoRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKEZwMi5hZGQoRnAyLm11bChjMiwgdDEpLCBGcDIubXVsKGMxLCB0MikpKSwgRnAyLm11bChjMCwgdDApKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjMDogRnAyLm11bCh0NCwgdDApLCBjMTogRnAyLm11bCh0NCwgdDEpLCBjMjogRnAyLm11bCh0NCwgdDIpIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEJ5dGVzIHV0aWxzXG4gICAgICAgIGZyb21CeXRlczogKGIpID0+IHtcbiAgICAgICAgICAgIGlmIChiLmxlbmd0aCAhPT0gRnA2LkJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbUJ5dGVzIGludmFsaWQgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGMwOiBGcDIuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoMCwgRnAyLkJZVEVTKSksXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5mcm9tQnl0ZXMoYi5zdWJhcnJheShGcDIuQllURVMsIDIgKiBGcDIuQllURVMpKSxcbiAgICAgICAgICAgICAgICBjMjogRnAyLmZyb21CeXRlcyhiLnN1YmFycmF5KDIgKiBGcDIuQllURVMpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHRvQnl0ZXM6ICh7IGMwLCBjMSwgYzIgfSkgPT4gY29uY2F0Qnl0ZXMoRnAyLnRvQnl0ZXMoYzApLCBGcDIudG9CeXRlcyhjMSksIEZwMi50b0J5dGVzKGMyKSksXG4gICAgICAgIGNtb3Y6ICh7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0sIGMpID0+ICh7XG4gICAgICAgICAgICBjMDogRnAyLmNtb3YoYzAsIHIwLCBjKSxcbiAgICAgICAgICAgIGMxOiBGcDIuY21vdihjMSwgcjEsIGMpLFxuICAgICAgICAgICAgYzI6IEZwMi5jbW92KGMyLCByMiwgYyksXG4gICAgICAgIH0pLFxuICAgICAgICBmcm9tQmlnU2l4OiAodCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHQpIHx8IHQubGVuZ3RoICE9PSA2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBGcDYgdXNhZ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYzA6IEZwMi5mcm9tQmlnVHVwbGUodC5zbGljZSgwLCAyKSksXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5mcm9tQmlnVHVwbGUodC5zbGljZSgyLCA0KSksXG4gICAgICAgICAgICAgICAgYzI6IEZwMi5mcm9tQmlnVHVwbGUodC5zbGljZSg0LCA2KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBmcm9iZW5pdXNNYXA6ICh7IGMwLCBjMSwgYzIgfSwgcG93ZXIpID0+ICh7XG4gICAgICAgICAgICBjMDogRnAyLmZyb2Jlbml1c01hcChjMCwgcG93ZXIpLFxuICAgICAgICAgICAgYzE6IEZwMi5tdWwoRnAyLmZyb2Jlbml1c01hcChjMSwgcG93ZXIpLCBGUDZfRlJPQkVOSVVTX0NPRUZGSUNJRU5UU18xW3Bvd2VyICUgNl0pLFxuICAgICAgICAgICAgYzI6IEZwMi5tdWwoRnAyLmZyb2Jlbml1c01hcChjMiwgcG93ZXIpLCBGUDZfRlJPQkVOSVVTX0NPRUZGSUNJRU5UU18yW3Bvd2VyICUgNl0pLFxuICAgICAgICB9KSxcbiAgICAgICAgbXVsQnlGcDI6ICh7IGMwLCBjMSwgYzIgfSwgcmhzKSA9PiAoe1xuICAgICAgICAgICAgYzA6IEZwMi5tdWwoYzAsIHJocyksXG4gICAgICAgICAgICBjMTogRnAyLm11bChjMSwgcmhzKSxcbiAgICAgICAgICAgIGMyOiBGcDIubXVsKGMyLCByaHMpLFxuICAgICAgICB9KSxcbiAgICAgICAgbXVsQnlOb25yZXNpZHVlOiAoeyBjMCwgYzEsIGMyIH0pID0+ICh7IGMwOiBGcDIubXVsQnlOb25yZXNpZHVlKGMyKSwgYzE6IGMwLCBjMjogYzEgfSksXG4gICAgICAgIC8vIFNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgICAgICBtdWwxOiAoeyBjMCwgYzEsIGMyIH0sIGIxKSA9PiAoe1xuICAgICAgICAgICAgYzA6IEZwMi5tdWxCeU5vbnJlc2lkdWUoRnAyLm11bChjMiwgYjEpKSxcbiAgICAgICAgICAgIGMxOiBGcDIubXVsKGMwLCBiMSksXG4gICAgICAgICAgICBjMjogRnAyLm11bChjMSwgYjEpLFxuICAgICAgICB9KSxcbiAgICAgICAgLy8gU3BhcnNlIG11bHRpcGxpY2F0aW9uXG4gICAgICAgIG11bDAxKHsgYzAsIGMxLCBjMiB9LCBiMCwgYjEpIHtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwMi5tdWwoYzAsIGIwKTsgLy8gYzAgKiBiMFxuICAgICAgICAgICAgbGV0IHQxID0gRnAyLm11bChjMSwgYjEpOyAvLyBjMSAqIGIxXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vICgoYzEgKyBjMikgKiBiMSAtIFQxKSAqICh1ICsgMSkgKyBUMFxuICAgICAgICAgICAgICAgIGMwOiBGcDIuYWRkKEZwMi5tdWxCeU5vbnJlc2lkdWUoRnAyLnN1YihGcDIubXVsKEZwMi5hZGQoYzEsIGMyKSwgYjEpLCB0MSkpLCB0MCksXG4gICAgICAgICAgICAgICAgLy8gKGIwICsgYjEpICogKGMwICsgYzEpIC0gVDAgLSBUMVxuICAgICAgICAgICAgICAgIGMxOiBGcDIuc3ViKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGIwLCBiMSksIEZwMi5hZGQoYzAsIGMxKSksIHQwKSwgdDEpLFxuICAgICAgICAgICAgICAgIC8vIChjMCArIGMyKSAqIGIwIC0gVDAgKyBUMVxuICAgICAgICAgICAgICAgIGMyOiBGcDIuYWRkKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGMwLCBjMiksIGIwKSwgdDApLCB0MSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgLy8gRnAxMlxuICAgIGNvbnN0IEZQMTJfRlJPQkVOSVVTX0NPRUZGSUNJRU5UUyA9IGNhbGNGcm9iZW5pdXNDb2VmZmljaWVudHMoRnAyLCBGcDJOb25yZXNpZHVlLCBGcC5PUkRFUiwgMTIsIDEsIDYpWzBdO1xuICAgIGNvbnN0IEZwMTJBZGQgPSAoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSA9PiAoe1xuICAgICAgICBjMDogRnA2LmFkZChjMCwgcjApLFxuICAgICAgICBjMTogRnA2LmFkZChjMSwgcjEpLFxuICAgIH0pO1xuICAgIGNvbnN0IEZwMTJTdWJ0cmFjdCA9ICh7IGMwLCBjMSB9LCB7IGMwOiByMCwgYzE6IHIxIH0pID0+ICh7XG4gICAgICAgIGMwOiBGcDYuc3ViKGMwLCByMCksXG4gICAgICAgIGMxOiBGcDYuc3ViKGMxLCByMSksXG4gICAgfSk7XG4gICAgY29uc3QgRnAxMk11bHRpcGx5ID0gKHsgYzAsIGMxIH0sIHJocykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geyBjMDogRnA2Lm11bChjMCwgcmhzKSwgYzE6IEZwNi5tdWwoYzEsIHJocykgfTtcbiAgICAgICAgbGV0IHsgYzA6IHIwLCBjMTogcjEgfSA9IHJocztcbiAgICAgICAgbGV0IHQxID0gRnA2Lm11bChjMCwgcjApOyAvLyBjMCAqIHIwXG4gICAgICAgIGxldCB0MiA9IEZwNi5tdWwoYzEsIHIxKTsgLy8gYzEgKiByMVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwNi5hZGQodDEsIEZwNi5tdWxCeU5vbnJlc2lkdWUodDIpKSwgLy8gVDEgKyBUMiAqIHZcbiAgICAgICAgICAgIC8vIChjMCArIGMxKSAqIChyMCArIHIxKSAtIChUMSArIFQyKVxuICAgICAgICAgICAgYzE6IEZwNi5zdWIoRnA2Lm11bChGcDYuYWRkKGMwLCBjMSksIEZwNi5hZGQocjAsIHIxKSksIEZwNi5hZGQodDEsIHQyKSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBGcDEyU3F1YXJlID0gKHsgYzAsIGMxIH0pID0+IHtcbiAgICAgICAgbGV0IGFiID0gRnA2Lm11bChjMCwgYzEpOyAvLyBjMCAqIGMxXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyAoYzEgKiB2ICsgYzApICogKGMwICsgYzEpIC0gQUIgLSBBQiAqIHZcbiAgICAgICAgICAgIGMwOiBGcDYuc3ViKEZwNi5zdWIoRnA2Lm11bChGcDYuYWRkKEZwNi5tdWxCeU5vbnJlc2lkdWUoYzEpLCBjMCksIEZwNi5hZGQoYzAsIGMxKSksIGFiKSwgRnA2Lm11bEJ5Tm9ucmVzaWR1ZShhYikpLFxuICAgICAgICAgICAgYzE6IEZwNi5hZGQoYWIsIGFiKSxcbiAgICAgICAgfTsgLy8gQUIgKyBBQlxuICAgIH07XG4gICAgZnVuY3Rpb24gRnA0U3F1YXJlKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYTIgPSBGcDIuc3FyKGEpO1xuICAgICAgICBjb25zdCBiMiA9IEZwMi5zcXIoYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdDogRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKGIyKSwgYTIpLCAvLyBiwrIgKiBOb25yZXNpZHVlICsgYcKyXG4gICAgICAgICAgICBzZWNvbmQ6IEZwMi5zdWIoRnAyLnN1YihGcDIuc3FyKEZwMi5hZGQoYSwgYikpLCBhMiksIGIyKSwgLy8gKGEgKyBiKcKyIC0gYcKyIC0gYsKyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IEZwMTIgPSB7XG4gICAgICAgIE9SREVSOiBGcDIuT1JERVIsIC8vIFRPRE86IHVudXNlZCwgYnV0IG5lZWQgdG8gdmVyaWZ5XG4gICAgICAgIGlzTEU6IEZwNi5pc0xFLFxuICAgICAgICBCSVRTOiAyICogRnA2LkJJVFMsXG4gICAgICAgIEJZVEVTOiAyICogRnA2LkJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKDIgKiBGcDYuQklUUyksXG4gICAgICAgIFpFUk86IHsgYzA6IEZwNi5aRVJPLCBjMTogRnA2LlpFUk8gfSxcbiAgICAgICAgT05FOiB7IGMwOiBGcDYuT05FLCBjMTogRnA2LlpFUk8gfSxcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBudW0sXG4gICAgICAgIGlzVmFsaWQ6ICh7IGMwLCBjMSB9KSA9PiBGcDYuaXNWYWxpZChjMCkgJiYgRnA2LmlzVmFsaWQoYzEpLFxuICAgICAgICBpczA6ICh7IGMwLCBjMSB9KSA9PiBGcDYuaXMwKGMwKSAmJiBGcDYuaXMwKGMxKSxcbiAgICAgICAgbmVnOiAoeyBjMCwgYzEgfSkgPT4gKHsgYzA6IEZwNi5uZWcoYzApLCBjMTogRnA2Lm5lZyhjMSkgfSksXG4gICAgICAgIGVxbDogKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSkgPT4gRnA2LmVxbChjMCwgcjApICYmIEZwNi5lcWwoYzEsIHIxKSxcbiAgICAgICAgc3FydDogbm90SW1wbGVtZW50ZWQsXG4gICAgICAgIGludjogKHsgYzAsIGMxIH0pID0+IHtcbiAgICAgICAgICAgIGxldCB0ID0gRnA2LmludihGcDYuc3ViKEZwNi5zcXIoYzApLCBGcDYubXVsQnlOb25yZXNpZHVlKEZwNi5zcXIoYzEpKSkpOyAvLyAxIC8gKGMwwrIgLSBjMcKyICogdilcbiAgICAgICAgICAgIHJldHVybiB7IGMwOiBGcDYubXVsKGMwLCB0KSwgYzE6IEZwNi5uZWcoRnA2Lm11bChjMSwgdCkpIH07IC8vICgoQzAgKiBUKSAqIFQpICsgKC1DMSAqIFQpICogd1xuICAgICAgICB9LFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gRnAxMi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IEZwLmludihGcC5jcmVhdGUocmhzKSkgOiBGcDEyLmludihyaHMpKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gbW9kLkZwUG93KEZwMTIsIG51bSwgcG93ZXIpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKG51bXMpID0+IG1vZC5GcEludmVydEJhdGNoKEZwMTIsIG51bXMpLFxuICAgICAgICAvLyBOb3JtYWxpemVkXG4gICAgICAgIGFkZDogRnAxMkFkZCxcbiAgICAgICAgc3ViOiBGcDEyU3VidHJhY3QsXG4gICAgICAgIG11bDogRnAxMk11bHRpcGx5LFxuICAgICAgICBzcXI6IEZwMTJTcXVhcmUsXG4gICAgICAgIC8vIE5vbk5vcm1hbGl6ZWQgc3R1ZmZcbiAgICAgICAgYWRkTjogRnAxMkFkZCxcbiAgICAgICAgc3ViTjogRnAxMlN1YnRyYWN0LFxuICAgICAgICBtdWxOOiBGcDEyTXVsdGlwbHksXG4gICAgICAgIHNxck46IEZwMTJTcXVhcmUsXG4gICAgICAgIC8vIEJ5dGVzIHV0aWxzXG4gICAgICAgIGZyb21CeXRlczogKGIpID0+IHtcbiAgICAgICAgICAgIGlmIChiLmxlbmd0aCAhPT0gRnAxMi5CWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21CeXRlcyBpbnZhbGlkIGxlbmd0aD0nICsgYi5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjMDogRnA2LmZyb21CeXRlcyhiLnN1YmFycmF5KDAsIEZwNi5CWVRFUykpLFxuICAgICAgICAgICAgICAgIGMxOiBGcDYuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoRnA2LkJZVEVTKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB0b0J5dGVzOiAoeyBjMCwgYzEgfSkgPT4gY29uY2F0Qnl0ZXMoRnA2LnRvQnl0ZXMoYzApLCBGcDYudG9CeXRlcyhjMSkpLFxuICAgICAgICBjbW92OiAoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9LCBjKSA9PiAoe1xuICAgICAgICAgICAgYzA6IEZwNi5jbW92KGMwLCByMCwgYyksXG4gICAgICAgICAgICBjMTogRnA2LmNtb3YoYzEsIHIxLCBjKSxcbiAgICAgICAgfSksXG4gICAgICAgIC8vIFV0aWxzXG4gICAgICAgIC8vIHRvU3RyaW5nKCkge1xuICAgICAgICAvLyAgIHJldHVybiAnJyArICdGcDEyKCcgKyB0aGlzLmMwICsgdGhpcy5jMSArICcqIHcnKTtcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gZnJvbVR1cGxlKGM6IFtGcDYsIEZwNl0pIHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IEZwMTIoLi4uYyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgZnJvbUJpZ1R3ZWx2ZTogKHQpID0+ICh7XG4gICAgICAgICAgICBjMDogRnA2LmZyb21CaWdTaXgodC5zbGljZSgwLCA2KSksXG4gICAgICAgICAgICBjMTogRnA2LmZyb21CaWdTaXgodC5zbGljZSg2LCAxMikpLFxuICAgICAgICB9KSxcbiAgICAgICAgLy8gUmFpc2VzIHRvIHEqKmkgLXRoIHBvd2VyXG4gICAgICAgIGZyb2Jlbml1c01hcChsaHMsIHBvd2VyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGMwLCBjMSwgYzIgfSA9IEZwNi5mcm9iZW5pdXNNYXAobGhzLmMxLCBwb3dlcik7XG4gICAgICAgICAgICBjb25zdCBjb2VmZiA9IEZQMTJfRlJPQkVOSVVTX0NPRUZGSUNJRU5UU1twb3dlciAlIDEyXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYzA6IEZwNi5mcm9iZW5pdXNNYXAobGhzLmMwLCBwb3dlciksXG4gICAgICAgICAgICAgICAgYzE6IEZwNi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjMDogRnAyLm11bChjMCwgY29lZmYpLFxuICAgICAgICAgICAgICAgICAgICBjMTogRnAyLm11bChjMSwgY29lZmYpLFxuICAgICAgICAgICAgICAgICAgICBjMjogRnAyLm11bChjMiwgY29lZmYpLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVsQnlGcDI6ICh7IGMwLCBjMSB9LCByaHMpID0+ICh7XG4gICAgICAgICAgICBjMDogRnA2Lm11bEJ5RnAyKGMwLCByaHMpLFxuICAgICAgICAgICAgYzE6IEZwNi5tdWxCeUZwMihjMSwgcmhzKSxcbiAgICAgICAgfSksXG4gICAgICAgIGNvbmp1Z2F0ZTogKHsgYzAsIGMxIH0pID0+ICh7IGMwLCBjMTogRnA2Lm5lZyhjMSkgfSksXG4gICAgICAgIC8vIFNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgICAgICBtdWwwMTQ6ICh7IGMwLCBjMSB9LCBvMCwgbzEsIG80KSA9PiB7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcDYubXVsMDEoYzAsIG8wLCBvMSk7XG4gICAgICAgICAgICBsZXQgdDEgPSBGcDYubXVsMShjMSwgbzQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjMDogRnA2LmFkZChGcDYubXVsQnlOb25yZXNpZHVlKHQxKSwgdDApLCAvLyBUMSAqIHYgKyBUMFxuICAgICAgICAgICAgICAgIC8vIChjMSArIGMwKSAqIFtvMCwgbzErbzRdIC0gVDAgLSBUMVxuICAgICAgICAgICAgICAgIGMxOiBGcDYuc3ViKEZwNi5zdWIoRnA2Lm11bDAxKEZwNi5hZGQoYzEsIGMwKSwgbzAsIEZwMi5hZGQobzEsIG80KSksIHQwKSwgdDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVsMDM0OiAoeyBjMCwgYzEgfSwgbzAsIG8zLCBvNCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IEZwNi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGMwOiBGcDIubXVsKGMwLmMwLCBvMCksXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5tdWwoYzAuYzEsIG8wKSxcbiAgICAgICAgICAgICAgICBjMjogRnAyLm11bChjMC5jMiwgbzApLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBiID0gRnA2Lm11bDAxKGMxLCBvMywgbzQpO1xuICAgICAgICAgICAgY29uc3QgZSA9IEZwNi5tdWwwMShGcDYuYWRkKGMwLCBjMSksIEZwMi5hZGQobzAsIG8zKSwgbzQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjMDogRnA2LmFkZChGcDYubXVsQnlOb25yZXNpZHVlKGIpLCBhKSxcbiAgICAgICAgICAgICAgICBjMTogRnA2LnN1YihlLCBGcDYuYWRkKGEsIGIpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEEgY3ljbG90b21pYyBncm91cCBpcyBhIHN1Ymdyb3VwIG9mIEZwXm4gZGVmaW5lZCBieVxuICAgICAgICAvLyAgIEfOpuKCmShwKSA9IHvOsSDiiIggRnDigb8gOiDOsV7OpuKCmShwKSA9IDF9XG4gICAgICAgIC8vIFRoZSByZXN1bHQgb2YgYW55IHBhaXJpbmcgaXMgaW4gYSBjeWNsb3RvbWljIHN1Ymdyb3VwXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMDkvNTY1LnBkZlxuICAgICAgICBfY3ljbG90b21pY1NxdWFyZTogb3B0cy5GcDEyY3ljbG90b21pY1NxdWFyZSxcbiAgICAgICAgX2N5Y2xvdG9taWNFeHA6IG9wdHMuRnAxMmN5Y2xvdG9taWNFeHAsXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvMzU0LnBkZlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDA5LzU2NS5wZGZcbiAgICAgICAgZmluYWxFeHBvbmVudGlhdGU6IG9wdHMuRnAxMmZpbmFsRXhwb25lbnRpYXRlLFxuICAgIH07XG4gICAgcmV0dXJuIHsgRnAsIEZwMiwgRnA2LCBGcDRTcXVhcmUsIEZwMTIgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvd2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/abstract/tower.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js":
/*!***************************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_1n << BigInt(n)) - _1n;\n// DRBG\nconst u8n = (len) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ087QUFDUDtBQUNBLDBDQUEwQztBQUMxQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQ25ELDhEQUE4RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsV0FBVyxZQUFZLElBQUk7QUFDcEQsa0NBQWtDLG9CQUFvQixJQUFJLGFBQWEsR0FBRztBQUMxRTtBQUNBLGtDQUFrQyxVQUFVLElBQUksU0FBUztBQUN6RCxrQ0FBa0Msb0JBQW9CLElBQUksU0FBUztBQUNuRSxrQ0FBa0MsMkJBQTJCO0FBQzdELGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcz81MzJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGV4LCBieXRlcyBhbmQgbnVtYmVyIHV0aWxpdGllcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXMoaXRlbSkge1xuICAgIGlmICghaXNCeXRlcyhpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWJvb2wodGl0bGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIGJvb2xlYW4gZXhwZWN0ZWQsIGdvdCAnICsgdmFsdWUpO1xufVxuLy8gVXNlZCBpbiB3ZWllcnN0cmFzcywgZGVyXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/ICcwJyArIGhleCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICByZXR1cm4gaGV4ID09PSAnJyA/IF8wbiA6IEJpZ0ludCgnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxufVxuLy8gQnVpbHQtaW4gaGV4IGNvbnZlcnNpb24gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc191aW50OGFycmF5X2Zyb21oZXhcbmNvbnN0IGhhc0hleEJ1aWx0aW4gPSBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbic7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjYXVzZTogJyArIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXMoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBvZiBsZW5ndGggJyArIGV4cGVjdGVkTGVuZ3RoICsgJyBleHBlY3RlZCwgZ290ICcgKyBsZW4pO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBJcyBwb3NpdGl2ZSBiaWdpbnRcbmNvbnN0IGlzUG9zQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPD0gbjtcbmV4cG9ydCBmdW5jdGlvbiBpblJhbmdlKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGlzUG9zQmlnKG4pICYmIGlzUG9zQmlnKG1pbikgJiYgaXNQb3NCaWcobWF4KSAmJiBtaW4gPD0gbiAmJiBuIDwgbWF4O1xufVxuLyoqXG4gKiBBc3NlcnRzIG1pbiA8PSBuIDwgbWF4LiBOT1RFOiBJdCdzIDwgbWF4IGFuZCBub3QgPD0gbWF4LlxuICogQGV4YW1wbGVcbiAqIGFJblJhbmdlKCd4JywgeCwgMW4sIDI1Nm4pOyAvLyB3b3VsZCBhc3N1bWUgeCBpcyBpbiAoMW4uLjI1NW4pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhSW5SYW5nZSh0aXRsZSwgbiwgbWluLCBtYXgpIHtcbiAgICAvLyBXaHkgbWluIDw9IG4gPCBtYXggYW5kIG5vdCBhIChtaW4gPCBuIDwgbWF4KSBPUiBiIChtaW4gPD0gbiA8PSBtYXgpP1xuICAgIC8vIGNvbnNpZGVyIFA9MjU2biwgbWluPTBuLCBtYXg9UFxuICAgIC8vIC0gYSBmb3IgbWluPTAgd291bGQgcmVxdWlyZSAtMTogICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAtMW4sIFApYFxuICAgIC8vIC0gYiB3b3VsZCBjb21tb25seSByZXF1aXJlIHN1YnRyYWN0aW9uOiAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUCAtIDFuKWBcbiAgICAvLyAtIG91ciB3YXkgaXMgdGhlIGNsZWFuZXN0OiAgICAgICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgMG4sIFApXG4gICAgaWYgKCFpblJhbmdlKG4sIG1pbiwgbWF4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCAnICsgdGl0bGUgKyAnOiAnICsgbWluICsgJyA8PSBuIDwgJyArIG1heCArICcsIGdvdCAnICsgbik7XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKiBUT0RPOiBtZXJnZSB3aXRoIG5MZW5ndGggaW4gbW9kdWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8xbiA8PCBCaWdJbnQobikpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oMCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXModmFsKSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW0gJyArIFN0cmluZyhmaWVsZE5hbWUpICsgJyBpcyBpbnZhbGlkLiBFeHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8qKlxuICogdGhyb3dzIG5vdCBpbXBsZW1lbnRlZCBlcnJvclxuICovXG5leHBvcnQgY29uc3Qgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG4vKipcbiAqIE1lbW9pemVzIChjYWNoZXMpIGNvbXB1dGF0aW9uIHJlc3VsdC5cbiAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuICAgICAgICBtYXAuc2V0KGFyZywgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\n\n// prettier-ignore\n\n// prettier-ignore\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowInfinityPoint: 'boolean',\n        allowedPrivateKeyLengths: 'array',\n        clearCofactor: 'function',\n        fromBytes: 'function',\n        isTorsionFree: 'function',\n        toBytes: 'function',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endo: CURVE.a must be 0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)((len.length / 2) | 128) : '';\n            const t = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\nfunction numToSizedHex(num, size) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, size));\n}\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n    }\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(key))\n                key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(num, N); // disabled by default, enabled for BLS\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z)  (x=X/Z, y=Y/Z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py) || Fp.is0(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(Fp, points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            /** See docs for {@link EndomorphismOpts} */\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.toRawBytes(isCompressed));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const { endo, nBitLength } = CURVE;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(tail);\n                if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('r', r, _1n, CURVE_ORDER); // r in [1..N]\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('s', s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */\n        assertValidity() { }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(this.toCompactHex());\n        }\n        toCompactHex() {\n            const l = nByteLength;\n            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength)(CURVE.n);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const arr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('key', item);\n        const len = arr.length;\n        const fpl = Fp.BYTES;\n        const compLen = fpl + 1; // e.g. 33 for 32\n        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n            return undefined;\n        }\n        else {\n            return len === compLen || len === uncompLen;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicB) === false)\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('num < 2^' + nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg)(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEQ7QUFDNUQ7QUFDa0g7QUFDbEg7QUFDMk47QUFDM047QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOERBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4REFBbUI7QUFDOUQsc0JBQXNCLDhEQUFtQjtBQUN6QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENB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LGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDeEQsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QixzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUNoRCx1Q0FBdUM7QUFDdkMsd0JBQXdCLDBEQUFhO0FBQ3JDLGdDQUFnQztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/MTZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlIG1ldGhvZHMuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGIuXG4gKlxuICogIyMjIFBhcmFtZXRlcnNcbiAqXG4gKiBUbyBpbml0aWFsaXplIGEgd2VpZXJzdHJhc3MgY3VydmUsIG9uZSBuZWVkcyB0byBwYXNzIGZvbGxvd2luZyBwYXJhbXM6XG4gKlxuICogKiBhOiBmb3JtdWxhIHBhcmFtXG4gKiAqIGI6IGZvcm11bGEgcGFyYW1cbiAqICogRnA6IGZpbml0ZSBmaWVsZCBvZiBwcmltZSBjaGFyYWN0ZXJpc3RpYyBQOyBtYXkgYmUgY29tcGxleCAoRnAyKS4gQXJpdGhtZXRpY3MgaXMgZG9uZSBpbiBmaWVsZFxuICogKiBuOiBvcmRlciBvZiBwcmltZSBzdWJncm91cCBhLmsuYSB0b3RhbCBhbW91bnQgb2YgdmFsaWQgY3VydmUgcG9pbnRzXG4gKiAqIEd4OiBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50LiBHeCA9IHggY29vcmRpbmF0ZVxuICogKiBHeTogLi4ueSBjb29yZGluYXRlXG4gKiAqIGg6IGNvZmFjdG9yLCB1c3VhbGx5IDEuIGgqbiA9IGN1cnZlIGdyb3VwIG9yZGVyIChuIGlzIG9ubHkgc3ViZ3JvdXAgb3JkZXIpXG4gKiAqIGxvd1M6IHdoZXRoZXIgdG8gZW5hYmxlIChkZWZhdWx0KSBvciBkaXNhYmxlIFwibG93LXNcIiBub24tbWFsbGVhYmxlIHNpZ25hdHVyZXNcbiAqXG4gKiAjIyMgRGVzaWduIHJhdGlvbmFsZSBmb3IgdHlwZXNcbiAqXG4gKiAqIEludGVyYWN0aW9uIGJldHdlZW4gY2xhc3NlcyBmcm9tIGRpZmZlcmVudCBjdXJ2ZXMgc2hvdWxkIGZhaWw6XG4gKiAgIGBrMjU2LlBvaW50LkJBU0UuYWRkKHAyNTYuUG9pbnQuQkFTRSlgXG4gKiAqIEZvciB0aGlzIHB1cnBvc2Ugd2Ugd2FudCB0byB1c2UgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLCB3aGljaCBpcyBmYXN0IGFuZCB3b3JrcyBkdXJpbmcgcnVudGltZVxuICogKiBEaWZmZXJlbnQgY2FsbHMgb2YgYGN1cnZlKClgIHdvdWxkIHJldHVybiBkaWZmZXJlbnQgY2xhc3NlcyAtXG4gKiAgIGBjdXJ2ZShwYXJhbXMpICE9PSBjdXJ2ZShwYXJhbXMpYDogaWYgc29tZWJvZHkgZGVjaWRlZCB0byBtb25rZXktcGF0Y2ggdGhlaXIgY3VydmUsXG4gKiAgIGl0IHdvbid0IGFmZmVjdCBvdGhlcnNcbiAqXG4gKiBUeXBlU2NyaXB0IGNhbid0IGluZmVyIHR5cGVzIGZvciBjbGFzc2VzIGNyZWF0ZWQgaW5zaWRlIGEgZnVuY3Rpb24uIENsYXNzZXMgaXMgb25lIGluc3RhbmNlXG4gKiBvZiBub21pbmF0aXZlIHR5cGVzIGluIFR5cGVTY3JpcHQgYW5kIGludGVyZmFjZXMgb25seSBjaGVjayBmb3Igc2hhcGUsIHNvIGl0J3MgaGFyZCB0byBjcmVhdGVcbiAqIHVuaXF1ZSB0eXBlIGZvciBldmVyeSBmdW5jdGlvbiBjYWxsLlxuICpcbiAqIFdlIGNhbiB1c2UgZ2VuZXJpYyB0eXBlcyB2aWEgc29tZSBwYXJhbSwgbGlrZSBjdXJ2ZSBvcHRzLCBidXQgdGhhdCB3b3VsZDpcbiAqICAgICAxLiBFbmFibGUgaW50ZXJhY3Rpb24gYmV0d2VlbiBgY3VydmUocGFyYW1zKWAgYW5kIGBjdXJ2ZShwYXJhbXMpYCAoY3VydmVzIG9mIHNhbWUgcGFyYW1zKVxuICogICAgIHdoaWNoIGlzIGhhcmQgdG8gZGVidWcuXG4gKiAgICAgMi4gUGFyYW1zIGNhbiBiZSBnZW5lcmljIGFuZCB3ZSBjYW4ndCBlbmZvcmNlIHRoZW0gdG8gYmUgY29uc3RhbnQgdmFsdWU6XG4gKiAgICAgaWYgc29tZWJvZHkgY3JlYXRlcyBjdXJ2ZSBmcm9tIG5vbi1jb25zdGFudCBwYXJhbXMsXG4gKiAgICAgaXQgd291bGQgYmUgYWxsb3dlZCB0byBpbnRlcmFjdCB3aXRoIG90aGVyIGN1cnZlcyB3aXRoIG5vbi1jb25zdGFudCBwYXJhbXNcbiAqXG4gKiBAdG9kbyBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi03Lmh0bWwjdW5pcXVlLXN5bWJvbFxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IHBpcHBlbmdlciwgdmFsaWRhdGVCYXNpYywgd05BRiB9IGZyb20gXCIuL2N1cnZlLmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IEZpZWxkLCBGcEludmVydEJhdGNoLCBnZXRNaW5IYXNoTGVuZ3RoLCBpbnZlcnQsIG1hcEhhc2hUb0ZpZWxkLCBtb2QsIHZhbGlkYXRlRmllbGQgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGFJblJhbmdlLCBhYm9vbCwgYml0TWFzaywgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgY3JlYXRlSG1hY0RyYmcsIGVuc3VyZUJ5dGVzLCBoZXhUb0J5dGVzLCBpblJhbmdlLCBpc0J5dGVzLCBtZW1vaXplZCwgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0hleFVucGFkZGVkLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cykge1xuICAgIGlmIChvcHRzLmxvd1MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvb2woJ2xvd1MnLCBvcHRzLmxvd1MpO1xuICAgIGlmIChvcHRzLnByZWhhc2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvb2woJ3ByZWhhc2gnLCBvcHRzLnByZWhhc2gpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbmRvOiBDVVJWRS5hIG11c3QgYmUgMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IGV4cGVjdGVkIFwiYmV0YVwiOiBiaWdpbnQgYW5kIFwic3BsaXRTY2FsYXJcIjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG5leHBvcnQgY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICBzdXBlcihtKTtcbiAgICB9XG59XG4vKipcbiAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG4gKlxuICogICAgIFsweDMwIChTRVFVRU5DRSksIGJ5dGVsZW5ndGgsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFIsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFNdXG4gKlxuICogRG9jczogaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvZG9jcy9hLXdhcm0td2VsY29tZS10by1hc24xLWFuZC1kZXIvLCBodHRwczovL2x1Y2EubnRvcC5vcmcvVGVhY2hpbmcvQXBwdW50aS9hc24xLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IERFUkVycixcbiAgICAvLyBCYXNpYyBidWlsZGluZyBibG9jayBpcyBUTFYgKFRhZy1MZW5ndGgtVmFsdWUpXG4gICAgX3Rsdjoge1xuICAgICAgICBlbmNvZGU6ICh0YWcsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoZGF0YUxlbik7XG4gICAgICAgICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyBudW1iZXJUb0hleFVucGFkZGVkKChsZW4ubGVuZ3RoIC8gMikgfCAxMjgpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0ID0gbnVtYmVyVG9IZXhVbnBhZGRlZCh0YWcpO1xuICAgICAgICAgICAgcmV0dXJuIHQgKyBsZW5MZW4gKyBsZW4gKyBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICAgICAgZGVjb2RlKHRhZywgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVtwb3MrK10gIT09IHRhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdGx2Jyk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgaXNMb25nID0gISEoZmlyc3QgJiAxMjgpOyAvLyBGaXJzdCBiaXQgb2YgZmlyc3QgbGVuZ3RoIGJ5dGUgaXMgZmxhZyBmb3Igc2hvcnQvbG9uZyBmb3JtXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICghaXNMb25nKVxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZpcnN0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9uZyBmb3JtOiBbbG9uZ0ZsYWcoMWJpdCksIGxlbmd0aExlbmd0aCg3Yml0KSwgbGVuZ3RoIChCRSldXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZmlyc3QgJiAxMjc7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbkxlbiA+IDQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBieXRlIGxlbmd0aCBpcyB0b28gYmlnJyk7IC8vIHRoaXMgd2lsbCBvdmVyZmxvdyB1MzIgaW4ganNcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5MZW4pO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlcy5sZW5ndGggIT09IGxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXNbMF0gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiB6ZXJvIGxlZnRtb3N0IGJ5dGUnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbGVuZ3RoQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggPDwgOCkgfCBiO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW5MZW47XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDEyOClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodi5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdmFsdWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm4geyB2LCBsOiBkYXRhLnN1YmFycmF5KHBvcyArIGxlbmd0aCkgfTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICBfaW50OiB7XG4gICAgICAgIGVuY29kZShudW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAobnVtIDwgXzBuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGxldCBoZXggPSBudW1iZXJUb0hleFVucGFkZGVkKG51bSk7XG4gICAgICAgICAgICAvLyBQYWQgd2l0aCB6ZXJvIGJ5dGUgaWYgbmVnYXRpdmUgZmxhZyBpcyBwcmVzZW50XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGhleFswXSwgMTYpICYgMGIxMDAwKVxuICAgICAgICAgICAgICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3VuZXhwZWN0ZWQgREVSIHBhcnNpbmcgYXNzZXJ0aW9uOiB1bnBhZGRlZCBoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvTnVtYmVyQkUoZGF0YSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSwgX2ludDogaW50LCBfdGx2OiB0bHYgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBoZXgpO1xuICAgICAgICBjb25zdCB7IHY6IHNlcUJ5dGVzLCBsOiBzZXFMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgzMCwgZGF0YSk7XG4gICAgICAgIGlmIChzZXFMZWZ0Qnl0ZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgY29uc3QgeyB2OiByQnl0ZXMsIGw6IHJMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgc2VxQnl0ZXMpO1xuICAgICAgICBjb25zdCB7IHY6IHNCeXRlcywgbDogc0xlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCByTGVmdEJ5dGVzKTtcbiAgICAgICAgaWYgKHNMZWZ0Qnl0ZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgcjogaW50LmRlY29kZShyQnl0ZXMpLCBzOiBpbnQuZGVjb2RlKHNCeXRlcykgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIGNvbnN0IHsgX3RsdjogdGx2LCBfaW50OiBpbnQgfSA9IERFUjtcbiAgICAgICAgY29uc3QgcnMgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc3MgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnMpKTtcbiAgICAgICAgY29uc3Qgc2VxID0gcnMgKyBzcztcbiAgICAgICAgcmV0dXJuIHRsdi5lbmNvZGUoMHgzMCwgc2VxKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIG51bVRvU2l6ZWRIZXgobnVtLCBzaXplKSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgobnVtYmVyVG9CeXRlc0JFKG51bSwgc2l6ZSkpO1xufVxuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCBGbiA9IEZpZWxkKENVUlZFLm4sIENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhLiBUYWtlcyB4LCByZXR1cm5zIHnCsi5cbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geMKyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHjCsyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkWFkoeCwgeSkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFRlc3QgMTogZXF1YXRpb24gecKyID0geMKzICsgYXggKyBiIHNob3VsZCB3b3JrIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgaWYgKCFpc1ZhbGlkWFkoQ1VSVkUuR3gsIENVUlZFLkd5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBnZW5lcmF0b3IgcG9pbnQnKTtcbiAgICAvLyBUZXN0IDI6IGRpc2NyaW1pbmFudCDOlCBwYXJ0IHNob3VsZCBiZSBub24temVybzogNGHCsyArIDI3YsKyICE9IDAuXG4gICAgLy8gR3VhcmFudGVlcyBjdXJ2ZSBpcyBnZW51cy0xLCBzbW9vdGggKG5vbi1zaW5ndWxhcikuXG4gICAgY29uc3QgXzRhMyA9IEZwLm11bChGcC5wb3coQ1VSVkUuYSwgXzNuKSwgXzRuKTtcbiAgICBjb25zdCBfMjdiMiA9IEZwLm11bChGcC5zcXIoQ1VSVkUuYiksIEJpZ0ludCgyNykpO1xuICAgIGlmIChGcC5pczAoRnAuYWRkKF80YTMsIF8yN2IyKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogYSBvciBiJyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIGluUmFuZ2UobnVtLCBfMW4sIENVUlZFLm4pO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoaXNCeXRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIGtleSA9IGJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiBieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5LCBleHBlY3RlZCBoZXggb3IgJyArIG5CeXRlTGVuZ3RoICsgJyBieXRlcywgZ290ICcgKyB0eXBlb2Yga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QobnVtLCBOKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFJblJhbmdlKCdwcml2YXRlIGtleScsIG51bSwgXzFuLCBOKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcmpwb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIE1lbW9pemVkIHRvQWZmaW5lIC8gdmFsaWRpdHkgY2hlY2suIFRoZXkgYXJlIGhlYXZ5LiBQb2ludHMgYXJlIGltbXV0YWJsZS5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKFgsIFksIFopIOKIiyAoeD1YL1osIHk9WS9aKVxuICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9IG1lbW9pemVkKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHA7XG4gICAgICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICAgICAgaWYgKEZwLmVxbCh6LCBGcC5PTkUpKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkWFkoeCwgeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICBpZiAoIXAuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoWCwgWSwgWikg4oiLICh4PVgvWiwgeT1ZL1opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpIHx8IEZwLmlzMChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwSW52ZXJ0QmF0Y2goRnAsIHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhcHJqcG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIG4sIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShzYykge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGFJblJhbmdlKCdzY2FsYXInLCBzYywgXzBuLCBOKTtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKHNjID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSB8fCBzYyA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgLy8gQ2FzZSBhOiBubyBlbmRvbW9ycGhpc20uIENhc2UgYjogaGFzIHByZWNvbXB1dGVzLlxuICAgICAgICAgICAgaWYgKCFlbmRvIHx8IHduYWYuaGFzUHJlY29tcHV0ZXModGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZFVuc2FmZSh0aGlzLCBzYywgUG9pbnQubm9ybWFsaXplWik7XG4gICAgICAgICAgICAvLyBDYXNlIGM6IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgLyoqIFNlZSBkb2NzIGZvciB7QGxpbmsgRW5kb21vcnBoaXNtT3B0c30gKi9cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBhSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICAvKiogU2VlIGRvY3MgZm9yIHtAbGluayBFbmRvbW9ycGhpc21PcHRzfSAqL1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjYWxhcik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaXopO1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICBhYm9vbCgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJhc2UgLyBnZW5lcmF0b3IgcG9pbnRcbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICAvLyB6ZXJvIC8gaW5maW5pdHkgLyBpZGVudGl0eSBwb2ludFxuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTsgLy8gMCwgMSwgMFxuICAgIGNvbnN0IHsgZW5kbywgbkJpdExlbmd0aCB9ID0gQ1VSVkU7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIGVuZG8gPyBNYXRoLmNlaWwobkJpdExlbmd0aCAvIDIpIDogbkJpdExlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGFuZCBFQ0RTQSBzaWduYXR1cmUgbWV0aG9kcyBmb3IgaXQuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRmllbGQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuICogLy8gQmVmb3JlIHRoYXQsIGRlZmluZSBCaWdJbnQtczogYSwgYiwgcCwgbiwgR3gsIEd5XG4gKiBjb25zdCBjdXJ2ZSA9IHdlaWVyc3RyYXNzKHsgYSwgYiwgRnA6IEZpZWxkKHApLCBuLCBHeCwgR3ksIGg6IDFuIH0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiwgbkJ5dGVMZW5ndGgsIG5CaXRMZW5ndGggfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSBjb25jYXRCeXRlcztcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluUmFuZ2UoeCwgXzFuLCBGcC5PUkRFUikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbCA9IGNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgY29uc3QgdWwgPSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFBvaW50LCBleHBlY3RlZCBsZW5ndGggb2YgJyArIGNsICsgJywgb3IgdW5jb21wcmVzc2VkICcgKyB1bCArICcsIGdvdCAnICsgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiBieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIGFJblJhbmdlKCdyJywgciwgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHIgaW4gWzEuLk5dXG4gICAgICAgICAgICBhSW5SYW5nZSgncycsIHMsIF8xbiwgQ1VSVkVfT1JERVIpOyAvLyBzIGluIFsxLi5OXVxuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICBpZiAocmVjb3ZlcnkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBuQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdG9kbyByZW1vdmVcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkgeyB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9TaXplZEhleChyYWRqLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBuQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub1NpemVkSGV4KHRoaXMuciwgbCkgKyBudW1Ub1NpemVkSGV4KHRoaXMucywgbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBhcnIgPSBlbnN1cmVCeXRlcygna2V5JywgaXRlbSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZwbCA9IEZwLkJZVEVTO1xuICAgICAgICBjb25zdCBjb21wTGVuID0gZnBsICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICAgICAgY29uc3QgdW5jb21wTGVuID0gMiAqIGZwbCArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgICAgIGlmIChDVVJWRS5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgfHwgbkJ5dGVMZW5ndGggPT09IGNvbXBMZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wTGVuIHx8IGxlbiA9PT0gdW5jb21wTGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpID09PSB0cnVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoaXNQcm9iUHViKHB1YmxpY0IpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBPdXIgY3VzdG9tIGNoZWNrIFwianVzdCBpbiBjYXNlXCIsIGZvciBwcm90ZWN0aW9uIGFnYWluc3QgRG9TXG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gODE5MilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IGlzIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIG5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IGJpdE1hc2sobkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBhSW5SYW5nZSgnbnVtIDwgMl4nICsgbkJpdExlbmd0aCwgbnVtLCBfMG4sIE9SREVSX01BU0spO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobnVtLCBuQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlcixcbiAgICAvLyB0aGlzIHdpbGwgYmUgaW52YWxpZCBhdCBsZWFzdCBmb3IgUDUyMS4gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsICYmIGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IGNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGZvcm1hdCB9ID0gb3B0cztcbiAgICAgICAgLy8gVmVyaWZ5IG9wdHMsIGRlZHVjZSBzaWduYXR1cmUgZm9ybWF0XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIGZvcm1hdCAhPT0gJ2NvbXBhY3QnICYmIGZvcm1hdCAhPT0gJ2RlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBtdXN0IGJlIGNvbXBhY3Qgb3IgZGVyJyk7XG4gICAgICAgIGNvbnN0IGlzSGV4ID0gdHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHNnKTtcbiAgICAgICAgY29uc3QgaXNPYmogPSAhaXNIZXggJiZcbiAgICAgICAgICAgICFmb3JtYXQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNnICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5zID09PSAnYmlnaW50JztcbiAgICAgICAgaWYgKCFpc0hleCAmJiAhaXNPYmopXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBVaW50OEFycmF5LCBoZXggc3RyaW5nIG9yIFNpZ25hdHVyZSBpbnN0YW5jZScpO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNPYmopXG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUoc2cuciwgc2cucyk7XG4gICAgICAgICAgICBpZiAoaXNIZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSAnY29tcGFjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV9zaWcgJiYgZm9ybWF0ICE9PSAnZGVyJylcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3NpZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTV1VGcFNxcnRSYXRpbyhGcCwgWikge1xuICAgIC8vIEdlbmVyaWMgaW1wbGVtZW50YXRpb25cbiAgICBjb25zdCBxID0gRnAuT1JERVI7XG4gICAgbGV0IGwgPSBfMG47XG4gICAgZm9yIChsZXQgbyA9IHEgLSBfMW47IG8gJSBfMm4gPT09IF8wbjsgbyAvPSBfMm4pXG4gICAgICAgIGwgKz0gXzFuO1xuICAgIGNvbnN0IGMxID0gbDsgLy8gMS4gYzEsIHRoZSBsYXJnZXN0IGludGVnZXIgc3VjaCB0aGF0IDJeYzEgZGl2aWRlcyBxIC0gMS5cbiAgICAvLyBXZSBuZWVkIDJuICoqIGMxIGFuZCAybiAqKiAoYzEtMSkuIFdlIGNhbid0IHVzZSAqKjsgYnV0IHdlIGNhbiB1c2UgPDwuXG4gICAgLy8gMm4gKiogYzEgPT0gMm4gPDwgKGMxLTEpXG4gICAgY29uc3QgXzJuX3Bvd19jMV8xID0gXzJuIDw8IChjMSAtIF8xbiAtIF8xbik7XG4gICAgY29uc3QgXzJuX3Bvd19jMSA9IF8ybl9wb3dfYzFfMSAqIF8ybjtcbiAgICBjb25zdCBjMiA9IChxIC0gXzFuKSAvIF8ybl9wb3dfYzE7IC8vIDIuIGMyID0gKHEgLSAxKSAvICgyXmMxKSAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjMyA9IChjMiAtIF8xbikgLyBfMm47IC8vIDMuIGMzID0gKGMyIC0gMSkgLyAyICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW47IC8vIDQuIGM0ID0gMl5jMSAtIDEgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNiA9IEZwLnBvdyhaLCBjMik7IC8vIDYuIGM2ID0gWl5jMlxuICAgIGNvbnN0IGM3ID0gRnAucG93KFosIChjMiArIF8xbikgLyBfMm4pOyAvLyA3LiBjNyA9IFpeKChjMiArIDEpIC8gMilcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IGM2OyAvLyAxLiB0djEgPSBjNlxuICAgICAgICBsZXQgdHYyID0gRnAucG93KHYsIGM0KTsgLy8gMi4gdHYyID0gdl5jNFxuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpOyAvLyA0LiB0djMgPSB0djMgKiB2XG4gICAgICAgIGxldCB0djUgPSBGcC5tdWwodSwgdHYzKTsgLy8gNS4gdHY1ID0gdSAqIHR2M1xuICAgICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xuICAgICAgICB0djUgPSBGcC5tdWwodHY1LCB0djIpOyAvLyA3LiB0djUgPSB0djUgKiB0djJcbiAgICAgICAgdHYyID0gRnAubXVsKHR2NSwgdik7IC8vIDguIHR2MiA9IHR2NSAqIHZcbiAgICAgICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcbiAgICAgICAgbGV0IHR2NCA9IEZwLm11bCh0djMsIHR2Mik7IC8vIDEwLiB0djQgPSB0djMgKiB0djJcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NCwgYzUpOyAvLyAxMS4gdHY1ID0gdHY0XmM1XG4gICAgICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxuICAgICAgICB0djIgPSBGcC5tdWwodHYzLCBjNyk7IC8vIDEzLiB0djIgPSB0djMgKiBjN1xuICAgICAgICB0djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAxNC4gdHY1ID0gdHY0ICogdHYxXG4gICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcbiAgICAgICAgdHY0ID0gRnAuY21vdih0djUsIHR2NCwgaXNRUik7IC8vIDE2LiB0djQgPSBDTU9WKHR2NSwgdHY0LCBpc1FSKVxuICAgICAgICAvLyAxNy4gZm9yIGkgaW4gKGMxLCBjMSAtIDEsIC4uLiwgMik6XG4gICAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdHY1ID0gaSAtIF8ybjsgLy8gMTguICAgIHR2NSA9IGkgLSAyXG4gICAgICAgICAgICB0djUgPSBfMm4gPDwgKHR2NSAtIF8xbik7IC8vIDE5LiAgICB0djUgPSAyXnR2NVxuICAgICAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxuICAgICAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcbiAgICAgICAgICAgIHR2MiA9IEZwLm11bCh0djMsIHR2MSk7IC8vIDIyLiAgICB0djIgPSB0djMgKiB0djFcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcbiAgICAgICAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG4gICAgICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBlMSk7IC8vIDI1LiAgICB0djMgPSBDTU9WKHR2MiwgdHYzLCBlMSlcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogdHYzIH07XG4gICAgfTtcbiAgICBpZiAoRnAuT1JERVIgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBzcXJ0X3JhdGlvXzNtb2Q0KHUsIHYpXG4gICAgICAgIGNvbnN0IGMxID0gKEZwLk9SREVSIC0gXzNuKSAvIF80bjsgLy8gMS4gYzEgPSAocSAtIDMpIC8gNCAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgY29uc3QgYzIgPSBGcC5zcXJ0KEZwLm5lZyhaKSk7IC8vIDIuIGMyID0gc3FydCgtWilcbiAgICAgICAgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgICAgIGxldCB0djEgPSBGcC5zcXIodik7IC8vIDEuIHR2MSA9IHZeMlxuICAgICAgICAgICAgY29uc3QgdHYyID0gRnAubXVsKHUsIHYpOyAvLyAyLiB0djIgPSB1ICogdlxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYyKTsgLy8gMy4gdHYxID0gdHYxICogdHYyXG4gICAgICAgICAgICBsZXQgeTEgPSBGcC5wb3codHYxLCBjMSk7IC8vIDQuIHkxID0gdHYxXmMxXG4gICAgICAgICAgICB5MSA9IEZwLm11bCh5MSwgdHYyKTsgLy8gNS4geTEgPSB5MSAqIHR2MlxuICAgICAgICAgICAgY29uc3QgeTIgPSBGcC5tdWwoeTEsIGMyKTsgLy8gNi4geTIgPSB5MSAqIGMyXG4gICAgICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwoRnAuc3FyKHkxKSwgdik7IC8vIDcuIHR2MyA9IHkxXjI7IDguIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgICAgIGNvbnN0IGlzUVIgPSBGcC5lcWwodHYzLCB1KTsgLy8gOS4gaXNRUiA9IHR2MyA9PSB1XG4gICAgICAgICAgICBsZXQgeSA9IEZwLmNtb3YoeTIsIHkxLCBpc1FSKTsgLy8gMTAuIHkgPSBDTU9WKHkyLCB5MSwgaXNRUilcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB5IH07IC8vIDExLiByZXR1cm4gKGlzUVIsIHkpIGlzUVIgPyB5IDogeSpjMlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XG4gICAgLy8gaWYgKEZwLk9SREVSICUgXzhuID09PSBfNW4pIC8vIHNxcnRfcmF0aW9fNW1vZDhcbiAgICByZXR1cm4gc3FydFJhdGlvO1xufVxuLyoqXG4gKiBTaW1wbGlmaWVkIFNoYWxsdWUtdmFuIGRlIFdvZXN0aWpuZS1VbGFzIE1ldGhvZFxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi02LjYuMlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIHZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIGNvbnN0IHR2NF9pbnYgPSBGcEludmVydEJhdGNoKEZwLCBbdHY0XSwgdHJ1ZSlbMF07XG4gICAgICAgIHggPSBGcC5tdWwoeCwgdHY0X2ludik7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/bls12-381.js":
/*!**********************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/bls12-381.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls12_381: () => (/* binding */ bls12_381)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/utils */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_bls_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/bls.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/bls.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/modular.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_tower_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract/tower.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/tower.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n * * Construct zk-SNARKs at the ~120-bit security\n * * Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\n *   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n *\n * ### Summary\n * 1. BLS Relies on Bilinear Pairing (expensive)\n * 2. Private Keys: 32 bytes\n * 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.\n * 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.\n *     - The signature is a point on the G2 subgroup, which is defined over a finite field\n *       with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the\n *       complex numbers).\n *     - We also support reversed 96-byte pubkeys & 48-byte short signatures.\n * 5. The 12 stands for the Embedding degree.\n *\n * ### Formulas\n * - `P = pk x G` - public keys\n * - `S = pk x H(m)` - signing\n * - `e(P, H(m)) == e(G, S)` - verification using pairings\n * - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n *\n * ### Compatibility and notes\n * 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC.\n * Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.\n * 2. Some projects use G2 for public keys and G1 for signatures. It's called \"short signature\".\n * 3. Curve security level is about 120 bits as per [Barbulescu-Duquesne 2017](https://hal.science/hal-01534101/file/main.pdf)\n * 4. Compatible with specs:\n *    [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n *    [cfrg-bls-signature-05](https://www.rfc-editor.org/rfc/draft-irtf-cfrg-bls-signature-05),\n *    RFC 9380.\n *\n * ### Params\n * To verify curve parameters, see\n * [pairing-friendly-curves spec](https://www.rfc-editor.org/rfc/draft-irtf-cfrg-pairing-friendly-curves-11).\n * Basic math is done over finite fields over p.\n * More complicated math is done over polynominal extension fields.\n * To simplify calculations in Fp12, we construct extension tower:\n *\n * Embedding degree (k): 12\n * Seed (X): -15132376222941642752\n * Fr:  (x-x+1)\n * Fp: ((x-1)  r(x)/3+x)\n * (E/Fp): Y=X+4\n * (E/Fp): Y = X+4(u+1) (M-type twist)\n * Ate loop size: X\n *\n * ### Towers\n * - Fp = Fp => Fp\n * - Fp(u) / (u - ) where  = -1\n * - Fp(v) / (v - ) where  = u + 1\n * - Fp(w) / (w - ) where  = v\n * - Fp[u] = Fp/u+1\n * - Fp[v] = Fp/v-1-u\n * - Fp[w] = Fp/w-v\n *\n * @todo construct bls & bn fp/fr from seed.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n// Types\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\nconst BLS_X = BigInt('0xd201000000010000');\nconst BLS_X_LEN = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BLS_X);\n// CURVE FIELDS\nconst { Fp, Fp2, Fp6, Fp4Square, Fp12 } = (0,_abstract_tower_js__WEBPACK_IMPORTED_MODULE_1__.tower12)({\n    // Order of Fp\n    ORDER: BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'),\n    // Finite extension field over irreducible polynominal.\n    // Fp(u) / (u - ) where  = -1\n    FP2_NONRESIDUE: [_1n, _1n],\n    Fp2mulByB: ({ c0, c1 }) => {\n        const t0 = Fp.mul(c0, _4n); // 4 * c0\n        const t1 = Fp.mul(c1, _4n); // 4 * c1\n        // (T0-T1) + (T0+T1)*i\n        return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n    },\n    // Fp12\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   G(p) = {  Fp : ^(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    Fp12cyclotomicSquare: ({ c0, c1 }) => {\n        const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n        const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n        const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\n        const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\n        const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\n        const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n        return {\n            c0: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n                c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n                c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n            }), // 2 * (T7 - c0c2)  + T7\n            c1: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n                c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n                c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n            }),\n        }; // 2 * (T6 + c1c2) + T6\n    },\n    Fp12cyclotomicExp(num, n) {\n        let z = Fp12.ONE;\n        for (let i = BLS_X_LEN - 1; i >= 0; i--) {\n            z = Fp12._cyclotomicSquare(z);\n            if ((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitGet)(n, i))\n                z = Fp12.mul(z, num);\n        }\n        return z;\n    },\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    Fp12finalExponentiate: (num) => {\n        const x = BLS_X;\n        // this^(q) / this\n        const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n        // t0^(q) * t0\n        const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n        const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n        const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n        const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n        const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n        const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n        const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n        const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n        const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n        const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n        const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n        // (t2 * t5)^(q) * (t4 * t1)^(q) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n        return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n    },\n});\n// Finite field over r.\n// This particular field is not used anywhere in bls12-381, but it is still useful.\nconst Fr = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));\n// END OF CURVE FIELDS\n// HashToCurve\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__.isogenyMap)(Fp2, [\n    // xNum\n    [\n        [\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        ],\n        [\n            '0x0',\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n        ],\n        [\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n        ],\n        [\n            '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n            '0x0',\n        ],\n    ],\n    // xDen\n    [\n        [\n            '0x0',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n        ],\n        [\n            '0xc',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n        ],\n        ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n        [\n            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        ],\n        [\n            '0x0',\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n        ],\n        [\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n        ],\n        [\n            '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n            '0x0',\n        ],\n    ],\n    // yDen\n    [\n        [\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        ],\n        [\n            '0x0',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n        ],\n        [\n            '0x12',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n        ],\n        ['0x1', '0x0'], // LAST 1\n    ],\n].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n        '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n        '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n        '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n        '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n        '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n        '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n        '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n        '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n        '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n        '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n        '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n        '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n        '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n        '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n        '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n        '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n        '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n        '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n        '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n        '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n        '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n        '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n        '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n        '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n        '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n        '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n        '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n        '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n        '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n        '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n        '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n        '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n        '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n        '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n        '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n        '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n        '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n        '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n        '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n        '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n        '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n        '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n        '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n        '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n        '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n        '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n        '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n        '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n        '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n        '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n        '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j))));\n// SWU Map - Fp2 to G2': y = x + 240i * x + 1012 + 1012i\nconst G2_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__.mapToCurveSimpleSWU)(Fp2, {\n    A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n    B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n    Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__.mapToCurveSimpleSWU)(Fp, {\n    A: Fp.create(BigInt('0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d')),\n    B: Fp.create(BigInt('0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0')),\n    Z: Fp.create(BigInt(11)),\n});\n// GLV endomorphism (P), for fast cofactor clearing\nconst { G2psi, G2psi2 } = (0,_abstract_tower_js__WEBPACK_IMPORTED_MODULE_1__.psiFrobenius)(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\n// Default hash_to_field options are for hash to G2.\n//\n// Parameter definitions are in section 5.3 of the spec unless otherwise noted.\n// Parameter values come from section 8.8.2 of the spec.\n// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2\n//\n// Base field F is GF(p^m)\n// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n// m = 2 (or 1 for G1 see section 8.8.1)\n// k = 128\nconst htfDefaults = Object.freeze({\n    // DST: a domain separation tag\n    // defined in section 2.2.5\n    // Use utils.getDSTLabel(), utils.setDSTLabel(value)\n    DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n    encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n    // p: the characteristic of F\n    //    where F is a finite field of characteristic p and order q = p^m\n    p: Fp.ORDER,\n    // m: the extension degree of F, m >= 1\n    //     where F is a finite field of characteristic p and order q = p^m\n    m: 2,\n    // k: the target security level for the suite in bits\n    // defined in section 5.1\n    k: 128,\n    // option to use a message that has already been processed by\n    // expand_message_xmd\n    expand: 'xmd',\n    // Hash functions for: expand_message_xmd is appropriate for use with a\n    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\n    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_5__.sha256,\n});\n// Encoding utils\n// Point on G1 curve: (x, y)\n// Compressed point of infinity\nconst COMPRESSED_ZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true }); // set compressed & point-at-infinity bits\nfunction parseMask(bytes) {\n    // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n    bytes = bytes.slice();\n    const mask = bytes[0] & 224;\n    const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n    const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n    const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n    bytes[0] &= 31; // clear mask (zero first 3 bits)\n    return { compressed, infinity, sort, value: bytes };\n}\nfunction setMask(bytes, mask) {\n    if (bytes[0] & 224)\n        throw new Error('setMask: non-empty mask');\n    if (mask.compressed)\n        bytes[0] |= 128;\n    if (mask.infinity)\n        bytes[0] |= 64;\n    if (mask.sort)\n        bytes[0] |= 32;\n    return bytes;\n}\nfunction signatureG1ToRawBytes(point) {\n    point.assertValidity();\n    const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);\n    const { x, y } = point.toAffine();\n    if (isZero)\n        return COMPRESSED_ZERO.slice();\n    const P = Fp.ORDER;\n    const sort = Boolean((y * _2n) / P);\n    return setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, Fp.BYTES), { compressed: true, sort });\n}\nfunction signatureG2ToRawBytes(point) {\n    // NOTE: by some reasons it was missed in bls12-381, looks like bug\n    point.assertValidity();\n    const len = Fp.BYTES;\n    if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(COMPRESSED_ZERO, (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(_0n, len));\n    const { x, y } = point.toAffine();\n    const { re: x0, im: x1 } = Fp2.reim(x);\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n    const sort = Boolean((tmp / Fp.ORDER) & _1n);\n    const z2 = x0;\n    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x1, len), { sort, compressed: true }), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(z2, len));\n}\n/**\n * bls12-381 pairing-friendly curve.\n * @example\n * import { bls12_381 as bls } from '@noble/curves/bls12-381';\n * // G1 keys, G2 signatures\n * const privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\n * const message = '64726e3da8';\n * const publicKey = bls.getPublicKey(privateKey);\n * const signature = bls.sign(message, privateKey);\n * const isValid = bls.verify(signature, message, publicKey);\n */\nconst bls12_381 = (0,_abstract_bls_js__WEBPACK_IMPORTED_MODULE_6__.bls)({\n    // Fields\n    fields: {\n        Fp,\n        Fp2,\n        Fp6,\n        Fp12,\n        Fr,\n    },\n    // G1 is the order-q subgroup of E1(Fp) : y = x + 4, #E1(Fp) = h1q, where\n    // characteristic; z + (z - z + 1)(z - 1)/3\n    G1: {\n        Fp,\n        // cofactor; (z - 1)/3\n        h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n        // generator's coordinates\n        // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n        // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n        Gx: BigInt('0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'),\n        Gy: BigInt('0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'),\n        a: Fp.ZERO,\n        b: _4n,\n        htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        isTorsionFree: (c, point) => {\n            // GLV endomorphism (P)\n            const beta = BigInt('0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe');\n            const phi = new c(Fp.mul(point.px, beta), point.py, point.pz);\n            // TODO: unroll\n            const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\n            const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\n            return u2P.equals(phi);\n        },\n        // Clear cofactor of G1\n        // https://eprint.iacr.org/2019/403\n        clearCofactor: (_c, point) => {\n            // return this.multiplyUnsafe(CURVE.h);\n            return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\n        },\n        mapToCurve: (scalars) => {\n            const { x, y } = G1_SWU(Fp.create(scalars[0]));\n            return isogenyMapG1(x, y);\n        },\n        fromBytes: (bytes) => {\n            const { compressed, infinity, sort, value } = parseMask(bytes);\n            if (value.length === 48 && compressed) {\n                // TODO: Fp.bytes\n                const P = Fp.ORDER;\n                const compressedValue = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value);\n                // Zero\n                const x = Fp.create(compressedValue & Fp.MASK);\n                if (infinity) {\n                    if (x !== _0n)\n                        throw new Error('G1: non-empty compressed point at infinity');\n                    return { x: _0n, y: _0n };\n                }\n                const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y = x + b\n                let y = Fp.sqrt(right);\n                if (!y)\n                    throw new Error('invalid compressed G1 point');\n                if ((y * _2n) / P !== BigInt(sort))\n                    y = Fp.neg(y);\n                return { x: Fp.create(x), y: Fp.create(y) };\n            }\n            else if (value.length === 96 && !compressed) {\n                // Check if the infinity flag is set\n                const x = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.subarray(0, Fp.BYTES));\n                const y = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.subarray(Fp.BYTES));\n                if (infinity) {\n                    if (x !== _0n || y !== _0n)\n                        throw new Error('G1: non-empty point at infinity');\n                    return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\n                }\n                return { x: Fp.create(x), y: Fp.create(y) };\n            }\n            else {\n                throw new Error('invalid point G1, expected 48/96 bytes');\n            }\n        },\n        toBytes: (c, point, isCompressed) => {\n            const isZero = point.equals(c.ZERO);\n            const { x, y } = point.toAffine();\n            if (isCompressed) {\n                if (isZero)\n                    return COMPRESSED_ZERO.slice();\n                const P = Fp.ORDER;\n                const sort = Boolean((y * _2n) / P);\n                return setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, Fp.BYTES), { compressed: true, sort });\n            }\n            else {\n                if (isZero) {\n                    // 2x PUBLIC_KEY_LENGTH\n                    const x = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([0x40]), new Uint8Array(2 * Fp.BYTES - 1));\n                    return x;\n                }\n                else {\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, Fp.BYTES), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y, Fp.BYTES));\n                }\n            }\n        },\n        ShortSignature: {\n            fromHex(hex) {\n                const { infinity, sort, value } = parseMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('signatureHex', hex, 48));\n                const P = Fp.ORDER;\n                const compressedValue = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value);\n                // Zero\n                if (infinity)\n                    return bls12_381.G1.ProjectivePoint.ZERO;\n                const x = Fp.create(compressedValue & Fp.MASK);\n                const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y = x + b\n                let y = Fp.sqrt(right);\n                if (!y)\n                    throw new Error('invalid compressed G1 point');\n                const aflag = BigInt(sort);\n                if ((y * _2n) / P !== aflag)\n                    y = Fp.neg(y);\n                const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });\n                point.assertValidity();\n                return point;\n            },\n            toRawBytes(point) {\n                return signatureG1ToRawBytes(point);\n            },\n            toHex(point) {\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(signatureG1ToRawBytes(point));\n            },\n        },\n    },\n    // G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),\n    // where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where\n    // G - 1\n    // h2q\n    G2: {\n        Fp: Fp2,\n        // cofactor\n        h: BigInt('0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'),\n        Gx: Fp2.fromBigTuple([\n            BigInt('0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'),\n            BigInt('0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'),\n        ]),\n        // y =\n        // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\n        // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        Gy: Fp2.fromBigTuple([\n            BigInt('0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'),\n            BigInt('0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'),\n        ]),\n        a: Fp2.ZERO,\n        b: Fp2.fromBigTuple([_4n, _4n]),\n        hEff: BigInt('0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'),\n        htfDefaults: { ...htfDefaults },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        mapToCurve: (scalars) => {\n            const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\n            return isogenyMapG2(x, y);\n        },\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        // Older version: https://eprint.iacr.org/2019/814.pdf\n        isTorsionFree: (c, P) => {\n            return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // (P) == [u](P)\n        },\n        // Maps the point into the prime-order subgroup G2.\n        // clear_cofactor_bls12381_g2 from RFC 9380.\n        // https://eprint.iacr.org/2017/419.pdf\n        // prettier-ignore\n        clearCofactor: (c, P) => {\n            const x = BLS_X;\n            let t1 = P.multiplyUnsafe(x).negate(); // [-x]P\n            let t2 = G2psi(c, P); // (P)\n            let t3 = P.double(); // 2P\n            t3 = G2psi2(c, t3); // (2P)\n            t3 = t3.subtract(t2); // (2P) - (P)\n            t2 = t1.add(t2); // [-x]P + (P)\n            t2 = t2.multiplyUnsafe(x).negate(); // [x]P - [x](P)\n            t3 = t3.add(t2); // (2P) - (P) + [x]P - [x](P)\n            t3 = t3.subtract(t1); // (2P) - (P) + [x]P - [x](P) + [x]P\n            const Q = t3.subtract(P); // (2P) - (P) + [x]P - [x](P) + [x]P - 1P\n            return Q; // [x-x-1]P + [x-1](P) + (2P)\n        },\n        fromBytes: (bytes) => {\n            const { compressed, infinity, sort, value } = parseMask(bytes);\n            if ((!compressed && !infinity && sort) || // 00100000\n                (!compressed && infinity && sort) || // 01100000\n                (sort && infinity && compressed) // 11100000\n            ) {\n                throw new Error('invalid encoding flag: ' + (bytes[0] & 224));\n            }\n            const L = Fp.BYTES;\n            const slc = (b, from, to) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(b.slice(from, to));\n            if (value.length === 96 && compressed) {\n                const b = bls12_381.params.G2b;\n                const P = Fp.ORDER;\n                if (infinity) {\n                    // check that all bytes are 0\n                    if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n                        throw new Error('invalid compressed G2 point');\n                    }\n                    return { x: Fp2.ZERO, y: Fp2.ZERO };\n                }\n                const x_1 = slc(value, 0, L);\n                const x_0 = slc(value, L, 2 * L);\n                const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n                const right = Fp2.add(Fp2.pow(x, _3n), b); // y = x + 4 * (u+1) = x + b\n                let y = Fp2.sqrt(right);\n                const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n                y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n                return { x, y };\n            }\n            else if (value.length === 192 && !compressed) {\n                if (infinity) {\n                    if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n                        throw new Error('invalid uncompressed G2 point');\n                    }\n                    return { x: Fp2.ZERO, y: Fp2.ZERO };\n                }\n                const x1 = slc(value, 0, L);\n                const x0 = slc(value, L, 2 * L);\n                const y1 = slc(value, 2 * L, 3 * L);\n                const y0 = slc(value, 3 * L, 4 * L);\n                return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n            }\n            else {\n                throw new Error('invalid point G2, expected 96/192 bytes');\n            }\n        },\n        toBytes: (c, point, isCompressed) => {\n            const { BYTES: len, ORDER: P } = Fp;\n            const isZero = point.equals(c.ZERO);\n            const { x, y } = point.toAffine();\n            if (isCompressed) {\n                if (isZero)\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(COMPRESSED_ZERO, (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(_0n, len));\n                const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x.c1, len), { compressed: true, sort: flag }), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x.c0, len));\n            }\n            else {\n                if (isZero)\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([0x40]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;\n                const { re: x0, im: x1 } = Fp2.reim(x);\n                const { re: y0, im: y1 } = Fp2.reim(y);\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x1, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x0, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y1, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y0, len));\n            }\n        },\n        Signature: {\n            // TODO: Optimize, it's very slow because of sqrt.\n            fromHex(hex) {\n                const { infinity, sort, value } = parseMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('signatureHex', hex));\n                const P = Fp.ORDER;\n                const half = value.length / 2;\n                if (half !== 48 && half !== 96)\n                    throw new Error('invalid compressed signature length, must be 96 or 192');\n                const z1 = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.slice(0, half));\n                const z2 = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.slice(half));\n                // Indicates the infinity point\n                if (infinity)\n                    return bls12_381.G2.ProjectivePoint.ZERO;\n                const x1 = Fp.create(z1 & Fp.MASK);\n                const x2 = Fp.create(z2);\n                const x = Fp2.create({ c0: x2, c1: x1 });\n                const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381.params.G2b); // y = x + 4\n                // The slow part\n                let y = Fp2.sqrt(y2);\n                if (!y)\n                    throw new Error('Failed to find a square root');\n                // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n                // If y1 happens to be zero, then use the bit of y0\n                const { re: y0, im: y1 } = Fp2.reim(y);\n                const aflag1 = BigInt(sort);\n                const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n                const isZero = y1 === _0n && (y0 * _2n) / P !== aflag1;\n                if (isGreater || isZero)\n                    y = Fp2.neg(y);\n                const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\n                point.assertValidity();\n                return point;\n            },\n            toRawBytes(point) {\n                return signatureG2ToRawBytes(point);\n            },\n            toHex(point) {\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(signatureG2ToRawBytes(point));\n            },\n        },\n    },\n    params: {\n        ateLoopSize: BLS_X, // The BLS parameter x for BLS12-381\n        r: Fr.ORDER, // order; z  z + 1; CURVE.n from other curves\n        xNegative: true,\n        twistType: 'multiplicative',\n    },\n    htfDefaults,\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_5__.sha256,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_7__.randomBytes,\n});\n//# sourceMappingURL=bls12-381.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9ibHMxMi0zODEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDTTtBQUNWO0FBQ007QUFDMkY7QUFDekk7QUFDeUQ7QUFDRztBQUNLO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQU07QUFDeEI7QUFDQSxRQUFRLGdDQUFnQyxFQUFFLDJEQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQyxnQkFBZ0IsK0JBQStCO0FBQy9DLGdCQUFnQiwrQkFBK0I7QUFDL0MsZ0JBQWdCLHdCQUF3QjtBQUN4QyxnQkFBZ0Isd0JBQXdCO0FBQ3hDLGdCQUFnQix3QkFBd0I7QUFDeEMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLEtBQUs7QUFDTDtBQUNBO0FB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O0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLDJCQUEyQiwrREFBTyxrQkFBa0IsbUVBQWU7QUFDbkU7QUFDQSx1QkFBdUIsK0RBQU8sU0FBUyxtRUFBZSxlQUFlLDhCQUE4QixHQUFHLG1FQUFlO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBTyx1REFBdUQ7QUFDekYsd0JBQXdCLGlCQUFpQjtBQUN6Qyx3QkFBd0IsaUJBQWlCO0FBQ3pDLHVCQUF1QiwrREFBTyxDQUFDLG1FQUFlLFdBQVcsbUVBQWUsV0FBVyxtRUFBZSxXQUFXLG1FQUFlO0FBQzVIO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0IsWUFBWSwrREFBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtRUFBZTtBQUMxQywyQkFBMkIsbUVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1Qiw4REFBVTtBQUNqQyxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsc0RBQU07QUFDaEIsZUFBZTtBQUNmLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2JsczEyLTM4MS5qcz8yOGZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYmxzMTItMzgxIGlzIHBhaXJpbmctZnJpZW5kbHkgQmFycmV0by1MeW5uLVNjb3R0IGVsbGlwdGljIGN1cnZlIGNvbnN0cnVjdGlvbiBhbGxvd2luZyB0bzpcbiAqICogQ29uc3RydWN0IHprLVNOQVJLcyBhdCB0aGUgfjEyMC1iaXQgc2VjdXJpdHlcbiAqICogRWZmaWNpZW50bHkgdmVyaWZ5IE4gYWdncmVnYXRlIHNpZ25hdHVyZXMgd2l0aCAxIHBhaXJpbmcgYW5kIE4gZWMgYWRkaXRpb25zOlxuICogICB0aGUgQm9uZWgtTHlubi1TaGFjaGFtIHNpZ25hdHVyZSBzY2hlbWUgaXMgb3JkZXJzIG9mIG1hZ25pdHVkZSBtb3JlIGVmZmljaWVudCB0aGFuIFNjaG5vcnJcbiAqXG4gKiAjIyMgU3VtbWFyeVxuICogMS4gQkxTIFJlbGllcyBvbiBCaWxpbmVhciBQYWlyaW5nIChleHBlbnNpdmUpXG4gKiAyLiBQcml2YXRlIEtleXM6IDMyIGJ5dGVzXG4gKiAzLiBQdWJsaWMgS2V5czogNDggYnl0ZXM6IDM4MSBiaXQgYWZmaW5lIHggY29vcmRpbmF0ZSwgZW5jb2RlZCBpbnRvIDQ4IGJpZy1lbmRpYW4gYnl0ZXMuXG4gKiA0LiBTaWduYXR1cmVzOiA5NiBieXRlczogdHdvIDM4MSBiaXQgaW50ZWdlcnMgKGFmZmluZSB4IGNvb3JkaW5hdGUpLCBlbmNvZGVkIGludG8gdHdvIDQ4IGJpZy1lbmRpYW4gYnl0ZSBhcnJheXMuXG4gKiAgICAgLSBUaGUgc2lnbmF0dXJlIGlzIGEgcG9pbnQgb24gdGhlIEcyIHN1Ymdyb3VwLCB3aGljaCBpcyBkZWZpbmVkIG92ZXIgYSBmaW5pdGUgZmllbGRcbiAqICAgICAgIHdpdGggZWxlbWVudHMgdHdpY2UgYXMgYmlnIGFzIHRoZSBHMSBjdXJ2ZSAoRzIgaXMgb3ZlciBGcDIgcmF0aGVyIHRoYW4gRnAuIEZwMiBpcyBhbmFsb2dvdXMgdG8gdGhlXG4gKiAgICAgICBjb21wbGV4IG51bWJlcnMpLlxuICogICAgIC0gV2UgYWxzbyBzdXBwb3J0IHJldmVyc2VkIDk2LWJ5dGUgcHVia2V5cyAmIDQ4LWJ5dGUgc2hvcnQgc2lnbmF0dXJlcy5cbiAqIDUuIFRoZSAxMiBzdGFuZHMgZm9yIHRoZSBFbWJlZGRpbmcgZGVncmVlLlxuICpcbiAqICMjIyBGb3JtdWxhc1xuICogLSBgUCA9IHBrIHggR2AgLSBwdWJsaWMga2V5c1xuICogLSBgUyA9IHBrIHggSChtKWAgLSBzaWduaW5nXG4gKiAtIGBlKFAsIEgobSkpID09IGUoRywgUylgIC0gdmVyaWZpY2F0aW9uIHVzaW5nIHBhaXJpbmdzXG4gKiAtIGBlKEcsIFMpID0gZShHLCBTVU0obikoU2kpKSA9IE1VTChuKShlKEcsIFNpKSlgIC0gc2lnbmF0dXJlIGFnZ3JlZ2F0aW9uXG4gKlxuICogIyMjIENvbXBhdGliaWxpdHkgYW5kIG5vdGVzXG4gKiAxLiBJdCBpcyBjb21wYXRpYmxlIHdpdGggQWxnb3JhbmQsIENoaWEsIERmaW5pdHksIEV0aGVyZXVtLCBGaWxlY29pbiwgWkVDLlxuICogRmlsZWNvaW4gdXNlcyBsaXR0bGUgZW5kaWFuIGJ5dGUgYXJyYXlzIGZvciBwcml2YXRlIGtleXMgLSBtYWtlIHN1cmUgdG8gcmV2ZXJzZSBieXRlIG9yZGVyLlxuICogMi4gU29tZSBwcm9qZWN0cyB1c2UgRzIgZm9yIHB1YmxpYyBrZXlzIGFuZCBHMSBmb3Igc2lnbmF0dXJlcy4gSXQncyBjYWxsZWQgXCJzaG9ydCBzaWduYXR1cmVcIi5cbiAqIDMuIEN1cnZlIHNlY3VyaXR5IGxldmVsIGlzIGFib3V0IDEyMCBiaXRzIGFzIHBlciBbQmFyYnVsZXNjdS1EdXF1ZXNuZSAyMDE3XShodHRwczovL2hhbC5zY2llbmNlL2hhbC0wMTUzNDEwMS9maWxlL21haW4ucGRmKVxuICogNC4gQ29tcGF0aWJsZSB3aXRoIHNwZWNzOlxuICogICAgW2NmcmctcGFpcmluZy1mcmllbmRseS1jdXJ2ZXMtMTFdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pcnRmLWNmcmctcGFpcmluZy1mcmllbmRseS1jdXJ2ZXMtMTEpLFxuICogICAgW2NmcmctYmxzLXNpZ25hdHVyZS0wNV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL2RyYWZ0LWlydGYtY2ZyZy1ibHMtc2lnbmF0dXJlLTA1KSxcbiAqICAgIFJGQyA5MzgwLlxuICpcbiAqICMjIyBQYXJhbXNcbiAqIFRvIHZlcmlmeSBjdXJ2ZSBwYXJhbWV0ZXJzLCBzZWVcbiAqIFtwYWlyaW5nLWZyaWVuZGx5LWN1cnZlcyBzcGVjXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvZHJhZnQtaXJ0Zi1jZnJnLXBhaXJpbmctZnJpZW5kbHktY3VydmVzLTExKS5cbiAqIEJhc2ljIG1hdGggaXMgZG9uZSBvdmVyIGZpbml0ZSBmaWVsZHMgb3ZlciBwLlxuICogTW9yZSBjb21wbGljYXRlZCBtYXRoIGlzIGRvbmUgb3ZlciBwb2x5bm9taW5hbCBleHRlbnNpb24gZmllbGRzLlxuICogVG8gc2ltcGxpZnkgY2FsY3VsYXRpb25zIGluIEZwMTIsIHdlIGNvbnN0cnVjdCBleHRlbnNpb24gdG93ZXI6XG4gKlxuICogRW1iZWRkaW5nIGRlZ3JlZSAoayk6IDEyXG4gKiBTZWVkIChYKTogLTE1MTMyMzc2MjIyOTQxNjQyNzUyXG4gKiBGcjogICh44oG0LXjCsisxKVxuICogRnA6ICgoeC0xKcKyIOKLhSByKHgpLzMreClcbiAqIChFL0ZwKTogWcKyPVjCsys0XG4gKiAoReKCnC9GcMKyKTogWcKyID0gWMKzKzQodSsxKSAoTS10eXBlIHR3aXN0KVxuICogQXRlIGxvb3Agc2l6ZTogWFxuICpcbiAqICMjIyBUb3dlcnNcbiAqIC0gRnDigoHigoIgPSBGcOKChsKyID0+IEZw4oKCwrNcbiAqIC0gRnAodSkgLyAodcKyIC0gzrIpIHdoZXJlIM6yID0gLTFcbiAqIC0gRnDigoIodikgLyAodsKzIC0gzr4pIHdoZXJlIM6+ID0gdSArIDFcbiAqIC0gRnDigoYodykgLyAod8KyIC0gzrMpIHdoZXJlIM6zID0gdlxuICogLSBGcMKyW3VdID0gRnAvdcKyKzFcbiAqIC0gRnDigbZbdl0gPSBGcMKyL3bCsy0xLXVcbiAqIC0gRnDCucKyW3ddID0gRnDigbYvd8KyLXZcbiAqXG4gKiBAdG9kbyBjb25zdHJ1Y3QgYmxzICYgYm4gZnAvZnIgZnJvbSBzZWVkLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IGJscyB9IGZyb20gXCIuL2Fic3RyYWN0L2Jscy5qc1wiO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tIFwiLi9hYnN0cmFjdC9tb2R1bGFyLmpzXCI7XG5pbXBvcnQgeyBiaXRHZXQsIGJpdExlbiwgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcyBhcyBjb25jYXRCLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFLCB9IGZyb20gXCIuL2Fic3RyYWN0L3V0aWxzLmpzXCI7XG4vLyBUeXBlc1xuaW1wb3J0IHsgaXNvZ2VueU1hcCB9IGZyb20gXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIjtcbmltcG9ydCB7IHBzaUZyb2Jlbml1cywgdG93ZXIxMiB9IGZyb20gXCIuL2Fic3RyYWN0L3Rvd2VyLmpzXCI7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVLCB9IGZyb20gXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCI7XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG4vLyBUaGUgQkxTIHBhcmFtZXRlciB4IChzZWVkKSBmb3IgQkxTMTItMzgxLiBOT1RFOiBpdCBpcyBuZWdhdGl2ZSFcbmNvbnN0IEJMU19YID0gQmlnSW50KCcweGQyMDEwMDAwMDAwMTAwMDAnKTtcbmNvbnN0IEJMU19YX0xFTiA9IGJpdExlbihCTFNfWCk7XG4vLyBDVVJWRSBGSUVMRFNcbmNvbnN0IHsgRnAsIEZwMiwgRnA2LCBGcDRTcXVhcmUsIEZwMTIgfSA9IHRvd2VyMTIoe1xuICAgIC8vIE9yZGVyIG9mIEZwXG4gICAgT1JERVI6IEJpZ0ludCgnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWInKSxcbiAgICAvLyBGaW5pdGUgZXh0ZW5zaW9uIGZpZWxkIG92ZXIgaXJyZWR1Y2libGUgcG9seW5vbWluYWwuXG4gICAgLy8gRnAodSkgLyAodcKyIC0gzrIpIHdoZXJlIM6yID0gLTFcbiAgICBGUDJfTk9OUkVTSURVRTogW18xbiwgXzFuXSxcbiAgICBGcDJtdWxCeUI6ICh7IGMwLCBjMSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHQwID0gRnAubXVsKGMwLCBfNG4pOyAvLyA0ICogYzBcbiAgICAgICAgY29uc3QgdDEgPSBGcC5tdWwoYzEsIF80bik7IC8vIDQgKiBjMVxuICAgICAgICAvLyAoVDAtVDEpICsgKFQwK1QxKSppXG4gICAgICAgIHJldHVybiB7IGMwOiBGcC5zdWIodDAsIHQxKSwgYzE6IEZwLmFkZCh0MCwgdDEpIH07XG4gICAgfSxcbiAgICAvLyBGcDEyXG4gICAgLy8gQSBjeWNsb3RvbWljIGdyb3VwIGlzIGEgc3ViZ3JvdXAgb2YgRnBebiBkZWZpbmVkIGJ5XG4gICAgLy8gICBHzqbigpkocCkgPSB7zrEg4oiIIEZw4oG/IDogzrFezqbigpkocCkgPSAxfVxuICAgIC8vIFRoZSByZXN1bHQgb2YgYW55IHBhaXJpbmcgaXMgaW4gYSBjeWNsb3RvbWljIHN1Ymdyb3VwXG4gICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAwOS81NjUucGRmXG4gICAgRnAxMmN5Y2xvdG9taWNTcXVhcmU6ICh7IGMwLCBjMSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYzA6IGMwYzAsIGMxOiBjMGMxLCBjMjogYzBjMiB9ID0gYzA7XG4gICAgICAgIGNvbnN0IHsgYzA6IGMxYzAsIGMxOiBjMWMxLCBjMjogYzFjMiB9ID0gYzE7XG4gICAgICAgIGNvbnN0IHsgZmlyc3Q6IHQzLCBzZWNvbmQ6IHQ0IH0gPSBGcDRTcXVhcmUoYzBjMCwgYzFjMSk7XG4gICAgICAgIGNvbnN0IHsgZmlyc3Q6IHQ1LCBzZWNvbmQ6IHQ2IH0gPSBGcDRTcXVhcmUoYzFjMCwgYzBjMik7XG4gICAgICAgIGNvbnN0IHsgZmlyc3Q6IHQ3LCBzZWNvbmQ6IHQ4IH0gPSBGcDRTcXVhcmUoYzBjMSwgYzFjMik7XG4gICAgICAgIGNvbnN0IHQ5ID0gRnAyLm11bEJ5Tm9ucmVzaWR1ZSh0OCk7IC8vIFQ4ICogKHUgKyAxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwNi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGMwOiBGcDIuYWRkKEZwMi5tdWwoRnAyLnN1Yih0MywgYzBjMCksIF8ybiksIHQzKSwgLy8gMiAqIChUMyAtIGMwYzApICArIFQzXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5hZGQoRnAyLm11bChGcDIuc3ViKHQ1LCBjMGMxKSwgXzJuKSwgdDUpLCAvLyAyICogKFQ1IC0gYzBjMSkgICsgVDVcbiAgICAgICAgICAgICAgICBjMjogRnAyLmFkZChGcDIubXVsKEZwMi5zdWIodDcsIGMwYzIpLCBfMm4pLCB0NyksXG4gICAgICAgICAgICB9KSwgLy8gMiAqIChUNyAtIGMwYzIpICArIFQ3XG4gICAgICAgICAgICBjMTogRnA2LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYzA6IEZwMi5hZGQoRnAyLm11bChGcDIuYWRkKHQ5LCBjMWMwKSwgXzJuKSwgdDkpLCAvLyAyICogKFQ5ICsgYzFjMCkgKyBUOVxuICAgICAgICAgICAgICAgIGMxOiBGcDIuYWRkKEZwMi5tdWwoRnAyLmFkZCh0NCwgYzFjMSksIF8ybiksIHQ0KSwgLy8gMiAqIChUNCArIGMxYzEpICsgVDRcbiAgICAgICAgICAgICAgICBjMjogRnAyLmFkZChGcDIubXVsKEZwMi5hZGQodDYsIGMxYzIpLCBfMm4pLCB0NiksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTsgLy8gMiAqIChUNiArIGMxYzIpICsgVDZcbiAgICB9LFxuICAgIEZwMTJjeWNsb3RvbWljRXhwKG51bSwgbikge1xuICAgICAgICBsZXQgeiA9IEZwMTIuT05FO1xuICAgICAgICBmb3IgKGxldCBpID0gQkxTX1hfTEVOIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHogPSBGcDEyLl9jeWNsb3RvbWljU3F1YXJlKHopO1xuICAgICAgICAgICAgaWYgKGJpdEdldChuLCBpKSlcbiAgICAgICAgICAgICAgICB6ID0gRnAxMi5tdWwoeiwgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gejtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvMzU0LnBkZlxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMDkvNTY1LnBkZlxuICAgIEZwMTJmaW5hbEV4cG9uZW50aWF0ZTogKG51bSkgPT4ge1xuICAgICAgICBjb25zdCB4ID0gQkxTX1g7XG4gICAgICAgIC8vIHRoaXNeKHHigbYpIC8gdGhpc1xuICAgICAgICBjb25zdCB0MCA9IEZwMTIuZGl2KEZwMTIuZnJvYmVuaXVzTWFwKG51bSwgNiksIG51bSk7XG4gICAgICAgIC8vIHQwXihxwrIpICogdDBcbiAgICAgICAgY29uc3QgdDEgPSBGcDEyLm11bChGcDEyLmZyb2Jlbml1c01hcCh0MCwgMiksIHQwKTtcbiAgICAgICAgY29uc3QgdDIgPSBGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljRXhwKHQxLCB4KSk7XG4gICAgICAgIGNvbnN0IHQzID0gRnAxMi5tdWwoRnAxMi5jb25qdWdhdGUoRnAxMi5fY3ljbG90b21pY1NxdWFyZSh0MSkpLCB0Mik7XG4gICAgICAgIGNvbnN0IHQ0ID0gRnAxMi5jb25qdWdhdGUoRnAxMi5fY3ljbG90b21pY0V4cCh0MywgeCkpO1xuICAgICAgICBjb25zdCB0NSA9IEZwMTIuY29uanVnYXRlKEZwMTIuX2N5Y2xvdG9taWNFeHAodDQsIHgpKTtcbiAgICAgICAgY29uc3QgdDYgPSBGcDEyLm11bChGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljRXhwKHQ1LCB4KSksIEZwMTIuX2N5Y2xvdG9taWNTcXVhcmUodDIpKTtcbiAgICAgICAgY29uc3QgdDcgPSBGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljRXhwKHQ2LCB4KSk7XG4gICAgICAgIGNvbnN0IHQyX3Q1X3Bvd19xMiA9IEZwMTIuZnJvYmVuaXVzTWFwKEZwMTIubXVsKHQyLCB0NSksIDIpO1xuICAgICAgICBjb25zdCB0NF90MV9wb3dfcTMgPSBGcDEyLmZyb2Jlbml1c01hcChGcDEyLm11bCh0NCwgdDEpLCAzKTtcbiAgICAgICAgY29uc3QgdDZfdDFjX3Bvd19xMSA9IEZwMTIuZnJvYmVuaXVzTWFwKEZwMTIubXVsKHQ2LCBGcDEyLmNvbmp1Z2F0ZSh0MSkpLCAxKTtcbiAgICAgICAgY29uc3QgdDdfdDNjX3QxID0gRnAxMi5tdWwoRnAxMi5tdWwodDcsIEZwMTIuY29uanVnYXRlKHQzKSksIHQxKTtcbiAgICAgICAgLy8gKHQyICogdDUpXihxwrIpICogKHQ0ICogdDEpXihxwrMpICogKHQ2ICogdDEuY29uaileKHFeMSkgKiB0NyAqIHQzLmNvbmogKiB0MVxuICAgICAgICByZXR1cm4gRnAxMi5tdWwoRnAxMi5tdWwoRnAxMi5tdWwodDJfdDVfcG93X3EyLCB0NF90MV9wb3dfcTMpLCB0Nl90MWNfcG93X3ExKSwgdDdfdDNjX3QxKTtcbiAgICB9LFxufSk7XG4vLyBGaW5pdGUgZmllbGQgb3ZlciByLlxuLy8gVGhpcyBwYXJ0aWN1bGFyIGZpZWxkIGlzIG5vdCB1c2VkIGFueXdoZXJlIGluIGJsczEyLTM4MSwgYnV0IGl0IGlzIHN0aWxsIHVzZWZ1bC5cbmNvbnN0IEZyID0gRmllbGQoQmlnSW50KCcweDczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDEnKSk7XG4vLyBFTkQgT0YgQ1VSVkUgRklFTERTXG4vLyBIYXNoVG9DdXJ2ZVxuLy8gMy1pc29nZW55IG1hcCBmcm9tIEUnIHRvIEUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjYXBwZW5kaXgtRS4zXG5jb25zdCBpc29nZW55TWFwRzIgPSBpc29nZW55TWFwKEZwMiwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDVjNzU5NTA3ZThlMzMzZWJiNWI3YTlhNDdkN2VkODUzMmM1MmQzOWZkM2EwNDJhODhiNTg0MjNjNTBhZTE1ZDVjMjYzOGUzNDNkOWM3MWM2MjM4YWFhYWFhYWE5N2Q2JyxcbiAgICAgICAgICAgICcweDVjNzU5NTA3ZThlMzMzZWJiNWI3YTlhNDdkN2VkODUzMmM1MmQzOWZkM2EwNDJhODhiNTg0MjNjNTBhZTE1ZDVjMjYzOGUzNDNkOWM3MWM2MjM4YWFhYWFhYWE5N2Q2JyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgICAgICAnMHgxMTU2MGJmMTdiYWE5OWJjMzIxMjZmY2VkNzg3Yzg4Zjk4NGY4N2FkZjdhZTBjN2Y5YTIwOGM2YjRmMjBhNDE4MTQ3MmFhYTljYjhkNTU1NTI2YTlmZmZmZmZmZmM3MWEnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxMTU2MGJmMTdiYWE5OWJjMzIxMjZmY2VkNzg3Yzg4Zjk4NGY4N2FkZjdhZTBjN2Y5YTIwOGM2YjRmMjBhNDE4MTQ3MmFhYTljYjhkNTU1NTI2YTlmZmZmZmZmZmM3MWUnLFxuICAgICAgICAgICAgJzB4OGFiMDVmOGJkZDU0Y2RlMTkwOTM3ZTc2YmMzZTQ0N2NjMjdjM2Q2ZmJkNzA2M2ZjZDEwNDYzNWE3OTA1MjBjMGEzOTU1NTRlNWM2YWFhYTkzNTRmZmZmZmZmZmUzOGQnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxNzFkNjU0MWZhMzhjY2ZhZWQ2ZGVhNjkxZjVmYjYxNGNiMTRiNGU3ZjRlODEwYWEyMmQ2MTA4ZjE0MmI4NTc1NzA5OGUzOGQwZjY3MWM3MTg4ZTJhYWFhYWFhYTVlZDEnLFxuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgIF0sXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICBbXG4gICAgICAgICAgICAnMHgwJyxcbiAgICAgICAgICAgICcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWE2MycsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweGMnLFxuICAgICAgICAgICAgJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYTlmJyxcbiAgICAgICAgXSxcbiAgICAgICAgWycweDEnLCAnMHgwJ10sIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MTUzMDQ3N2M3YWI0MTEzYjU5YTRjMThiMDc2ZDExOTMwZjdkYTVkNGEwN2Y2NDliZjU0NDM5ZDg3ZDI3ZTUwMGZjOGMyNWViZjhjOTJmNjgxMmNmYzcxYzcxYzZkNzA2JyxcbiAgICAgICAgICAgICcweDE1MzA0NzdjN2FiNDExM2I1OWE0YzE4YjA3NmQxMTkzMGY3ZGE1ZDRhMDdmNjQ5YmY1NDQzOWQ4N2QyN2U1MDBmYzhjMjVlYmY4YzkyZjY4MTJjZmM3MWM3MWM2ZDcwNicsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDAnLFxuICAgICAgICAgICAgJzB4NWM3NTk1MDdlOGUzMzNlYmI1YjdhOWE0N2Q3ZWQ4NTMyYzUyZDM5ZmQzYTA0MmE4OGI1ODQyM2M1MGFlMTVkNWMyNjM4ZTM0M2Q5YzcxYzYyMzhhYWFhYWFhYTk3YmUnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxMTU2MGJmMTdiYWE5OWJjMzIxMjZmY2VkNzg3Yzg4Zjk4NGY4N2FkZjdhZTBjN2Y5YTIwOGM2YjRmMjBhNDE4MTQ3MmFhYTljYjhkNTU1NTI2YTlmZmZmZmZmZmM3MWMnLFxuICAgICAgICAgICAgJzB4OGFiMDVmOGJkZDU0Y2RlMTkwOTM3ZTc2YmMzZTQ0N2NjMjdjM2Q2ZmJkNzA2M2ZjZDEwNDYzNWE3OTA1MjBjMGEzOTU1NTRlNWM2YWFhYTkzNTRmZmZmZmZmZmUzOGYnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxMjRjOWFkNDNiNmNmNzliZmJmNzA0M2RlMzgxMWFkMDc2MWIwZjM3YTFlMjYyODZiMGU5NzdjNjlhYTI3NDUyNGU3OTA5N2E1NmRjNGJkOWUxYjM3MWM3MWM3MThiMTAnLFxuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgIF0sXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmE4ZmInLFxuICAgICAgICAgICAgJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhOGZiJyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmE5ZDMnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxMicsXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhOTknLFxuICAgICAgICBdLFxuICAgICAgICBbJzB4MScsICcweDAnXSwgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgocGFpcikgPT4gRnAyLmZyb21CaWdUdXBsZShwYWlyLm1hcChCaWdJbnQpKSkpKTtcbi8vIDExLWlzb2dlbnkgbWFwIGZyb20gRScgdG8gRVxuY29uc3QgaXNvZ2VueU1hcEcxID0gaXNvZ2VueU1hcChGcCwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDExYTA1ZjJiMWU4MzMzNDBiODA5MTAxZGQ5OTgxNTg1NmIzMDNlODhhMmQ3MDA1ZmYyNjI3YjU2Y2RiNGUyYzg1NjEwYzJkNWYyZTYyZDZlYWVhYzE2NjI3MzQ2NDliNycsXG4gICAgICAgICcweDE3Mjk0ZWQzZTk0M2FiMmYwNTg4YmFiMjIxNDdhODFjN2MxN2U3NWIyZjZhODQxN2Y1NjVlMzNjNzBkMWU4NmI0ODM4ZjJhNmYzMThjMzU2ZTgzNGVlZjFiM2NiODNiYicsXG4gICAgICAgICcweGQ1NDAwNWRiOTc2NzhlYzFkMTA0OGM1ZDEwYTlhMWJjZTAzMjQ3MzI5NTk4M2U1Njg3OGU1MDFlYzY4ZTI1Yzk1OGMzZTNkMmEwOTcyOWZlMDE3OWY5ZGFjOWVkY2IwJyxcbiAgICAgICAgJzB4MTc3OGU3MTY2ZmNjNmRiNzRlMDYwOWQzMDdlNTU0MTJkN2Y1ZTQ2NTZhOGRiZjI1ZjFiMzMyODlmMWIzMzA4MzUzMzZlMjVjZTMxMDcxOTNjNWIzODg2NDFkOWI2ODYxJyxcbiAgICAgICAgJzB4ZTk5NzI2YTMxOTlmNDQzNjY0MmI0YjNlNDExOGU1NDk5ZGI5OTVhMTI1N2ZiM2YwODZlZWI2NTk4MmZhYzE4OTg1YTI4NmYzMDFlNzdjNDUxMTU0Y2U5YWM4ODk1ZDknLFxuICAgICAgICAnMHgxNjMwYzMyNTBkNzMxM2ZmMDFkMTIwMWJmN2E3NGFiNWRiM2NiMTdkZDk1Mjc5OWI5ZWQzYWI5MDk3ZTY4ZjkwYTA4NzBkMmRjYWU3M2QxOWNkMTNjMWM2NmY2NTI5ODMnLFxuICAgICAgICAnMHhkNmVkNjU1M2ZlNDRkMjk2YTM3MjZjMzhhZTY1MmJmYjExNTg2MjY0ZjBmOGNlMTkwMDhlMjE4ZjljODZiMmE4ZGEyNTEyOGMxMDUyZWNhZGRkN2YyMjVhMTM5ZWQ4NCcsXG4gICAgICAgICcweDE3YjgxZTc3MDFhYmRiZTJlODc0Mzg4NGQxMTE3ZTUzMzU2ZGU1YWIyNzViNGRiMWE2ODJjNjJlZjBmMjc1MzMzOWI3YzhmOGM4ZjQ3NWFmOWNjYjU2MThlM2YwYzg4ZScsXG4gICAgICAgICcweDgwZDNjZjFmOWE3OGZjNDdiOTBiMzM1NjNiZTk5MGRjNDNiNzU2Y2U3OWY1NTc0YTJjNTk2YzkyOGM1ZDFkZTRmYTI5NWYyOTZiNzRlOTU2ZDcxOTg2YTg0OTdlMzE3JyxcbiAgICAgICAgJzB4MTY5YjFmOGUxYmNmYTdjNDJlMGMzNzUxNWQxMzhmMjJkZDJlY2I4MDNhMGM1Yzk5Njc2MzE0YmFmNGJiMWI3ZmEzMTkwYjJlZGMwMzI3Nzk3ZjI0MTA2N2JlMzkwYzllJyxcbiAgICAgICAgJzB4MTAzMjFkYTA3OWNlMDdlMjcyZDhlYzA5ZDI1NjViMGRmYTdkY2NkZGU2Nzg3Zjk2ZDUwYWYzNjAwM2IxNDg2NmY2OWI3NzFmOGMyODVkZWNjYTY3ZGYzZjE2MDVmYjdiJyxcbiAgICAgICAgJzB4NmUwOGMyNDhlMjYwZTcwYmQxZTk2MjM4MWVkZWUzZDMxZDc5ZDdlMjJjODM3YmMyM2MwYmYxYmMyNGM2YjY4YzI0YjFiODBiNjRkMzkxZmE5YzhiYTJlOGJhMmQyMjknLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4OGNhOGQ1NDhjZmYxOWFlMThiMmU2MmY0YmQzZmE2ZjAxZDVlZjRiYTM1YjQ4YmE5Yzk1ODg2MTdmYzhhYzYyYjU1OGQ2ODFiZTM0M2RmODk5M2NmOWZhNDBkMjFiMWMnLFxuICAgICAgICAnMHgxMjU2MWE1ZGViNTU5YzQzNDhiNDcxMTI5OGU1MzYzNjcwNDFlOGNhMGNmMDgwMGMwMTI2YzI1ODhjNDhiZjU3MTNkYWE4ODQ2Y2IwMjZlOWU1YzgyNzZlYzgyYjNiZmYnLFxuICAgICAgICAnMHhiMjk2MmZlNTdhMzIyNWU4MTM3ZTYyOWJmZjI5OTFmNmY4OTQxNmY1YTcxOGNkMWZjYTY0ZTAwYjExYWNlYWNkNmEzZDA5NjdjOTRmZWRjZmNjMjM5YmE1Y2I4M2UxOScsXG4gICAgICAgICcweDM0MjU1ODFhNThhZTJmZWM4M2FhZmVmN2M0MGViNTQ1YjA4MjQzZjE2YjE2NTUxNTRjY2E4YWJjMjhkNmZkMDQ5NzZkNTI0M2VlY2Y1YzQxMzBkZTg5MzhkYzYyY2Q4JyxcbiAgICAgICAgJzB4MTNhOGUxNjIwMjI5MTRhODBhNmYxZDVmNDNlN2EwN2RmZmRmYzc1OWExMjA2MmJiOGQ2YjQ0ZTgzM2IzMDZkYTliZDI5YmE4MWYzNTc4MWQ1MzlkMzk1YjM1MzJhMjFlJyxcbiAgICAgICAgJzB4ZTczNTVmOGU0ZTY2N2I5NTUzOTBmN2YwNTA2YzZlOTM5NTczNWU5Y2U5Y2FkNGQwYTQzYmNlZjI0Yjg5ODJmNzQwMGQyNGJjNDIyOGYxMWMwMmRmOWEyOWY2MzA0YTUnLFxuICAgICAgICAnMHg3NzJjYWFjZjE2OTM2MTkwZjNlMGM2M2UwNTk2NzIxNTcwZjU3OTlhZjUzYTE4OTRlMmUwNzMwNjJhZWRlOWNlYTczYjM1MzhmMGRlMDZjZWMyNTc0NDk2ZWU4NGEzYScsXG4gICAgICAgICcweDE0YTdhYzJhOWQ2NGE4YjIzMGIzZjViMDc0Y2YwMTk5NmU3ZjYzYzIxYmNhNjhhODE5OTZlMWNkZjk4MjJjNTgwZmE1Yjk0ODlkMTFlMmQzMTFmN2Q5OWJiZGNjNWE1ZScsXG4gICAgICAgICcweGExMGVjZjZhZGE1NGY4MjVlOTIwYjNkYWZjN2EzY2NlMDdmOGQxZDcxNjEzNjZiNzQxMDBkYTY3ZjM5ODgzNTAzODI2NjkyYWJiYTQzNzA0Nzc2ZWMzYTc5YTFkNjQxJyxcbiAgICAgICAgJzB4OTVmYzEzYWI5ZTkyYWQ0NDc2ZDZlM2ViM2E1NjY4MGY2ODJiNGVlOTZmN2QwMzc3NmRmNTMzOTc4ZjMxYzE1OTMxNzRlNGI0Yjc4NjUwMDJkNjM4NGQxNjhlY2RkMGEnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDkwZDk3YzgxYmEyNGVlMDI1OWQxZjA5NDk4MGRjZmExMWFkMTM4ZTQ4YTg2OTUyMmI1MmFmNmM5NTY1NDNkM2NkMGM3YWVlOWIzYmEzYzJiZTk4NDU3MTk3MDdiYjMzJyxcbiAgICAgICAgJzB4MTM0OTk2YTEwNGVlNTgxMWQ1MTAzNmQ3NzZmYjQ2ODMxMjIzZTk2YzI1NGYzODNkMGY5MDYzNDNlYjY3YWQzNGQ2YzU2NzExOTYyZmE4YmZlMDk3ZTc1YTJlNDFjNjk2JyxcbiAgICAgICAgJzB4Y2M3ODZiYWE5NjZlNjZmNGEzODRjODZhM2I0OTk0MjU1MmUyZDY1OGEzMWNlMmMzNDRiZTRiOTE0MDBkYTdkMjZkNTIxNjI4YjAwNTIzYjhkZmUyNDBjNzJkZTFmNicsXG4gICAgICAgICcweDFmODYzNzZlODk4MWMyMTc4OTg3NTFhZDg3NDY3NTdkNDJhYTdiOTBlZWI3OTFjMDllNGEzZWMwMzI1MWNmOWRlNDA1YWJhOWVjNjFkZWNhNjM1NWM3N2IwZTVmNGNiJyxcbiAgICAgICAgJzB4OGNjMDNmZGVmZTBmZjEzNWNhZjRmZTJhMjE1MjljNDE5NTUzNmZiZTNjZTUwYjg3OTgzM2ZkMjIxMzUxYWRjMmVlN2Y4ZGMwOTkwNDBhODQxYjZkYWVjZjJlOGZlZGInLFxuICAgICAgICAnMHgxNjYwM2ZjYTQwNjM0YjZhMjIxMWUxMWRiOGYwYTZhMDc0YTdkMGQ0YWZhZGI3YmQ3NjUwNWMzZDNhZDU1NDRlMjAzZjYzMjZjOTVhODA3Mjk5YjIzYWIxMzYzM2E1ZjAnLFxuICAgICAgICAnMHg0YWIwYjliY2ZhYzFiYmNiMmM5NzdkMDI3Nzk2YjNjZTc1YmI4Y2EyYmUxODRjYjUyMzE0MTNjNGQ2MzRmMzc0N2E4N2FjMjQ2MGY0MTVlYzk2MWY4ODU1ZmU5ZDZmMicsXG4gICAgICAgICcweDk4N2M4ZDUzMzNhYjg2ZmRlOTkyNmJkMmNhNmM2NzQxNzBhMDViZmUzYmRkODFmZmQwMzhkYTZjMjZjODQyNjQyZjY0NTUwZmVkZmU5MzVhMTVlNGNhMzE4NzBmYjI5JyxcbiAgICAgICAgJzB4OWZjNDAxOGJkOTY2ODRiZTg4YzllMjIxZTRkYTFiYjhmM2FiZDE2Njc5ZGMyNmMxZThiNmU2YTFmMjBjYWJlNjlkNjUyMDFjNzg2MDdhMzYwMzcwZTU3N2JkYmE1ODcnLFxuICAgICAgICAnMHhlMWJiYTdhMTE4NmJkYjUyMjNhYmRlN2FkYTE0YTIzYzQyYTBjYTc5MTVhZjZmZTA2OTg1ZTdlZDFlNGQ0M2I5YjNmNzA1NWRkNGViYTZmMmJhZmFhZWJjYTczMWMzMCcsXG4gICAgICAgICcweDE5NzEzZTQ3OTM3Y2QxYmUwZGZkMGI4ZjFkNDNmYjkzY2QyZmNiY2I2Y2FmNDkzZmQxMTgzZTQxNjM4OWU2MTAzMWJmM2E1Y2NlM2ZiYWZjZTgxMzcxMWFkMDExYzEzMicsXG4gICAgICAgICcweDE4YjQ2YTkwOGYzNmY2ZGViOTE4YzE0M2ZlZDJlZGNjNTIzNTU5YjhhYWYwYzI0NjJlNmJmZTdmOTExZjY0MzI0OWQ5Y2RmNDFiNDRkNjA2Y2UwN2M4YTRkMDA3NGQ4ZScsXG4gICAgICAgICcweGIxODJjYWMxMDFiOTM5OWQxNTUwOTYwMDRmNTNmNDQ3YWE3YjEyYTM0MjZiMDhlYzAyNzEwZTgwN2I0NjMzZjA2Yzg1MWMxOTE5MjExZjIwZDRjMDRmMDBiOTcxZWY4JyxcbiAgICAgICAgJzB4MjQ1YTM5NGFkMWVjYTliNzJmYzAwYWU3YmUzMTVkYzc1N2IzYjA4MGQ0YzE1ODAxM2U2NjMyZDNjNDA2NTljYzZjZjkwYWQxYzIzMmE2NDQyZDlkM2Y1ZGI5ODAxMzMnLFxuICAgICAgICAnMHg1YzEyOTY0NWU0NGNmMTEwMmExNTlmNzQ4YzRhM2ZjNWU2NzNkODFkN2U4NjU2OGQ5YWIwZjVkMzk2YTdjZTQ2YmExMDQ5YjY1NzlhZmI3ODY2YjFlNzE1NDc1MjI0YicsXG4gICAgICAgICcweDE1ZTZiZTRlOTkwZjAzY2U0ZWE1MGIzYjQyZGYyZWI1Y2IxODFkOGY4NDk2NWEzOTU3YWRkNGZhOTVhZjAxYjJiNjY1MDI3ZWZlYzAxYzc3MDRiNDU2YmU2OWM4YjYwNCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHgxNjExMmM0YzNhOWM5OGIyNTIxODExNDBmYWQwZWFlOTYwMWE2ZGU1Nzg5ODBiZTZlZWMzMjMyYjViZTcyZTdhMDdmMzY4OGVmNjBjMjA2ZDAxNDc5MjUzYjAzNjYzYzEnLFxuICAgICAgICAnMHgxOTYyZDc1YzIzODEyMDFlMWEwY2JkNmM0M2MzNDhiODg1Yzg0ZmY3MzFjNGQ1OWNhNGExMDM1NmY0NTNlMDFmNzhhNDI2MDc2MzUyOWUzNTMyZjYxMDJjMmU0OWEwM2QnLFxuICAgICAgICAnMHg1OGRmMzMwNjY0MGRhMjc2ZmFhYWU3ZDZlOGViMTU3NzhjNDg1NTU1MWFlN2YzMTBjMzVhNWRkMjc5Y2QyZWNhNjc1N2NkNjM2Zjk2Zjg5MWUyNTM4YjUzZGJmNjdmMicsXG4gICAgICAgICcweDE2YjdkMjg4Nzk4ZTUzOTVmMjBkMjNiZjg5ZWRiNGQxZDExNWM1ZGJkZGJjZDMwZTEyM2RhNDg5ZTcyNmFmNDE3MjczNjRmMmMyODI5N2FkYThkMjZkOTg0NDVmNTQxNicsXG4gICAgICAgICcweGJlMGUwNzk1NDVmNDNlNGIwMGNjOTEyZjgyMjhkZGNjNmQxOWM5ZjBmNjliYmIwNTQyZWRhMGZjOWRlYzkxNmEyMGIxNWRjMGZkMmVkZWRkYTM5MTQyMzExYTUwMDFkJyxcbiAgICAgICAgJzB4OGQ5ZTUyOTcxODZkYjJkOWZiMjY2ZWFhYzc4MzE4MmI3MDE1MmM2NTU1MGQ4ODFjNWVjZDg3YjZmMGY1YTY0NDlmMzhkYjlkZmE5Y2NlMjAyYzY0NzdmYWFmOWI3YWMnLFxuICAgICAgICAnMHgxNjYwMDdjMDhhOTlkYjJmYzNiYTg3MzRhY2U5ODI0YjVlZWNmZGZhOGQwY2Y4ZWY1ZGQzNjViYzQwMGEwMDUxZDVmYTljMDFhNThiMWZiOTNkMWExMzk5MTI2YTc3NWMnLFxuICAgICAgICAnMHgxNmEzZWYwOGJlM2VhN2VhMDNiY2RkZmFiYmE2ZmY2ZWU1YTQzNzVlZmExZjRmZDdmZWIzNGZkMjA2MzU3MTMyYjkyMGY1YjAwODAxZGVlNDYwZWU0MTVhMTU4MTJlZDknLFxuICAgICAgICAnMHgxODY2YzhlZDMzNmM2MTIzMWExYmU1NGZkMWQ3NGNjNGY5ZmIwY2U0YzZhZjU5MjBhYmM1NzUwYzRiZjM5YjQ4NTJjZmUyZjdiYjkyNDg4MzZiMjMzZDlkNTU1MzVkNGEnLFxuICAgICAgICAnMHgxNjdhNTVjZGE3MGE2ZTFjZWE4MjA1OTdkOTRhODQ5MDMyMTZmNzYzZTEzZDg3YmI1MzA4NTkyZTdlYTdkNGZiYzczODVlYTNkNTI5YjM1ZTM0NmVmNDhiYjg5MTNmNTUnLFxuICAgICAgICAnMHg0ZDJmMjU5ZWVhNDA1YmQ0OGYwMTBhMDFhZDI5MTFkOWM2ZGQwMzliYjYxYTYyOTBlNTkxYjM2ZTYzNmE1Yzg3MWE1YzI5ZjRmODMwNjA0MDBmOGI0OWNiYThmNmFhOCcsXG4gICAgICAgICcweGFjY2JiNjc0ODFkMDMzZmY1ODUyYzFlNDhjNTBjNDc3Zjk0ZmY4YWVmY2U0MmQyOGMwZjlhODhjZWE3OTEzNTE2Zjk2ODk4NmY3ZWJiZWE5Njg0YjUyOWUyNTYxMDkyJyxcbiAgICAgICAgJzB4YWQ2Yjk1MTRjNzY3ZmUzYzM2MTMxNDRiNDVmMTQ5NjU0MzM0NmQ5OGFkZjAyMjY3ZDVjZWVmOWEwMGQ5Yjg2OTMwMDA3NjNlM2I5MGFjMTFlOTliMTM4NTczMzQ1Y2MnLFxuICAgICAgICAnMHgyNjYwNDAwZWIyZTRmM2I2MjhiZGQwZDUzY2Q3NmYyYmY1NjViOTRlNzI5MjdjMWNiNzQ4ZGYyNzk0MjQ4MGU0MjA1MTdiZDg3MTRjYzgwZDFmYWRjMTMyNmVkMDZmNycsXG4gICAgICAgICcweGUwZmExZDgxNmRkYzAzZTZiMjQyNTVlMGQ3ODE5YzE3MWM0MGY2NWUyNzNiODUzMzI0ZWZjZDYzNTZjYWEyMDVjYTJmNTcwZjEzNDk3ODA0NDE1NDczYTFkNjM0YjhmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpO1xuLy8gU1dVIE1hcCAtIEZwMiB0byBHMic6IHnCsiA9IHjCsyArIDI0MGkgKiB4ICsgMTAxMiArIDEwMTJpXG5jb25zdCBHMl9TV1UgPSBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwMiwge1xuICAgIEE6IEZwMi5jcmVhdGUoeyBjMDogRnAuY3JlYXRlKF8wbiksIGMxOiBGcC5jcmVhdGUoQmlnSW50KDI0MCkpIH0pLCAvLyBBJyA9IDI0MCAqIElcbiAgICBCOiBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZShCaWdJbnQoMTAxMikpLCBjMTogRnAuY3JlYXRlKEJpZ0ludCgxMDEyKSkgfSksIC8vIEInID0gMTAxMiAqICgxICsgSSlcbiAgICBaOiBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZShCaWdJbnQoLTIpKSwgYzE6IEZwLmNyZWF0ZShCaWdJbnQoLTEpKSB9KSwgLy8gWjogLSgyICsgSSlcbn0pO1xuLy8gT3B0aW1pemVkIFNXVSBNYXAgLSBGcCB0byBHMVxuY29uc3QgRzFfU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwge1xuICAgIEE6IEZwLmNyZWF0ZShCaWdJbnQoJzB4MTQ0Njk4YTNiOGU5NDMzZDY5M2EwMmM5NmQ0OTgyYjBlYTk4NTM4M2VlNjZhOGQ4ZTg5ODFhZWZkODgxYWM5ODkzNmY4ZGEwZTBmOTdmNWNmNDI4MDgyZDU4NGMxZCcpKSxcbiAgICBCOiBGcC5jcmVhdGUoQmlnSW50KCcweDEyZTI5MDhkMTE2ODgwMzAwMThiMTJlODc1M2VlZTNiMjAxNmMxZjBmMjRmNDA3MGEwYjljMTRmY2VmMzVlZjU1YTIzMjE1YTMxNmNlYWE1ZDFjYzQ4ZTk4ZTE3MmJlMCcpKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KDExKSksXG59KTtcbi8vIEdMViBlbmRvbW9ycGhpc20gzqgoUCksIGZvciBmYXN0IGNvZmFjdG9yIGNsZWFyaW5nXG5jb25zdCB7IEcycHNpLCBHMnBzaTIgfSA9IHBzaUZyb2Jlbml1cyhGcCwgRnAyLCBGcDIuZGl2KEZwMi5PTkUsIEZwMi5OT05SRVNJRFVFKSk7IC8vIDEvKHUrMSlcbi8vIERlZmF1bHQgaGFzaF90b19maWVsZCBvcHRpb25zIGFyZSBmb3IgaGFzaCB0byBHMi5cbi8vXG4vLyBQYXJhbWV0ZXIgZGVmaW5pdGlvbnMgYXJlIGluIHNlY3Rpb24gNS4zIG9mIHRoZSBzcGVjIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQuXG4vLyBQYXJhbWV0ZXIgdmFsdWVzIGNvbWUgZnJvbSBzZWN0aW9uIDguOC4yIG9mIHRoZSBzcGVjLlxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi04LjguMlxuLy9cbi8vIEJhc2UgZmllbGQgRiBpcyBHRihwXm0pXG4vLyBwID0gMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJcbi8vIG0gPSAyIChvciAxIGZvciBHMSBzZWUgc2VjdGlvbiA4LjguMSlcbi8vIGsgPSAxMjhcbmNvbnN0IGh0ZkRlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLy8gRFNUOiBhIGRvbWFpbiBzZXBhcmF0aW9uIHRhZ1xuICAgIC8vIGRlZmluZWQgaW4gc2VjdGlvbiAyLjIuNVxuICAgIC8vIFVzZSB1dGlscy5nZXREU1RMYWJlbCgpLCB1dGlscy5zZXREU1RMYWJlbCh2YWx1ZSlcbiAgICBEU1Q6ICdCTFNfU0lHX0JMUzEyMzgxRzJfWE1EOlNIQS0yNTZfU1NXVV9ST19OVUxfJyxcbiAgICBlbmNvZGVEU1Q6ICdCTFNfU0lHX0JMUzEyMzgxRzJfWE1EOlNIQS0yNTZfU1NXVV9ST19OVUxfJyxcbiAgICAvLyBwOiB0aGUgY2hhcmFjdGVyaXN0aWMgb2YgRlxuICAgIC8vICAgIHdoZXJlIEYgaXMgYSBmaW5pdGUgZmllbGQgb2YgY2hhcmFjdGVyaXN0aWMgcCBhbmQgb3JkZXIgcSA9IHBebVxuICAgIHA6IEZwLk9SREVSLFxuICAgIC8vIG06IHRoZSBleHRlbnNpb24gZGVncmVlIG9mIEYsIG0gPj0gMVxuICAgIC8vICAgICB3aGVyZSBGIGlzIGEgZmluaXRlIGZpZWxkIG9mIGNoYXJhY3RlcmlzdGljIHAgYW5kIG9yZGVyIHEgPSBwXm1cbiAgICBtOiAyLFxuICAgIC8vIGs6IHRoZSB0YXJnZXQgc2VjdXJpdHkgbGV2ZWwgZm9yIHRoZSBzdWl0ZSBpbiBiaXRzXG4gICAgLy8gZGVmaW5lZCBpbiBzZWN0aW9uIDUuMVxuICAgIGs6IDEyOCxcbiAgICAvLyBvcHRpb24gdG8gdXNlIGEgbWVzc2FnZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkIGJ5XG4gICAgLy8gZXhwYW5kX21lc3NhZ2VfeG1kXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICAvLyBIYXNoIGZ1bmN0aW9ucyBmb3I6IGV4cGFuZF9tZXNzYWdlX3htZCBpcyBhcHByb3ByaWF0ZSBmb3IgdXNlIHdpdGggYVxuICAgIC8vIHdpZGUgcmFuZ2Ugb2YgaGFzaCBmdW5jdGlvbnMsIGluY2x1ZGluZyBTSEEtMiwgU0hBLTMsIEJMQUtFMiwgYW5kIG90aGVycy5cbiAgICAvLyBCQlMrIHVzZXMgYmxha2UyOiBodHRwczovL2dpdGh1Yi5jb20vaHlwZXJsZWRnZXIvYXJpZXMtZnJhbWV3b3JrLWdvL2lzc3Vlcy8yMjQ3XG4gICAgaGFzaDogc2hhMjU2LFxufSk7XG4vLyBFbmNvZGluZyB1dGlsc1xuLy8gUG9pbnQgb24gRzEgY3VydmU6ICh4LCB5KVxuLy8gQ29tcHJlc3NlZCBwb2ludCBvZiBpbmZpbml0eVxuY29uc3QgQ09NUFJFU1NFRF9aRVJPID0gc2V0TWFzayhGcC50b0J5dGVzKF8wbiksIHsgaW5maW5pdHk6IHRydWUsIGNvbXByZXNzZWQ6IHRydWUgfSk7IC8vIHNldCBjb21wcmVzc2VkICYgcG9pbnQtYXQtaW5maW5pdHkgYml0c1xuZnVuY3Rpb24gcGFyc2VNYXNrKGJ5dGVzKSB7XG4gICAgLy8gQ29weSwgc28gd2UgY2FuIHJlbW92ZSBtYXNrIGRhdGEuIEl0IHdpbGwgYmUgcmVtb3ZlZCBhbHNvIGxhdGVyLCB3aGVuIEZwLmNyZWF0ZSB3aWxsIGNhbGwgbW9kdWxvLlxuICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoKTtcbiAgICBjb25zdCBtYXNrID0gYnl0ZXNbMF0gJiAyMjQ7XG4gICAgY29uc3QgY29tcHJlc3NlZCA9ICEhKChtYXNrID4+IDcpICYgMSk7IC8vIGNvbXByZXNzaW9uIGJpdCAoMGIxMDAwXzAwMDApXG4gICAgY29uc3QgaW5maW5pdHkgPSAhISgobWFzayA+PiA2KSAmIDEpOyAvLyBwb2ludCBhdCBpbmZpbml0eSBiaXQgKDBiMDEwMF8wMDAwKVxuICAgIGNvbnN0IHNvcnQgPSAhISgobWFzayA+PiA1KSAmIDEpOyAvLyBzb3J0IGJpdCAoMGIwMDEwXzAwMDApXG4gICAgYnl0ZXNbMF0gJj0gMzE7IC8vIGNsZWFyIG1hc2sgKHplcm8gZmlyc3QgMyBiaXRzKVxuICAgIHJldHVybiB7IGNvbXByZXNzZWQsIGluZmluaXR5LCBzb3J0LCB2YWx1ZTogYnl0ZXMgfTtcbn1cbmZ1bmN0aW9uIHNldE1hc2soYnl0ZXMsIG1hc2spIHtcbiAgICBpZiAoYnl0ZXNbMF0gJiAyMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0TWFzazogbm9uLWVtcHR5IG1hc2snKTtcbiAgICBpZiAobWFzay5jb21wcmVzc2VkKVxuICAgICAgICBieXRlc1swXSB8PSAxMjg7XG4gICAgaWYgKG1hc2suaW5maW5pdHkpXG4gICAgICAgIGJ5dGVzWzBdIHw9IDY0O1xuICAgIGlmIChtYXNrLnNvcnQpXG4gICAgICAgIGJ5dGVzWzBdIHw9IDMyO1xuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZUcxVG9SYXdCeXRlcyhwb2ludCkge1xuICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgY29uc3QgaXNaZXJvID0gcG9pbnQuZXF1YWxzKGJsczEyXzM4MS5HMS5Qcm9qZWN0aXZlUG9pbnQuWkVSTyk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludC50b0FmZmluZSgpO1xuICAgIGlmIChpc1plcm8pXG4gICAgICAgIHJldHVybiBDT01QUkVTU0VEX1pFUk8uc2xpY2UoKTtcbiAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgY29uc3Qgc29ydCA9IEJvb2xlYW4oKHkgKiBfMm4pIC8gUCk7XG4gICAgcmV0dXJuIHNldE1hc2sobnVtYmVyVG9CeXRlc0JFKHgsIEZwLkJZVEVTKSwgeyBjb21wcmVzc2VkOiB0cnVlLCBzb3J0IH0pO1xufVxuZnVuY3Rpb24gc2lnbmF0dXJlRzJUb1Jhd0J5dGVzKHBvaW50KSB7XG4gICAgLy8gTk9URTogYnkgc29tZSByZWFzb25zIGl0IHdhcyBtaXNzZWQgaW4gYmxzMTItMzgxLCBsb29rcyBsaWtlIGJ1Z1xuICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgaWYgKHBvaW50LmVxdWFscyhibHMxMl8zODEuRzIuUHJvamVjdGl2ZVBvaW50LlpFUk8pKVxuICAgICAgICByZXR1cm4gY29uY2F0QihDT01QUkVTU0VEX1pFUk8sIG51bWJlclRvQnl0ZXNCRShfMG4sIGxlbikpO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICBjb25zdCB7IHJlOiB4MCwgaW06IHgxIH0gPSBGcDIucmVpbSh4KTtcbiAgICBjb25zdCB7IHJlOiB5MCwgaW06IHkxIH0gPSBGcDIucmVpbSh5KTtcbiAgICBjb25zdCB0bXAgPSB5MSA+IF8wbiA/IHkxICogXzJuIDogeTAgKiBfMm47XG4gICAgY29uc3Qgc29ydCA9IEJvb2xlYW4oKHRtcCAvIEZwLk9SREVSKSAmIF8xbik7XG4gICAgY29uc3QgejIgPSB4MDtcbiAgICByZXR1cm4gY29uY2F0QihzZXRNYXNrKG51bWJlclRvQnl0ZXNCRSh4MSwgbGVuKSwgeyBzb3J0LCBjb21wcmVzc2VkOiB0cnVlIH0pLCBudW1iZXJUb0J5dGVzQkUoejIsIGxlbikpO1xufVxuLyoqXG4gKiBibHMxMi0zODEgcGFpcmluZy1mcmllbmRseSBjdXJ2ZS5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBibHMxMl8zODEgYXMgYmxzIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9ibHMxMi0zODEnO1xuICogLy8gRzEga2V5cywgRzIgc2lnbmF0dXJlc1xuICogY29uc3QgcHJpdmF0ZUtleSA9ICc2N2Q1M2YxNzBiOTA4Y2FiYjllYjMyNmMzYzMzNzc2MmQ1OTI4OWE4ZmVjNzlmN2JjOTI1NGI1ODRiNzMyNjVjJztcbiAqIGNvbnN0IG1lc3NhZ2UgPSAnNjQ3MjZlM2RhOCc7XG4gKiBjb25zdCBwdWJsaWNLZXkgPSBibHMuZ2V0UHVibGljS2V5KHByaXZhdGVLZXkpO1xuICogY29uc3Qgc2lnbmF0dXJlID0gYmxzLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSk7XG4gKiBjb25zdCBpc1ZhbGlkID0gYmxzLnZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gKi9cbmV4cG9ydCBjb25zdCBibHMxMl8zODEgPSBibHMoe1xuICAgIC8vIEZpZWxkc1xuICAgIGZpZWxkczoge1xuICAgICAgICBGcCxcbiAgICAgICAgRnAyLFxuICAgICAgICBGcDYsXG4gICAgICAgIEZwMTIsXG4gICAgICAgIEZyLFxuICAgIH0sXG4gICAgLy8gRzEgaXMgdGhlIG9yZGVyLXEgc3ViZ3JvdXAgb2YgRTEoRnApIDogecKyID0geMKzICsgNCwgI0UxKEZwKSA9IGgxcSwgd2hlcmVcbiAgICAvLyBjaGFyYWN0ZXJpc3RpYzsgeiArICh64oG0IC0gesKyICsgMSkoeiAtIDEpwrIvM1xuICAgIEcxOiB7XG4gICAgICAgIEZwLFxuICAgICAgICAvLyBjb2ZhY3RvcjsgKHogLSAxKcKyLzNcbiAgICAgICAgaDogQmlnSW50KCcweDM5NmM4YzAwNTU1NWUxNTY4YzAwYWFhYjAwMDBhYWFiJyksXG4gICAgICAgIC8vIGdlbmVyYXRvcidzIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIHggPSAzNjg1NDE2NzUzNzEzMzg3MDE2NzgxMDg4MzE1MTgzMDc3NzU3OTYxNjIwNzk1NzgyNTQ2NDA5ODk0NTc4Mzc4Njg4NjA3NTkyMzc4Mzc2MzE4ODM2MDU0OTQ3Njc2MzQ1ODIxNTQ4MTA0MTg1NDY0NTA3XG4gICAgICAgIC8vIHkgPSAxMzM5NTA2NTQ0OTQ0NDc2NDczMDIwNDcxMzc5OTQxOTIxMjIxNTg0OTMzODc1OTM4MzQ5NjIwNDI2NTQzNzM2NDE2NTExNDIzOTU2MzMzNTA2NDcyNzI0NjU1MzUzMzY2NTM0OTkyMzkxNzU2NDQxNTY5XG4gICAgICAgIEd4OiBCaWdJbnQoJzB4MTdmMWQzYTczMTk3ZDc5NDI2OTU2MzhjNGZhOWFjMGZjMzY4OGM0Zjk3NzRiOTA1YTE0ZTNhM2YxNzFiYWM1ODZjNTVlODNmZjk3YTFhZWZmYjNhZjAwYWRiMjJjNmJiJyksXG4gICAgICAgIEd5OiBCaWdJbnQoJzB4MDhiM2Y0ODFlM2FhYTBmMWEwOWUzMGVkNzQxZDhhZTRmY2Y1ZTA5NWQ1ZDAwYWY2MDBkYjE4Y2IyYzA0YjNlZGQwM2NjNzQ0YTI4ODhhZTQwY2FhMjMyOTQ2YzVlN2UxJyksXG4gICAgICAgIGE6IEZwLlpFUk8sXG4gICAgICAgIGI6IF80bixcbiAgICAgICAgaHRmRGVmYXVsdHM6IHsgLi4uaHRmRGVmYXVsdHMsIG06IDEsIERTVDogJ0JMU19TSUdfQkxTMTIzODFHMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPX05VTF8nIH0sXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiB0cnVlLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6IHRydWUsXG4gICAgICAgIC8vIENoZWNrcyBpcyB0aGUgcG9pbnQgcmVzaWRlcyBpbiBwcmltZS1vcmRlciBzdWJncm91cC5cbiAgICAgICAgLy8gcG9pbnQuaXNUb3JzaW9uRnJlZSgpIHNob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgcG9pbnRzXG4gICAgICAgIC8vIEl0IHJldHVybnMgZmFsc2UgZm9yIHNoaXR0eSBwb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjEvMTEzMC5wZGZcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogKGMsIHBvaW50KSA9PiB7XG4gICAgICAgICAgICAvLyBHTFYgZW5kb21vcnBoaXNtIM+IKFApXG4gICAgICAgICAgICBjb25zdCBiZXRhID0gQmlnSW50KCcweDVmMTk2NzJmZGY3NmNlNTFiYTY5YzYwNzZhMGY3N2VhZGRiM2E5M2JlNmY4OTY4OGRlMTdkODEzNjIwYTAwMDIyZTAxZmZmZmZmZmVmZmZlJyk7XG4gICAgICAgICAgICBjb25zdCBwaGkgPSBuZXcgYyhGcC5tdWwocG9pbnQucHgsIGJldGEpLCBwb2ludC5weSwgcG9pbnQucHopO1xuICAgICAgICAgICAgLy8gVE9ETzogdW5yb2xsXG4gICAgICAgICAgICBjb25zdCB4UCA9IHBvaW50Lm11bHRpcGx5VW5zYWZlKEJMU19YKS5uZWdhdGUoKTsgLy8gW3hdUFxuICAgICAgICAgICAgY29uc3QgdTJQID0geFAubXVsdGlwbHlVbnNhZmUoQkxTX1gpOyAvLyBbdTJdUFxuICAgICAgICAgICAgcmV0dXJuIHUyUC5lcXVhbHMocGhpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2xlYXIgY29mYWN0b3Igb2YgRzFcbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS80MDNcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogKF9jLCBwb2ludCkgPT4ge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQubXVsdGlwbHlVbnNhZmUoQkxTX1gpLmFkZChwb2ludCk7IC8vIHgqUCArIFBcbiAgICAgICAgfSxcbiAgICAgICAgbWFwVG9DdXJ2ZTogKHNjYWxhcnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gRzFfU1dVKEZwLmNyZWF0ZShzY2FsYXJzWzBdKSk7XG4gICAgICAgICAgICByZXR1cm4gaXNvZ2VueU1hcEcxKHgsIHkpO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjb21wcmVzc2VkLCBpbmZpbml0eSwgc29ydCwgdmFsdWUgfSA9IHBhcnNlTWFzayhieXRlcyk7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSA0OCAmJiBjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRnAuYnl0ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZFZhbHVlID0gYnl0ZXNUb051bWJlckJFKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmNyZWF0ZShjb21wcmVzc2VkVmFsdWUgJiBGcC5NQVNLKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggIT09IF8wbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRzE6IG5vbi1lbXB0eSBjb21wcmVzc2VkIHBvaW50IGF0IGluZmluaXR5Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IF8wbiwgeTogXzBuIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gRnAuYWRkKEZwLnBvdyh4LCBfM24pLCBGcC5jcmVhdGUoYmxzMTJfMzgxLnBhcmFtcy5HMWIpKTsgLy8gecKyID0geMKzICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydChyaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKCF5KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY29tcHJlc3NlZCBHMSBwb2ludCcpO1xuICAgICAgICAgICAgICAgIGlmICgoeSAqIF8ybikgLyBQICE9PSBCaWdJbnQoc29ydCkpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuY3JlYXRlKHgpLCB5OiBGcC5jcmVhdGUoeSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PT0gOTYgJiYgIWNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5maW5pdHkgZmxhZyBpcyBzZXRcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gYnl0ZXNUb051bWJlckJFKHZhbHVlLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZS5zdWJhcnJheShGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCAhPT0gXzBuIHx8IHkgIT09IF8wbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRzE6IG5vbi1lbXB0eSBwb2ludCBhdCBpbmZpbml0eScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxzMTJfMzgxLkcxLlByb2plY3RpdmVQb2ludC5aRVJPLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLmNyZWF0ZSh4KSwgeTogRnAuY3JlYXRlKHkpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQgRzEsIGV4cGVjdGVkIDQ4Lzk2IGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvQnl0ZXM6IChjLCBwb2ludCwgaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1plcm8gPSBwb2ludC5lcXVhbHMoYy5aRVJPKTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNaZXJvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ09NUFJFU1NFRF9aRVJPLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnQgPSBCb29sZWFuKCh5ICogXzJuKSAvIFApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRNYXNrKG51bWJlclRvQnl0ZXNCRSh4LCBGcC5CWVRFUyksIHsgY29tcHJlc3NlZDogdHJ1ZSwgc29ydCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMnggUFVCTElDX0tFWV9MRU5HVEhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGNvbmNhdEIobmV3IFVpbnQ4QXJyYXkoWzB4NDBdKSwgbmV3IFVpbnQ4QXJyYXkoMiAqIEZwLkJZVEVTIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXRCKG51bWJlclRvQnl0ZXNCRSh4LCBGcC5CWVRFUyksIG51bWJlclRvQnl0ZXNCRSh5LCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgU2hvcnRTaWduYXR1cmU6IHtcbiAgICAgICAgICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmZpbml0eSwgc29ydCwgdmFsdWUgfSA9IHBhcnNlTWFzayhlbnN1cmVCeXRlcygnc2lnbmF0dXJlSGV4JywgaGV4LCA0OCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBGcC5PUkRFUjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkVmFsdWUgPSBieXRlc1RvTnVtYmVyQkUodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFplcm9cbiAgICAgICAgICAgICAgICBpZiAoaW5maW5pdHkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibHMxMl8zODEuRzEuUHJvamVjdGl2ZVBvaW50LlpFUk87XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmNyZWF0ZShjb21wcmVzc2VkVmFsdWUgJiBGcC5NQVNLKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IEZwLmFkZChGcC5wb3coeCwgXzNuKSwgRnAuY3JlYXRlKGJsczEyXzM4MS5wYXJhbXMuRzFiKSk7IC8vIHnCsiA9IHjCsyArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQocmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmICgheSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbXByZXNzZWQgRzEgcG9pbnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZmxhZyA9IEJpZ0ludChzb3J0KTtcbiAgICAgICAgICAgICAgICBpZiAoKHkgKiBfMm4pIC8gUCAhPT0gYWZsYWcpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBibHMxMl8zODEuRzEuUHJvamVjdGl2ZVBvaW50LmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgICAgICAgICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvUmF3Qnl0ZXMocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlRzFUb1Jhd0J5dGVzKHBvaW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0hleChwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHNpZ25hdHVyZUcxVG9SYXdCeXRlcyhwb2ludCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIEcyIGlzIHRoZSBvcmRlci1xIHN1Ymdyb3VwIG9mIEUyKEZwwrIpIDogecKyID0geMKzKzQoMSviiJriiJIxKSxcbiAgICAvLyB3aGVyZSBGcDIgaXMgRnBb4oia4oiSMV0vKHgyKzEpLiAjRTIoRnAyICkgPSBoMnEsIHdoZXJlXG4gICAgLy8gR8KyIC0gMVxuICAgIC8vIGgycVxuICAgIEcyOiB7XG4gICAgICAgIEZwOiBGcDIsXG4gICAgICAgIC8vIGNvZmFjdG9yXG4gICAgICAgIGg6IEJpZ0ludCgnMHg1ZDU0M2E5NTQxNGU3ZjEwOTFkNTA3OTI4NzZhMjAyY2Q5MWRlNDU0NzA4NWFiYWE2OGEyMDViMmU1YTdkZGZhNjI4ZjFjYjRkOWU4MmVmMjE1MzdlMjkzYTY2OTFhZTE2MTZlYzZlNzg2ZjBjNzBjZjFjMzhlMzFjNzIzOGU1JyksXG4gICAgICAgIEd4OiBGcDIuZnJvbUJpZ1R1cGxlKFtcbiAgICAgICAgICAgIEJpZ0ludCgnMHgwMjRhYTJiMmYwOGYwYTkxMjYwODA1MjcyZGM1MTA1MWM2ZTQ3YWQ0ZmE0MDNiMDJiNDUxMGI2NDdhZTNkMTc3MGJhYzAzMjZhODA1YmJlZmQ0ODA1NmM4YzEyMWJkYjgnKSxcbiAgICAgICAgICAgIEJpZ0ludCgnMHgxM2UwMmI2MDUyNzE5ZjYwN2RhY2QzYTA4ODI3NGY2NTU5NmJkMGQwOTkyMGI2MWFiNWRhNjFiYmRjN2Y1MDQ5MzM0Y2YxMTIxMzk0NWQ1N2U1YWM3ZDA1NWQwNDJiN2UnKSxcbiAgICAgICAgXSksXG4gICAgICAgIC8vIHkgPVxuICAgICAgICAvLyA5Mjc1NTM2NjU0OTIzMzI0NTU3NDcyMDE5NjU3NzYwMzc4ODA3NTc3NDAxOTM0NTM1OTI5NzAwMjUwMjc5Nzg3OTM5NzY4NzcwMDI2NzU1NjQ5ODA5NDkyODk3Mjc5NTc1NjU1NzU0MzMzNDQyMTk1ODIsXG4gICAgICAgIC8vIDE5ODUxNTA2MDIyODcyOTE5MzU1NjgwNTQ1MjExNzcxNzE2MzgzMDA4Njg5NzgyMTU2NTU3MzA4NTkzNzg2NjUwNjYzNDQ3MjYzNzM4MjM3MTg0MjM4NjkxMDQyNjMzMzM5ODQ2NDE0OTQzNDAzNDc5MDVcbiAgICAgICAgR3k6IEZwMi5mcm9tQmlnVHVwbGUoW1xuICAgICAgICAgICAgQmlnSW50KCcweDBjZTVkNTI3NzI3ZDZlMTE4Y2M5Y2RjNmRhMmUzNTFhYWRmZDliYWE4Y2JkZDNhNzZkNDI5YTY5NTE2MGQxMmM5MjNhYzljYzNiYWNhMjg5ZTE5MzU0ODYwOGI4MjgwMScpLFxuICAgICAgICAgICAgQmlnSW50KCcweDA2MDZjNGEwMmVhNzM0Y2MzMmFjZDJiMDJiYzI4Yjk5Y2IzZTI4N2U4NWE3NjNhZjI2NzQ5MmFiNTcyZTk5YWIzZjM3MGQyNzVjZWMxZGExYWFhOTA3NWZmMDVmNzliZScpLFxuICAgICAgICBdKSxcbiAgICAgICAgYTogRnAyLlpFUk8sXG4gICAgICAgIGI6IEZwMi5mcm9tQmlnVHVwbGUoW180biwgXzRuXSksXG4gICAgICAgIGhFZmY6IEJpZ0ludCgnMHhiYzY5ZjA4ZjJlZTc1YjM1ODRjNmEwZWE5MWIzNTI4ODhlMmE4ZTkxNDVhZDc2ODk5ODZmZjAzMTUwOGZmZTEzMjljMmYxNzg3MzFkYjk1NmQ4MmJmMDE1ZDEyMTJiMDJlYzBlYzY5ZDc0NzdjMWFlOTU0Y2JjMDY2ODlmNmEzNTk4OTRjMGFkZWJiZjZiNGU4MDIwMDA1YWFhOTU1NTEnKSxcbiAgICAgICAgaHRmRGVmYXVsdHM6IHsgLi4uaHRmRGVmYXVsdHMgfSxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6IHRydWUsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogdHJ1ZSxcbiAgICAgICAgbWFwVG9DdXJ2ZTogKHNjYWxhcnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gRzJfU1dVKEZwMi5mcm9tQmlnVHVwbGUoc2NhbGFycykpO1xuICAgICAgICAgICAgcmV0dXJuIGlzb2dlbnlNYXBHMih4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2hlY2tzIGlzIHRoZSBwb2ludCByZXNpZGVzIGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwLlxuICAgICAgICAvLyBwb2ludC5pc1RvcnNpb25GcmVlKCkgc2hvdWxkIHJldHVybiB0cnVlIGZvciB2YWxpZCBwb2ludHNcbiAgICAgICAgLy8gSXQgcmV0dXJucyBmYWxzZSBmb3Igc2hpdHR5IHBvaW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAyMS8xMTMwLnBkZlxuICAgICAgICAvLyBPbGRlciB2ZXJzaW9uOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5LzgxNC5wZGZcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogKGMsIFApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQLm11bHRpcGx5VW5zYWZlKEJMU19YKS5uZWdhdGUoKS5lcXVhbHMoRzJwc2koYywgUCkpOyAvLyDPiChQKSA9PSBbdV0oUClcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwcyB0aGUgcG9pbnQgaW50byB0aGUgcHJpbWUtb3JkZXIgc3ViZ3JvdXAgRzIuXG4gICAgICAgIC8vIGNsZWFyX2NvZmFjdG9yX2JsczEyMzgxX2cyIGZyb20gUkZDIDkzODAuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTcvNDE5LnBkZlxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogKGMsIFApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBCTFNfWDtcbiAgICAgICAgICAgIGxldCB0MSA9IFAubXVsdGlwbHlVbnNhZmUoeCkubmVnYXRlKCk7IC8vIFsteF1QXG4gICAgICAgICAgICBsZXQgdDIgPSBHMnBzaShjLCBQKTsgLy8gzqgoUClcbiAgICAgICAgICAgIGxldCB0MyA9IFAuZG91YmxlKCk7IC8vIDJQXG4gICAgICAgICAgICB0MyA9IEcycHNpMihjLCB0Myk7IC8vIM6owrIoMlApXG4gICAgICAgICAgICB0MyA9IHQzLnN1YnRyYWN0KHQyKTsgLy8gzqjCsigyUCkgLSDOqChQKVxuICAgICAgICAgICAgdDIgPSB0MS5hZGQodDIpOyAvLyBbLXhdUCArIM6oKFApXG4gICAgICAgICAgICB0MiA9IHQyLm11bHRpcGx5VW5zYWZlKHgpLm5lZ2F0ZSgpOyAvLyBbeMKyXVAgLSBbeF3OqChQKVxuICAgICAgICAgICAgdDMgPSB0My5hZGQodDIpOyAvLyDOqMKyKDJQKSAtIM6oKFApICsgW3jCsl1QIC0gW3hdzqgoUClcbiAgICAgICAgICAgIHQzID0gdDMuc3VidHJhY3QodDEpOyAvLyDOqMKyKDJQKSAtIM6oKFApICsgW3jCsl1QIC0gW3hdzqgoUCkgKyBbeF1QXG4gICAgICAgICAgICBjb25zdCBRID0gdDMuc3VidHJhY3QoUCk7IC8vIM6owrIoMlApIC0gzqgoUCkgKyBbeMKyXVAgLSBbeF3OqChQKSArIFt4XVAgLSAxUFxuICAgICAgICAgICAgcmV0dXJuIFE7IC8vIFt4wrIteC0xXVAgKyBbeC0xXc6oKFApICsgzqjCsigyUClcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29tcHJlc3NlZCwgaW5maW5pdHksIHNvcnQsIHZhbHVlIH0gPSBwYXJzZU1hc2soYnl0ZXMpO1xuICAgICAgICAgICAgaWYgKCghY29tcHJlc3NlZCAmJiAhaW5maW5pdHkgJiYgc29ydCkgfHwgLy8gMDAxMDAwMDBcbiAgICAgICAgICAgICAgICAoIWNvbXByZXNzZWQgJiYgaW5maW5pdHkgJiYgc29ydCkgfHwgLy8gMDExMDAwMDBcbiAgICAgICAgICAgICAgICAoc29ydCAmJiBpbmZpbml0eSAmJiBjb21wcmVzc2VkKSAvLyAxMTEwMDAwMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuY29kaW5nIGZsYWc6ICcgKyAoYnl0ZXNbMF0gJiAyMjQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEwgPSBGcC5CWVRFUztcbiAgICAgICAgICAgIGNvbnN0IHNsYyA9IChiLCBmcm9tLCB0bykgPT4gYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDk2ICYmIGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gYmxzMTJfMzgxLnBhcmFtcy5HMmI7XG4gICAgICAgICAgICAgICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgICAgICAgICAgICAgIGlmIChpbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IGFsbCBieXRlcyBhcmUgMFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUucmVkdWNlKChwLCBjKSA9PiAocCAhPT0gMCA/IGMgKyAxIDogYyksIDApID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbXByZXNzZWQgRzIgcG9pbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcDIuWkVSTywgeTogRnAyLlpFUk8gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeF8xID0gc2xjKHZhbHVlLCAwLCBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4XzAgPSBzbGModmFsdWUsIEwsIDIgKiBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAyLmNyZWF0ZSh7IGMwOiBGcC5jcmVhdGUoeF8wKSwgYzE6IEZwLmNyZWF0ZSh4XzEpIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gRnAyLmFkZChGcDIucG93KHgsIF8zbiksIGIpOyAvLyB5wrIgPSB4wrMgKyA0ICogKHUrMSkgPSB4wrMgKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcDIuc3FydChyaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgWV9iaXQgPSB5LmMxID09PSBfMG4gPyAoeS5jMCAqIF8ybikgLyBQIDogKHkuYzEgKiBfMm4pIC8gUCA/IF8xbiA6IF8wbjtcbiAgICAgICAgICAgICAgICB5ID0gc29ydCAmJiBZX2JpdCA+IDAgPyB5IDogRnAyLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDE5MiAmJiAhY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUucmVkdWNlKChwLCBjKSA9PiAocCAhPT0gMCA/IGMgKyAxIDogYyksIDApID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHVuY29tcHJlc3NlZCBHMiBwb2ludCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwMi5aRVJPLCB5OiBGcDIuWkVSTyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB4MSA9IHNsYyh2YWx1ZSwgMCwgTCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeDAgPSBzbGModmFsdWUsIEwsIDIgKiBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MSA9IHNsYyh2YWx1ZSwgMiAqIEwsIDMgKiBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MCA9IHNsYyh2YWx1ZSwgMyAqIEwsIDQgKiBMKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcDIuZnJvbUJpZ1R1cGxlKFt4MCwgeDFdKSwgeTogRnAyLmZyb21CaWdUdXBsZShbeTAsIHkxXSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCBHMiwgZXhwZWN0ZWQgOTYvMTkyIGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvQnl0ZXM6IChjLCBwb2ludCwgaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEJZVEVTOiBsZW4sIE9SREVSOiBQIH0gPSBGcDtcbiAgICAgICAgICAgIGNvbnN0IGlzWmVybyA9IHBvaW50LmVxdWFscyhjLlpFUk8pO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1plcm8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXRCKENPTVBSRVNTRURfWkVSTywgbnVtYmVyVG9CeXRlc0JFKF8wbiwgbGVuKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmxhZyA9IEJvb2xlYW4oeS5jMSA9PT0gXzBuID8gKHkuYzAgKiBfMm4pIC8gUCA6ICh5LmMxICogXzJuKSAvIFApO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXRCKHNldE1hc2sobnVtYmVyVG9CeXRlc0JFKHguYzEsIGxlbiksIHsgY29tcHJlc3NlZDogdHJ1ZSwgc29ydDogZmxhZyB9KSwgbnVtYmVyVG9CeXRlc0JFKHguYzAsIGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEIobmV3IFVpbnQ4QXJyYXkoWzB4NDBdKSwgbmV3IFVpbnQ4QXJyYXkoNCAqIGxlbiAtIDEpKTsgLy8gYnl0ZXNbMF0gfD0gMSA8PCA2O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmU6IHgwLCBpbTogeDEgfSA9IEZwMi5yZWltKHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmU6IHkwLCBpbTogeTEgfSA9IEZwMi5yZWltKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXRCKG51bWJlclRvQnl0ZXNCRSh4MSwgbGVuKSwgbnVtYmVyVG9CeXRlc0JFKHgwLCBsZW4pLCBudW1iZXJUb0J5dGVzQkUoeTEsIGxlbiksIG51bWJlclRvQnl0ZXNCRSh5MCwgbGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFNpZ25hdHVyZToge1xuICAgICAgICAgICAgLy8gVE9ETzogT3B0aW1pemUsIGl0J3MgdmVyeSBzbG93IGJlY2F1c2Ugb2Ygc3FydC5cbiAgICAgICAgICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmZpbml0eSwgc29ydCwgdmFsdWUgfSA9IHBhcnNlTWFzayhlbnN1cmVCeXRlcygnc2lnbmF0dXJlSGV4JywgaGV4KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbGYgPSB2YWx1ZS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgICAgIGlmIChoYWxmICE9PSA0OCAmJiBoYWxmICE9PSA5NilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbXByZXNzZWQgc2lnbmF0dXJlIGxlbmd0aCwgbXVzdCBiZSA5NiBvciAxOTInKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6MSA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZS5zbGljZSgwLCBoYWxmKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgejIgPSBieXRlc1RvTnVtYmVyQkUodmFsdWUuc2xpY2UoaGFsZikpO1xuICAgICAgICAgICAgICAgIC8vIEluZGljYXRlcyB0aGUgaW5maW5pdHkgcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoaW5maW5pdHkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibHMxMl8zODEuRzIuUHJvamVjdGl2ZVBvaW50LlpFUk87XG4gICAgICAgICAgICAgICAgY29uc3QgeDEgPSBGcC5jcmVhdGUoejEgJiBGcC5NQVNLKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4MiA9IEZwLmNyZWF0ZSh6Mik7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwMi5jcmVhdGUoeyBjMDogeDIsIGMxOiB4MSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IEZwMi5hZGQoRnAyLnBvdyh4LCBfM24pLCBibHMxMl8zODEucGFyYW1zLkcyYik7IC8vIHnCsiA9IHjCsyArIDRcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2xvdyBwYXJ0XG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcDIuc3FydCh5Mik7XG4gICAgICAgICAgICAgICAgaWYgKCF5KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGEgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIHkgd2hvc2UgbGVmdG1vc3QgYml0IG9mIHRoZSBpbWFnaW5hcnkgcGFydCBpcyBlcXVhbCB0byB0aGUgYV9mbGFnMVxuICAgICAgICAgICAgICAgIC8vIElmIHkxIGhhcHBlbnMgdG8gYmUgemVybywgdGhlbiB1c2UgdGhlIGJpdCBvZiB5MFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmU6IHkwLCBpbTogeTEgfSA9IEZwMi5yZWltKHkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmbGFnMSA9IEJpZ0ludChzb3J0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0dyZWF0ZXIgPSB5MSA+IF8wbiAmJiAoeTEgKiBfMm4pIC8gUCAhPT0gYWZsYWcxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzWmVybyA9IHkxID09PSBfMG4gJiYgKHkwICogXzJuKSAvIFAgIT09IGFmbGFnMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNHcmVhdGVyIHx8IGlzWmVybylcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwMi5uZWcoeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBibHMxMl8zODEuRzIuUHJvamVjdGl2ZVBvaW50LmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgICAgICAgICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvUmF3Qnl0ZXMocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlRzJUb1Jhd0J5dGVzKHBvaW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0hleChwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHNpZ25hdHVyZUcyVG9SYXdCeXRlcyhwb2ludCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHBhcmFtczoge1xuICAgICAgICBhdGVMb29wU2l6ZTogQkxTX1gsIC8vIFRoZSBCTFMgcGFyYW1ldGVyIHggZm9yIEJMUzEyLTM4MVxuICAgICAgICByOiBGci5PUkRFUiwgLy8gb3JkZXI7IHrigbQg4oiSIHrCsiArIDE7IENVUlZFLm4gZnJvbSBvdGhlciBjdXJ2ZXNcbiAgICAgICAgeE5lZ2F0aXZlOiB0cnVlLFxuICAgICAgICB0d2lzdFR5cGU6ICdtdWx0aXBsaWNhdGl2ZScsXG4gICAgfSxcbiAgICBodGZEZWZhdWx0cyxcbiAgICBoYXNoOiBzaGEyNTYsXG4gICAgcmFuZG9tQnl0ZXMsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsczEyLTM4MS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/bls12-381.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/nist.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/nist.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   p256_hasher: () => (/* binding */ p256_hasher),\n/* harmony export */   p384: () => (/* binding */ p384),\n/* harmony export */   p384_hasher: () => (/* binding */ p384_hasher),\n/* harmony export */   p521: () => (/* binding */ p521),\n/* harmony export */   p521_hasher: () => (/* binding */ p521_hasher),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1),\n/* harmony export */   secp384r1: () => (/* binding */ secp384r1),\n/* harmony export */   secp521r1: () => (/* binding */ secp521r1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\nconst Fp256 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst p256_a = Fp256.create(BigInt('-3'));\nconst p256_b = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n/**\n * secp256r1 curve, ECDSA and ECDH methods.\n * Field: `2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n`\n */\n// prettier-ignore\nconst p256 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p256_a,\n    b: p256_b,\n    Fp: Fp256,\n    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n    h: BigInt(1),\n    lowS: false\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256);\n/** Alias to p256. */\nconst secp256r1 = p256;\nconst p256_mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp256, {\n    A: p256_a,\n    B: p256_b,\n    Z: Fp256.create(BigInt('-10')),\n}))();\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nconst p256_hasher = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp256r1.ProjectivePoint, (scalars) => p256_mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp256.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\n// Field over which we'll do calculations.\nconst Fp384 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'));\nconst p384_a = Fp384.create(BigInt('-3'));\n// prettier-ignore\nconst p384_b = BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef');\n/**\n * secp384r1 curve, ECDSA and ECDH methods.\n * Field: `2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n`.\n * */\n// prettier-ignore\nconst p384 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p384_a,\n    b: p384_b,\n    Fp: Fp384,\n    n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n    Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n    Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n    h: BigInt(1),\n    lowS: false\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha384);\n/** Alias to p384. */\nconst secp384r1 = p384;\nconst p384_mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp384, {\n    A: p384_a,\n    B: p384_b,\n    Z: Fp384.create(BigInt('-12')),\n}))();\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nconst p384_hasher = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp384r1.ProjectivePoint, (scalars) => p384_mapSWU(scalars[0]), {\n    DST: 'P384_XMD:SHA-384_SSWU_RO_',\n    encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n    p: Fp384.ORDER,\n    m: 1,\n    k: 192,\n    expand: 'xmd',\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha384,\n}))();\n// Field over which we'll do calculations.\nconst Fp521 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt('0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'));\nconst p521_a = Fp521.create(BigInt('-3'));\nconst p521_b = BigInt('0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00');\n/**\n * NIST secp521r1 aka p521 curve, ECDSA and ECDH methods.\n * Field: `2n**521n - 1n`.\n */\n// prettier-ignore\nconst p521 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p521_a,\n    b: p521_b,\n    Fp: Fp521,\n    n: BigInt('0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'),\n    Gx: BigInt('0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'),\n    Gy: BigInt('0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'),\n    h: BigInt(1),\n    lowS: false,\n    allowedPrivateKeyLengths: [130, 131, 132] // P521 keys are variable-length. Normalize to 132b\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha512);\n/** Alias to p521. */\nconst secp521r1 = p521;\nconst p521_mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp521, {\n    A: p521_a,\n    B: p521_b,\n    Z: Fp521.create(BigInt('-4')),\n}))();\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nconst p521_hasher = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp521r1.ProjectivePoint, (scalars) => p521_mapSWU(scalars[0]), {\n    DST: 'P521_XMD:SHA-512_SSWU_RO_',\n    encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n    p: Fp521.ORDER,\n    m: 1,\n    k: 256,\n    expand: 'xmd',\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha512,\n}))();\n//# sourceMappingURL=nist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9uaXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzREO0FBQ1g7QUFDVTtBQUNiO0FBQ2tCO0FBQ2hFLGNBQWMsMkRBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxhQUFhLDZEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0RBQU07QUFDVDtBQUNPO0FBQ1AsMkNBQTJDLDZFQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTywyQ0FBMkMsd0VBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBTTtBQUNoQixDQUFDO0FBQ0Q7QUFDQSxjQUFjLDJEQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxhQUFhLDZEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0RBQU07QUFDVDtBQUNPO0FBQ1AsMkNBQTJDLDZFQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTywyQ0FBMkMsd0VBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBTTtBQUNoQixDQUFDO0FBQ0Q7QUFDQSxjQUFjLDJEQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sYUFBYSw2REFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0RBQU07QUFDVDtBQUNPO0FBQ1AsMkNBQTJDLDZFQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTywyQ0FBMkMsd0VBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBTTtBQUNoQixDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9uaXN0LmpzP2MwYzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBtb2R1bGUgZm9yIE5JU1QgUDI1NiwgUDM4NCwgUDUyMSBjdXJ2ZXMuXG4gKiBEbyBub3QgdXNlIGZvciBub3cuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tIFwiLi9fc2hvcnR3X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIjtcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuY29uc3QgRnAyNTYgPSBGaWVsZChCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpKTtcbmNvbnN0IHAyNTZfYSA9IEZwMjU2LmNyZWF0ZShCaWdJbnQoJy0zJykpO1xuY29uc3QgcDI1Nl9iID0gQmlnSW50KCcweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGInKTtcbi8qKlxuICogc2VjcDI1NnIxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICogRmllbGQ6IGAybioqMjI0biAqICgybioqMzJuLTFuKSArIDJuKioxOTJuICsgMm4qKjk2bi0xbmBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgcDI1NiA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBwMjU2X2EsXG4gICAgYjogcDI1Nl9iLFxuICAgIEZwOiBGcDI1NixcbiAgICBuOiBCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZiY2U2ZmFhZGE3MTc5ZTg0ZjNiOWNhYzJmYzYzMjU1MScpLFxuICAgIEd4OiBCaWdJbnQoJzB4NmIxN2QxZjJlMTJjNDI0N2Y4YmNlNmU1NjNhNDQwZjI3NzAzN2Q4MTJkZWIzM2EwZjRhMTM5NDVkODk4YzI5NicpLFxuICAgIEd5OiBCaWdJbnQoJzB4NGZlMzQyZTJmZTFhN2Y5YjhlZTdlYjRhN2MwZjllMTYyYmNlMzM1NzZiMzE1ZWNlY2JiNjQwNjgzN2JmNTFmNScpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZVxufSwgc2hhMjU2KTtcbi8qKiBBbGlhcyB0byBwMjU2LiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZyMSA9IHAyNTY7XG5jb25zdCBwMjU2X21hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcDI1Niwge1xuICAgIEE6IHAyNTZfYSxcbiAgICBCOiBwMjU2X2IsXG4gICAgWjogRnAyNTYuY3JlYXRlKEJpZ0ludCgnLTEwJykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHAyNTYgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDI1Nl9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2cjEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4gcDI1Nl9tYXBTV1Uoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdQMjU2X1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdQMjU2X1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcDI1Ni5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuLy8gRmllbGQgb3ZlciB3aGljaCB3ZSdsbCBkbyBjYWxjdWxhdGlvbnMuXG5jb25zdCBGcDM4NCA9IEZpZWxkKEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZmZmYwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmYnKSk7XG5jb25zdCBwMzg0X2EgPSBGcDM4NC5jcmVhdGUoQmlnSW50KCctMycpKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgcDM4NF9iID0gQmlnSW50KCcweGIzMzEyZmE3ZTIzZWU3ZTQ5ODhlMDU2YmUzZjgyZDE5MTgxZDljNmVmZTgxNDExMjAzMTQwODhmNTAxMzg3NWFjNjU2Mzk4ZDhhMmVkMTlkMmE4NWM4ZWRkM2VjMmFlZicpO1xuLyoqXG4gKiBzZWNwMzg0cjEgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuXG4gKiBGaWVsZDogYDJuKiozODRuIC0gMm4qKjEyOG4gLSAybioqOTZuICsgMm4qKjMybiAtIDFuYC5cbiAqICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBwMzg0ID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IHAzODRfYSxcbiAgICBiOiBwMzg0X2IsXG4gICAgRnA6IEZwMzg0LFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjNzYzNGQ4MWY0MzcyZGRmNTgxYTBkYjI0OGIwYTc3YWVjZWMxOTZhY2NjNTI5NzMnKSxcbiAgICBHeDogQmlnSW50KCcweGFhODdjYTIyYmU4YjA1Mzc4ZWIxYzcxZWYzMjBhZDc0NmUxZDNiNjI4YmE3OWI5ODU5Zjc0MWUwODI1NDJhMzg1NTAyZjI1ZGJmNTUyOTZjM2E1NDVlMzg3Mjc2MGFiNycpLFxuICAgIEd5OiBCaWdJbnQoJzB4MzYxN2RlNGE5NjI2MmM2ZjVkOWU5OGJmOTI5MmRjMjlmOGY0MWRiZDI4OWExNDdjZTlkYTMxMTNiNWYwYjhjMDBhNjBiMWNlMWQ3ZTgxOWQ3YTQzMWQ3YzkwZWEwZTVmJyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IGZhbHNlXG59LCBzaGEzODQpO1xuLyoqIEFsaWFzIHRvIHAzODQuICovXG5leHBvcnQgY29uc3Qgc2VjcDM4NHIxID0gcDM4NDtcbmNvbnN0IHAzODRfbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwMzg0LCB7XG4gICAgQTogcDM4NF9hLFxuICAgIEI6IHAzODRfYixcbiAgICBaOiBGcDM4NC5jcmVhdGUoQmlnSW50KCctMTInKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gcDM4NCBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydCBjb25zdCBwMzg0X2hhc2hlciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AzODRyMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiBwMzg0X21hcFNXVShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ1AzODRfWE1EOlNIQS0zODRfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ1AzODRfWE1EOlNIQS0zODRfU1NXVV9OVV8nLFxuICAgIHA6IEZwMzg0Lk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTkyLFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMzg0LFxufSkpKCk7XG4vLyBGaWVsZCBvdmVyIHdoaWNoIHdlJ2xsIGRvIGNhbGN1bGF0aW9ucy5cbmNvbnN0IEZwNTIxID0gRmllbGQoQmlnSW50KCcweDFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJykpO1xuY29uc3QgcDUyMV9hID0gRnA1MjEuY3JlYXRlKEJpZ0ludCgnLTMnKSk7XG5jb25zdCBwNTIxX2IgPSBCaWdJbnQoJzB4MDA1MTk1M2ViOTYxOGUxYzlhMWY5MjlhMjFhMGI2ODU0MGVlYTJkYTcyNWI5OWIzMTVmM2I4YjQ4OTkxOGVmMTA5ZTE1NjE5Mzk1MWVjN2U5MzdiMTY1MmMwYmQzYmIxYmYwNzM1NzNkZjg4M2QyYzM0ZjFlZjQ1MWZkNDZiNTAzZjAwJyk7XG4vKipcbiAqIE5JU1Qgc2VjcDUyMXIxIGFrYSBwNTIxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICogRmllbGQ6IGAybioqNTIxbiAtIDFuYC5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgcDUyMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBwNTIxX2EsXG4gICAgYjogcDUyMV9iLFxuICAgIEZwOiBGcDUyMSxcbiAgICBuOiBCaWdJbnQoJzB4MDFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmE1MTg2ODc4M2JmMmY5NjZiN2ZjYzAxNDhmNzA5YTVkMDNiYjVjOWI4ODk5YzQ3YWViYjZmYjcxZTkxMzg2NDA5JyksXG4gICAgR3g6IEJpZ0ludCgnMHgwMGM2ODU4ZTA2YjcwNDA0ZTljZDllM2VjYjY2MjM5NWI0NDI5YzY0ODEzOTA1M2ZiNTIxZjgyOGFmNjA2YjRkM2RiYWExNGI1ZTc3ZWZlNzU5MjhmZTFkYzEyN2EyZmZhOGRlMzM0OGIzYzE4NTZhNDI5YmY5N2U3ZTMxYzJlNWJkNjYnKSxcbiAgICBHeTogQmlnSW50KCcweDAxMTgzOTI5NmE3ODlhM2JjMDA0NWM4YTVmYjQyYzdkMWJkOTk4ZjU0NDQ5NTc5YjQ0NjgxN2FmYmQxNzI3M2U2NjJjOTdlZTcyOTk1ZWY0MjY0MGM1NTBiOTAxM2ZhZDA3NjEzNTNjNzA4NmEyNzJjMjQwODhiZTk0NzY5ZmQxNjY1MCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZSxcbiAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IFsxMzAsIDEzMSwgMTMyXSAvLyBQNTIxIGtleXMgYXJlIHZhcmlhYmxlLWxlbmd0aC4gTm9ybWFsaXplIHRvIDEzMmJcbn0sIHNoYTUxMik7XG4vKiogQWxpYXMgdG8gcDUyMS4gKi9cbmV4cG9ydCBjb25zdCBzZWNwNTIxcjEgPSBwNTIxO1xuY29uc3QgcDUyMV9tYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnA1MjEsIHtcbiAgICBBOiBwNTIxX2EsXG4gICAgQjogcDUyMV9iLFxuICAgIFo6IEZwNTIxLmNyZWF0ZShCaWdJbnQoJy00JykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHA1MjEgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDUyMV9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwNTIxcjEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4gcDUyMV9tYXBTV1Uoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdQNTIxX1hNRDpTSEEtNTEyX1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdQNTIxX1hNRDpTSEEtNTEyX1NTV1VfTlVfJyxcbiAgICBwOiBGcDUyMS5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDI1NixcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTUxMixcbn0pKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmlzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/nist.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/p256.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/p256.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1)\n/* harmony export */ });\n/* harmony import */ var _nist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nist.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/nist.js\");\n/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst p256 = _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256;\nconst secp256r1 = _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256;\nconst hashToCurve = /* @__PURE__ */ (() => _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256_hasher.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256_hasher.encodeToCurve)();\n//# sourceMappingURL=p256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9wMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QztBQUNVO0FBQ2hELGFBQWEsMENBQUs7QUFDbEIsa0JBQWtCLDBDQUFLO0FBQ3ZCLDJDQUEyQyxpREFBVztBQUN0RCw2Q0FBNkMsaURBQVc7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9wMjU2LmpzP2RhY2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBOSVNUIHNlY3AyNTZyMSBha2EgcDI1Ni5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHt9IGZyb20gXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIjtcbmltcG9ydCB7IHAyNTZfaGFzaGVyLCBwMjU2IGFzIHAyNTZuIH0gZnJvbSBcIi4vbmlzdC5qc1wiO1xuZXhwb3J0IGNvbnN0IHAyNTYgPSBwMjU2bjtcbmV4cG9ydCBjb25zdCBzZWNwMjU2cjEgPSBwMjU2bjtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcDI1Nl9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcDI1Nl9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXAyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/p256.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js":
/*!**********************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1),\n/* harmony export */   secp256k1_hasher: () => (/* binding */ secp256k1_hasher)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"../node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = /* @__PURE__ */ (() => secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)('x', x, _1n, secp256k1P); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nconst secp256k1_hasher = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => secp256k1_hasher.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => secp256k1_hasher.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDTTtBQUNEO0FBQ3NCO0FBQ2Q7QUFDNEQ7QUFDckQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBSyxxQ0FBcUMsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDBDQUEwQyxLQUFLLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ08sa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHFCQUFxQix5REFBRztBQUN4QixxQkFBcUIseURBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyxFQUFFLHNEQUFNO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQU07QUFDM0IsZUFBZSwrREFBVztBQUMxQjtBQUNBO0FBQ0EsV0FBVywwREFBTSxDQUFDLCtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBZTtBQUN2QyxvQkFBb0IseURBQUc7QUFDdkIsb0JBQW9CLHlEQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQVEsMkJBQTJCO0FBQ3ZDO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdFQUFXO0FBQy9ELGNBQWMsK0RBQVc7QUFDekIsWUFBWSx1QkFBdUIsbUNBQW1DO0FBQ3RFLGNBQWMsK0RBQVcsMEJBQTBCO0FBQ25ELCtEQUErRDtBQUMvRCx3REFBd0Q7QUFDeEQsZ0NBQWdDO0FBQ2hDO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBVztBQUMzQixjQUFjLCtEQUFXO0FBQ3pCLGdCQUFnQiwrREFBVztBQUMzQjtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQsNENBQTRDLDJCQUEyQjtBQUN2RSxhQUFhLDJEQUFPO0FBQ3BCO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RSxhQUFhLDJEQUFPO0FBQ3BCO0FBQ0EsOERBQThEO0FBQzlELDJDQUEyQztBQUMzQztBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ08sZ0RBQWdELHdFQUFZO0FBQ25FLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFNO0FBQ2hCLENBQUM7QUFDTTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/NzkxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE5JU1Qgc2VjcDI1NmsxLiBTZWUgW3BkZl0oaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMi12Mi5wZGYpLlxuICpcbiAqIFNlZW1zIHRvIGJlIHJpZ2lkIChub3QgYmFja2Rvb3JlZClcbiAqIFthcyBwZXIgZGlzY3Vzc2lvbl0oaHR0cHM6Ly9iaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzUpLlxuICpcbiAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAqIFtTZWUgZXhwbGFuYXRpb25dKGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NikuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tIFwiLi9fc2hvcnR3X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSBcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpblJhbmdlLCBudW1iZXJUb0J5dGVzQkUsIH0gZnJvbSBcIi4vYWJzdHJhY3QvdXRpbHMuanNcIjtcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuLyoqXG4gKiBzZWNwMjU2azEgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuXG4gKlxuICogRmllbGQ6IGAybioqMjU2biAtIDJuKiozMm4gLSAybioqOW4gLSAybioqOG4gLSAybioqN24gLSAybioqNm4gLSAybioqNG4gLSAxbmBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogY29uc3QgcHViID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShwcml2KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpOyAvLyBtZXNzYWdlIGhhc2ggKG5vdCBtZXNzYWdlKSBpbiBlY2RzYVxuICogY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnLCBwcml2KTsgLy8gYHtwcmVoYXNoOiB0cnVlfWAgb3B0aW9uIGlzIGF2YWlsYWJsZVxuICogY29uc3QgaXNWYWxpZCA9IHNlY3AyNTZrMS52ZXJpZnkoc2lnLCBtc2csIHB1YikgPT09IHRydWU7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBfMG4sXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwOiBGcGsxLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgZW5kbzoge1xuICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50KSgpO1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgYUluUmFuZ2UoJ3gnLCB4LCBfMW4sIHNlY3AyNTZrMVApOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFO1xuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4obnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gbnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKG51bShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChudW0ocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gbnVtKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghaW5SYW5nZShyLCBfMW4sIHNlY3AyNTZrMVApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFpblJhbmdlKHMsIF8xbiwgc2VjcDI1NmsxTikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgcHJpdik7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2Nobm9yci52ZXJpZnkoc2lnLCBtc2csIHB1Yik7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwazEsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gc2VjcDI1NmsxIHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMV9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHNlY3AyNTZrMV9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gc2VjcDI1NmsxX2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/_blake.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/_blake.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BSIGMA: () => (/* binding */ BSIGMA),\n/* harmony export */   G1s: () => (/* binding */ G1s),\n/* harmony export */   G2s: () => (/* binding */ G2s)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal helpers for blake hash.\n * @module\n */\n\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nconst BSIGMA = /* @__PURE__ */ Uint8Array.from([\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    // Blake1, unused in others\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n// Mixing function G splitted in two halfs\nfunction G1s(a, b, c, d, x) {\n    a = (a + b + x) | 0;\n    d = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr)(d ^ a, 16);\n    c = (c + d) | 0;\n    b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr)(b ^ c, 12);\n    return { a, b, c, d };\n}\nfunction G2s(a, b, c, d, x) {\n    a = (a + b + x) | 0;\n    d = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr)(d ^ a, 8);\n    c = (c + d) | 0;\n    b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr)(b ^ c, 7);\n    return { a, b, c, d };\n}\n//# sourceMappingURL=_blake.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYmxha2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEsK0NBQUk7QUFDWjtBQUNBLFFBQVEsK0NBQUk7QUFDWixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0EsUUFBUSwrQ0FBSTtBQUNaO0FBQ0EsUUFBUSwrQ0FBSTtBQUNaLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2JsYWtlLmpzPzEwNzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciBibGFrZSBoYXNoLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyByb3RyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKlxuICogSW50ZXJuYWwgYmxha2UgdmFyaWFibGUuXG4gKiBGb3IgQkxBS0UyYiwgdGhlIHR3byBleHRyYSBwZXJtdXRhdGlvbnMgZm9yIHJvdW5kcyAxMCBhbmQgMTEgYXJlIFNJR01BWzEwLi4xMV0gPSBTSUdNQVswLi4xXS5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgQlNJR01BID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAgIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gICAgNywgOSwgMywgMSwgMTMsIDEyLCAxMSwgMTQsIDIsIDYsIDUsIDEwLCA0LCAwLCAxNSwgOCxcbiAgICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAgIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gICAgMTIsIDUsIDEsIDE1LCAxNCwgMTMsIDQsIDEwLCAwLCA3LCA2LCAzLCA5LCAyLCA4LCAxMSxcbiAgICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICAgIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gICAgMTAsIDIsIDgsIDQsIDcsIDYsIDEsIDUsIDE1LCAxMSwgOSwgMTQsIDMsIDEyLCAxMywgMCxcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gICAgLy8gQmxha2UxLCB1bnVzZWQgaW4gb3RoZXJzXG4gICAgMTEsIDgsIDEyLCAwLCA1LCAyLCAxNSwgMTMsIDEwLCAxNCwgMywgNiwgNywgMSwgOSwgNCxcbiAgICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICAgIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gICAgMiwgMTIsIDYsIDEwLCAwLCAxMSwgOCwgMywgNCwgMTMsIDcsIDUsIDE1LCAxNCwgMSwgOSxcbl0pO1xuLy8gTWl4aW5nIGZ1bmN0aW9uIEcgc3BsaXR0ZWQgaW4gdHdvIGhhbGZzXG5leHBvcnQgZnVuY3Rpb24gRzFzKGEsIGIsIGMsIGQsIHgpIHtcbiAgICBhID0gKGEgKyBiICsgeCkgfCAwO1xuICAgIGQgPSByb3RyKGQgXiBhLCAxNik7XG4gICAgYyA9IChjICsgZCkgfCAwO1xuICAgIGIgPSByb3RyKGIgXiBjLCAxMik7XG4gICAgcmV0dXJuIHsgYSwgYiwgYywgZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEcycyhhLCBiLCBjLCBkLCB4KSB7XG4gICAgYSA9IChhICsgYiArIHgpIHwgMDtcbiAgICBkID0gcm90cihkIF4gYSwgOCk7XG4gICAgYyA9IChjICsgZCkgfCAwO1xuICAgIGIgPSByb3RyKGIgXiBjLCA3KTtcbiAgICByZXR1cm4geyBhLCBiLCBjLCBkIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYmxha2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/_blake.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/_md.js":
/*!****************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/_md.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nconst SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nconst SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nconst SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nconst SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0Y7QUFDeEY7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLGVBQWUsa0RBQU87QUFDdEIsUUFBUSxpREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanM/Y2JmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIE1lcmtsZS1EYW1nYXJkIGhhc2ggdXRpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IEhhc2gsIGFieXRlcywgYWV4aXN0cywgYW91dHB1dCwgY2xlYW4sIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTQuIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfZGF0YXZpZXdfc2V0YmlndWludDY0ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIENoaShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAofmEgJiBjKTtcbn1cbi8qKiBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHV0cyBpcyB0cnVlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbn1cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykpO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsIFNIQS0yIHN0YXRlOiBmcmFjdGlvbmFsIHBhcnRzIG9mIHNxdWFyZSByb290cyBvZiBmaXJzdCAxNiBwcmltZXMgMi4uNTMuXG4gKiBDaGVjayBvdXQgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AgZm9yIHJlY29tcHV0YXRpb24gZ3VpZGUuXG4gKi9cbi8qKiBJbml0aWFsIFNIQTI1NiBzdGF0ZS4gQml0cyAwLi4zMiBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydCBjb25zdCBTSEEyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOSxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMjI0IHN0YXRlLiBCaXRzIDMyLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnQgY29uc3QgU0hBMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTM4NCBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnQgY29uc3QgU0hBMzg0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSwgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSwgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNywgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBNTEyIHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0IGNvbnN0IFNIQTUxMl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LCAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLCAweDNjNmVmMzcyLCAweGZlOTRmODJiLCAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzksXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnTDtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzPzQ5ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciB1NjQuIEJpZ1VpbnQ2NEFycmF5IGlzIHRvbyBzbG93IGFzIHBlciAyMDI1LCBzbyB3ZSBpbXBsZW1lbnQgaXQgdXNpbmcgVWludDMyQXJyYXkuXG4gKiBAdG9kbyByZS1jaGVjayBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQyMjEyNTg4XG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBsc3QubGVuZ3RoO1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBhZGQsIGFkZDNILCBhZGQzTCwgYWRkNEgsIGFkZDRMLCBhZGQ1SCwgYWRkNUwsIGZyb21CaWcsIHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgcm90cjMySCwgcm90cjMyTCwgcm90ckJILCByb3RyQkwsIHJvdHJTSCwgcm90clNMLCBzaHJTSCwgc2hyU0wsIHNwbGl0LCB0b0JpZyB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/blake2.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/blake2.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLAKE2: () => (/* binding */ BLAKE2),\n/* harmony export */   BLAKE2b: () => (/* binding */ BLAKE2b),\n/* harmony export */   BLAKE2s: () => (/* binding */ BLAKE2s),\n/* harmony export */   blake2b: () => (/* binding */ blake2b),\n/* harmony export */   blake2s: () => (/* binding */ blake2s),\n/* harmony export */   compress: () => (/* binding */ compress)\n/* harmony export */ });\n/* harmony import */ var _blake_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_blake.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_blake.js\");\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_md.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\n\n\n\n// prettier-ignore\n\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add3L(Al, Bl, Xl);\n    Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotr32H(Dh, Dl), Dl: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotr32L(Dh, Dl) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 24)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrSH(Bh, Bl, 24), Bl: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrSL(Bh, Bl, 24) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction G2b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add3L(Al, Bl, Xl);\n    Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrSH(Dh, Dl, 16), Dl: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrSL(Dh, Dl, 16) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 63)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrBH(Bh, Bl, 63), Bl: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrBL(Bh, Bl, 63) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(keyLen);\n    if (outputLen < 0 || outputLen > keyLen)\n        throw new Error('outputLen bigger than keyLen');\n    const { key, salt, personalization } = opts;\n    if (key !== undefined && (key.length < 1 || key.length > keyLen))\n        throw new Error('key length must be undefined or 1..' + keyLen);\n    if (salt !== undefined && salt.length !== saltLen)\n        throw new Error('salt must be undefined or ' + saltLen);\n    if (personalization !== undefined && personalization.length !== persLen)\n        throw new Error('personalization must be undefined or ' + persLen);\n}\n/** Class, from which others are subclassed. */\nclass BLAKE2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        this.length = 0;\n        this.pos = 0;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(blockLen);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(outputLen);\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.buffer = new Uint8Array(blockLen);\n        this.buffer32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(data);\n        // Main difference with other hashes: there is flag for last block,\n        // so we cannot process current block before we know that there\n        // is the next one. This significantly complicates logic and reduces ability\n        // to do zero-copy processing\n        const { blockLen, buffer, buffer32 } = this;\n        const len = data.length;\n        const offset = data.byteOffset;\n        const buf = data.buffer;\n        for (let pos = 0; pos < len;) {\n            // If buffer is full and we still have input (don't process last block, same as blake2s)\n            if (this.pos === blockLen) {\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(buffer32);\n                this.compress(buffer32, 0, false);\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(buffer32);\n                this.pos = 0;\n            }\n            const take = Math.min(blockLen - this.pos, len - pos);\n            const dataOffset = offset + pos;\n            // full block && aligned to 4 bytes && not last in input\n            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n                const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(data32);\n                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n                    this.length += blockLen;\n                    this.compress(data32, pos32, false);\n                }\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(data32);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            this.length += take;\n            pos += take;\n        }\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        const { pos, buffer32 } = this;\n        this.finished = true;\n        // Padding\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer.subarray(pos));\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(buffer32);\n        this.compress(buffer32, 0, true);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(buffer32);\n        const out32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(out);\n        this.get().forEach((v, i) => (out32[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(v)));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        const { buffer, length, finished, destroyed, outputLen, pos } = this;\n        to || (to = new this.constructor({ dkLen: outputLen }));\n        to.set(...this.get());\n        to.buffer.set(buffer);\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        // @ts-ignore\n        to.outputLen = outputLen;\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nclass BLAKE2b extends BLAKE2 {\n    constructor(opts = {}) {\n        const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n        super(128, olen);\n        // Same as SHA-512, but LE\n        this.v0l = B2B_IV[0] | 0;\n        this.v0h = B2B_IV[1] | 0;\n        this.v1l = B2B_IV[2] | 0;\n        this.v1h = B2B_IV[3] | 0;\n        this.v2l = B2B_IV[4] | 0;\n        this.v2h = B2B_IV[5] | 0;\n        this.v3l = B2B_IV[6] | 0;\n        this.v3h = B2B_IV[7] | 0;\n        this.v4l = B2B_IV[8] | 0;\n        this.v4h = B2B_IV[9] | 0;\n        this.v5l = B2B_IV[10] | 0;\n        this.v5h = B2B_IV[11] | 0;\n        this.v6l = B2B_IV[12] | 0;\n        this.v6h = B2B_IV[13] | 0;\n        this.v7l = B2B_IV[14] | 0;\n        this.v7h = B2B_IV[15] | 0;\n        checkBlake2Opts(olen, opts, 64, 16, 16);\n        let { key, personalization, salt } = opts;\n        let keyLength = 0;\n        if (key !== undefined) {\n            key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(key);\n            keyLength = key.length;\n        }\n        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (salt !== undefined) {\n            salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt);\n            const slt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(salt);\n            this.v4l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[0]);\n            this.v4h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[1]);\n            this.v5l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[2]);\n            this.v5h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[3]);\n        }\n        if (personalization !== undefined) {\n            personalization = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(personalization);\n            const pers = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(personalization);\n            this.v6l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[0]);\n            this.v6h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[1]);\n            this.v7l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[2]);\n            this.v7h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[3]);\n        }\n        if (key !== undefined) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(key);\n            this.update(tmp);\n        }\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    compress(msg, offset, isLast) {\n        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n        BBUF.set(B2B_IV, 16); // Second half from IV.\n        let { h, l } = _u64_js__WEBPACK_IMPORTED_MODULE_0__.fromBig(BigInt(this.length));\n        BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n        BBUF[25] = B2B_IV[9] ^ h; // High word.\n        // Invert all bits for last block\n        if (isLast) {\n            BBUF[28] = ~BBUF[28];\n            BBUF[29] = ~BBUF[29];\n        }\n        let j = 0;\n        const s = _blake_js__WEBPACK_IMPORTED_MODULE_2__.BSIGMA;\n        for (let i = 0; i < 12; i++) {\n            G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n            G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        }\n        this.v0l ^= BBUF[0] ^ BBUF[16];\n        this.v0h ^= BBUF[1] ^ BBUF[17];\n        this.v1l ^= BBUF[2] ^ BBUF[18];\n        this.v1h ^= BBUF[3] ^ BBUF[19];\n        this.v2l ^= BBUF[4] ^ BBUF[20];\n        this.v2h ^= BBUF[5] ^ BBUF[21];\n        this.v3l ^= BBUF[6] ^ BBUF[22];\n        this.v3h ^= BBUF[7] ^ BBUF[23];\n        this.v4l ^= BBUF[8] ^ BBUF[24];\n        this.v4h ^= BBUF[9] ^ BBUF[25];\n        this.v5l ^= BBUF[10] ^ BBUF[26];\n        this.v5h ^= BBUF[11] ^ BBUF[27];\n        this.v6l ^= BBUF[12] ^ BBUF[28];\n        this.v6h ^= BBUF[13] ^ BBUF[29];\n        this.v7l ^= BBUF[14] ^ BBUF[30];\n        this.v7h ^= BBUF[15] ^ BBUF[31];\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(BBUF);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer32);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nconst blake2b = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createOptHasher)((opts) => new BLAKE2b(opts));\n// prettier-ignore\nfunction compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    let j = 0;\n    for (let i = 0; i < rounds; i++) {\n        ({ a: v0, b: v4, c: v8, d: v12 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v0, b: v4, c: v8, d: v12 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v3, v4, v9, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v3, v4, v9, v14, msg[offset + s[j++]]));\n    }\n    return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\nconst B2S_IV = _md_js__WEBPACK_IMPORTED_MODULE_3__.SHA256_IV;\nclass BLAKE2s extends BLAKE2 {\n    constructor(opts = {}) {\n        const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n        super(64, olen);\n        // Internal state, same as SHA-256\n        this.v0 = B2S_IV[0] | 0;\n        this.v1 = B2S_IV[1] | 0;\n        this.v2 = B2S_IV[2] | 0;\n        this.v3 = B2S_IV[3] | 0;\n        this.v4 = B2S_IV[4] | 0;\n        this.v5 = B2S_IV[5] | 0;\n        this.v6 = B2S_IV[6] | 0;\n        this.v7 = B2S_IV[7] | 0;\n        checkBlake2Opts(olen, opts, 32, 8, 8);\n        let { key, personalization, salt } = opts;\n        let keyLength = 0;\n        if (key !== undefined) {\n            key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(key);\n            keyLength = key.length;\n        }\n        this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (salt !== undefined) {\n            salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt);\n            const slt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(salt);\n            this.v4 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[0]);\n            this.v5 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[1]);\n        }\n        if (personalization !== undefined) {\n            personalization = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(personalization);\n            const pers = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(personalization);\n            this.v6 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[0]);\n            this.v7 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[1]);\n        }\n        if (key !== undefined) {\n            // Pad to blockLen and update\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(key);\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(key);\n            this.update(tmp);\n        }\n    }\n    get() {\n        const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n        return [v0, v1, v2, v3, v4, v5, v6, v7];\n    }\n    // prettier-ignore\n    set(v0, v1, v2, v3, v4, v5, v6, v7) {\n        this.v0 = v0 | 0;\n        this.v1 = v1 | 0;\n        this.v2 = v2 | 0;\n        this.v3 = v3 | 0;\n        this.v4 = v4 | 0;\n        this.v5 = v5 | 0;\n        this.v6 = v6 | 0;\n        this.v7 = v7 | 0;\n    }\n    compress(msg, offset, isLast) {\n        const { h, l } = _u64_js__WEBPACK_IMPORTED_MODULE_0__.fromBig(BigInt(this.length));\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(_blake_js__WEBPACK_IMPORTED_MODULE_2__.BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);\n        this.v0 ^= v0 ^ v8;\n        this.v1 ^= v1 ^ v9;\n        this.v2 ^= v2 ^ v10;\n        this.v3 ^= v3 ^ v11;\n        this.v4 ^= v4 ^ v12;\n        this.v5 ^= v5 ^ v13;\n        this.v6 ^= v6 ^ v14;\n        this.v7 ^= v7 ^ v15;\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer32);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nconst blake2s = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createOptHasher)((opts) => new BLAKE2s(opts));\n//# sourceMappingURL=blake2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9ibGFrZTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDVjtBQUNKO0FBQ2pDO0FBQ2tJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRDtBQUNBLGFBQWEsMENBQVM7QUFDdEIsU0FBUywwQ0FBUztBQUNsQjtBQUNBO0FBQ0EsT0FBTyxTQUFTLElBQUksMEJBQTBCO0FBQzlDLE9BQU8sU0FBUyxJQUFJLElBQUksNENBQVcsY0FBYyw0Q0FBVyxVQUFVO0FBQ3RFO0FBQ0EsT0FBTyxlQUFlLEVBQUUsd0NBQU87QUFDL0I7QUFDQSxPQUFPLFNBQVMsSUFBSSwwQkFBMEI7QUFDOUMsT0FBTyxTQUFTLElBQUksSUFBSSwyQ0FBVSxrQkFBa0IsMkNBQVUsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQ7QUFDQSxhQUFhLDBDQUFTO0FBQ3RCLFNBQVMsMENBQVM7QUFDbEI7QUFDQTtBQUNBLE9BQU8sU0FBUyxJQUFJLDBCQUEwQjtBQUM5QyxPQUFPLFNBQVMsSUFBSSxJQUFJLDJDQUFVLGtCQUFrQiwyQ0FBVSxjQUFjO0FBQzVFO0FBQ0EsT0FBTyxlQUFlLEVBQUUsd0NBQU87QUFDL0I7QUFDQSxPQUFPLFNBQVMsSUFBSSwwQkFBMEI7QUFDOUMsT0FBTyxTQUFTLElBQUksSUFBSSwyQ0FBVSxrQkFBa0IsMkNBQVUsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdD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UztBQUNoQyx1QkFBdUIsb0RBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTyxFQUFFLDRDQUFXO0FBQ3BDO0FBQ0EsZ0JBQWdCLHVFQUF1RSxXQUFXLDZDQUFNO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQywwREFBZTtBQUN0RCIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2JsYWtlMi5qcz81YTYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYmxha2UyYiAoNjQtYml0KSAmIGJsYWtlMnMgKDggdG8gMzItYml0KSBoYXNoIGZ1bmN0aW9ucy5cbiAqIGIgY291bGQgaGF2ZSBiZWVuIGZhc3RlciwgYnV0IHRoZXJlIGlzIG5vIGZhc3QgdTY0IGluIGpzLCBzbyBzIGlzIDEuNXggZmFzdGVyLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBCU0lHTUEsIEcxcywgRzJzIH0gZnJvbSBcIi4vX2JsYWtlLmpzXCI7XG5pbXBvcnQgeyBTSEEyNTZfSVYgfSBmcm9tIFwiLi9fbWQuanNcIjtcbmltcG9ydCAqIGFzIHU2NCBmcm9tIFwiLi9fdTY0LmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYW51bWJlciwgYW91dHB1dCwgY2xlYW4sIGNyZWF0ZU9wdEhhc2hlciwgSGFzaCwgc3dhcDMySWZCRSwgc3dhcDhJZkJFLCB0b0J5dGVzLCB1MzIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gU2FtZSBhcyBTSEE1MTJfSVYsIGJ1dCBzd2FwcGVkIGVuZGlhbm5lc3M6IExFIGluc3RlYWQgb2YgQkUuIGl2WzFdIGlzIGl2WzBdLCBldGMuXG5jb25zdCBCMkJfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhmM2JjYzkwOCwgMHg2YTA5ZTY2NywgMHg4NGNhYTczYiwgMHhiYjY3YWU4NSwgMHhmZTk0ZjgyYiwgMHgzYzZlZjM3MiwgMHg1ZjFkMzZmMSwgMHhhNTRmZjUzYSxcbiAgICAweGFkZTY4MmQxLCAweDUxMGU1MjdmLCAweDJiM2U2YzFmLCAweDliMDU2ODhjLCAweGZiNDFiZDZiLCAweDFmODNkOWFiLCAweDEzN2UyMTc5LCAweDViZTBjZDE5LFxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyXG5jb25zdCBCQlVGID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSgzMik7XG4vLyBNaXhpbmcgZnVuY3Rpb24gRyBzcGxpdHRlZCBpbiB0d28gaGFsZnNcbmZ1bmN0aW9uIEcxYihhLCBiLCBjLCBkLCBtc2csIHgpIHtcbiAgICAvLyBOT1RFOiBWIGlzIExFIGhlcmVcbiAgICBjb25zdCBYbCA9IG1zZ1t4XSwgWGggPSBtc2dbeCArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQWwgPSBCQlVGWzIgKiBhXSwgQWggPSBCQlVGWzIgKiBhICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBCbCA9IEJCVUZbMiAqIGJdLCBCaCA9IEJCVUZbMiAqIGIgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IENsID0gQkJVRlsyICogY10sIENoID0gQkJVRlsyICogYyArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgRGwgPSBCQlVGWzIgKiBkXSwgRGggPSBCQlVGWzIgKiBkICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8vIHZbYV0gPSAodlthXSArIHZbYl0gKyB4KSB8IDA7XG4gICAgbGV0IGxsID0gdTY0LmFkZDNMKEFsLCBCbCwgWGwpO1xuICAgIEFoID0gdTY0LmFkZDNIKGxsLCBBaCwgQmgsIFhoKTtcbiAgICBBbCA9IGxsIHwgMDtcbiAgICAvLyB2W2RdID0gcm90cih2W2RdIF4gdlthXSwgMzIpXG4gICAgKHsgRGgsIERsIH0gPSB7IERoOiBEaCBeIEFoLCBEbDogRGwgXiBBbCB9KTtcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IHU2NC5yb3RyMzJIKERoLCBEbCksIERsOiB1NjQucm90cjMyTChEaCwgRGwpIH0pO1xuICAgIC8vIHZbY10gPSAodltjXSArIHZbZF0pIHwgMDtcbiAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQoQ2gsIENsLCBEaCwgRGwpKTtcbiAgICAvLyB2W2JdID0gcm90cih2W2JdIF4gdltjXSwgMjQpXG4gICAgKHsgQmgsIEJsIH0gPSB7IEJoOiBCaCBeIENoLCBCbDogQmwgXiBDbCB9KTtcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IHU2NC5yb3RyU0goQmgsIEJsLCAyNCksIEJsOiB1NjQucm90clNMKEJoLCBCbCwgMjQpIH0pO1xuICAgIChCQlVGWzIgKiBhXSA9IEFsKSwgKEJCVUZbMiAqIGEgKyAxXSA9IEFoKTtcbiAgICAoQkJVRlsyICogYl0gPSBCbCksIChCQlVGWzIgKiBiICsgMV0gPSBCaCk7XG4gICAgKEJCVUZbMiAqIGNdID0gQ2wpLCAoQkJVRlsyICogYyArIDFdID0gQ2gpO1xuICAgIChCQlVGWzIgKiBkXSA9IERsKSwgKEJCVUZbMiAqIGQgKyAxXSA9IERoKTtcbn1cbmZ1bmN0aW9uIEcyYihhLCBiLCBjLCBkLCBtc2csIHgpIHtcbiAgICAvLyBOT1RFOiBWIGlzIExFIGhlcmVcbiAgICBjb25zdCBYbCA9IG1zZ1t4XSwgWGggPSBtc2dbeCArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQWwgPSBCQlVGWzIgKiBhXSwgQWggPSBCQlVGWzIgKiBhICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBCbCA9IEJCVUZbMiAqIGJdLCBCaCA9IEJCVUZbMiAqIGIgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IENsID0gQkJVRlsyICogY10sIENoID0gQkJVRlsyICogYyArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgRGwgPSBCQlVGWzIgKiBkXSwgRGggPSBCQlVGWzIgKiBkICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIC8vIHZbYV0gPSAodlthXSArIHZbYl0gKyB4KSB8IDA7XG4gICAgbGV0IGxsID0gdTY0LmFkZDNMKEFsLCBCbCwgWGwpO1xuICAgIEFoID0gdTY0LmFkZDNIKGxsLCBBaCwgQmgsIFhoKTtcbiAgICBBbCA9IGxsIHwgMDtcbiAgICAvLyB2W2RdID0gcm90cih2W2RdIF4gdlthXSwgMTYpXG4gICAgKHsgRGgsIERsIH0gPSB7IERoOiBEaCBeIEFoLCBEbDogRGwgXiBBbCB9KTtcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IHU2NC5yb3RyU0goRGgsIERsLCAxNiksIERsOiB1NjQucm90clNMKERoLCBEbCwgMTYpIH0pO1xuICAgIC8vIHZbY10gPSAodltjXSArIHZbZF0pIHwgMDtcbiAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQoQ2gsIENsLCBEaCwgRGwpKTtcbiAgICAvLyB2W2JdID0gcm90cih2W2JdIF4gdltjXSwgNjMpXG4gICAgKHsgQmgsIEJsIH0gPSB7IEJoOiBCaCBeIENoLCBCbDogQmwgXiBDbCB9KTtcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IHU2NC5yb3RyQkgoQmgsIEJsLCA2MyksIEJsOiB1NjQucm90ckJMKEJoLCBCbCwgNjMpIH0pO1xuICAgIChCQlVGWzIgKiBhXSA9IEFsKSwgKEJCVUZbMiAqIGEgKyAxXSA9IEFoKTtcbiAgICAoQkJVRlsyICogYl0gPSBCbCksIChCQlVGWzIgKiBiICsgMV0gPSBCaCk7XG4gICAgKEJCVUZbMiAqIGNdID0gQ2wpLCAoQkJVRlsyICogYyArIDFdID0gQ2gpO1xuICAgIChCQlVGWzIgKiBkXSA9IERsKSwgKEJCVUZbMiAqIGQgKyAxXSA9IERoKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQmxha2UyT3B0cyhvdXRwdXRMZW4sIG9wdHMgPSB7fSwga2V5TGVuLCBzYWx0TGVuLCBwZXJzTGVuKSB7XG4gICAgYW51bWJlcihrZXlMZW4pO1xuICAgIGlmIChvdXRwdXRMZW4gPCAwIHx8IG91dHB1dExlbiA+IGtleUxlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRMZW4gYmlnZ2VyIHRoYW4ga2V5TGVuJyk7XG4gICAgY29uc3QgeyBrZXksIHNhbHQsIHBlcnNvbmFsaXphdGlvbiB9ID0gb3B0cztcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgKGtleS5sZW5ndGggPCAxIHx8IGtleS5sZW5ndGggPiBrZXlMZW4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleSBsZW5ndGggbXVzdCBiZSB1bmRlZmluZWQgb3IgMS4uJyArIGtleUxlbik7XG4gICAgaWYgKHNhbHQgIT09IHVuZGVmaW5lZCAmJiBzYWx0Lmxlbmd0aCAhPT0gc2FsdExlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYWx0IG11c3QgYmUgdW5kZWZpbmVkIG9yICcgKyBzYWx0TGVuKTtcbiAgICBpZiAocGVyc29uYWxpemF0aW9uICE9PSB1bmRlZmluZWQgJiYgcGVyc29uYWxpemF0aW9uLmxlbmd0aCAhPT0gcGVyc0xlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwZXJzb25hbGl6YXRpb24gbXVzdCBiZSB1bmRlZmluZWQgb3IgJyArIHBlcnNMZW4pO1xufVxuLyoqIENsYXNzLCBmcm9tIHdoaWNoIG90aGVycyBhcmUgc3ViY2xhc3NlZC4gKi9cbmV4cG9ydCBjbGFzcyBCTEFLRTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIGFudW1iZXIoYmxvY2tMZW4pO1xuICAgICAgICBhbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLmJ1ZmZlcjMyID0gdTMyKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgLy8gTWFpbiBkaWZmZXJlbmNlIHdpdGggb3RoZXIgaGFzaGVzOiB0aGVyZSBpcyBmbGFnIGZvciBsYXN0IGJsb2NrLFxuICAgICAgICAvLyBzbyB3ZSBjYW5ub3QgcHJvY2VzcyBjdXJyZW50IGJsb2NrIGJlZm9yZSB3ZSBrbm93IHRoYXQgdGhlcmVcbiAgICAgICAgLy8gaXMgdGhlIG5leHQgb25lLiBUaGlzIHNpZ25pZmljYW50bHkgY29tcGxpY2F0ZXMgbG9naWMgYW5kIHJlZHVjZXMgYWJpbGl0eVxuICAgICAgICAvLyB0byBkbyB6ZXJvLWNvcHkgcHJvY2Vzc2luZ1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGJ1ZmZlcjMyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0O1xuICAgICAgICBjb25zdCBidWYgPSBkYXRhLmJ1ZmZlcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgLy8gSWYgYnVmZmVyIGlzIGZ1bGwgYW5kIHdlIHN0aWxsIGhhdmUgaW5wdXQgKGRvbid0IHByb2Nlc3MgbGFzdCBibG9jaywgc2FtZSBhcyBibGFrZTJzKVxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHN3YXAzMklmQkUoYnVmZmVyMzIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3MoYnVmZmVyMzIsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzd2FwMzJJZkJFKGJ1ZmZlcjMyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFPZmZzZXQgPSBvZmZzZXQgKyBwb3M7XG4gICAgICAgICAgICAvLyBmdWxsIGJsb2NrICYmIGFsaWduZWQgdG8gNCBieXRlcyAmJiBub3QgbGFzdCBpbiBpbnB1dFxuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuICYmICEoZGF0YU9mZnNldCAlIDQpICYmIHBvcyArIHRha2UgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmLCBkYXRhT2Zmc2V0LCBNYXRoLmZsb29yKChsZW4gLSBwb3MpIC8gNCkpO1xuICAgICAgICAgICAgICAgIHN3YXAzMklmQkUoZGF0YTMyKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MzMiA9IDA7IHBvcyArIGJsb2NrTGVuIDwgbGVuOyBwb3MzMiArPSBidWZmZXIzMi5sZW5ndGgsIHBvcyArPSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCArPSBibG9ja0xlbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzcyhkYXRhMzIsIHBvczMyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3YXAzMklmQkUoZGF0YTMyKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGNvbnN0IHsgcG9zLCBidWZmZXIzMiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKSk7XG4gICAgICAgIHN3YXAzMklmQkUoYnVmZmVyMzIpO1xuICAgICAgICB0aGlzLmNvbXByZXNzKGJ1ZmZlcjMyLCAwLCB0cnVlKTtcbiAgICAgICAgc3dhcDMySWZCRShidWZmZXIzMik7XG4gICAgICAgIGNvbnN0IG91dDMyID0gdTMyKG91dCk7XG4gICAgICAgIHRoaXMuZ2V0KCkuZm9yRWFjaCgodiwgaSkgPT4gKG91dDMyW2ldID0gc3dhcDhJZkJFKHYpKSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBvdXRwdXRMZW4sIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoeyBka0xlbjogb3V0cHV0TGVuIH0pKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJMQUtFMmIgZXh0ZW5kcyBCTEFLRTIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBvbGVuID0gb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gNjQgOiBvcHRzLmRrTGVuO1xuICAgICAgICBzdXBlcigxMjgsIG9sZW4pO1xuICAgICAgICAvLyBTYW1lIGFzIFNIQS01MTIsIGJ1dCBMRVxuICAgICAgICB0aGlzLnYwbCA9IEIyQl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMudjBoID0gQjJCX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy52MWwgPSBCMkJfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLnYxaCA9IEIyQl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMudjJsID0gQjJCX0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy52MmggPSBCMkJfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLnYzbCA9IEIyQl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMudjNoID0gQjJCX0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy52NGwgPSBCMkJfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLnY0aCA9IEIyQl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMudjVsID0gQjJCX0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMudjVoID0gQjJCX0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMudjZsID0gQjJCX0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMudjZoID0gQjJCX0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMudjdsID0gQjJCX0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMudjdoID0gQjJCX0lWWzE1XSB8IDA7XG4gICAgICAgIGNoZWNrQmxha2UyT3B0cyhvbGVuLCBvcHRzLCA2NCwgMTYsIDE2KTtcbiAgICAgICAgbGV0IHsga2V5LCBwZXJzb25hbGl6YXRpb24sIHNhbHQgfSA9IG9wdHM7XG4gICAgICAgIGxldCBrZXlMZW5ndGggPSAwO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGtleSA9IHRvQnl0ZXMoa2V5KTtcbiAgICAgICAgICAgIGtleUxlbmd0aCA9IGtleS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52MGwgXj0gdGhpcy5vdXRwdXRMZW4gfCAoa2V5TGVuZ3RoIDw8IDgpIHwgKDB4MDEgPDwgMTYpIHwgKDB4MDEgPDwgMjQpO1xuICAgICAgICBpZiAoc2FsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzYWx0ID0gdG9CeXRlcyhzYWx0KTtcbiAgICAgICAgICAgIGNvbnN0IHNsdCA9IHUzMihzYWx0KTtcbiAgICAgICAgICAgIHRoaXMudjRsIF49IHN3YXA4SWZCRShzbHRbMF0pO1xuICAgICAgICAgICAgdGhpcy52NGggXj0gc3dhcDhJZkJFKHNsdFsxXSk7XG4gICAgICAgICAgICB0aGlzLnY1bCBePSBzd2FwOElmQkUoc2x0WzJdKTtcbiAgICAgICAgICAgIHRoaXMudjVoIF49IHN3YXA4SWZCRShzbHRbM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJzb25hbGl6YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGVyc29uYWxpemF0aW9uID0gdG9CeXRlcyhwZXJzb25hbGl6YXRpb24pO1xuICAgICAgICAgICAgY29uc3QgcGVycyA9IHUzMihwZXJzb25hbGl6YXRpb24pO1xuICAgICAgICAgICAgdGhpcy52NmwgXj0gc3dhcDhJZkJFKHBlcnNbMF0pO1xuICAgICAgICAgICAgdGhpcy52NmggXj0gc3dhcDhJZkJFKHBlcnNbMV0pO1xuICAgICAgICAgICAgdGhpcy52N2wgXj0gc3dhcDhJZkJFKHBlcnNbMl0pO1xuICAgICAgICAgICAgdGhpcy52N2ggXj0gc3dhcDhJZkJFKHBlcnNbM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUGFkIHRvIGJsb2NrTGVuIGFuZCB1cGRhdGVcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tMZW4pO1xuICAgICAgICAgICAgdG1wLnNldChrZXkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodG1wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGxldCB7IHYwbCwgdjBoLCB2MWwsIHYxaCwgdjJsLCB2MmgsIHYzbCwgdjNoLCB2NGwsIHY0aCwgdjVsLCB2NWgsIHY2bCwgdjZoLCB2N2wsIHY3aCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFt2MGwsIHYwaCwgdjFsLCB2MWgsIHYybCwgdjJoLCB2M2wsIHYzaCwgdjRsLCB2NGgsIHY1bCwgdjVoLCB2NmwsIHY2aCwgdjdsLCB2N2hdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQodjBsLCB2MGgsIHYxbCwgdjFoLCB2MmwsIHYyaCwgdjNsLCB2M2gsIHY0bCwgdjRoLCB2NWwsIHY1aCwgdjZsLCB2NmgsIHY3bCwgdjdoKSB7XG4gICAgICAgIHRoaXMudjBsID0gdjBsIHwgMDtcbiAgICAgICAgdGhpcy52MGggPSB2MGggfCAwO1xuICAgICAgICB0aGlzLnYxbCA9IHYxbCB8IDA7XG4gICAgICAgIHRoaXMudjFoID0gdjFoIHwgMDtcbiAgICAgICAgdGhpcy52MmwgPSB2MmwgfCAwO1xuICAgICAgICB0aGlzLnYyaCA9IHYyaCB8IDA7XG4gICAgICAgIHRoaXMudjNsID0gdjNsIHwgMDtcbiAgICAgICAgdGhpcy52M2ggPSB2M2ggfCAwO1xuICAgICAgICB0aGlzLnY0bCA9IHY0bCB8IDA7XG4gICAgICAgIHRoaXMudjRoID0gdjRoIHwgMDtcbiAgICAgICAgdGhpcy52NWwgPSB2NWwgfCAwO1xuICAgICAgICB0aGlzLnY1aCA9IHY1aCB8IDA7XG4gICAgICAgIHRoaXMudjZsID0gdjZsIHwgMDtcbiAgICAgICAgdGhpcy52NmggPSB2NmggfCAwO1xuICAgICAgICB0aGlzLnY3bCA9IHY3bCB8IDA7XG4gICAgICAgIHRoaXMudjdoID0gdjdoIHwgMDtcbiAgICB9XG4gICAgY29tcHJlc3MobXNnLCBvZmZzZXQsIGlzTGFzdCkge1xuICAgICAgICB0aGlzLmdldCgpLmZvckVhY2goKHYsIGkpID0+IChCQlVGW2ldID0gdikpOyAvLyBGaXJzdCBoYWxmIGZyb20gc3RhdGUuXG4gICAgICAgIEJCVUYuc2V0KEIyQl9JViwgMTYpOyAvLyBTZWNvbmQgaGFsZiBmcm9tIElWLlxuICAgICAgICBsZXQgeyBoLCBsIH0gPSB1NjQuZnJvbUJpZyhCaWdJbnQodGhpcy5sZW5ndGgpKTtcbiAgICAgICAgQkJVRlsyNF0gPSBCMkJfSVZbOF0gXiBsOyAvLyBMb3cgd29yZCBvZiB0aGUgb2Zmc2V0LlxuICAgICAgICBCQlVGWzI1XSA9IEIyQl9JVls5XSBeIGg7IC8vIEhpZ2ggd29yZC5cbiAgICAgICAgLy8gSW52ZXJ0IGFsbCBiaXRzIGZvciBsYXN0IGJsb2NrXG4gICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgIEJCVUZbMjhdID0gfkJCVUZbMjhdO1xuICAgICAgICAgICAgQkJVRlsyOV0gPSB+QkJVRlsyOV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBjb25zdCBzID0gQlNJR01BO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIEcxYigwLCA0LCA4LCAxMiwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigwLCA0LCA4LCAxMiwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxYigxLCA1LCA5LCAxMywgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigxLCA1LCA5LCAxMywgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxYigyLCA2LCAxMCwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMiwgNiwgMTAsIDE0LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDMsIDcsIDExLCAxNSwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigzLCA3LCAxMSwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMCwgNSwgMTAsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDAsIDUsIDEwLCAxNSwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxYigxLCA2LCAxMSwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMSwgNiwgMTEsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDIsIDcsIDgsIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDIsIDcsIDgsIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDMsIDQsIDksIDE0LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDMsIDQsIDksIDE0LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudjBsIF49IEJCVUZbMF0gXiBCQlVGWzE2XTtcbiAgICAgICAgdGhpcy52MGggXj0gQkJVRlsxXSBeIEJCVUZbMTddO1xuICAgICAgICB0aGlzLnYxbCBePSBCQlVGWzJdIF4gQkJVRlsxOF07XG4gICAgICAgIHRoaXMudjFoIF49IEJCVUZbM10gXiBCQlVGWzE5XTtcbiAgICAgICAgdGhpcy52MmwgXj0gQkJVRls0XSBeIEJCVUZbMjBdO1xuICAgICAgICB0aGlzLnYyaCBePSBCQlVGWzVdIF4gQkJVRlsyMV07XG4gICAgICAgIHRoaXMudjNsIF49IEJCVUZbNl0gXiBCQlVGWzIyXTtcbiAgICAgICAgdGhpcy52M2ggXj0gQkJVRls3XSBeIEJCVUZbMjNdO1xuICAgICAgICB0aGlzLnY0bCBePSBCQlVGWzhdIF4gQkJVRlsyNF07XG4gICAgICAgIHRoaXMudjRoIF49IEJCVUZbOV0gXiBCQlVGWzI1XTtcbiAgICAgICAgdGhpcy52NWwgXj0gQkJVRlsxMF0gXiBCQlVGWzI2XTtcbiAgICAgICAgdGhpcy52NWggXj0gQkJVRlsxMV0gXiBCQlVGWzI3XTtcbiAgICAgICAgdGhpcy52NmwgXj0gQkJVRlsxMl0gXiBCQlVGWzI4XTtcbiAgICAgICAgdGhpcy52NmggXj0gQkJVRlsxM10gXiBCQlVGWzI5XTtcbiAgICAgICAgdGhpcy52N2wgXj0gQkJVRlsxNF0gXiBCQlVGWzMwXTtcbiAgICAgICAgdGhpcy52N2ggXj0gQkJVRlsxNV0gXiBCQlVGWzMxXTtcbiAgICAgICAgY2xlYW4oQkJVRik7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIzMik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbi8qKlxuICogQmxha2UyYiBoYXNoIGZ1bmN0aW9uLiA2NC1iaXQuIDEuNXggc2xvd2VyIHRoYW4gYmxha2UycyBpbiBKUy5cbiAqIEBwYXJhbSBtc2cgLSBtZXNzYWdlIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKiBAcGFyYW0gb3B0cyAtIGRrTGVuIG91dHB1dCBsZW5ndGgsIGtleSBmb3IgTUFDIG1vZGUsIHNhbHQsIHBlcnNvbmFsaXphdGlvblxuICovXG5leHBvcnQgY29uc3QgYmxha2UyYiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVPcHRIYXNoZXIoKG9wdHMpID0+IG5ldyBCTEFLRTJiKG9wdHMpKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzKHMsIG9mZnNldCwgbXNnLCByb3VuZHMsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5LCB2MTAsIHYxMSwgdjEyLCB2MTMsIHYxNCwgdjE1KSB7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmRzOyBpKyspIHtcbiAgICAgICAgKHsgYTogdjAsIGI6IHY0LCBjOiB2OCwgZDogdjEyIH0gPSBHMXModjAsIHY0LCB2OCwgdjEyLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MCwgYjogdjQsIGM6IHY4LCBkOiB2MTIgfSA9IEcycyh2MCwgdjQsIHY4LCB2MTIsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYxLCBiOiB2NSwgYzogdjksIGQ6IHYxMyB9ID0gRzFzKHYxLCB2NSwgdjksIHYxMywgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjEsIGI6IHY1LCBjOiB2OSwgZDogdjEzIH0gPSBHMnModjEsIHY1LCB2OSwgdjEzLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MiwgYjogdjYsIGM6IHYxMCwgZDogdjE0IH0gPSBHMXModjIsIHY2LCB2MTAsIHYxNCwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjIsIGI6IHY2LCBjOiB2MTAsIGQ6IHYxNCB9ID0gRzJzKHYyLCB2NiwgdjEwLCB2MTQsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYzLCBiOiB2NywgYzogdjExLCBkOiB2MTUgfSA9IEcxcyh2MywgdjcsIHYxMSwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MywgYjogdjcsIGM6IHYxMSwgZDogdjE1IH0gPSBHMnModjMsIHY3LCB2MTEsIHYxNSwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjAsIGI6IHY1LCBjOiB2MTAsIGQ6IHYxNSB9ID0gRzFzKHYwLCB2NSwgdjEwLCB2MTUsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYwLCBiOiB2NSwgYzogdjEwLCBkOiB2MTUgfSA9IEcycyh2MCwgdjUsIHYxMCwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MSwgYjogdjYsIGM6IHYxMSwgZDogdjEyIH0gPSBHMXModjEsIHY2LCB2MTEsIHYxMiwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjEsIGI6IHY2LCBjOiB2MTEsIGQ6IHYxMiB9ID0gRzJzKHYxLCB2NiwgdjExLCB2MTIsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYyLCBiOiB2NywgYzogdjgsIGQ6IHYxMyB9ID0gRzFzKHYyLCB2NywgdjgsIHYxMywgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjIsIGI6IHY3LCBjOiB2OCwgZDogdjEzIH0gPSBHMnModjIsIHY3LCB2OCwgdjEzLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MywgYjogdjQsIGM6IHY5LCBkOiB2MTQgfSA9IEcxcyh2MywgdjQsIHY5LCB2MTQsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYzLCBiOiB2NCwgYzogdjksIGQ6IHYxNCB9ID0gRzJzKHYzLCB2NCwgdjksIHYxNCwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUgfTtcbn1cbmNvbnN0IEIyU19JViA9IFNIQTI1Nl9JVjtcbmV4cG9ydCBjbGFzcyBCTEFLRTJzIGV4dGVuZHMgQkxBS0UyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3Qgb2xlbiA9IG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IDMyIDogb3B0cy5ka0xlbjtcbiAgICAgICAgc3VwZXIoNjQsIG9sZW4pO1xuICAgICAgICAvLyBJbnRlcm5hbCBzdGF0ZSwgc2FtZSBhcyBTSEEtMjU2XG4gICAgICAgIHRoaXMudjAgPSBCMlNfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLnYxID0gQjJTX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy52MiA9IEIyU19JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMudjMgPSBCMlNfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLnY0ID0gQjJTX0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy52NSA9IEIyU19JVls1XSB8IDA7XG4gICAgICAgIHRoaXMudjYgPSBCMlNfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLnY3ID0gQjJTX0lWWzddIHwgMDtcbiAgICAgICAgY2hlY2tCbGFrZTJPcHRzKG9sZW4sIG9wdHMsIDMyLCA4LCA4KTtcbiAgICAgICAgbGV0IHsga2V5LCBwZXJzb25hbGl6YXRpb24sIHNhbHQgfSA9IG9wdHM7XG4gICAgICAgIGxldCBrZXlMZW5ndGggPSAwO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGtleSA9IHRvQnl0ZXMoa2V5KTtcbiAgICAgICAgICAgIGtleUxlbmd0aCA9IGtleS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52MCBePSB0aGlzLm91dHB1dExlbiB8IChrZXlMZW5ndGggPDwgOCkgfCAoMHgwMSA8PCAxNikgfCAoMHgwMSA8PCAyNCk7XG4gICAgICAgIGlmIChzYWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNhbHQgPSB0b0J5dGVzKHNhbHQpO1xuICAgICAgICAgICAgY29uc3Qgc2x0ID0gdTMyKHNhbHQpO1xuICAgICAgICAgICAgdGhpcy52NCBePSBzd2FwOElmQkUoc2x0WzBdKTtcbiAgICAgICAgICAgIHRoaXMudjUgXj0gc3dhcDhJZkJFKHNsdFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcnNvbmFsaXphdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwZXJzb25hbGl6YXRpb24gPSB0b0J5dGVzKHBlcnNvbmFsaXphdGlvbik7XG4gICAgICAgICAgICBjb25zdCBwZXJzID0gdTMyKHBlcnNvbmFsaXphdGlvbik7XG4gICAgICAgICAgICB0aGlzLnY2IF49IHN3YXA4SWZCRShwZXJzWzBdKTtcbiAgICAgICAgICAgIHRoaXMudjcgXj0gc3dhcDhJZkJFKHBlcnNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUGFkIHRvIGJsb2NrTGVuIGFuZCB1cGRhdGVcbiAgICAgICAgICAgIGFieXRlcyhrZXkpO1xuICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ibG9ja0xlbik7XG4gICAgICAgICAgICB0bXAuc2V0KGtleSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0bXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3XTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2Nykge1xuICAgICAgICB0aGlzLnYwID0gdjAgfCAwO1xuICAgICAgICB0aGlzLnYxID0gdjEgfCAwO1xuICAgICAgICB0aGlzLnYyID0gdjIgfCAwO1xuICAgICAgICB0aGlzLnYzID0gdjMgfCAwO1xuICAgICAgICB0aGlzLnY0ID0gdjQgfCAwO1xuICAgICAgICB0aGlzLnY1ID0gdjUgfCAwO1xuICAgICAgICB0aGlzLnY2ID0gdjYgfCAwO1xuICAgICAgICB0aGlzLnY3ID0gdjcgfCAwO1xuICAgIH1cbiAgICBjb21wcmVzcyhtc2csIG9mZnNldCwgaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gdTY0LmZyb21CaWcoQmlnSW50KHRoaXMubGVuZ3RoKSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCB7IHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5LCB2MTAsIHYxMSwgdjEyLCB2MTMsIHYxNCwgdjE1IH0gPSBjb21wcmVzcyhCU0lHTUEsIG9mZnNldCwgbXNnLCAxMCwgdGhpcy52MCwgdGhpcy52MSwgdGhpcy52MiwgdGhpcy52MywgdGhpcy52NCwgdGhpcy52NSwgdGhpcy52NiwgdGhpcy52NywgQjJTX0lWWzBdLCBCMlNfSVZbMV0sIEIyU19JVlsyXSwgQjJTX0lWWzNdLCBsIF4gQjJTX0lWWzRdLCBoIF4gQjJTX0lWWzVdLCBpc0xhc3QgPyB+QjJTX0lWWzZdIDogQjJTX0lWWzZdLCBCMlNfSVZbN10pO1xuICAgICAgICB0aGlzLnYwIF49IHYwIF4gdjg7XG4gICAgICAgIHRoaXMudjEgXj0gdjEgXiB2OTtcbiAgICAgICAgdGhpcy52MiBePSB2MiBeIHYxMDtcbiAgICAgICAgdGhpcy52MyBePSB2MyBeIHYxMTtcbiAgICAgICAgdGhpcy52NCBePSB2NCBeIHYxMjtcbiAgICAgICAgdGhpcy52NSBePSB2NSBeIHYxMztcbiAgICAgICAgdGhpcy52NiBePSB2NiBeIHYxNDtcbiAgICAgICAgdGhpcy52NyBePSB2NyBeIHYxNTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcjMyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqXG4gKiBCbGFrZTJzIGhhc2ggZnVuY3Rpb24uIEZvY3VzZXMgb24gOC1iaXQgdG8gMzItYml0IHBsYXRmb3Jtcy4gMS41eCBmYXN0ZXIgdGhhbiBibGFrZTJiIGluIEpTLlxuICogQHBhcmFtIG1zZyAtIG1lc3NhZ2UgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqIEBwYXJhbSBvcHRzIC0gZGtMZW4gb3V0cHV0IGxlbmd0aCwga2V5IGZvciBNQUMgbW9kZSwgc2FsdCwgcGVyc29uYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBibGFrZTJzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU9wdEhhc2hlcigob3B0cykgPT4gbmV3IEJMQUtFMnMob3B0cykpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ymxha2UyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/blake2.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/blake3.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/blake3.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLAKE3: () => (/* binding */ BLAKE3),\n/* harmony export */   blake3: () => (/* binding */ blake3)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_u64.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _blake2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blake2.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/blake2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC & KDF.\n *\n * It is advertised as \"the fastest cryptographic hash\". However, it isn't true in JS.\n * Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:\n *\n * * There is only 30% reduction in number of rounds from blake2s\n * * Speed-up comes from tree structure, which is parallelized using SIMD & threading.\n *   These features are not present in JS, so we only get overhead from trees.\n * * Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.\n * * It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm\n * @module\n */\n\n\n\n// prettier-ignore\n\n// Flag bitset\nconst B3_Flags = {\n    CHUNK_START: 0b1,\n    CHUNK_END: 0b10,\n    PARENT: 0b100,\n    ROOT: 0b1000,\n    KEYED_HASH: 0b10000,\n    DERIVE_KEY_CONTEXT: 0b100000,\n    DERIVE_KEY_MATERIAL: 0b1000000,\n};\nconst B3_IV = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV.slice();\nconst B3_SIGMA = /* @__PURE__ */ (() => {\n    const Id = Array.from({ length: 16 }, (_, i) => i);\n    const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);\n    const res = [];\n    for (let i = 0, v = Id; i < 7; i++, v = permute(v))\n        res.push(...v);\n    return Uint8Array.from(res);\n})();\n/** Blake3 hash. Can be used as MAC and KDF. */\nclass BLAKE3 extends _blake2_js__WEBPACK_IMPORTED_MODULE_1__.BLAKE2 {\n    constructor(opts = {}, flags = 0) {\n        super(64, opts.dkLen === undefined ? 32 : opts.dkLen);\n        this.chunkPos = 0; // Position of current block in chunk\n        this.chunksDone = 0; // How many chunks we already have\n        this.flags = 0 | 0;\n        this.stack = [];\n        // Output\n        this.posOut = 0;\n        this.bufferOut32 = new Uint32Array(16);\n        this.chunkOut = 0; // index of output chunk\n        this.enableXOF = true;\n        const { key, context } = opts;\n        const hasContext = context !== undefined;\n        if (key !== undefined) {\n            if (hasContext)\n                throw new Error('Only \"key\" or \"context\" can be specified at same time');\n            const k = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(key).slice();\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(k, 32);\n            this.IV = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)(k);\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.swap32IfBE)(this.IV);\n            this.flags = flags | B3_Flags.KEYED_HASH;\n        }\n        else if (hasContext) {\n            const ctx = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(context);\n            const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT)\n                .update(ctx)\n                .digest();\n            this.IV = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)(contextKey);\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.swap32IfBE)(this.IV);\n            this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;\n        }\n        else {\n            this.IV = B3_IV.slice();\n            this.flags = flags;\n        }\n        this.state = this.IV.slice();\n        this.bufferOut = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u8)(this.bufferOut32);\n    }\n    // Unused\n    get() {\n        return [];\n    }\n    set() { }\n    b2Compress(counter, flags, buf, bufPos = 0) {\n        const { state: s, pos } = this;\n        const { h, l } = (0,_u64_js__WEBPACK_IMPORTED_MODULE_3__.fromBig)(BigInt(counter), true);\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = (0,_blake2_js__WEBPACK_IMPORTED_MODULE_1__.compress)(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);\n        s[0] = v0 ^ v8;\n        s[1] = v1 ^ v9;\n        s[2] = v2 ^ v10;\n        s[3] = v3 ^ v11;\n        s[4] = v4 ^ v12;\n        s[5] = v5 ^ v13;\n        s[6] = v6 ^ v14;\n        s[7] = v7 ^ v15;\n    }\n    compress(buf, bufPos = 0, isLast = false) {\n        // Compress last block\n        let flags = this.flags;\n        if (!this.chunkPos)\n            flags |= B3_Flags.CHUNK_START;\n        if (this.chunkPos === 15 || isLast)\n            flags |= B3_Flags.CHUNK_END;\n        if (!isLast)\n            this.pos = this.blockLen;\n        this.b2Compress(this.chunksDone, flags, buf, bufPos);\n        this.chunkPos += 1;\n        // If current block is last in chunk (16 blocks), then compress chunks\n        if (this.chunkPos === 16 || isLast) {\n            let chunk = this.state;\n            this.state = this.IV.slice();\n            // If not the last one, compress only when there are trailing zeros in chunk counter\n            // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n            // 1 (001) - leaf not finished (just push current chunk to stack)\n            // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n            // 3 (011) - last leaf not finished\n            // 4 (100) - leafs finished at depth=1 and depth=2\n            for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n                if (!(last = this.stack.pop()))\n                    break;\n                this.buffer32.set(last, 0);\n                this.buffer32.set(chunk, 8);\n                this.pos = this.blockLen;\n                this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);\n                chunk = this.state;\n                this.state = this.IV.slice();\n            }\n            this.chunksDone++;\n            this.chunkPos = 0;\n            this.stack.push(chunk);\n        }\n        this.pos = 0;\n    }\n    _cloneInto(to) {\n        to = super._cloneInto(to);\n        const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;\n        to.state.set(state.slice());\n        to.stack = stack.map((i) => Uint32Array.from(i));\n        to.IV.set(IV);\n        to.flags = flags;\n        to.chunkPos = chunkPos;\n        to.chunksDone = chunksDone;\n        to.posOut = posOut;\n        to.chunkOut = chunkOut;\n        to.enableXOF = this.enableXOF;\n        to.bufferOut32.set(this.bufferOut32);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.clean)(this.state, this.buffer32, this.IV, this.bufferOut32);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.clean)(...this.stack);\n    }\n    // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n    b2CompressOut() {\n        const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;\n        const { h, l } = (0,_u64_js__WEBPACK_IMPORTED_MODULE_3__.fromBig)(BigInt(this.chunkOut++));\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.swap32IfBE)(buffer32);\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = (0,_blake2_js__WEBPACK_IMPORTED_MODULE_1__.compress)(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);\n        out32[0] = v0 ^ v8;\n        out32[1] = v1 ^ v9;\n        out32[2] = v2 ^ v10;\n        out32[3] = v3 ^ v11;\n        out32[4] = v4 ^ v12;\n        out32[5] = v5 ^ v13;\n        out32[6] = v6 ^ v14;\n        out32[7] = v7 ^ v15;\n        out32[8] = s[0] ^ v8;\n        out32[9] = s[1] ^ v9;\n        out32[10] = s[2] ^ v10;\n        out32[11] = s[3] ^ v11;\n        out32[12] = s[4] ^ v12;\n        out32[13] = s[5] ^ v13;\n        out32[14] = s[6] ^ v14;\n        out32[15] = s[7] ^ v15;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.swap32IfBE)(buffer32);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.swap32IfBE)(out32);\n        this.posOut = 0;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        // Padding\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.clean)(this.buffer.subarray(this.pos));\n        // Process last chunk\n        let flags = this.flags | B3_Flags.ROOT;\n        if (this.stack.length) {\n            flags |= B3_Flags.PARENT;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.swap32IfBE)(this.buffer32);\n            this.compress(this.buffer32, 0, true);\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.swap32IfBE)(this.buffer32);\n            this.chunksDone = 0;\n            this.pos = this.blockLen;\n        }\n        else {\n            flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;\n        }\n        this.flags = flags;\n        this.b2CompressOut();\n    }\n    writeInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.aexists)(this, false);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(out);\n        this.finish();\n        const { blockLen, bufferOut } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.b2CompressOut();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible after digest call');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.aoutput)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.enableXOF = false;\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n}\n/**\n * BLAKE3 hash function. Can be used as MAC and KDF.\n * @param msg - message that would be hashed\n * @param opts - `dkLen` for output length, `key` for MAC mode, `context` for KDF mode\n * @example\n * const data = new Uint8Array(32);\n * const hash = blake3(data);\n * const mac = blake3(data, { key: new Uint8Array(32) });\n * const kdf = blake3(data, { context: 'application name' });\n */\nconst blake3 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.createXOFer)((opts) => new BLAKE3(opts));\n//# sourceMappingURL=blake3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9ibGFrZTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDRDtBQUNXO0FBQy9DO0FBQ2lIO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBUztBQUN2QjtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ08scUJBQXFCLDhDQUFNO0FBQ2xDLHlCQUF5QjtBQUN6QjtBQUNBLDJCQUEyQjtBQUMzQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFPO0FBQzdCLFlBQVksaURBQU07QUFDbEIsc0JBQXNCLDhDQUFHO0FBQ3pCLFlBQVkscURBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFPO0FBQy9CLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQSxzQkFBc0IsOENBQUc7QUFDekIsWUFBWSxxREFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsZ0JBQWdCLE9BQU8sRUFBRSxnREFBTztBQUNoQztBQUNBLGdCQUFnQix1RUFBdUUsRUFBRSxvREFBUTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQseUJBQXlCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2IsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckUsZ0JBQWdCLE9BQU8sRUFBRSxnREFBTztBQUNoQyxRQUFRLHFEQUFVO0FBQ2xCO0FBQ0EsZ0JBQWdCLHVFQUF1RSxFQUFFLG9EQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBVTtBQUNsQixRQUFRLHFEQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBVTtBQUN0QjtBQUNBLFlBQVkscURBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2YsUUFBUSxpREFBTTtBQUNkO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0Qyw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNPLCtCQUErQixzREFBVztBQUNqRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2JsYWtlMy5qcz84MWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQmxha2UzIGZhc3QgaGFzaCBpcyBCbGFrZTIgd2l0aCByZWR1Y2VkIHNlY3VyaXR5IChyb3VuZCBjb3VudCkuIENhbiBhbHNvIGJlIHVzZWQgYXMgTUFDICYgS0RGLlxuICpcbiAqIEl0IGlzIGFkdmVydGlzZWQgYXMgXCJ0aGUgZmFzdGVzdCBjcnlwdG9ncmFwaGljIGhhc2hcIi4gSG93ZXZlciwgaXQgaXNuJ3QgdHJ1ZSBpbiBKUy5cbiAqIFdoeSBpcyB0aGlzIHNvIHNsb3c/IFdoaWxlIGl0IHNob3VsZCBiZSA2eCBmYXN0ZXIgdGhhbiBibGFrZTJiLCBwZXJmIGRpZmYgaXMgb25seSAyMCU6XG4gKlxuICogKiBUaGVyZSBpcyBvbmx5IDMwJSByZWR1Y3Rpb24gaW4gbnVtYmVyIG9mIHJvdW5kcyBmcm9tIGJsYWtlMnNcbiAqICogU3BlZWQtdXAgY29tZXMgZnJvbSB0cmVlIHN0cnVjdHVyZSwgd2hpY2ggaXMgcGFyYWxsZWxpemVkIHVzaW5nIFNJTUQgJiB0aHJlYWRpbmcuXG4gKiAgIFRoZXNlIGZlYXR1cmVzIGFyZSBub3QgcHJlc2VudCBpbiBKUywgc28gd2Ugb25seSBnZXQgb3ZlcmhlYWQgZnJvbSB0cmVlcy5cbiAqICogUGFyYWxsZWxpemF0aW9uIG9ubHkgaGFwcGVucyBvbiAxMDI0LWJ5dGUgY2h1bmtzOiB0aGVyZSBpcyBubyBiZW5lZml0IGZvciBzbWFsbCBpbnB1dHMuXG4gKiAqIEl0IGlzIHN0aWxsIHBvc3NpYmxlIHRvIG1ha2UgaXQgZmFzdGVyIHVzaW5nOiBhKSBsb29wIHVucm9sbGluZyBiKSB3ZWIgd29ya2VycyBjKSB3YXNtXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IFNIQTI1Nl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0IHsgZnJvbUJpZyB9IGZyb20gXCIuL191NjQuanNcIjtcbmltcG9ydCB7IEJMQUtFMiwgY29tcHJlc3MgfSBmcm9tIFwiLi9ibGFrZTIuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhbnVtYmVyLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlWE9GZXIsIHN3YXAzMklmQkUsIHRvQnl0ZXMsIHUzMiwgdTggfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gRmxhZyBiaXRzZXRcbmNvbnN0IEIzX0ZsYWdzID0ge1xuICAgIENIVU5LX1NUQVJUOiAwYjEsXG4gICAgQ0hVTktfRU5EOiAwYjEwLFxuICAgIFBBUkVOVDogMGIxMDAsXG4gICAgUk9PVDogMGIxMDAwLFxuICAgIEtFWUVEX0hBU0g6IDBiMTAwMDAsXG4gICAgREVSSVZFX0tFWV9DT05URVhUOiAwYjEwMDAwMCxcbiAgICBERVJJVkVfS0VZX01BVEVSSUFMOiAwYjEwMDAwMDAsXG59O1xuY29uc3QgQjNfSVYgPSBTSEEyNTZfSVYuc2xpY2UoKTtcbmNvbnN0IEIzX1NJR01BID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgY29uc3QgSWQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG4gICAgY29uc3QgcGVybXV0ZSA9IChhcnIpID0+IFsyLCA2LCAzLCAxMCwgNywgMCwgNCwgMTMsIDEsIDExLCAxMiwgNSwgOSwgMTQsIDE1LCA4XS5tYXAoKGkpID0+IGFycltpXSk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIHYgPSBJZDsgaSA8IDc7IGkrKywgdiA9IHBlcm11dGUodikpXG4gICAgICAgIHJlcy5wdXNoKC4uLnYpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbn0pKCk7XG4vKiogQmxha2UzIGhhc2guIENhbiBiZSB1c2VkIGFzIE1BQyBhbmQgS0RGLiAqL1xuZXhwb3J0IGNsYXNzIEJMQUtFMyBleHRlbmRzIEJMQUtFMiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9LCBmbGFncyA9IDApIHtcbiAgICAgICAgc3VwZXIoNjQsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IDMyIDogb3B0cy5ka0xlbik7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSAwOyAvLyBQb3NpdGlvbiBvZiBjdXJyZW50IGJsb2NrIGluIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtzRG9uZSA9IDA7IC8vIEhvdyBtYW55IGNodW5rcyB3ZSBhbHJlYWR5IGhhdmVcbiAgICAgICAgdGhpcy5mbGFncyA9IDAgfCAwO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8vIE91dHB1dFxuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyT3V0MzIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuICAgICAgICB0aGlzLmNodW5rT3V0ID0gMDsgLy8gaW5kZXggb2Ygb3V0cHV0IGNodW5rXG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBrZXksIGNvbnRleHQgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRleHQgPSBjb250ZXh0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGhhc0NvbnRleHQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IFwia2V5XCIgb3IgXCJjb250ZXh0XCIgY2FuIGJlIHNwZWNpZmllZCBhdCBzYW1lIHRpbWUnKTtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0b0J5dGVzKGtleSkuc2xpY2UoKTtcbiAgICAgICAgICAgIGFieXRlcyhrLCAzMik7XG4gICAgICAgICAgICB0aGlzLklWID0gdTMyKGspO1xuICAgICAgICAgICAgc3dhcDMySWZCRSh0aGlzLklWKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncyB8IEIzX0ZsYWdzLktFWUVEX0hBU0g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdG9CeXRlcyhjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBuZXcgQkxBS0UzKHsgZGtMZW46IDMyIH0sIEIzX0ZsYWdzLkRFUklWRV9LRVlfQ09OVEVYVClcbiAgICAgICAgICAgICAgICAudXBkYXRlKGN0eClcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCk7XG4gICAgICAgICAgICB0aGlzLklWID0gdTMyKGNvbnRleHRLZXkpO1xuICAgICAgICAgICAgc3dhcDMySWZCRSh0aGlzLklWKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncyB8IEIzX0ZsYWdzLkRFUklWRV9LRVlfTUFURVJJQUw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLklWID0gQjNfSVYuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5JVi5zbGljZSgpO1xuICAgICAgICB0aGlzLmJ1ZmZlck91dCA9IHU4KHRoaXMuYnVmZmVyT3V0MzIpO1xuICAgIH1cbiAgICAvLyBVbnVzZWRcbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgc2V0KCkgeyB9XG4gICAgYjJDb21wcmVzcyhjb3VudGVyLCBmbGFncywgYnVmLCBidWZQb3MgPSAwKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGU6IHMsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKEJpZ0ludChjb3VudGVyKSwgdHJ1ZSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCB7IHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5LCB2MTAsIHYxMSwgdjEyLCB2MTMsIHYxNCwgdjE1IH0gPSBjb21wcmVzcyhCM19TSUdNQSwgYnVmUG9zLCBidWYsIDcsIHNbMF0sIHNbMV0sIHNbMl0sIHNbM10sIHNbNF0sIHNbNV0sIHNbNl0sIHNbN10sIEIzX0lWWzBdLCBCM19JVlsxXSwgQjNfSVZbMl0sIEIzX0lWWzNdLCBoLCBsLCBwb3MsIGZsYWdzKTtcbiAgICAgICAgc1swXSA9IHYwIF4gdjg7XG4gICAgICAgIHNbMV0gPSB2MSBeIHY5O1xuICAgICAgICBzWzJdID0gdjIgXiB2MTA7XG4gICAgICAgIHNbM10gPSB2MyBeIHYxMTtcbiAgICAgICAgc1s0XSA9IHY0IF4gdjEyO1xuICAgICAgICBzWzVdID0gdjUgXiB2MTM7XG4gICAgICAgIHNbNl0gPSB2NiBeIHYxNDtcbiAgICAgICAgc1s3XSA9IHY3IF4gdjE1O1xuICAgIH1cbiAgICBjb21wcmVzcyhidWYsIGJ1ZlBvcyA9IDAsIGlzTGFzdCA9IGZhbHNlKSB7XG4gICAgICAgIC8vIENvbXByZXNzIGxhc3QgYmxvY2tcbiAgICAgICAgbGV0IGZsYWdzID0gdGhpcy5mbGFncztcbiAgICAgICAgaWYgKCF0aGlzLmNodW5rUG9zKVxuICAgICAgICAgICAgZmxhZ3MgfD0gQjNfRmxhZ3MuQ0hVTktfU1RBUlQ7XG4gICAgICAgIGlmICh0aGlzLmNodW5rUG9zID09PSAxNSB8fCBpc0xhc3QpXG4gICAgICAgICAgICBmbGFncyB8PSBCM19GbGFncy5DSFVOS19FTkQ7XG4gICAgICAgIGlmICghaXNMYXN0KVxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLmIyQ29tcHJlc3ModGhpcy5jaHVua3NEb25lLCBmbGFncywgYnVmLCBidWZQb3MpO1xuICAgICAgICB0aGlzLmNodW5rUG9zICs9IDE7XG4gICAgICAgIC8vIElmIGN1cnJlbnQgYmxvY2sgaXMgbGFzdCBpbiBjaHVuayAoMTYgYmxvY2tzKSwgdGhlbiBjb21wcmVzcyBjaHVua3NcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtQb3MgPT09IDE2IHx8IGlzTGFzdCkge1xuICAgICAgICAgICAgbGV0IGNodW5rID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLklWLnNsaWNlKCk7XG4gICAgICAgICAgICAvLyBJZiBub3QgdGhlIGxhc3Qgb25lLCBjb21wcmVzcyBvbmx5IHdoZW4gdGhlcmUgYXJlIHRyYWlsaW5nIHplcm9zIGluIGNodW5rIGNvdW50ZXJcbiAgICAgICAgICAgIC8vIGNodW5rcyB1c2VkIGFzIGJpbmFyeSB0cmVlIHdoZXJlIGN1cnJlbnQgc3RhY2sgaXMgcGF0aC4gWmVybyBtZWFucyBjdXJyZW50IGxlYWYgaXMgZmluaXNoZWQgYW5kIGNhbiBiZSBjb21wcmVzc2VkLlxuICAgICAgICAgICAgLy8gMSAoMDAxKSAtIGxlYWYgbm90IGZpbmlzaGVkIChqdXN0IHB1c2ggY3VycmVudCBjaHVuayB0byBzdGFjaylcbiAgICAgICAgICAgIC8vIDIgKDAxMCkgLSBsZWFmIGZpbmlzaGVkIGF0IGRlcHRoPTEgKG1lcmdlIHdpdGggbGFzdCBlbG0gb24gc3RhY2sgYW5kIHB1c2ggYmFjaylcbiAgICAgICAgICAgIC8vIDMgKDAxMSkgLSBsYXN0IGxlYWYgbm90IGZpbmlzaGVkXG4gICAgICAgICAgICAvLyA0ICgxMDApIC0gbGVhZnMgZmluaXNoZWQgYXQgZGVwdGg9MSBhbmQgZGVwdGg9MlxuICAgICAgICAgICAgZm9yIChsZXQgbGFzdCwgY2h1bmtzID0gdGhpcy5jaHVua3NEb25lICsgMTsgaXNMYXN0IHx8ICEoY2h1bmtzICYgMSk7IGNodW5rcyA+Pj0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghKGxhc3QgPSB0aGlzLnN0YWNrLnBvcCgpKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIzMi5zZXQobGFzdCwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIzMi5zZXQoY2h1bmssIDgpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgICAgICAgICB0aGlzLmIyQ29tcHJlc3MoMCwgdGhpcy5mbGFncyB8IEIzX0ZsYWdzLlBBUkVOVCwgdGhpcy5idWZmZXIzMiwgMCk7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLklWLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNodW5rc0RvbmUrKztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gPSBzdXBlci5fY2xvbmVJbnRvKHRvKTtcbiAgICAgICAgY29uc3QgeyBJViwgZmxhZ3MsIHN0YXRlLCBjaHVua1BvcywgcG9zT3V0LCBjaHVua091dCwgc3RhY2ssIGNodW5rc0RvbmUgfSA9IHRoaXM7XG4gICAgICAgIHRvLnN0YXRlLnNldChzdGF0ZS5zbGljZSgpKTtcbiAgICAgICAgdG8uc3RhY2sgPSBzdGFjay5tYXAoKGkpID0+IFVpbnQzMkFycmF5LmZyb20oaSkpO1xuICAgICAgICB0by5JVi5zZXQoSVYpO1xuICAgICAgICB0by5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0by5jaHVua1BvcyA9IGNodW5rUG9zO1xuICAgICAgICB0by5jaHVua3NEb25lID0gY2h1bmtzRG9uZTtcbiAgICAgICAgdG8ucG9zT3V0ID0gcG9zT3V0O1xuICAgICAgICB0by5jaHVua091dCA9IGNodW5rT3V0O1xuICAgICAgICB0by5lbmFibGVYT0YgPSB0aGlzLmVuYWJsZVhPRjtcbiAgICAgICAgdG8uYnVmZmVyT3V0MzIuc2V0KHRoaXMuYnVmZmVyT3V0MzIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW4odGhpcy5zdGF0ZSwgdGhpcy5idWZmZXIzMiwgdGhpcy5JViwgdGhpcy5idWZmZXJPdXQzMik7XG4gICAgICAgIGNsZWFuKC4uLnRoaXMuc3RhY2spO1xuICAgIH1cbiAgICAvLyBTYW1lIGFzIGIyQ29tcHJlc3MsIGJ1dCBkb2Vzbid0IG1vZGlmeSBzdGF0ZSBhbmQgcmV0dXJucyAxNiB1MzIgYXJyYXkgKGluc3RlYWQgb2YgOClcbiAgICBiMkNvbXByZXNzT3V0KCkge1xuICAgICAgICBjb25zdCB7IHN0YXRlOiBzLCBwb3MsIGZsYWdzLCBidWZmZXIzMiwgYnVmZmVyT3V0MzI6IG91dDMyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcoQmlnSW50KHRoaXMuY2h1bmtPdXQrKykpO1xuICAgICAgICBzd2FwMzJJZkJFKGJ1ZmZlcjMyKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IHsgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUgfSA9IGNvbXByZXNzKEIzX1NJR01BLCAwLCBidWZmZXIzMiwgNywgc1swXSwgc1sxXSwgc1syXSwgc1szXSwgc1s0XSwgc1s1XSwgc1s2XSwgc1s3XSwgQjNfSVZbMF0sIEIzX0lWWzFdLCBCM19JVlsyXSwgQjNfSVZbM10sIGwsIGgsIHBvcywgZmxhZ3MpO1xuICAgICAgICBvdXQzMlswXSA9IHYwIF4gdjg7XG4gICAgICAgIG91dDMyWzFdID0gdjEgXiB2OTtcbiAgICAgICAgb3V0MzJbMl0gPSB2MiBeIHYxMDtcbiAgICAgICAgb3V0MzJbM10gPSB2MyBeIHYxMTtcbiAgICAgICAgb3V0MzJbNF0gPSB2NCBeIHYxMjtcbiAgICAgICAgb3V0MzJbNV0gPSB2NSBeIHYxMztcbiAgICAgICAgb3V0MzJbNl0gPSB2NiBeIHYxNDtcbiAgICAgICAgb3V0MzJbN10gPSB2NyBeIHYxNTtcbiAgICAgICAgb3V0MzJbOF0gPSBzWzBdIF4gdjg7XG4gICAgICAgIG91dDMyWzldID0gc1sxXSBeIHY5O1xuICAgICAgICBvdXQzMlsxMF0gPSBzWzJdIF4gdjEwO1xuICAgICAgICBvdXQzMlsxMV0gPSBzWzNdIF4gdjExO1xuICAgICAgICBvdXQzMlsxMl0gPSBzWzRdIF4gdjEyO1xuICAgICAgICBvdXQzMlsxM10gPSBzWzVdIF4gdjEzO1xuICAgICAgICBvdXQzMlsxNF0gPSBzWzZdIF4gdjE0O1xuICAgICAgICBvdXQzMlsxNV0gPSBzWzddIF4gdjE1O1xuICAgICAgICBzd2FwMzJJZkJFKGJ1ZmZlcjMyKTtcbiAgICAgICAgc3dhcDMySWZCRShvdXQzMik7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MpKTtcbiAgICAgICAgLy8gUHJvY2VzcyBsYXN0IGNodW5rXG4gICAgICAgIGxldCBmbGFncyA9IHRoaXMuZmxhZ3MgfCBCM19GbGFncy5ST09UO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IEIzX0ZsYWdzLlBBUkVOVDtcbiAgICAgICAgICAgIHN3YXAzMklmQkUodGhpcy5idWZmZXIzMik7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzKHRoaXMuYnVmZmVyMzIsIDAsIHRydWUpO1xuICAgICAgICAgICAgc3dhcDMySWZCRSh0aGlzLmJ1ZmZlcjMyKTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzRG9uZSA9IDA7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbGFncyB8PSAoIXRoaXMuY2h1bmtQb3MgPyBCM19GbGFncy5DSFVOS19TVEFSVCA6IDApIHwgQjNfRmxhZ3MuQ0hVTktfRU5EO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5iMkNvbXByZXNzT3V0KCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXJPdXQgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmIyQ29tcHJlc3NPdXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBhZnRlciBkaWdlc3QgY2FsbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIGFudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGZhbHNlO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxufVxuLyoqXG4gKiBCTEFLRTMgaGFzaCBmdW5jdGlvbi4gQ2FuIGJlIHVzZWQgYXMgTUFDIGFuZCBLREYuXG4gKiBAcGFyYW0gbXNnIC0gbWVzc2FnZSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICogQHBhcmFtIG9wdHMgLSBgZGtMZW5gIGZvciBvdXRwdXQgbGVuZ3RoLCBga2V5YCBmb3IgTUFDIG1vZGUsIGBjb250ZXh0YCBmb3IgS0RGIG1vZGVcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICogY29uc3QgaGFzaCA9IGJsYWtlMyhkYXRhKTtcbiAqIGNvbnN0IG1hYyA9IGJsYWtlMyhkYXRhLCB7IGtleTogbmV3IFVpbnQ4QXJyYXkoMzIpIH0pO1xuICogY29uc3Qga2RmID0gYmxha2UzKGRhdGEsIHsgY29udGV4dDogJ2FwcGxpY2F0aW9uIG5hbWUnIH0pO1xuICovXG5leHBvcnQgY29uc3QgYmxha2UzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVhPRmVyKChvcHRzKSA9PiBuZXcgQkxBS0UzKG9wdHMpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsYWtlMy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/blake3.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!***********************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */\n// @ts-ignore\n\nconst crypto = node_crypto__WEBPACK_IMPORTED_MODULE_0__ && typeof node_crypto__WEBPACK_IMPORTED_MODULE_0__ === 'object' && \"webcrypto\" in node_crypto__WEBPACK_IMPORTED_MODULE_0__\n    ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto\n    : node_crypto__WEBPACK_IMPORTED_MODULE_0__ && typeof node_crypto__WEBPACK_IMPORTED_MODULE_0__ === 'object' && \"randomBytes\" in node_crypto__WEBPACK_IMPORTED_MODULE_0__\n        ? node_crypto__WEBPACK_IMPORTED_MODULE_0__\n        : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDM0IsZUFBZSx3Q0FBRSxXQUFXLHdDQUFFLGlCQUFpQix1REFBaUI7QUFDdkUsTUFBTSxrREFBWTtBQUNsQixNQUFNLHdDQUFFLFdBQVcsd0NBQUUsaUJBQWlCLHlEQUFtQjtBQUN6RCxVQUFVLHdDQUFFO0FBQ1o7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanM/NDFiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIHdlYmNyeXB0byBhbGlhcy5cbiAqIFdlIHByZWZlciBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gbm9kZS5qcyAxNisuXG4gKiBGYWxscyBiYWNrIHRvIE5vZGUuanMgYnVpbHQtaW4gY3J5cHRvIGZvciBOb2RlLmpzIDw9djE0LlxuICogU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuICogQG1vZHVsZVxuICovXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgKiBhcyBuYyBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgY29uc3QgY3J5cHRvID0gbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAnd2ViY3J5cHRvJyBpbiBuY1xuICAgID8gbmMud2ViY3J5cHRvXG4gICAgOiBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICdyYW5kb21CeXRlcycgaW4gbmNcbiAgICAgICAgPyBuY1xuICAgICAgICA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0b05vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/hmac.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/hmac.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\n\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(pad);\n    }\n    update(buf) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzBFO0FBQ25FLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2YsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcz9mOTJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYWhhc2gsIGNsZWFuLCBIYXNoLCB0b0J5dGVzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFoYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIGNsZWFuKHBhZCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbiAqIGltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG4gKiBjb25zdCBtYWMxID0gaG1hYyhzaGEyNTYsICdrZXknLCAnbWVzc2FnZScpO1xuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/legacy.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/legacy.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MD5: () => (/* binding */ MD5),\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   SHA1: () => (/* binding */ SHA1),\n/* harmony export */   md5: () => (/* binding */ md5),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha1: () => (/* binding */ sha1)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\n\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nclass SHA1 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nconst sha1 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nclass MD5 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nconst md5 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nconst ripemd160 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9sZWdhY3kuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwwQ0FBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQyx3QkFBd0IsK0NBQUk7QUFDNUI7QUFDQSxjQUFjLGdCQUFnQjtBQUM5Qix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esb0JBQW9CLDJDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSTtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLHVEQUFZO0FBQ2hEO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0JBQWtCLDBDQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsdURBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHdCQUF3QiwwQ0FBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0EsMERBQTBEO0FBQzFELHNEQUFzRDtBQUN0RCxrRUFBa0U7QUFDbEUsNEJBQTRCLFFBQVE7QUFDcEMsNEJBQTRCLCtDQUFJO0FBQ2hDLHVDQUF1QywrQ0FBSSxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDLDRCQUE0QiwrQ0FBSTtBQUNoQyx1Q0FBdUMsK0NBQUksZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyx1REFBWTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2xlZ2FjeS5qcz9mNTUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuXG5TSEExIChSRkMgMzE3NCksIE1ENSAoUkZDIDEzMjEpIGFuZCBSSVBFTUQxNjAgKFJGQyAyMjg2KSBsZWdhY3ksIHdlYWsgaGFzaCBmdW5jdGlvbnMuXG5Eb24ndCB1c2UgdGhlbSBpbiBhIG5ldyBwcm90b2NvbC4gV2hhdCBcIndlYWtcIiBtZWFuczpcblxuLSBDb2xsaXNpb25zIGNhbiBiZSBtYWRlIHdpdGggMl4xOCBlZmZvcnQgaW4gTUQ1LCAyXjYwIGluIFNIQTEsIDJeODAgaW4gUklQRU1EMTYwLlxuLSBObyBwcmFjdGljYWwgcHJlLWltYWdlIGF0dGFja3MgKG9ubHkgdGhlb3JldGljYWwsIDJeMTIzLjQpXG4tIEhNQUMgc2VlbXMga2luZGEgb2s6IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjE1MVxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBDaGksIEhhc2hNRCwgTWFqIH0gZnJvbSBcIi4vX21kLmpzXCI7XG5pbXBvcnQgeyBjbGVhbiwgY3JlYXRlSGFzaGVyLCByb3RsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKiBJbml0aWFsIFNIQTEgc3RhdGUgKi9cbmNvbnN0IFNIQTFfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCxcbl0pO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgU0hBMV9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG4vKiogU0hBMSBsZWdhY3kgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBTSEExIGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuQSA9IFNIQTFfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEExX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMV9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTFfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEExX0lWWzRdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRV07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBELCBFKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTFfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKVxuICAgICAgICAgICAgU0hBMV9XW2ldID0gcm90bChTSEExX1dbaSAtIDNdIF4gU0hBMV9XW2kgLSA4XSBeIFNIQTFfV1tpIC0gMTRdIF4gU0hBMV9XW2kgLSAxNl0sIDEpO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBGLCBLO1xuICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgSyA9IDB4NWE4Mjc5OTk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIEsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDYwKSB7XG4gICAgICAgICAgICAgICAgRiA9IE1haihCLCBDLCBEKTtcbiAgICAgICAgICAgICAgICBLID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEYgPSBCIF4gQyBeIEQ7XG4gICAgICAgICAgICAgICAgSyA9IDB4Y2E2MmMxZDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBUID0gKHJvdGwoQSwgNSkgKyBGICsgRSArIEsgKyBTSEExX1dbaV0pIHwgMDtcbiAgICAgICAgICAgIEUgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gcm90bChCLCAzMCk7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSBUO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKFNIQTFfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuLyoqIFNIQTEgKFJGQyAzMTc0KSBsZWdhY3kgaGFzaCBmdW5jdGlvbi4gSXQgd2FzIGNyeXB0b2dyYXBoaWNhbGx5IGJyb2tlbi4gKi9cbmV4cG9ydCBjb25zdCBzaGExID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMSgpKTtcbi8qKiBQZXItcm91bmQgY29uc3RhbnRzICovXG5jb25zdCBwMzIgPSAvKiBAX19QVVJFX18gKi8gTWF0aC5wb3coMiwgMzIpO1xuY29uc3QgSyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2NCB9LCAoXywgaSkgPT4gTWF0aC5mbG9vcihwMzIgKiBNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpKSk7XG4vKiogbWQ1IGluaXRpYWwgc3RhdGU6IHNhbWUgYXMgc2hhMSwgYnV0IDQgdTMyIGluc3RlYWQgb2YgNS4gKi9cbmNvbnN0IE1ENV9JViA9IC8qIEBfX1BVUkVfXyAqLyBTSEExX0lWLnNsaWNlKDAsIDQpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgTUQ1X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbi8qKiBNRDUgbGVnYWN5IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgTUQ1IGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDE2LCA4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5BID0gTUQ1X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gTUQ1X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gTUQ1X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gTUQ1X0lWWzNdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRF07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBEKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgTUQ1X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBEIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBGLCBnLCBzO1xuICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgZyA9IGk7XG4gICAgICAgICAgICAgICAgcyA9IFs3LCAxMiwgMTcsIDIyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoRCwgQiwgQyk7XG4gICAgICAgICAgICAgICAgZyA9ICg1ICogaSArIDEpICUgMTY7XG4gICAgICAgICAgICAgICAgcyA9IFs1LCA5LCAxNCwgMjBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBnID0gKDMgKiBpICsgNSkgJSAxNjtcbiAgICAgICAgICAgICAgICBzID0gWzQsIDExLCAxNiwgMjNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRiA9IEMgXiAoQiB8IH5EKTtcbiAgICAgICAgICAgICAgICBnID0gKDcgKiBpKSAlIDE2O1xuICAgICAgICAgICAgICAgIHMgPSBbNiwgMTAsIDE1LCAyMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBGID0gRiArIEEgKyBLW2ldICsgTUQ1X1dbZ107XG4gICAgICAgICAgICBBID0gRDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQiArIHJvdGwoRiwgc1tpICUgNF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBEKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oTUQ1X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwKTtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbi8qKlxuICogTUQ1IChSRkMgMTMyMSkgbGVnYWN5IGhhc2ggZnVuY3Rpb24uIEl0IHdhcyBjcnlwdG9ncmFwaGljYWxseSBicm9rZW4uXG4gKiBNRDUgYXJjaGl0ZWN0dXJlIGlzIHNpbWlsYXIgdG8gU0hBMSwgd2l0aCBzb21lIGRpZmZlcmVuY2VzOlxuICogLSBSZWR1Y2VkIG91dHB1dCBsZW5ndGg6IDE2IGJ5dGVzICgxMjggYml0KSBpbnN0ZWFkIG9mIDIwXG4gKiAtIDY0IHJvdW5kcywgaW5zdGVhZCBvZiA4MFxuICogLSBMaXR0bGUtZW5kaWFuOiBjb3VsZCBiZSBmYXN0ZXIsIGJ1dCB3aWxsIHJlcXVpcmUgbW9yZSBjb2RlXG4gKiAtIE5vbi1saW5lYXIgaW5kZXggc2VsZWN0aW9uOiBodWdlIHNwZWVkLXVwIGZvciB1bnJvbGxcbiAqIC0gUGVyIHJvdW5kIGNvbnN0YW50czogbW9yZSBtZW1vcnkgYWNjZXNzZXMsIGFkZGl0aW9uYWwgc3BlZWQtdXAgZm9yIHVucm9sbFxuICovXG5leHBvcnQgY29uc3QgbWQ1ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgTUQ1KCkpO1xuLy8gUklQRU1ELTE2MFxuY29uc3QgUmhvMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbl0pO1xuY29uc3QgSWQxNjAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IFVpbnQ4QXJyYXkuZnJvbShuZXcgQXJyYXkoMTYpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBpKSkpKCk7XG5jb25zdCBQaTE2MCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSWQxNjAubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KSkoKTtcbmNvbnN0IGlkeExSID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgY29uc3QgTCA9IFtJZDE2MF07XG4gICAgY29uc3QgUiA9IFtQaTE2MF07XG4gICAgY29uc3QgcmVzID0gW0wsIFJdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBmb3IgKGxldCBqIG9mIHJlcylcbiAgICAgICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvMTYwW2tdKSk7XG4gICAgcmV0dXJuIHJlcztcbn0pKCk7XG5jb25zdCBpZHhMID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpZHhMUlswXSkoKTtcbmNvbnN0IGlkeFIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlkeExSWzFdKSgpO1xuLy8gY29uc3QgW2lkeEwsIGlkeFJdID0gaWR4TFI7XG5jb25zdCBzaGlmdHMxNjAgPSAvKiBAX19QVVJFX18gKi8gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IFVpbnQ4QXJyYXkuZnJvbShpKSk7XG5jb25zdCBzaGlmdHNMMTYwID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0czE2MFtpXVtqXSkpO1xuY29uc3Qgc2hpZnRzUjE2MCA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHMxNjBbaV1bal0pKTtcbmNvbnN0IEtsMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGUsXG5dKTtcbmNvbnN0IEtyMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDAsXG5dKTtcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxuZnVuY3Rpb24gcmlwZW1kX2YoZ3JvdXAsIHgsIHksIHopIHtcbiAgICBpZiAoZ3JvdXAgPT09IDApXG4gICAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gICAgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGlmIChncm91cCA9PT0gMilcbiAgICAgICAgcmV0dXJuICh4IHwgfnkpIF4gejtcbiAgICBpZiAoZ3JvdXAgPT09IDMpXG4gICAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiB+eik7XG4gICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IEJVRl8xNjAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmV4cG9ydCBjbGFzcyBSSVBFTUQxNjAgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5IHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IGgwLCBoMSwgaDIsIGgzLCBoNCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xuICAgIH1cbiAgICBzZXQoaDAsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSBoMiB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBCVUZfMTYwW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBhbCA9IHRoaXMuaDAgfCAwLCBhciA9IGFsLCBibCA9IHRoaXMuaDEgfCAwLCBiciA9IGJsLCBjbCA9IHRoaXMuaDIgfCAwLCBjciA9IGNsLCBkbCA9IHRoaXMuaDMgfCAwLCBkciA9IGRsLCBlbCA9IHRoaXMuaDQgfCAwLCBlciA9IGVsO1xuICAgICAgICAvLyBJbnN0ZWFkIG9mIGl0ZXJhdGluZyAwIHRvIDgwLCB3ZSBzcGxpdCBpdCBpbnRvIDUgZ3JvdXBzXG4gICAgICAgIC8vIEFuZCB1c2UgdGhlIGdyb3VwcyBpbiBjb25zdGFudHMsIGZ1bmN0aW9ucywgZXRjLiBNdWNoIHNpbXBsZXJcbiAgICAgICAgZm9yIChsZXQgZ3JvdXAgPSAwOyBncm91cCA8IDU7IGdyb3VwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJHcm91cCA9IDQgLSBncm91cDtcbiAgICAgICAgICAgIGNvbnN0IGhibCA9IEtsMTYwW2dyb3VwXSwgaGJyID0gS3IxNjBbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHJsID0gaWR4TFtncm91cF0sIHJyID0gaWR4Ultncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc2wgPSBzaGlmdHNMMTYwW2dyb3VwXSwgc3IgPSBzaGlmdHNSMTYwW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bCA9IChyb3RsKGFsICsgcmlwZW1kX2YoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGXzE2MFtybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSByb3RsKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyByaXBlbWRfZihyR3JvdXAsIGJyLCBjciwgZHIpICsgQlVGXzE2MFtycltpXV0gKyBoYnIsIHNyW2ldKSArIGVyKSB8IDA7XG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihCVUZfMTYwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbi8qKlxuICogUklQRU1ELTE2MCAtIGEgbGVnYWN5IGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cbiAqICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuICogKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgUklQRU1EMTYwKCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVnYWN5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/legacy.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/pbkdf2.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hmac.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\n\n// prettier-ignore\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(c);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(dkLen);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(asyncTick);\n    if (c < 1)\n        throw new Error('iterations (c) should be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.kdfInputToBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.kdfInputToBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_1__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(u);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9wYmtkZjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lDO0FBQ2pDO0FBQzRHO0FBQzVHO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1QsaUJBQWlCLG9EQUFTLEdBQUcsMEJBQTBCO0FBQ3ZELFlBQVksc0JBQXNCO0FBQ2xDLElBQUksa0RBQU87QUFDWCxJQUFJLGtEQUFPO0FBQ1gsSUFBSSxrREFBTztBQUNYO0FBQ0E7QUFDQSxxQkFBcUIsMERBQWU7QUFDcEMsaUJBQWlCLDBEQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBSTtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLG9EQUFvRCwrQkFBK0I7QUFDbkY7QUFDTztBQUNQLFlBQVksNkJBQTZCO0FBQ3pDLGNBQWM7QUFDZDtBQUNBLGlCQUFpQixxREFBVTtBQUMzQjtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1QkFBdUI7QUFDMUU7QUFDTztBQUNQLFlBQVksd0NBQXdDO0FBQ3BELGNBQWM7QUFDZDtBQUNBLGlCQUFpQixxREFBVTtBQUMzQjtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3Bia2RmMi5qcz9iY2NlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUEJLREYgKFJGQyAyODk4KS4gQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEga2V5IGZyb20gcGFzc3dvcmQgYW5kIHNhbHQuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiLi9obWFjLmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGFoYXNoLCBhbnVtYmVyLCBhc3luY0xvb3AsIGNoZWNrT3B0cywgY2xlYW4sIGNyZWF0ZVZpZXcsIEhhc2gsIGtkZklucHV0VG9CeXRlcyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBDb21tb24gcHJvbG9ndWUgYW5kIGVwaWxvZ3VlIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xuICAgIGFoYXNoKGhhc2gpO1xuICAgIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljayB9ID0gb3B0cztcbiAgICBhbnVtYmVyKGMpO1xuICAgIGFudW1iZXIoZGtMZW4pO1xuICAgIGFudW1iZXIoYXN5bmNUaWNrKTtcbiAgICBpZiAoYyA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0aW9ucyAoYykgc2hvdWxkIGJlID49IDEnKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IGtkZklucHV0VG9CeXRlcyhfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHNhbHQgPSBrZGZJbnB1dFRvQnl0ZXMoX3NhbHQpO1xuICAgIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICBjb25zdCBQUkYgPSBobWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xuICAgIHJldHVybiB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfTtcbn1cbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XG4gICAgUFJGLmRlc3Ryb3koKTtcbiAgICBQUkZTYWx0LmRlc3Ryb3koKTtcbiAgICBpZiAocHJmVylcbiAgICAgICAgcHJmVy5kZXN0cm95KCk7XG4gICAgY2xlYW4odSk7XG4gICAgcmV0dXJuIERLO1xufVxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3N3b3JkIGZyb20gd2hpY2ggYSBkZXJpdmVkIGtleSBpcyBnZW5lcmF0ZWRcbiAqIEBwYXJhbSBzYWx0IC0gY3J5cHRvZ3JhcGhpYyBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGtleSA9IHBia2RmMihzaGEyNTYsICdwYXNzd29yZCcsICdzYWx0JywgeyBka0xlbjogMzIsIGM6IE1hdGgucG93KDIsIDE4KSB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8qKlxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLiBBc3luYyB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IHBia2RmMkFzeW5jKHNoYTI1NiwgJ3Bhc3N3b3JkJywgJ3NhbHQnLCB7IGRrTGVuOiAzMiwgYzogNTAwXzAwMCB9KTtcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoYyAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/pbkdf2.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js":
/*!**********************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legacy.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/legacy.js\");\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\n\n/** @deprecated Use import from `noble/hashes/legacy` module */\nconst RIPEMD160 = _legacy_js__WEBPACK_IMPORTED_MODULE_0__.RIPEMD160;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nconst ripemd160 = _legacy_js__WEBPACK_IMPORTED_MODULE_0__.ripemd160;\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0U7QUFDL0U7QUFDTyxrQkFBa0IsaURBQVU7QUFDbkM7QUFDTyxrQkFBa0IsaURBQVU7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanM/ZjhhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJJUEVNRC0xNjAgbGVnYWN5IGhhc2ggZnVuY3Rpb24uXG4gKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4gKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuaW1wb3J0IHsgUklQRU1EMTYwIGFzIFJJUEVNRDE2MG4sIHJpcGVtZDE2MCBhcyByaXBlbWQxNjBuIH0gZnJvbSBcIi4vbGVnYWN5LmpzXCI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvbGVnYWN5YCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBSSVBFTUQxNjAgPSBSSVBFTUQxNjBuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL2xlZ2FjeWAgbW9kdWxlICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gcmlwZW1kMTYwbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/scrypt.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/scrypt.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: () => (/* binding */ scrypt),\n/* harmony export */   scryptAsync: () => (/* binding */ scryptAsync)\n/* harmony export */ });\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pbkdf2.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sha2.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * RFC 7914 Scrypt KDF. Can be used to create a key from password and salt.\n * @module\n */\n\n\n// prettier-ignore\n\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    // Based on https://cr.yp.to/salsa20.html\n    // Xor blocks\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    // Save state to temporary variables (salsa)\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop (salsa)\n    for (let i = 0; i < 8; i += 2) {\n        x04 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x00 + x12 | 0, 7);\n        x08 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 + x00 | 0, 9);\n        x12 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x08 + x04 | 0, 13);\n        x00 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 + x08 | 0, 18);\n        x09 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 + x01 | 0, 7);\n        x13 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x09 + x05 | 0, 9);\n        x01 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 + x09 | 0, 13);\n        x05 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x01 + x13 | 0, 18);\n        x14 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x10 + x06 | 0, 7);\n        x02 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 + x10 | 0, 9);\n        x06 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x02 + x14 | 0, 13);\n        x10 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 + x02 | 0, 18);\n        x03 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 + x11 | 0, 7);\n        x07 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x03 + x15 | 0, 9);\n        x11 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 + x03 | 0, 13);\n        x15 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x11 + x07 | 0, 18);\n        x01 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x00 + x03 | 0, 7);\n        x02 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x01 + x00 | 0, 9);\n        x03 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x02 + x01 | 0, 13);\n        x00 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x03 + x02 | 0, 18);\n        x06 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 + x04 | 0, 7);\n        x07 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 + x05 | 0, 9);\n        x04 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 + x06 | 0, 13);\n        x05 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 + x07 | 0, 18);\n        x11 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x10 + x09 | 0, 7);\n        x08 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x11 + x10 | 0, 9);\n        x09 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x08 + x11 | 0, 13);\n        x10 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x09 + x08 | 0, 18);\n        x12 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 + x14 | 0, 7);\n        x13 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 + x15 | 0, 9);\n        x14 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 + x12 | 0, 13);\n        x15 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 + x13 | 0, 18);\n    }\n    // Write output (salsa)\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for (let i = 0; i < 16; i++)\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n        if (i > 0)\n            tail += 16; // First iteration overwrites tmp value in tail\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n    }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n    // Maxmem - 1GB+1KB by default\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10,\n        maxmem: 1024 ** 3 + 1024,\n    }, _opts);\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(N);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(r);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(p);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(dkLen);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(asyncTick);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(maxmem);\n    if (onProgress !== undefined && typeof onProgress !== 'function')\n        throw new Error('progressCb should be function');\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    // Max N is 2^32 (Integrify is 32-bit). Real limit is 2^22: JS engines Uint8Array limit is 4GB in 2024.\n    // Spec check `N >= 2^(blockSize / 8)` is not done for compat with popular libs,\n    // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:\n    // https://www.rfc-editor.org/errata_search.php?rfc=7914\n    const pow32 = Math.pow(2, 32);\n    if (N <= 1 || (N & (N - 1)) !== 0 || N > pow32) {\n        throw new Error('Scrypt: N must be larger than 1, a power of 2, and less than 2^32');\n    }\n    if (p < 0 || p > ((pow32 - 1) * 32) / blockSize) {\n        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\n    }\n    if (dkLen < 0 || dkLen > (pow32 - 1) * 32) {\n        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\n    }\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem) {\n        throw new Error('Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of ' + maxmem);\n    }\n    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n    // Since it has only one iteration there is no reason to use async variant\n    const B = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__.pbkdf2)(_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256, password, salt, { c: 1, dkLen: blockSize * p });\n    const B32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(B);\n    // Re-used between parallel iterations. Array(iterations) of B\n    const V = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(new Uint8Array(blockSize * N));\n    const tmp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(new Uint8Array(blockSize));\n    let blockMixCb = () => { };\n    if (onProgress) {\n        const totalBlockMix = 2 * N * p;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n        let blockMixCnt = 0;\n        blockMixCb = () => {\n            blockMixCnt++;\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n                onProgress(blockMixCnt / totalBlockMix);\n        };\n    }\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n    const res = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__.pbkdf2)(_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256, password, B, { c: 1, dkLen });\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(B, V, tmp);\n    return res;\n}\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n * @example\n * scrypt('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });\n */\nfunction scrypt(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.swap32IfBE)(B32);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        for (let i = 0, pos = 0; i < N - 1; i++) {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        for (let i = 0; i < N; i++) {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        }\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.swap32IfBE)(B32);\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n/**\n * Scrypt KDF from RFC 7914. Async version.\n * @example\n * await scryptAsync('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });\n */\nasync function scryptAsync(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.swap32IfBE)(B32);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        let pos = 0;\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(N - 1, asyncTick, () => {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        });\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(N, asyncTick, () => {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        });\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.swap32IfBE)(B32);\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n//# sourceMappingURL=scrypt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zY3J5cHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNGO0FBQ25DO0FBQ3lGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLDBEQUEwRDtBQUMxRCxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHdCQUF3QjtBQUN4Qiw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnREFBZ0Q7QUFDNUQsSUFBSSxrREFBTztBQUNYLElBQUksa0RBQU87QUFDWCxJQUFJLGtEQUFPO0FBQ1gsSUFBSSxrREFBTztBQUNYLElBQUksa0RBQU87QUFDWCxJQUFJLGtEQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBTSxDQUFDLDRDQUFNLG9CQUFvQiw0QkFBNEI7QUFDM0UsZ0JBQWdCLDhDQUFHO0FBQ25CO0FBQ0EsY0FBYyw4Q0FBRztBQUNqQixnQkFBZ0IsOENBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixrREFBTSxDQUFDLDRDQUFNLGlCQUFpQixhQUFhO0FBQzNELElBQUksZ0RBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7QUFDTztBQUNQLFlBQVksMERBQTBEO0FBQ3RFLElBQUkscURBQVU7QUFDZCxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsZ0NBQWdDO0FBQ2hDLGlDQUFpQyxXQUFXO0FBQzVDLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxzREFBc0Q7QUFDdEQsNEJBQTRCLGlCQUFpQjtBQUM3QywrREFBK0Q7QUFDL0QsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlDQUFpQztBQUM1RTtBQUNPO0FBQ1AsWUFBWSxxRUFBcUU7QUFDakYsSUFBSSxxREFBVTtBQUNkLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxnQ0FBZ0M7QUFDaEM7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCLDBEQUEwRDtBQUMxRDtBQUNBLFNBQVM7QUFDVCx3REFBd0Q7QUFDeEQ7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCO0FBQ0Esc0RBQXNEO0FBQ3RELDRCQUE0QixpQkFBaUI7QUFDN0MsK0RBQStEO0FBQy9ELDBDQUEwQztBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBLElBQUkscURBQVU7QUFDZDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zY3J5cHQuanM/ZTFkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJGQyA3OTE0IFNjcnlwdCBLREYuIENhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGtleSBmcm9tIHBhc3N3b3JkIGFuZCBzYWx0LlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBwYmtkZjIgfSBmcm9tIFwiLi9wYmtkZjIuanNcIjtcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCIuL3NoYTIuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYW51bWJlciwgYXN5bmNMb29wLCBjaGVja09wdHMsIGNsZWFuLCByb3RsLCBzd2FwMzJJZkJFLCB1MzIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gVGhlIG1haW4gU2NyeXB0IGxvb3A6IHVzZXMgU2Fsc2EgZXh0ZW5zaXZlbHkuXG4vLyBTaXggdmVyc2lvbnMgb2YgdGhlIGZ1bmN0aW9uIHdlcmUgdHJpZWQsIHRoaXMgaXMgdGhlIGZhc3Rlc3Qgb25lLlxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBYb3JBbmRTYWxzYShwcmV2LCBwaSwgaW5wdXQsIGlpLCBvdXQsIG9pKSB7XG4gICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9jci55cC50by9zYWxzYTIwLmh0bWxcbiAgICAvLyBYb3IgYmxvY2tzXG4gICAgbGV0IHkwMCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAxID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDIgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwMyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA0ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDUgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwNiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA3ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDggPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwOSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTEwID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTEgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTEzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICAvLyBTYXZlIHN0YXRlIHRvIHRlbXBvcmFyeSB2YXJpYWJsZXMgKHNhbHNhKVxuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgLy8gTWFpbiBsb29wIChzYWxzYSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMikge1xuICAgICAgICB4MDQgXj0gcm90bCh4MDAgKyB4MTIgfCAwLCA3KTtcbiAgICAgICAgeDA4IF49IHJvdGwoeDA0ICsgeDAwIHwgMCwgOSk7XG4gICAgICAgIHgxMiBePSByb3RsKHgwOCArIHgwNCB8IDAsIDEzKTtcbiAgICAgICAgeDAwIF49IHJvdGwoeDEyICsgeDA4IHwgMCwgMTgpO1xuICAgICAgICB4MDkgXj0gcm90bCh4MDUgKyB4MDEgfCAwLCA3KTtcbiAgICAgICAgeDEzIF49IHJvdGwoeDA5ICsgeDA1IHwgMCwgOSk7XG4gICAgICAgIHgwMSBePSByb3RsKHgxMyArIHgwOSB8IDAsIDEzKTtcbiAgICAgICAgeDA1IF49IHJvdGwoeDAxICsgeDEzIHwgMCwgMTgpO1xuICAgICAgICB4MTQgXj0gcm90bCh4MTAgKyB4MDYgfCAwLCA3KTtcbiAgICAgICAgeDAyIF49IHJvdGwoeDE0ICsgeDEwIHwgMCwgOSk7XG4gICAgICAgIHgwNiBePSByb3RsKHgwMiArIHgxNCB8IDAsIDEzKTtcbiAgICAgICAgeDEwIF49IHJvdGwoeDA2ICsgeDAyIHwgMCwgMTgpO1xuICAgICAgICB4MDMgXj0gcm90bCh4MTUgKyB4MTEgfCAwLCA3KTtcbiAgICAgICAgeDA3IF49IHJvdGwoeDAzICsgeDE1IHwgMCwgOSk7XG4gICAgICAgIHgxMSBePSByb3RsKHgwNyArIHgwMyB8IDAsIDEzKTtcbiAgICAgICAgeDE1IF49IHJvdGwoeDExICsgeDA3IHwgMCwgMTgpO1xuICAgICAgICB4MDEgXj0gcm90bCh4MDAgKyB4MDMgfCAwLCA3KTtcbiAgICAgICAgeDAyIF49IHJvdGwoeDAxICsgeDAwIHwgMCwgOSk7XG4gICAgICAgIHgwMyBePSByb3RsKHgwMiArIHgwMSB8IDAsIDEzKTtcbiAgICAgICAgeDAwIF49IHJvdGwoeDAzICsgeDAyIHwgMCwgMTgpO1xuICAgICAgICB4MDYgXj0gcm90bCh4MDUgKyB4MDQgfCAwLCA3KTtcbiAgICAgICAgeDA3IF49IHJvdGwoeDA2ICsgeDA1IHwgMCwgOSk7XG4gICAgICAgIHgwNCBePSByb3RsKHgwNyArIHgwNiB8IDAsIDEzKTtcbiAgICAgICAgeDA1IF49IHJvdGwoeDA0ICsgeDA3IHwgMCwgMTgpO1xuICAgICAgICB4MTEgXj0gcm90bCh4MTAgKyB4MDkgfCAwLCA3KTtcbiAgICAgICAgeDA4IF49IHJvdGwoeDExICsgeDEwIHwgMCwgOSk7XG4gICAgICAgIHgwOSBePSByb3RsKHgwOCArIHgxMSB8IDAsIDEzKTtcbiAgICAgICAgeDEwIF49IHJvdGwoeDA5ICsgeDA4IHwgMCwgMTgpO1xuICAgICAgICB4MTIgXj0gcm90bCh4MTUgKyB4MTQgfCAwLCA3KTtcbiAgICAgICAgeDEzIF49IHJvdGwoeDEyICsgeDE1IHwgMCwgOSk7XG4gICAgICAgIHgxNCBePSByb3RsKHgxMyArIHgxMiB8IDAsIDEzKTtcbiAgICAgICAgeDE1IF49IHJvdGwoeDE0ICsgeDEzIHwgMCwgMTgpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXQgKHNhbHNhKVxuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbmZ1bmN0aW9uIEJsb2NrTWl4KGlucHV0LCBpaSwgb3V0LCBvaSwgcikge1xuICAgIC8vIFRoZSBibG9jayBCIGlzIHIgMTI4LWJ5dGUgY2h1bmtzICh3aGljaCBpcyBlcXVpdmFsZW50IG9mIDJyIDY0LWJ5dGUgY2h1bmtzKVxuICAgIGxldCBoZWFkID0gb2kgKyAwO1xuICAgIGxldCB0YWlsID0gb2kgKyAxNiAqIHI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgICBvdXRbdGFpbCArIGldID0gaW5wdXRbaWkgKyAoMiAqIHIgLSAxKSAqIDE2ICsgaV07IC8vIFgg4oaQIEJbMnLiiJIxXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrLCBoZWFkICs9IDE2LCBpaSArPSAxNikge1xuICAgICAgICAvLyBXZSB3cml0ZSBvZGQgJiBldmVuIFlpIGF0IHNhbWUgdGltZS4gRXZlbjogMGJYWFhYWDAgT2RkOiAgMGJYWFhYWDFcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCB0YWlsLCBpbnB1dCwgaWksIG91dCwgaGVhZCk7IC8vIGhlYWRbaV0gPSBTYWxzYShibG9ja0luWzIqaV0gXiB0YWlsW2ktMV0pXG4gICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgIHRhaWwgKz0gMTY7IC8vIEZpcnN0IGl0ZXJhdGlvbiBvdmVyd3JpdGVzIHRtcCB2YWx1ZSBpbiB0YWlsXG4gICAgICAgIFhvckFuZFNhbHNhKG91dCwgaGVhZCwgaW5wdXQsIChpaSArPSAxNiksIG91dCwgdGFpbCk7IC8vIHRhaWxbaV0gPSBTYWxzYShibG9ja0luWzIqaSsxXSBeIGhlYWRbaV0pXG4gICAgfVxufVxuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIF9vcHRzKSB7XG4gICAgLy8gTWF4bWVtIC0gMUdCKzFLQiBieSBkZWZhdWx0XG4gICAgY29uc3Qgb3B0cyA9IGNoZWNrT3B0cyh7XG4gICAgICAgIGRrTGVuOiAzMixcbiAgICAgICAgYXN5bmNUaWNrOiAxMCxcbiAgICAgICAgbWF4bWVtOiAxMDI0ICoqIDMgKyAxMDI0LFxuICAgIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBhc3luY1RpY2ssIG1heG1lbSwgb25Qcm9ncmVzcyB9ID0gb3B0cztcbiAgICBhbnVtYmVyKE4pO1xuICAgIGFudW1iZXIocik7XG4gICAgYW51bWJlcihwKTtcbiAgICBhbnVtYmVyKGRrTGVuKTtcbiAgICBhbnVtYmVyKGFzeW5jVGljayk7XG4gICAgYW51bWJlcihtYXhtZW0pO1xuICAgIGlmIChvblByb2dyZXNzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9uUHJvZ3Jlc3MgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvZ3Jlc3NDYiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICBjb25zdCBibG9ja1NpemUgPSAxMjggKiByO1xuICAgIGNvbnN0IGJsb2NrU2l6ZTMyID0gYmxvY2tTaXplIC8gNDtcbiAgICAvLyBNYXggTiBpcyAyXjMyIChJbnRlZ3JpZnkgaXMgMzItYml0KS4gUmVhbCBsaW1pdCBpcyAyXjIyOiBKUyBlbmdpbmVzIFVpbnQ4QXJyYXkgbGltaXQgaXMgNEdCIGluIDIwMjQuXG4gICAgLy8gU3BlYyBjaGVjayBgTiA+PSAyXihibG9ja1NpemUgLyA4KWAgaXMgbm90IGRvbmUgZm9yIGNvbXBhdCB3aXRoIHBvcHVsYXIgbGlicyxcbiAgICAvLyB3aGljaCB1c2VkIGluY29ycmVjdCByOiAxLCBwOiA4LiBBbHNvLCB0aGUgY2hlY2sgc2VlbXMgdG8gYmUgYSBzcGVjIGVycm9yOlxuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2VycmF0YV9zZWFyY2gucGhwP3JmYz03OTE0XG4gICAgY29uc3QgcG93MzIgPSBNYXRoLnBvdygyLCAzMik7XG4gICAgaWYgKE4gPD0gMSB8fCAoTiAmIChOIC0gMSkpICE9PSAwIHx8IE4gPiBwb3czMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogTiBtdXN0IGJlIGxhcmdlciB0aGFuIDEsIGEgcG93ZXIgb2YgMiwgYW5kIGxlc3MgdGhhbiAyXjMyJyk7XG4gICAgfVxuICAgIGlmIChwIDwgMCB8fCBwID4gKChwb3czMiAtIDEpICogMzIpIC8gYmxvY2tTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NyeXB0OiBwIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byAoKDJeMzIgLSAxKSAqIDMyKSAvICgxMjggKiByKScpO1xuICAgIH1cbiAgICBpZiAoZGtMZW4gPCAwIHx8IGRrTGVuID4gKHBvdzMyIC0gMSkgKiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogZGtMZW4gc2hvdWxkIGJlIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICgyXjMyIC0gMSkgKiAzMicpO1xuICAgIH1cbiAgICBjb25zdCBtZW1Vc2VkID0gYmxvY2tTaXplICogKE4gKyBwKTtcbiAgICBpZiAobWVtVXNlZCA+IG1heG1lbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcnlwdDogbWVtdXNlZCBpcyBiaWdnZXIgdGhhbiBtYXhNZW0uIEV4cGVjdGVkIDEyOCAqIHIgKiAoTiArIHApID4gbWF4bWVtIG9mICcgKyBtYXhtZW0pO1xuICAgIH1cbiAgICAvLyBbQjAuLi5CcOKIkjFdIOKGkCBQQktERjJITUFDLVNIQTI1NihQYXNzcGhyYXNlLCBTYWx0LCAxLCBibG9ja1NpemUqUGFyYWxsZWxpemF0aW9uRmFjdG9yKVxuICAgIC8vIFNpbmNlIGl0IGhhcyBvbmx5IG9uZSBpdGVyYXRpb24gdGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSBhc3luYyB2YXJpYW50XG4gICAgY29uc3QgQiA9IHBia2RmMihzaGEyNTYsIHBhc3N3b3JkLCBzYWx0LCB7IGM6IDEsIGRrTGVuOiBibG9ja1NpemUgKiBwIH0pO1xuICAgIGNvbnN0IEIzMiA9IHUzMihCKTtcbiAgICAvLyBSZS11c2VkIGJldHdlZW4gcGFyYWxsZWwgaXRlcmF0aW9ucy4gQXJyYXkoaXRlcmF0aW9ucykgb2YgQlxuICAgIGNvbnN0IFYgPSB1MzIobmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplICogTikpO1xuICAgIGNvbnN0IHRtcCA9IHUzMihuZXcgVWludDhBcnJheShibG9ja1NpemUpKTtcbiAgICBsZXQgYmxvY2tNaXhDYiA9ICgpID0+IHsgfTtcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICBjb25zdCB0b3RhbEJsb2NrTWl4ID0gMiAqIE4gKiBwO1xuICAgICAgICAvLyBJbnZva2UgY2FsbGJhY2sgaWYgcHJvZ3Jlc3MgY2hhbmdlcyBmcm9tIDEwLjAxIHRvIDEwLjAyXG4gICAgICAgIC8vIEFsbG93cyB0byBkcmF3IHNtb290aCBwcm9ncmVzcyBiYXIgb24gdXAgdG8gOEsgc2NyZWVuXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrUGVyID0gTWF0aC5tYXgoTWF0aC5mbG9vcih0b3RhbEJsb2NrTWl4IC8gMTAwMDApLCAxKTtcbiAgICAgICAgbGV0IGJsb2NrTWl4Q250ID0gMDtcbiAgICAgICAgYmxvY2tNaXhDYiA9ICgpID0+IHtcbiAgICAgICAgICAgIGJsb2NrTWl4Q250Kys7XG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcyAmJiAoIShibG9ja01peENudCAlIGNhbGxiYWNrUGVyKSB8fCBibG9ja01peENudCA9PT0gdG90YWxCbG9ja01peCkpXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhibG9ja01peENudCAvIHRvdGFsQmxvY2tNaXgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiLCBhc3luY1RpY2sgfTtcbn1cbmZ1bmN0aW9uIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCkge1xuICAgIGNvbnN0IHJlcyA9IHBia2RmMihzaGEyNTYsIHBhc3N3b3JkLCBCLCB7IGM6IDEsIGRrTGVuIH0pO1xuICAgIGNsZWFuKEIsIFYsIHRtcCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogU2NyeXB0IEtERiBmcm9tIFJGQyA3OTE0LlxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc1xuICogQHBhcmFtIHNhbHQgLSBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHBhcmFtZXRlcnNcbiAqIC0gYE5gIGlzIGNwdS9tZW0gd29yayBmYWN0b3IgKHBvd2VyIG9mIDIgZS5nLiAyKioxOClcbiAqIC0gYHJgIGlzIGJsb2NrIHNpemUgKDggaXMgY29tbW9uKSwgZmluZS10dW5lcyBzZXF1ZW50aWFsIG1lbW9yeSByZWFkIHNpemUgYW5kIHBlcmZvcm1hbmNlXG4gKiAtIGBwYCBpcyBwYXJhbGxlbGl6YXRpb24gZmFjdG9yICgxIGlzIGNvbW1vbilcbiAqIC0gYGRrTGVuYCBpcyBvdXRwdXQga2V5IGxlbmd0aCBpbiBieXRlcyBlLmcuIDMyLlxuICogLSBgYXN5bmNUaWNrYCAtIChkZWZhdWx0OiAxMCkgbWF4IHRpbWUgaW4gbXMgZm9yIHdoaWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBibG9jayBleGVjdXRpb25cbiAqIC0gYG1heG1lbWAgLSAoZGVmYXVsdDogYDEwMjQgKiogMyArIDEwMjRgIGFrYSAxR0IrMUtCKS4gQSBsaW1pdCB0aGF0IHRoZSBhcHAgY291bGQgdXNlIGZvciBzY3J5cHRcbiAqIC0gYG9uUHJvZ3Jlc3NgIC0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSBleGVjdXRlZCBmb3IgcHJvZ3Jlc3MgcmVwb3J0XG4gKiBAcmV0dXJucyBEZXJpdmVkIGtleVxuICogQGV4YW1wbGVcbiAqIHNjcnlwdCgncGFzc3dvcmQnLCAnc2FsdCcsIHsgTjogMioqMTgsIHI6IDgsIHA6IDEsIGRrTGVuOiAzMiB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcnlwdChwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGJsb2NrU2l6ZTMyLCBWLCBCMzIsIEIsIHRtcCwgYmxvY2tNaXhDYiB9ID0gc2NyeXB0SW5pdChwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgc3dhcDMySWZCRShCMzIpO1xuICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBwOyBwaSsrKSB7XG4gICAgICAgIGNvbnN0IFBpID0gYmxvY2tTaXplMzIgKiBwaTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemUzMjsgaSsrKVxuICAgICAgICAgICAgVltpXSA9IEIzMltQaSArIGldOyAvLyBWWzBdID0gQltpXVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IE4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIEJsb2NrTWl4KFYsIHBvcywgViwgKHBvcyArPSBibG9ja1NpemUzMiksIHIpOyAvLyBWW2ldID0gQmxvY2tNaXgoVltpLTFdKTtcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfVxuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxuICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxuICAgICAgICAgICAgY29uc3QgaiA9IEIzMltQaSArIGJsb2NrU2l6ZTMyIC0gMTZdICUgTjsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYmxvY2tTaXplMzI7IGsrKylcbiAgICAgICAgICAgICAgICB0bXBba10gPSBCMzJbUGkgKyBrXSBeIFZbaiAqIGJsb2NrU2l6ZTMyICsga107IC8vIHRtcCA9IEIgXiBWW2pdXG4gICAgICAgICAgICBCbG9ja01peCh0bXAsIDAsIEIzMiwgUGksIHIpOyAvLyBCID0gQmxvY2tNaXgoQiBeIFZbal0pXG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dhcDMySWZCRShCMzIpO1xuICAgIHJldHVybiBzY3J5cHRPdXRwdXQocGFzc3dvcmQsIGRrTGVuLCBCLCBWLCB0bXApO1xufVxuLyoqXG4gKiBTY3J5cHQgS0RGIGZyb20gUkZDIDc5MTQuIEFzeW5jIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgc2NyeXB0QXN5bmMoJ3Bhc3N3b3JkJywgJ3NhbHQnLCB7IE46IDIqKjE4LCByOiA4LCBwOiAxLCBka0xlbjogMzIgfSk7XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzY3J5cHRBc3luYyhwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgTiwgciwgcCwgZGtMZW4sIGJsb2NrU2l6ZTMyLCBWLCBCMzIsIEIsIHRtcCwgYmxvY2tNaXhDYiwgYXN5bmNUaWNrIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBzd2FwMzJJZkJFKEIzMik7XG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTMyOyBpKyspXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoTiAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgQmxvY2tNaXgoViwgcG9zLCBWLCAocG9zICs9IGJsb2NrU2l6ZTMyKSwgcik7IC8vIFZbaV0gPSBCbG9ja01peChWW2ktMV0pO1xuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9KTtcbiAgICAgICAgQmxvY2tNaXgoViwgKE4gLSAxKSAqIGJsb2NrU2l6ZTMyLCBCMzIsIFBpLCByKTsgLy8gUHJvY2VzcyBsYXN0IGVsZW1lbnRcbiAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoTiwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBGaXJzdCB1MzIgb2YgdGhlIGxhc3QgNjQtYnl0ZSBibG9jayAodTMyIGlzIExFKVxuICAgICAgICAgICAgY29uc3QgaiA9IEIzMltQaSArIGJsb2NrU2l6ZTMyIC0gMTZdICUgTjsgLy8gaiA9IEludGVncmlmeShYKSAlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYmxvY2tTaXplMzI7IGsrKylcbiAgICAgICAgICAgICAgICB0bXBba10gPSBCMzJbUGkgKyBrXSBeIFZbaiAqIGJsb2NrU2l6ZTMyICsga107IC8vIHRtcCA9IEIgXiBWW2pdXG4gICAgICAgICAgICBCbG9ja01peCh0bXAsIDAsIEIzMiwgUGksIHIpOyAvLyBCID0gQmxvY2tNaXgoQiBeIFZbal0pXG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzd2FwMzJJZkJFKEIzMik7XG4gICAgcmV0dXJuIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3J5cHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/scrypt.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   SHA384: () => (/* binding */ SHA384),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),\n/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\n\n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dGO0FBQ3ZEO0FBQ3NCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMENBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQVM7QUFDMUIsaUJBQWlCLDZDQUFTO0FBQzFCLGlCQUFpQiw2Q0FBUztBQUMxQixpQkFBaUIsNkNBQVM7QUFDMUIsaUJBQWlCLDZDQUFTO0FBQzFCLGlCQUFpQiw2Q0FBUztBQUMxQixpQkFBaUIsNkNBQVM7QUFDMUIsaUJBQWlCLDZDQUFTO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQscUNBQXFDLDJDQUFHO0FBQ3hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQsaUNBQWlDLDJDQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNPLCtCQUErQix1REFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyx1REFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyx1REFBWTtBQUN0RCIsInNvdXJjZXMiOlsid2VicGFjazovL0BndHUtZGFvL25leHRqcy8uLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTIuanM/OWQ2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNIQTIgaGFzaCBmdW5jdGlvbi4gQS5rLmEuIHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIsIHNoYTUxMl8yMjQsIHNoYTUxMl8yNTYuXG4gKiBTSEEyNTYgaXMgdGhlIGZhc3Rlc3QgaGFzaCBpbXBsZW1lbnRhYmxlIGluIEpTLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIENoZWNrIG91dCBbUkZDIDQ2MzRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWosIFNIQTIyNF9JViwgU0hBMjU2X0lWLCBTSEEzODRfSVYsIFNIQTUxMl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0ICogYXMgdTY0IGZyb20gXCIuL191NjQuanNcIjtcbmltcG9ydCB7IGNsZWFuLCBjcmVhdGVIYXNoZXIsIHJvdHIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuZXhwb3J0IGNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gMzIpIHtcbiAgICAgICAgc3VwZXIoNjQsIG91dHB1dExlbiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEEyNTZfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BID0gU0hBMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjI0X0lWWzddIHwgMDtcbiAgICB9XG59XG4vLyBTSEEyLTUxMiBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cbi8vIFJvdW5kIGNvbnRhbnRzXG4vLyBGaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEs1MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG5jb25zdCBTSEE1MTJfS2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMF0pKCk7XG5jb25zdCBTSEE1MTJfS2wgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMV0pKCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gNjQpIHtcbiAgICAgICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gU0hBNTEyX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFNIQTUxMl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBTSEE1MTJfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gU0hBNTEyX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFNIQTUxMl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBTSEE1MTJfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gU0hBNTEyX0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFNIQTUxMl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBTSEE1MTJfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gU0hBNTEyX0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFNIQTUxMl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gU0hBNTEyX0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBTSEE1MTJfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFNIQTUxMl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gU0hBNTEyX0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBTSEE1MTJfSVZbMTVdIHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKFNIQTUxMl9XX0gsIFNIQTUxMl9XX0wpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig0OCk7XG4gICAgICAgIHRoaXMuQWggPSBTSEEzODRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gU0hBMzg0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFNIQTM4NF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBTSEEzODRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gU0hBMzg0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFNIQTM4NF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBTSEEzODRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gU0hBMzg0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFNIQTM4NF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBTSEEzODRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gU0hBMzg0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBTSEEzODRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFNIQTM4NF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gU0hBMzg0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBTSEEzODRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFNIQTM4NF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbi8qKlxuICogVHJ1bmNhdGVkIFNIQTUxMi8yNTYgYW5kIFNIQTUxMi8yMjQuXG4gKiBTSEE1MTJfSVYgaXMgWE9SZWQgd2l0aCAweGE1YTVhNWE1YTVhNWE1YTUsIHRoZW4gdXNlZCBhcyBcImludGVybWVkaWFyeVwiIElWIG9mIFNIQTUxMi90LlxuICogVGhlbiB0IGhhc2hlcyBzdHJpbmcgdG8gcHJvZHVjZSByZXN1bHQgSVYuXG4gKiBTZWUgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AuXG4gKi9cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4OGMzZDM3YzgsIDB4MTk1NDRkYTIsIDB4NzNlMTk5NjYsIDB4ODlkY2Q0ZDYsIDB4MWRmYWI3YWUsIDB4MzJmZjljODIsIDB4Njc5ZGQ1MTQsIDB4NTgyZjlmY2YsXG4gICAgMHgwZjZkMmI2OSwgMHg3YmQ0NGRhOCwgMHg3N2UzNmY3MywgMHgwNGM0ODk0MiwgMHgzZjlkODVhOCwgMHg2YTFkMzZjOCwgMHgxMTEyZTZhZCwgMHg5MWQ2OTJhMSxcbl0pO1xuLyoqIFNIQTUxMi8yNTYgSVYgKi9cbmNvbnN0IFQyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgyMjMxMjE5NCwgMHhmYzJiZjcyYywgMHg5ZjU1NWZhMywgMHhjODRjNjRjMiwgMHgyMzkzYjg2YiwgMHg2ZjUzYjE1MSwgMHg5NjM4NzcxOSwgMHg1OTQwZWFiZCxcbiAgICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG5leHBvcnQgY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BaCA9IFQyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDIyNF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjI0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyMjRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDIyNF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDIyNF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDIyNF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDIyNF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDIyNF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDIyNF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMzIpO1xuICAgICAgICB0aGlzLkFoID0gVDI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjU2X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyNTZfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDI1Nl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjU2X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjU2X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjU2X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjU2X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjU2X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjU2X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuXG4gKlxuICogSXQgaXMgdGhlIGZhc3Rlc3QgSlMgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTI1NigpKTtcbi8qKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQgKi9cbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vKiogU0hBMi01MTIgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTUxMigpKTtcbi8qKiBTSEEyLTM4NCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yNTYgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yMjQgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/sha256.js":
/*!*******************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/sha256.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha2.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\n\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst SHA256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst sha256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst SHA224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst sha224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha224;\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RztBQUN4RztBQUNPLGVBQWUsNENBQU87QUFDN0I7QUFDTyxlQUFlLDRDQUFPO0FBQzdCO0FBQ08sZUFBZSw0Q0FBTztBQUM3QjtBQUNPLGVBQWUsNENBQU87QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZ3R1LWRhby9uZXh0anMvLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/ZDM2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNIQTItMjU2IGEuay5hLiBzaGEyNTYuIEluIEpTLCBpdCBpcyB0aGUgZmFzdGVzdCBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqXG4gKiBDaGVjayBvdXQgW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuaW1wb3J0IHsgU0hBMjI0IGFzIFNIQTIyNG4sIHNoYTIyNCBhcyBzaGEyMjRuLCBTSEEyNTYgYXMgU0hBMjU2biwgc2hhMjU2IGFzIHNoYTI1Nm4sIH0gZnJvbSBcIi4vc2hhMi5qc1wiO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1NiA9IFNIQTI1Nm47XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gc2hhMjU2bjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjQgPSBTSEEyMjRuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IHNoYTIyNG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/sha3.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/sha3.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\n\n// prettier-ignore\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(B);\n}\n/** Keccak sponge function. */\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this, false);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nconst sha3_224 = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nconst sha3_256 = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nconst sha3_384 = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nconst sha3_512 = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nconst keccak_224 = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nconst keccak_256 = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nconst keccak_384 = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nconst keccak_512 = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nconst shake128 = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nconst shake256 = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRTtBQUNsRTtBQUNpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOENBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0QscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0Q7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFVO0FBQ2xCO0FBQ0EsUUFBUSxxREFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixlQUFlLGtEQUFPO0FBQ3RCLFFBQVEsaURBQU07QUFDZCxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdURBQVk7QUFDekQ7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUCxrREFBa0Qsc0RBQVcsV0FBVztBQUN4RTtBQUNPO0FBQ1A7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcz83ODY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU0hBMyAoa2VjY2FrKSBoYXNoIGZ1bmN0aW9uLCBiYXNlZCBvbiBhIG5ldyBcIlNwb25nZSBmdW5jdGlvblwiIGRlc2lnbi5cbiAqIERpZmZlcmVudCBmcm9tIG9sZGVyIGhhc2hlcywgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuICpcbiAqIENoZWNrIG91dCBbRklQUy0yMDJdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4yMDIucGRmKSxcbiAqIFtXZWJzaXRlXShodHRwczovL2tlY2Nhay50ZWFtL2tlY2Nhay5odG1sKSxcbiAqIFt0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBTSEEtMyBhbmQgS2VjY2FrXShodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTU3Mjcvd2hhdC1hcmUtdGhlLWtleS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXRoZS1kcmFmdC1zaGEtMy1zdGFuZGFyZC1hbmQtdGhlLWtlY2Nhay1zdWIpLlxuICpcbiAqIENoZWNrIG91dCBgc2hhMy1hZGRvbnNgIG1vZHVsZSBmb3IgY1NIQUtFLCBrMTIsIGFuZCBvdGhlcnMuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tIFwiLi9fdTY0LmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYW51bWJlciwgYW91dHB1dCwgY2xlYW4sIGNyZWF0ZUhhc2hlciwgY3JlYXRlWE9GZXIsIEhhc2gsIHN3YXAzMklmQkUsIHRvQnl0ZXMsIHUzMiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBObyBfX1BVUkVfXyBhbm5vdGF0aW9ucyBpbiBzaGEzIGhlYWRlcjpcbi8vIEVWRVJZVEhJTkcgaXMgaW4gZmFjdCB1c2VkIG9uIGV2ZXJ5IGV4cG9ydC5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSBCaWdJbnQoMHg3MSk7XG5jb25zdCBTSEEzX1BJID0gW107XG5jb25zdCBTSEEzX1JPVEwgPSBbXTtcbmNvbnN0IF9TSEEzX0lPVEEgPSBbXTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgSU9UQVMgPSBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcbmNvbnN0IFNIQTNfSU9UQV9IID0gSU9UQVNbMF07XG5jb25zdCBTSEEzX0lPVEFfTCA9IElPVEFTWzFdO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLyoqIGBrZWNjYWtmMTYwMGAgaW50ZXJuYWwgZnVuY3Rpb24sIGFkZGl0aW9uYWxseSBhbGxvd3MgdG8gYWRqdXN0IHJvdW5kIGNvdW50LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIGNsZWFuKEIpO1xufVxuLyoqIEtlY2NhayBzcG9uZ2UgZnVuY3Rpb24uICovXG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBhbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgLy8gMCA8IGJsb2NrTGVuIDwgMjAwXG4gICAgICAgIGlmICghKDAgPCBibG9ja0xlbiAmJiBibG9ja0xlbiA8IDIwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIHN3YXAzMklmQkUodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgc3dhcDMySWZCRSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYWJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBhbnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGNsZWFuKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuLyoqIFNIQTMtMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGtlY2Nhay0yNTYuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxMzYsIDI1NiAvIDgpKSgpO1xuLyoqIFNIQTMtMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxMDQsIDM4NCAvIDgpKSgpO1xuLyoqIFNIQTMtNTEyIGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCA3MiwgNTEyIC8gOCkpKCk7XG4vKioga2VjY2FrLTIyNCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKioga2VjY2FrLTM4NCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpKSgpO1xuLyoqIGtlY2Nhay01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpKSgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiBjcmVhdGVYT0Zlcigob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbi8qKiBTSEFLRTEyOCBYT0Ygd2l0aCAxMjgtYml0IHNlY3VyaXR5LiAqL1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpKSgpO1xuLyoqIFNIQUtFMjU2IFhPRiB3aXRoIDI1Ni1iaXQgc2VjdXJpdHkuICovXG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "../node_modules/ox/node_modules/@noble/hashes/esm/utils.js":
/*!******************************************************************!*\
  !*** ../node_modules/ox/node_modules/@noble/hashes/esm/utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createOptHasher: () => (/* binding */ createOptHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   createXOFer: () => (/* binding */ createXOFer),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"../node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nconst swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nconst byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nconst wrapConstructor = createHasher;\nconst wrapConstructorWithOpts = createOptHasher;\nconst wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes === 'function') {\n        return Uint8Array.from(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUCxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsK0JBQStCLHdEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGd0dS1kYW8vbmV4dGpzLy4uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/MjVhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGhhc2ggKi9cbmV4cG9ydCBmdW5jdGlvbiBhaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLmNyZWF0ZUhhc2hlcicpO1xuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5leHBvcnQgZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IHN3YXA4SWZCRSA9IGlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBzd2FwOElmQkU7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBjb25zdCBzd2FwMzJJZkJFID0gaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHt9LnRvU3RyaW5nLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlICovXG5leHBvcnQgY2xhc3MgSGFzaCB7XG59XG4vKiogV3JhcHMgaGFzaCBmdW5jdGlvbiwgY3JlYXRpbmcgYW4gaW50ZXJmYWNlIG9uIHRvcCBvZiBpdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0SGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVhPRmVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGNvbnN0IHdyYXBDb25zdHJ1Y3RvciA9IGNyZWF0ZUhhc2hlcjtcbmV4cG9ydCBjb25zdCB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZU9wdEhhc2hlcjtcbmV4cG9ydCBjb25zdCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZVhPRmVyO1xuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;